/ 7	. 

/ lees	,
https://matplotlib.org/3.1.1/tutorials/introductory/pyplot.html

/ 13	. 

plt.plot([1, 3, 10, 50])

You may be wondering why the x-axis ranges from 0-3 and the y-axis from 1-4. If you provide a single list or array to the plot() command, matplotlib assumes it is a sequence of y values, and automatically generates the x values for you. Since python ranges start with 0, the default x vector has the same length as y but starts with 0. Hence the x data are [0,1,2,3].

/ we zien gebroken lijn door 0,1 1,3 2,10 3,50

/ 13	. 

plt.plot([1, 2, 3, 4], [1, 4, 9, 16])

/ we zien gebroken lijn door 1,1 2,4 3,9 4,16


/ 7	. 

In [8163]: plt.plot([1,5],[2,6])
/ we zien lijn door 1,2 en 5,6

In [8163]: plt.plot(([1,5],[2,6]))
Out[8163]: 
/ we zien 2 lijnen, van (0,1) naar (1,2) en van 0,5 naar 1,6

In [8270]: plt.plot(([1,3],[2,5],[4,10],[7,12]))
/ [1,3] zijn values bij 0
/ [2,5] zijn values bij 1
/ [4,10] zijn values bij 2
/ [7,12] zijn values bij 3
/ dus we zien 2 gebroken lijnen , een door (0,1), (1,2), (2,4), (3,7) en de ander door (0,3), (1,5), (2,10), (3,12)

In [8272]: plt.plot([1,3],[2,5],[4,10],[7,12])
/ we zien 2 lijnstukken, de 1ste door (1,2) en (3,5) en de 2de door (4,7) en (10,12)
/ 2 aan 2 dus	, net als plt.plot(t,t,t,t**2) 	(voor **2 moet t een np.array zijn ipv een list)

/ 7	 

/ lees	,
https://matplotlib.org/3.1.0/api/markers_api.html

/ 7	. 

In [8198]: p
Out[8198]: 
array([[1, 2],
       [3, 4],
       [5, 6]])

In [8197]: q
Out[8197]: array([1, 2, 1])

In [8196]: p[q==1,0],p[q==1,1]
Out[8196]: (array([1, 5]), array([2, 6]))
/ een soort mesh grid	,
/ TODO

In [8202]: plt.plot(p[q==1,0],p[q==1,1])
/ line van 1,2 naar 5,6	,

/ 7	. 

In [8285]: p=np.array([1,2,3,4,5,6,7,8]).reshape(-1,2)
In [8286]: p
Out[8286]: 
array([[1, 2],
       [3, 4],
       [5, 6],
       [7, 8]])
In [8287]: q=np.array([1,2,1,1])

In [8288]: p[q==1,0],p[q==1,1]
Out[8288]: (array([1, 5, 7]), array([2, 6, 8]))

In [8289]: p[q==2,0],p[q==2,1]
Out[8289]: (array([3]), array([4]))

In [8291]: plt.plot(p[q==1,0],p[q==1,1])
/ we zien 1 lijn door (1,2), (5,6), (7,8)
/ en 1 punt	,

/ 7	. 

/ SAMENVATTING PLOT

/ zorg altijd dat de args van .plot met zijn 2en zijn	, dus
	.plot(t,t,t,t*2, ...)
/ of	,
	.plot([1,2,3],[4,5,6])	: we zien gebroken lijn door (1,4), (2,5), (3,6)

/ als je doet	,
	.plot(([1,2,3],[4,5,6])) 
/ dan geef je dus maar 1 ding	, en zien	we een variant van
	.plot([1,4,7])
/ deze geeft een gebroken lijn door (0,1), (1,4) (2,7)
/ bij 
	.plot(([1,2,3],[4,5,6])) 
/ zien we 2 gebroken lijnen: de 1ste door (0,1), (1,2) (2,3) en de 2de door (0,4), (1,5), (2,6)
/ als je niet 2 dingen geeft maar plot de keys zelf, en ziet hij wat je geeft als values	,

/ 7	. 

In [8312]: x=iris['data'][:,[2,3]]
In [8313]: x[:3]
Out[8313]: 
array([[1.4, 0.2],
       [1.4, 0.2],
       [1.3, 0.2]])

In [8314]: x[:3,0]
Out[8314]: array([1.4, 1.4, 1.3])
In [8316]: x[:3,1]
Out[8316]: array([0.2, 0.2, 0.2])

/ we willen van de 1ste en 2de column de min en max	,

In [8317]: min(x[:,0])
Out[8317]: 1.0
In [8318]: min(x[:,1])
Out[8318]: 0.1
In [8319]: max(x[:,0])
Out[8319]: 6.9
In [8320]: max(x[:,1])
Out[8320]: 2.5

/ omdat 6.9-1.0=5.9, neem 59+1=60 roosterpunten	,
/ omdat 2.5-.1=2.4, neem 24+1=25 roosterpunten	,

In [8326]: i=np.linspace(min(x[:,0]),max(x[:,0]),60)
In [8329]: j=np.linspace(min(x[:,1]),max(x[:,1]),25)

In [8333]: i
Out[8333]: 
array([1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1, 2.2,
       2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2, 3.3, 3.4, 3.5,
       3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8,
       4.9, 5. , 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1,
       6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 6.9])
In [8332]: j
Out[8332]: 
array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. , 1.1, 1.2, 1.3,
       1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1, 2.2, 2.3, 2.4, 2.5])





/ Einde SAMENVATTING PLOT


/ 7	. 

/ precies wat het moet doen	,
In [8218]:  a=np.linspace(10,20,21)
In [8219]: plt.figure()
In [8220]: plt.plot(a,np.sin(a))

In [8221]: a.shape
Out[8221]: (21,)
In [8222]: np.sin(a).shape
Out[8222]: (21,)

/ 7	. 

/ voor .plot maakt het niet uit of we hem een list geven of een numpy array	,

In [8229]: a=np.arange(0,10)
In [8233]: b=np.sin(a)
In [8246]: a2=a.tolist()
In [8244]: b2=np.sin(a2).tolist()

/ np.sin(a) is np.sin(a2), is een numpy array	, a is een numpy array, a2 een list	,

In [8247]: plt.plot(a2,b2)
/=
In [8248]: plt.plot(a,b)

/ we zien een grafiek, met (a[0],b[0]), ...

/ 7	. 


/ 7	 

delta=.5
p=np.arange(-2,2,delta)
q=np.arange(-1,1,delta)
P,Q=np.meshgrid(p,q)
plt.figure()
R=P+Q
c=plt.contour(P,Q,R)
c=plt.contour(P,Q,P*Q)

In [8341]: p
Out[8341]: array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5])
In [8342]: q
Out[8342]: array([-1. , -0.5,  0. ,  0.5])

In [8338]: P,Q=np.meshgrid(p,q)

In [8345]: P
Out[8345]: 
array([[-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5],
       [-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5],
       [-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5],
       [-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5]])

In [8346]: Q
Out[8346]: 
array([[-1. , -1. , -1. , -1. , -1. , -1. , -1. , -1. ],
       [-0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5],
       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],
       [ 0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5]])


In [8347]: P+Q
Out[8347]: 
array([[-3. , -2.5, -2. , -1.5, -1. , -0.5,  0. ,  0.5],
       [-2.5, -2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ],
       [-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5],
       [-1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ]])

In [8354]: P.ravel()
Out[8354]: 
array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5, -2. , -1.5, -1. ,
       -0.5,  0. ,  0.5,  1. ,  1.5, -2. , -1.5, -1. , -0.5,  0. ,  0.5,
        1. ,  1.5, -2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5])

In [8355]: Q.ravel()
Out[8355]: 
array([-1. , -1. , -1. , -1. , -1. , -1. , -1. , -1. , -0.5, -0.5, -0.5,
       -0.5, -0.5, -0.5, -0.5, -0.5,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ,
        0. ,  0. ,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5])

In [8356]: np.c_[P.ravel(),Q.ravel()]
Out[8356]: 
array([[-2. , -1. ],
       [-1.5, -1. ],
       [-1. , -1. ],
       [-0.5, -1. ],
       [ 0. , -1. ],
       [ 0.5, -1. ],
       [ 1. , -1. ],
       [ 1.5, -1. ],
       [-2. , -0.5],
       [-1.5, -0.5],
       [-1. , -0.5],
       [-0.5, -0.5],
       [ 0. , -0.5],
       [ 0.5, -0.5],
       [ 1. , -0.5],
       [ 1.5, -0.5],
       [-2. ,  0. ],
       [-1.5,  0. ],
       [-1. ,  0. ],
       [-0.5,  0. ],
       [ 0. ,  0. ],
       [ 0.5,  0. ],
       [ 1. ,  0. ],
       [ 1.5,  0. ],
       [-2. ,  0.5],
       [-1.5,  0.5],
       [-1. ,  0.5],
       [-0.5,  0.5],
       [ 0. ,  0.5],
       [ 0.5,  0.5],
       [ 1. ,  0.5],
       [ 1.5,  0.5]])

In [8363]: np.c_[np.ones(len(P.ravel())),P.ravel(),Q.ravel()]
Out[8363]: 
array([[ 1. , -2. , -1. ],
       [ 1. , -1.5, -1. ],
...

/ CONTOUR, PAD NAAR MINIMA MAXIMA 

/ 13		. 

/ zoek min	,

a=0
b=0
x=np.array([a,b]).reshape(-1,1)
a=x
J=a/(1+b)
gradJ=np.array([1/(1+b),-a/(1+b)**2]).reshape(-1,1)
HaTa=0
HbTa=-1/(1+b)**2
HaTb=HbTa
HbTb=2*a/(1+b)**3
H=np.block([[HaTa,HbTa],[HaTb,HbTb]])
x=x-np.linalg.inv(H).dot(gradJ)
x
history

/ 13	. 

/ zoek min	,

/ f=(x-1)**2+(y-1)**2-7


x0, x1 = np.meshgrid(
        np.linspace(0,2, 11),
        np.linspace(0,2, 11),
)
X= np.c_[x0.ravel(), x1.ravel()]
In [9565]: X.shape
Out[9565]: (121, 2)

/ ook 2 keer 121 elems	,
In [9567]: x0.shape
Out[9567]: (11, 11)
In [9568]: x0.shape
Out[9568]: (11, 11)

/ er geldt,
x0.ravel()==X[:,0]
x1.ravel()==X[:,1]

In [9539]: f=(x0-1)**2+(x1-1)**2-7
In [9553]: f.shape
Out[9553]: (11, 11)

plt.figure()
c= plt.contour(x0, x1, f, cmap=plt.cm.brg)
plt.clabel(c, inline=1, fontsize=12)

/ 13	. 

/ zoek min	,
/ in 1 stap zijn we er al	,

# f=(x-3)**2+(y-7)**2-14
x=np.array([0,0])
display(x)
for _ in range(0,10): 
	gradf=np.array([2*(x[0]-3),2*(x[1]-7)])
	H=2*np.diag(np.ones(2))
	x=x-np.linalg.inv(H).dot(gradf)
	display(x)

array([0, 0])
array([3., 7.])
...


/ 13	. 

///////////////////////////////////////////////
/ model contourlijnen en het pad naar het minimum	,

/ we hebben	gemaakt	,
[eric@almond my]$ pwd
/home/eric/Devel/python/my
$ ls -ltr
model_contourlijnen_padnaarminimum.py

/ zoek min	,

/ lees,
https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.gca.html
/ om dezelfde schaal op de assen te krijgen	,
/ gca=get current axes	,

x0, x1 = np.meshgrid( np.linspace(0,2, 11), np.linspace(0,4,21),)
#X= np.c_[x0.ravel(), x1.ravel()]

f=(x0-1)**4+(x1-2)**4-7

plt.figure()
plt.gca().set_aspect('equal')
c= plt.contour(x0, x1, f,cmap=plt.cm.brg)
plt.clabel(c, fmt='%1.1f', inline_spacing=40,fontsize=10)

x=np.zeros((10,2))
for i in range(0,10-1): 
	gradf=np.array([4*(x[i,0]-1)**3,4*(x[i,1]-2)**3])
	H=np.block([[4*3*(x[i,0]-1)**2,0],[0,4*3*(x[i,1]-2)**2]])
	x[i+1]=x[i]-np.linalg.inv(H).dot(gradf)
	display(x[i+1])
	plt.scatter(x[:,0],x[:,1],)
# or	,
#	plt.plot(x[:,0],x[:,1],)

/ 13	. 

/ contourlijnen en het pad naar het minimum	en maximum,

/ fct heeft meerdere minima en maxima	,

x0, x1 = np.meshgrid( 
	np.linspace(-np.sqrt(4*np.pi),np.sqrt(4*np.pi),11), 
	np.linspace(-np.sqrt(4*np.pi),np.sqrt(4*np.pi),11), 
)

f=

plt.figure()
plt.gca().set_aspect('equal')
c= plt.contour(x0, x1, f,cmap=plt.cm.brg)
plt.clabel(c, fmt='%1.1f', inline_spacing=40,fontsize=10)

x=np.zeros((10,2))
for i in range(0,10-1): 
	gradf=np.array([4*(x[i,0]-1)**3,4*(x[i,1]-2)**3])
	H=np.block([[4*3*(x[i,0]-1)**2,0],[0,4*3*(x[i,1]-2)**2]])
	x[i+1]=x[i]-np.linalg.inv(H).dot(gradf)
	display(x[i+1])
	plt.scatter(x[:,0],x[:,1],)
# or	,
#	plt.plot(x[:,0],x[:,1],)



/ 13	. 

/ change array value	,

/ lees	,
https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html

x=np.arange(-5,5,1)
In [9631]: x
Out[9631]: array([-5, -4, -3, -2, -1,  0,  1,  2,  3,  4])

/ we maken straks een fct die zou delen door 0	,
/ we willen van 0 .1 maken	, maar 
In [9632]: x.dtype
Out[9632]: dtype('int64')

x=x.astype(float)
np.place(x,x==0,.1)
In [9636]: x
Out[9636]: array([-5. , -4. , -3. , -2. , -1. ,  0.1,  1. ,  2. ,  3. ,  4. ])

/ np.place werkt zo: je kunt ook een array van values geven: [.1,.2]. np.place vervangt de values in het array net zolang als dat kan	,

In [9637]: np.place (x,x>1,[.1,.2])
In [9638]: x
Out[9638]: array([-5. , -4. , -3. , -2. , -1. ,  0.1,  1. ,  0.1,  0.2,  0.1])

/ er zijn 3 values te vervangen, en hij probeert .1,.2,.1,.2, ...

/ als we opnieuw beginnen	,

In [9641]: x=np.arange(-5,5,1)
In [9642]: x=x.astype(float)
In [9643]: x
Out[9643]: array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
In [9644]: np.place (x,x>0,[.1,.2])
In [9645]: x
Out[9645]: array([-5. , -4. , -3. , -2. , -1. ,  0. ,  0.1,  0.2,  0.1,  0.2])

/ hier zien we 4 values changed	,

/ 13	. 

/ meshgrid	,

/ np.meshgrid is een list	, van 2 numpy arrays, van shape (10,) bijv	,

x=np.arange(-5,5,1,dtype=float)
y=np.arange(-5,5,1,dtype=float)
np.place(x,x==0,.1)
np.place(y,y==0,.1)
x_,y_=np.meshgrid(x,y)
f=np.sin(x_**2+y_**2)/(x_**2+y_**2)
In [9670]: f.shape
Out[9670]: (10, 10)

plt.figure()
c= plt.contour(x_, y_, f, cmap=plt.cm.brg)
plt.clabel(c, inline=1, fontsize=12)

/ We zien herhalingen, 
/ Zoek straks naar extremen, kijk waar je uitkomt	,
/ TODO

/ 13	. 

/ vectorveld	,

/ lees	,
https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.axes.Axes.quiver.html#matplotlib.axes.Axes.quiver

X = np.arange(-10, 10, 1)
Y = np.arange(-10, 10, 1)
U, V = np.meshgrid(X, Y)
plt.figure()
q = plt.quiver(X, Y, U, V)
plt.quiverkey(q, X=0.3, Y=1.1, U=10,
             label='Quiver key, length = 10', labelpos='E')


X_, Y_ = np.meshgrid(np.arange(0, 2 * np.pi, .2), np.arange(0, 2 * np.pi, .2))
U_ = np.cos(X_)
V_ = np.sin(Y_)
plt.figure()
q = plt.quiver(X_, Y_, U_, V_,units="width")
plt.quiverkey(q, 0.9, 0.9, 2, r'$2 \frac{m}{s}$', labelpos='E', coordinates='figure')
/ TODO

/ Einde CONTOUR, PAD NAAR MINIMA MAXIMA 
