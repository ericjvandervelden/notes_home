/ See CALLBACKINFO FixedValue, ...
/ See UITSTAP
/ See CLASS FILES CGLIB IN FS

/ 7	. 

/ Lees	, 
http://mydailyjava.blogspot.nl/2013/11/cglib-missing-manual.html

[eric@localhost cglib]$ pwd
/home/eric/Devel/Java/cglib
[eric@localhost cglib]$ tar xvzf  ~/Downloads/cglib-study.tgz 

$ vi SampleTest.java
	@Test
	public void testCallbackFilter(){
		Enhancer enhancer=new Enhancer();
		CallbackHelper helper=new CallbackHelper(Sample.class, new Class[0]) {
			
			@Override
			protected Object getCallback(Method method) {			/ called multiple times in CallbackHelper.<init>	, 
				if(method.getDeclaringClass()!=Object.class 
						&& method.getReturnType()==String.class){
					return new FixedValue() {
						
						@Override
						public Object loadObject() throws Exception {
							return testHello;
						}
					};
				}
				else{
					return NoOp.INSTANCE;
				}

			}
		};
		enhancer.setSuperclass(Sample.class);
		enhancer.setCallbackFilter(helper);
		enhancer.setCallbacks(helper.getCallbacks());
		Sample sample=(Sample)enhancer.create();			<-
		String result=sample.fct("foo");
		Assert.assertEquals(testHello, result);
		result=sample.fct2("foo");
		Assert.assertEquals(testHello, result);
		result=sample.toString();
		Assert.assertNotEquals(testHello, result);
		int hash=sample.hashCode();

	}
}

/ op <-	, 

this	SampleTest  (id=36)	
enhancer	Enhancer  (id=37)	
helper	SampleTest$5  (id=39)	
	callbacks	ArrayList<E>  (id=50)	
		[0]	SampleTest$5$1  (id=66)		Sample.fct 				<- volgorde TODO	
		[1]	SampleTest$5$1  (id=67)		Sample.fct2
		[2]	NoOp$1  (id=68)				Object.equals
		[3]	NoOp$1  (id=68)				Object.clone	
		[4]	NoOp$1  (id=68)				Object.hashCode
		[5]	NoOp$1  (id=68)				Object.toString	
	methodMap	HashMap<K,V>  (id=57)	
		[0]	HashMap$Entry<K,V>  (id=88)	
			key	Method  (id=97)				public boolean java.lang.Object.equals(java.lang.Object)	
			value	Integer  (id=98)	
		[1]	HashMap$Entry<K,V>  (id=89)	
			key	Method  (id=107)			public java.lang.String first.Sample.fct(java.lang.String)	
			value	Integer  (id=108)	
		[2]	HashMap$Entry<K,V>  (id=90)	
			key	Method  (id=111)			protected native java.lang.Object java.lang.Object.clone() throws java.lang.CloneNotSupportedException	
			value	Integer  (id=98)	
		[3]	HashMap$Entry<K,V>  (id=91)	
			key	Method  (id=114)			public java.lang.String first.Sample.fct2(java.lang.String)	
			value	Integer  (id=115)	
		[4]	HashMap$Entry<K,V>  (id=92)	
			key	Method  (id=119)			public native int java.lang.Object.hashCode()	
			value	Integer  (id=98)	
		[5]	HashMap$Entry<K,V>  (id=93)	
			key	Method  (id=123)			public java.lang.String java.lang.Object.toString()	
			value	Integer  (id=98)	
	this$0	SampleTest  (id=36)	

/ 7	. 

/ we start opnieuw	, 
/s
SampleTest.testMethodInterceptor() line: 79	
		Enhancer enhancer=new Enhancer();
/s
Enhancer.<clinit>() line: 73	
    private static final EnhancerKey KEY_FACTORY =
      (EnhancerKey)KeyFactory.create(EnhancerKey.class, KeyFactory.HASH_ASM_TYPE, null);

///////////////////////////////////////////////////////////////////
/ UITSTAP
/ we maken nu een uitstap	, we gaan deze eerst maken 	, 

/s
KeyFactory.create(Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 153	
        return create(keyInterface.getClassLoader(), keyInterface, first, next);
/ keyInterface= interface net.sf.cglib.proxy.Enhancer$EnhancerKey	/ is een interface
/s
KeyFactory.create(ClassLoader, Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 162	
        Generator gen = new Generator();
/s
KeyFactory$Generator.<init>() line: 188	
            super(SOURCE);
/s
KeyFactory$Generator(AbstractClassGenerator<T>).<init>(AbstractClassGenerator$Source) line: 137	

    private GeneratorStrategy strategy = DefaultGeneratorStrategy.INSTANCE;
/=
   		public static final DefaultGeneratorStrategy INSTANCE = new DefaultGeneratorStrategy();

    private NamingPolicy namingPolicy = DefaultNamingPolicy.INSTANCE;
/=
    	public static final DefaultNamingPolicy INSTANCE = new DefaultNamingPolicy();

        this.source = source;
source	AbstractClassGenerator$Source  (id=80)	
	name	"net.sf.cglib.core.KeyFactory" (id=83)	
/t
KeyFactory.create(ClassLoader, Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 163	
        Generator gen = new Generator();
/d
        gen.setInterface(keyInterface);
keyInterface	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey) (id=43)	

        if (customizer != null) {
            gen.addCustomizer(customizer);

        if (next != null && !next.isEmpty()) {
/n
        gen.setClassLoader(loader);
        return gen.create();
/s
KeyFactory$Generator.create() line: 220	
            setNamePrefix(keyInterface.getName());
/s
KeyFactory$Generator(AbstractClassGenerator<T>).setNamePrefix(String) line: 142	
namePrefix	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=120)	
/t
KeyFactory$Generator.create() line: 220
            setNamePrefix(keyInterface.getName());
/d
            return (KeyFactory)super.create(keyInterface.getName());
/s
KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 275	
/=
    protected Object create(Object key) {
key	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=120)	

            Map<ClassLoader, ClassLoaderData> cache = CACHE;

/ intermezzo

abstract public class AbstractClassGenerator<T>
    private static volatile Map<ClassLoader, ClassLoaderData> CACHE = new WeakHashMap<ClassLoader, ClassLoaderData>();

/ Einde intermezzo

            ClassLoaderData data = cache.get(loader);
null
            if (data == null) {
                synchronized (AbstractClassGenerator.class) {
                    cache = CACHE;
                    data = cache.get(loader);
null
                    if (data == null) {
                        Map<ClassLoader, ClassLoaderData> newCache = new WeakHashMap<ClassLoader, ClassLoaderData>(cache);
                        data = new ClassLoaderData(loader);
/s
/ intermezzo
        private static final Function<AbstractClassGenerator, Object> GET_KEY = new Function<AbstractClassGenerator, Object>() {
            public Object apply(AbstractClassGenerator gen) {
                return gen.key;
            }
        };
/ Einde intermezzo
AbstractClassGenerator$ClassLoaderData.<init>(ClassLoader) line: 73	
            Function<AbstractClassGenerator, Object> load =										<-
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);		/ straks hier	, 
                            return gen.wrapCachedClass(klass);
                        }
                    };
            generatedClasses = new LoadingCache<AbstractClassGenerator, Object, Object>(GET_KEY, load);
/s
LoadingCache<K,KK,V>.<init>(Function<K,KK>, Function<K,V>) line: 19	
        this.keyMapper = keyMapper;
        this.loader = loader;
        this.map = new ConcurrentHashMap<KK, Object>();
keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=846)		/ GET_KEY hierboven
loader	AbstractClassGenerator$ClassLoaderData$3  (id=845)			/ load hierboven	,

/t
KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 285	
                        data = new ClassLoaderData(loader);
/d
this	KeyFactory$Generator  (id=79)	
data	AbstractClassGenerator$ClassLoaderData  (id=139)	
	classLoader	WeakReference<T>  (id=850)	
		discovered	null	
		next	null	
		queue	ReferenceQueue$Null  (id=874)	
		referent	Launcher$AppClassLoader  (id=45)	
	generatedClasses	LoadingCache<K,KK,V>  (id=857)	
		keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=846)	
		loader	AbstractClassGenerator$ClassLoaderData$3  (id=845)	
		map	ConcurrentHashMap<K,V>  (id=881)	
	reservedClassNames	HashSet<E>  (id=839)	
	uniqueNamePredicate	AbstractClassGenerator$ClassLoaderData$1  (id=872)	

                        newCache.put(loader, data);
                        CACHE = newCache;
            this.key = key;
key	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=120)	

            Object obj = data.get(this, getUseCache());
/s
AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 116	
useCache=true
            } else {
              Object cachedValue = generatedClasses.get(gen);
/s
LoadingCache<K,KK,V>.get(K) line: 28	
this
	keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=846)	
	loader	AbstractClassGenerator$ClassLoaderData$3  (id=845)	
	map	ConcurrentHashMap<K,V>  (id=881)	
key	KeyFactory$Generator  (id=79)	
	key	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=120)	

        final KK cacheKey = keyMapper.apply(key);
/s
AbstractClassGenerator$ClassLoaderData$2.apply(AbstractClassGenerator) line: 81	
/=
            public Object apply(AbstractClassGenerator gen) {
                return gen.key;
gen	KeyFactory$Generator  (id=79)	
	key	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=120)	
/t
LoadingCache<K,KK,V>.get(K) line: 29	
        final KK cacheKey = keyMapper.apply(key);
/d
cacheKey	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=120)	
        Object v = map.get(cacheKey);
null
        return createEntry(key, cacheKey, v);
/s
LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 52	

this	LoadingCache<K,KK,V>  (id=857)	
	keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=846)	
	loader	AbstractClassGenerator$ClassLoaderData$3  (id=845)	
	map	ConcurrentHashMap<K,V>  (id=881)	

       FutureTask<V> task;
        boolean creator = false;
        if (v != null) {
/n
        } else {
            task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);
                }
            });


/t
LoadingCache<K,KK,V>.get(K) line: 34	
        final KK cacheKey = keyMapper.apply(key);
/d
"net.sf.cglib.proxy.Enhancer$EnhancerKey"
        Object v = map.get(cacheKey);
null
        return createEntry(key, cacheKey, v);
this	LoadingCache<K,KK,V>  (id=888)	
key	KeyFactory$Generator  (id=79)	
cacheKey	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=866)	
v	null	
/s
LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 61	
        } else {
            task = new FutureTask<V>(new Callable<V>() {		<-
                public V call() throws Exception {
                    return loader.apply(key);
                }
            });
            Object prevTask = map.putIfAbsent(cacheKey, task);
null
            if (prevTask == null) {
                // creator does the load
                creator = true;
                task.run();
/s
FutureTask<V>.run() line: 266	
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
/s
LoadingCache$2.call() line: 54	
        } else {
            task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);										<-
/s
AbstractClassGenerator$ClassLoaderData$3.apply(Object) line: 91	
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);			<-
/s
KeyFactory$Generator(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 308	
       Class gen;
        Object save = CURRENT.get();
null
        CURRENT.set(this);
this	KeyFactory$Generator  (id=79)	

            ClassLoader classLoader = data.getClassLoader();
            synchronized (classLoader) {
              String name = generateClassName(data.getUniqueNamePredicate());              
/s
KeyFactory$Generator(AbstractClassGenerator<T>).generateClassName(Predicate) line: 154	
        return namingPolicy.getClassName(namePrefix, source.name, key, nameTestPredicate);
/s
DefaultNamingPolicy.getClassName(String, String, Object, Predicate) line: 39	
/=
    public String getClassName(String prefix, String source, Object key, Predicate names) {
key==prefix="net.sf.cglib.proxy.Enhancer$EnhancerKey"
        String base =
            prefix + "$$" + 
            source.substring(source.lastIndexOf('.') + 1) +
            getTag() + "$$" +
            Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());
"net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72"

        String attempt = base;
        int index = 2;
        while (names.evaluate(attempt))
/s
AbstractClassGenerator$ClassLoaderData$1.evaluate(Object) line: 75	
       private final Predicate uniqueNamePredicate = new Predicate() {
            public boolean evaluate(Object name) {
                return reservedClassNames.contains(name);					<-
/n
reservedClassNames=[]
/t
DefaultNamingPolicy.getClassName(String, String, Object, Predicate) line: 39	
        while (names.evaluate(attempt))
/n
        return attempt;
/t
KeyFactory$Generator(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 318	
              String name = generateClassName(data.getUniqueNamePredicate());              
/d
              data.reserveName(name);
/ adds to reservedClassNames
              this.setClassName(name);
            byte[] b = strategy.generate(this);
this	KeyFactory$Generator  (id=79)	
/s
DefaultGeneratorStrategy.generate(ClassGenerator) line: 24	
        DebuggingClassWriter cw = getClassVisitor();
/s
DefaultGeneratorStrategy.getClassVisitor() line: 30	
      return new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);
/s
DebuggingClassWriter.<init>(int) line: 49	
	super(Opcodes.ASM5, new ClassWriter(flags));

/ Intermezzo

/ we zien dat asm een dep is , niet asm-debug-all	, 
/ daarom kunnen we asm niet debug	, en zien we steeds die meldingen over missing linenumbers	,

eric@almond asm-study]$ less ~/.gradle/caches/modules-2/files-2.1/cglib/cglib-parent/3.2.5/4da69f04c070e401e8b0a258834861559c162b/cglib-parent-3.2.5.pom 
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.ow2.asm</groupId>
                <artifactId>asm</artifactId>
                <version>${asm.version}</version>
            </dependency>

            <properties>
                <asm.version>6.0_ALPHA</asm.version>

[eric@almond asm-study]$ less ~/.gradle/caches/modules-2/files-2.1/cglib/cglib/3.2.5/a121d3fe68b8db7c23f8842eb07461b418f8d7c6/cglib-3.2.5.pom 
   <properties>
        <asm.version>5.2</asm.version>


/ build cglib zelf	, 
/ TODO

/ Einde Intermezzo

/s
DebuggingClassWriter.<init>(int) line: 49	
	super(Opcodes.ASM5, new ClassWriter(flags));
/t
DefaultGeneratorStrategy.generate(ClassGenerator) line: 25	
        DebuggingClassWriter cw = getClassVisitor();
/d
        transform(cg).generateClass(cw);	 / transform doet niets,	 
/s
KeyFactory$Generator.generateClass(ClassVisitor) line: 241	
            ClassEmitter ce = new ClassEmitter(v);
/s
ClassEmitter.<init>(ClassVisitor) line: 42	
        setTarget(cv);

/ intermezzo

public class ClassEmitter extends ClassTransformer {

public abstract class ClassTransformer extends ClassVisitor {
    public ClassTransformer() {
	super(Opcodes.ASM5);
    }
    public ClassTransformer(int opcode) {
	super(opcode);
    }
   public abstract void setTarget(ClassVisitor target);
}

/ Einde intermezzo

/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 243	
            ClassEmitter ce = new ClassEmitter(v);
/d
            Method newInstance = ReflectUtils.findNewInstance(keyInterface);
/ keyInterface=interface net.sf.cglib.proxy.Enhancer$EnhancerKey
/s
ReflectUtils.findNewInstance(Class) line: 341	
        Method m = findInterfaceMethod(iface);
/s
ReflectUtils.findInterfaceMethod(Class) line: 448	
        Method[] methods = iface.getDeclaredMethods();
        return methods[0];
/t
ReflectUtils.findNewInstance(Class) line: 341	
        Method m = findInterfaceMethod(iface);
/d
public abstract java.lang.Object net.sf.cglib.proxy.Enhancer$EnhancerKey.newInstance(java.lang.String,java.lang.String[],net.sf.cglib.core.WeakCacheKey,org.objectweb.asm.Type[],boolean,boolean,java.lang.Long)

/ intermezzo

Enhlancer.class
    /** Internal interface, only public due to ClassLoader issues. */
    public interface EnhancerKey {
        public Object newInstance(String type,
                                  String[] interfaces,
                                  WeakCacheKey<CallbackFilter> filter,
                                  Type[] callbackTypes,
                                  boolean useFactory,
                                  boolean interceptDuringConstruction,
                                  Long serialVersionUID);
    }

/ Einde intermezzo

/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 244	
            Method newInstance = ReflectUtils.findNewInstance(keyInterface);
/d
            Type[] parameterTypes = TypeUtils.getTypes(newInstance.getParameterTypes());
/s
TypeUtils.getTypes(Class[]) line: 325	
/=
    public static Type[] getTypes(Class[] classes) {	/ Type is asm type	, 
classes	Class<T>[7]  (id=1012)	
	[0]	Class<T> (java.lang.String) (id=50)	
	[1]	Class<T> (java.lang.String[]) (id=732)	
	[2]	Class<T> (net.sf.cglib.core.WeakCacheKey) (id=1011)	
	[3]	Class<T> (org.objectweb.asm.Type[]) (id=1013)	
	[4]	Class<T> (boolean) (id=1014)	
	[5]	Class<T> (boolean) (id=1014)	
	[6]	Class<T> (java.lang.Long) (id=787)	
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 249	
            Type[] parameterTypes = TypeUtils.getTypes(newInstance.getParameterTypes());
/d

/ 1313	. 

/ we gaan de class def maken 	, 


            ce.begin_class(Constants.V1_2,
                           Constants.ACC_PUBLIC,
                           getClassName(),		/ "net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72"
                           KEY_FACTORY,				/ Type Lnet/sf/cglib/core/KeyFactory;
                           new Type[]{ Type.getType(keyInterface) },
                           Constants.SOURCE_FILE);
/s
ClassEmitter.begin_class(int, int, String, Type, Type[], String) line: 68	
/=
    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {

this	ClassEmitter  (id=977)	
version	46	
access	1	
className	"net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72" (id=961)	
superType	Type  (id=1113)					/ Lnet/sf/cglib/core/KeyFactory;
interfaces	Type[1]  (id=1118)		/ [Lnet/sf/cglib/proxy/Enhancer$EnhancerKey;]
source	"<generated>" (id=1119)	

        final Type classType = Type.getType("L" + className.replace('.', '/') + ";");
Lnet/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72;

        classInfo = new ClassInfo() {
            public Type getType() {
                return classType;
            }
            public Type getSuperType() {
                return (superType != null) ? superType : Constants.TYPE_OBJECT;
            }
            public Type[] getInterfaces() {
                return interfaces;
            }
            public int getModifiers() {
                return access;
            }
        };

this	ClassEmitter  (id=977)	
	classInfo	ClassEmitter$1  (id=1146)	
		this$0	ClassEmitter  (id=977)	
		val$access	1	
		val$classType	Type  (id=1142)		/ Lnet/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72;
		val$interfaces	Type[1]  (id=1118) / [Lnet/sf/cglib/proxy/Enhancer$EnhancerKey;]	
		val$superType	Type  (id=1113)	/ Lnet/sf/cglib/core/KeyFactory;

        cv.visit(version,
                 access,
                 classInfo.getType().getInternalName(),
                 null,
                 classInfo.getSuperType().getInternalName(),
                 TypeUtils.toInternalNames(interfaces));

/ intermezzo

this	ClassEmitter  (id=977)	
	cv	DebuggingClassWriter  (id=969)		/ extends ClassVisitor	,
		cv	ClassWriter  (id=1193)	

    public void visit(int version, int access, String name, String signature,
            String superName, String[] interfaces) {
        if (cv != null) {
            cv.visit(version, access, name, signature, superName, interfaces);

/ cv is dus een class wriiter	,

/ Einde intermezzo

        if (source != null)
            cv.visitSource(source, null);
/ TODO
        init();	/ NIETS
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 255	
            ce.begin_class(Constants.V1_2,
                           Constants.ACC_PUBLIC,
                           getClassName(),
                           KEY_FACTORY,
                           new Type[]{ Type.getType(keyInterface) },
                           Constants.SOURCE_FILE);
/d

/ 1313. 

/ we gaan de default ctor <init> maken 	, zonder args	, 

            EmitUtils.null_constructor(ce);
/s
EmitUtils.null_constructor(ClassEmitter) line: 89	

/ we gaan	,
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);
        e.load_this();
        e.super_invoke_constructor();
        e.return_value();
        e.end_method();

        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);
Constants.ACC_PUBLIC=1
CSTRUCT_NULL=<init>()V	, 2 strings, name="<init>", desc="()V"
/s
ClassEmitter.begin_method(int, Signature, Type[]) line: 142	
        MethodVisitor v = cv.visitMethod(access,
                                         sig.getName(),
                                         sig.getDescriptor(),
                                         null,
                                         TypeUtils.toInternalNames(exceptions));
            return new CodeEmitter(this, v, access, sig, exceptions);
/s
CodeEmitter.<init>(ClassEmitter, MethodVisitor, int, Signature, Type[]) line: 106	
        super(access, sig.getDescriptor(), mv);
/s
CodeEmitter(LocalVariablesSorter).<init>(int, String, MethodVisitor) line: 66	
        super(Opcodes.ASM5, mv);
        state = new State();
        Type[] args = Type.getArgumentTypes(desc);
[]
        state.nextLocal = ((Opcodes.ACC_STATIC & access) != 0) ? 0 : 1;
1
        for (int i = 0; i < args.length; i++) {
            state.nextLocal += args[i].getSize();
        }
        firstLocal = state.nextLocal;
/t
CodeEmitter.<init>(ClassEmitter, MethodVisitor, int, Signature, Type[]) line: 107	
        super(access, sig.getDescriptor(), mv);
/d
       	this.ce = ce; 		/ ce is ClassEmitter	,
        state = new State(ce.getClassInfo(), access, sig, exceptionTypes);
/t
EmitUtils.null_constructor(ClassEmitter) line: 90	
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);
/d
ce	ClassEmitter  (id=977)	
e	CodeEmitter  (id=1231)	
	api	327680	
	ce	ClassEmitter  (id=977)	
	firstLocal	1	
	mv	MethodWriter  (id=1223)	
	state	CodeEmitter$State  (id=1318)	
		access	1	
		argumentTypes	Type[0]  (id=1325)	
		classInfo	ClassEmitter$1  (id=1146)	
		exceptionTypes	null	
		localOffset	1	
		sig	Signature  (id=1212)	
	state	LocalVariablesSorter$State  (id=1290)	
		mapping	(id=1297)	
		nextLocal	1	

/ we zien 2 state	, 1 uit CodeEmitter, 1 uit super class LocalVariablesSorter	, 
/ dat kan	,  het zijn privates	,

        e.load_this();
/s
CodeEmitter.load_this() line: 359	
        mv.visitVarInsn(Constants.ALOAD, 0);
/t
EmitUtils.null_constructor(ClassEmitter) line: 91	
        e.load_this();
/d
        e.super_invoke_constructor();
/s
CodeEmitter.super_invoke_constructor() line: 487	
        invoke_constructor(ce.getSuperType());
/s
ClassEmitter.getSuperType() line: 122	
        return classInfo.getSuperType();
this	ClassEmitter  (id=977)	
	classInfo	ClassEmitter$1  (id=1146)	
		this$0	ClassEmitter  (id=977)	
		val$access	1	
		val$classType	Type  (id=1142)	
		val$interfaces	Type[1]  (id=1118)	
		val$superType	Type  (id=1113)				/ Lnet/sf/cglib/core/KeyFactory;
/t
CodeEmitter.super_invoke_constructor() line: 487	
        invoke_constructor(ce.getSuperType());
/pd
/s
CodeEmitter.invoke_constructor(Type) line: 483	
        invoke_constructor(type, CSTRUCT_NULL);
/s
CodeEmitter.invoke_constructor(Type, Signature) line: 528	
        emit_invoke(Constants.INVOKESPECIAL, type, sig);
/s
CodeEmitter.emit_invoke(int, Type, Signature) line: 495	
        mv.visitMethodInsn(opcode,										/ 183=b6=invoke_special
                           type.getInternalName(),		/ net/sf/cglib/core/KeyFactory
                           sig.getName(),							/ <init>
                           sig.getDescriptor(),				/ ()V
                           opcode == Opcodes.INVOKEINTERFACE); / false (183 != 185)
/t
EmitUtils.null_constructor(ClassEmitter) line: 92	
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);
        e.load_this();
        e.super_invoke_constructor();
/d
        e.return_value();
/s
CodeEmitter.return_value() line: 419	
        mv.visitInsn(state.sig.getReturnType().getOpcode(Constants.IRETURN));

this	CodeEmitter  (id=1231)	
	state	CodeEmitter$State  (id=1318)	
		sig	Signature  (id=1212)				/ <init>()V
state.sig.getReturnType()==V
state.sig.getReturnType().getOpcode(Constants.IRETURN)=RETURN	, omdat Type V hebben	, 

/ Intermezzo

/ lees	,
http://asm.ow2.org/asm50/javadoc/user/index.html

Type.class
public int getOpcode(int opcode)

an opcode that is similar to the given opcode, but adapted to this Java type. For example, if this type is float and opcode is IRETURN, this method returns FRETURN.

/ Einde Intermezzo

/t
EmitUtils.null_constructor(ClassEmitter) line: 92	
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);
        e.load_this();
        e.super_invoke_constructor();
        e.return_value();
/d
        e.end_method();
/s
CodeEmitter.end_method() line: 138	
        visitMaxs(0, 0);
/s
CodeEmitter.visitMaxs(int, int) line: 842	
        if (!TypeUtils.isAbstract(state.access)) {
            mv.visitMaxs(0, 0);
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 256	

/ we kijken vanaf begin deze mth wat we hebben gedaan	, 

            ClassEmitter ce = new ClassEmitter(v);	
v	DebuggingClassWriter  (id=969)	
	api	327680	
	className	"net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72" (id=1201)	
	cv	ClassWriter  (id=1193)	
	superName	"net.sf.cglib.core.KeyFactory" (id=1202)	

            Method newInstance = ReflectUtils.findNewInstance(keyInterface);
this	KeyFactory$Generator  (id=79)	
	keyInterface	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey) (id=64)	

/ intermezzo

Enhancer.class
    public interface EnhancerKey {
        public Object newInstance(String type,
                                  String[] interfaces,
                                  WeakCacheKey<CallbackFilter> filter,
                                  Type[] callbackTypes,
                                  boolean useFactory,
                                  boolean interceptDuringConstruction,
                                  Long serialVersionUID);
    }


/ Einde intermezzo

            ce.begin_class(Constants.V1_2,
                           Constants.ACC_PUBLIC,
                           getClassName(),	/ net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
                           KEY_FACTORY,	/ Type Lnet/sf/cglib/core/KeyFactory;
                           new Type[]{ Type.getType(keyInterface) }, / net.sf.cglib.proxy.Enhancer$EnhancerKey
                           Constants.SOURCE_FILE);	/ <generated>
            EmitUtils.null_constructor(ce);
/d

/ 1313	 .

/ we gaan de newInstance mth maken 	, 

            EmitUtils.factory_method(ce, ReflectUtils.getSignature(newInstance));
ReflectUtils.geSignature(newInstance)	 
	desc	"(Ljava/lang/String;[Ljava/lang/String;Lnet/sf/cglib/core/WeakCacheKey;[Lorg/objectweb/asm/Type;ZZLjava/lang/Long;)Ljava/lang/Object;" (id=1494)	
	name	"newInstance" (id=1491)	

/s
ReflectUtils.getSignature(Member) line: 164	
        if (member instanceof Method) {
            return new Signature(member.getName(), Type.getMethodDescriptor((Method)member));
/t
/s
EmitUtils.factory_method(ClassEmitter, Signature) line: 79	

/ we gaan	,
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
        e.new_instance_this();
        e.dup();
        e.load_args();
        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));
        e.return_value();
        e.end_method();

        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
/s
ClassEmitter.begin_method(int, Signature, Type[]) line: 144	
        MethodVisitor v = cv.visitMethod(access,
                                         sig.getName(),
                                         sig.getDescriptor(),
                                         null,
                                         TypeUtils.toInternalNames(exceptions));
v org.objectweb.asm.MethodWriter@4bbfb90a																					<-
sig.getDescriptor()="(Ljava/lang/String;[Ljava/lang/String;Lnet/sf/cglib/core/WeakCacheKey;[Lorg/objectweb/asm/Type;ZZLjava/lang/Long;)Ljava/lang/Object;" (id=1494)	
sig.getName()="newInstance" (id=1491)	

       } else {
            return new CodeEmitter(this, v, access, sig, exceptions);
/s
CodeEmitter.<init>(ClassEmitter, MethodVisitor, int, Signature, Type[]) line: 106	
        super(access, sig.getDescriptor(), mv);
/s
CodeEmitter(LocalVariablesSorter).<init>(int, String, MethodVisitor) line: 73	

/ mv is de MethodWriter die hierboven is create	,
/ public class LocalVariablesSorter extends MethodVisitor {

        super(Opcodes.ASM5, mv);
        state = new State();
        Type[] args = Type.getArgumentTypes(desc);
        state.nextLocal = ((Opcodes.ACC_STATIC & access) != 0) ? 0 : 1;
        for (int i = 0; i < args.length; i++) {
7
            state.nextLocal += args[i].getSize();
        }
        firstLocal = state.nextLocal;
/t
CodeEmitter.<init>(ClassEmitter, MethodVisitor, int, Signature, Type[]) line: 107	
       super(access, sig.getDescriptor(), mv);
/d
        this.ce = ce;
        state = new State(ce.getClassInfo(), access, sig, exceptionTypes);
/t
EmitUtils.factory_method(ClassEmitter, Signature) line: 80	
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
/d
        e.new_instance_this();
/s
CodeEmitter.new_instance_this() line: 540	
        new_instance(ce.getClassType());
/s
ClassEmitter.getClassType() line: 118	
        return classInfo.getType();

this	ClassEmitter  (id=977)	
	classInfo	ClassEmitter$1  (id=1146)	
		this$0	ClassEmitter  (id=977)	
		val$access	1	
		val$classType	Type  (id=1142)		/ Lnet/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72;
		val$interfaces	Type[1]  (id=1118)	
		val$superType	Type  (id=1113)	


/ Intermezzo

public class ClassEmitter extends ClassTransformer {
    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {
        final Type classType = Type.getType("L" + className.replace('.', '/') + ";");
        classInfo = new ClassInfo() {
            public Type getType() {
                return classType;
            }
            public Type getSuperType() {
                return (superType != null) ? superType : Constants.TYPE_OBJECT;
            }
            public Type[] getInterfaces() {
                return interfaces;
            }
            public int getModifiers() {
                return access;
            }
        };
				...

/ Einde Intermezzo

/t
CodeEmitter.new_instance_this() line: 540	
        new_instance(ce.getClassType());
/pd
/s
CodeEmitter.new_instance(Type) line: 544	
        emit_type(Constants.NEW, type);
/s
CodeEmitter.emit_type(int, Type) line: 549	
        } else {
            desc = type.getInternalName(); / net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
        }
        mv.visitTypeInsn(opcode, desc);	 / opcode=Constants.NEW
/t
EmitUtils.factory_method(ClassEmitter, Signature) line: 81	
       CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
        e.new_instance_this();
/d
        e.dup();
/s
CodeEmiiter.class
    public void dup() { mv.visitInsn(Constants.DUP); }
/t
EmitUtils.factory_method(ClassEmitter, Signature) line: 81	
       CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
        e.new_instance_this();
        e.dup();
/d
        e.load_args();
/s
CodeEmitter.load_args() line: 366	
        load_args(0, state.argumentTypes.length);	/ state.argumentTypes.length==7
/s
CodeEmitter.load_args(int, int) line: 380	
/=
    public void load_args(int fromArg, int count) {	/ fromArg=0, count=7

        int pos = state.localOffset + skipArgs(fromArg);	/ state.localOffset=1
1
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];	/ Ljava/lang/String;
            load_local(t, pos);
/s
CodeEmitter.load_local(Type, int) line: 398	
        mv.visitVarInsn(t.getOpcode(Constants.ILOAD), pos);	/ aload=25 , pos=1
/t
CodeEmitter.load_args(int, int) line: 380	
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];  / Ljava/lang/String;
            load_local(t, pos);	 / pos=1
/d
            pos += t.getSize();	
/ volgende	,
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];  / Ljava/lang/String;
            load_local(t, pos);	/ aload	, pos=2
            pos += t.getSize(); 	
/ volgende	,
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];  / Lnet/sf/cglib/core/WeakCacheKey; 
            load_local(t, pos);	/ aload, pos=3
            pos += t.getSize(); 	
/ volgende	,
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];  / [Lorg/objectweb/asm/Type; 
            load_local(t, pos);	/ aload, pos=4
            pos += t.getSize(); 	
/ volgende	,
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];  / Z 
            load_local(t, pos);	/ iload, pos=5
            pos += t.getSize(); 	
/ volgende	,
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];  / Z 
            load_local(t, pos);	/ iload , pos=6
            pos += t.getSize(); 	
/ volgende	,
        for (int i = 0; i < count; i++) {
            Type t = state.argumentTypes[fromArg + i];  / Ljava/lang/Long; 
            load_local(t, pos);	/ aload , pos=7
            pos += t.getSize(); 	
/t
EmitUtils.factory_method(ClassEmitter, Signature) line: 83	
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
        e.new_instance_this();
        e.dup();
        e.load_args();
        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));
/s
/ sig.getArgumentTypes()) = Type[] van de 7 types	, 
/s
TypeUtils.parseConstructor(Type[]) line: 204	
        StringBuffer sb = new StringBuffer();
        sb.append("(");
        for (int i = 0; i < types.length; i++) {
            sb.append(types[i].getDescriptor());
        }
        sb.append(")");
        sb.append("V"); / sb= (Ljava/lang/String;[Ljava/lang/String;Lnet/sf/cglib/core/WeakCacheKey;[Lorg/objectweb/asm/Type;ZZLjava/lang/Long;)V
        return new Signature(Constants.CONSTRUCTOR_NAME, sb.toString()); / Constants.CONSTRUCTOR_NAME="<init>" 
/t
/s
CodeEmitter.invoke_constructor_this(Signature) line: 532	
        invoke_constructor(ce.getClassType(), sig); / ce.getClassType()=Lnet/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72;
/s
CodeEmitter.invoke_constructor(Type, Signature) line: 528	
        emit_invoke(Constants.INVOKESPECIAL, type, sig);
/s
CodeEmitter.emit_invoke(int, Type, Signature) line: 500	
        mv.visitMethodInsn(opcode,	/ Constants.INVOKESPECIAL
                           type.getInternalName(), / Lnet/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
                           sig.getName(),	/ <init>
                           sig.getDescriptor(),	/ (Ljava/lang/String;[Ljava/lang/String;Lnet/sf/cglib/core/WeakCacheKey;[Lorg/objectweb/asm/Type;ZZLjava/lang/Long;)V
                           opcode == Opcodes.INVOKEINTERFACE);	/ false
/t
EmitUtils.factory_method(ClassEmitter, Signature) line: 84	
        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
        e.new_instance_this();
        e.dup();
        e.load_args();
        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));
/d
        e.return_value();
/s
CodeEmitter.return_value() line: 419	
        mv.visitInsn(state.sig.getReturnType().getOpcode(Constants.IRETURN));	 / areturn, state.sig.getReturnType()=Ljava/lang/Object;
/t
EmitUtils.factory_method(ClassEmitter, Signature) line: 85	
       CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);
        e.new_instance_this();
        e.dup();
        e.load_args();
        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));
        e.return_value();
/d
        e.end_method();
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 258	
            EmitUtils.factory_method(ce, ReflectUtils.getSignature(newInstance));
/d

/ 1313	. 

/ we gaan 2de <init> maken	,  met args	, om de fields te set	, WH voor field inj	, 

            int seed = 0;
            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,
                                            TypeUtils.parseConstructor(parameterTypes),
                                            null);
/s
ClassEmitter.begin_method(int, Signature, Type[]) line: 142	
/=
    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {
/ sig=<init>(Ljava/lang/String;[Ljava/lang/String;Lnet/sf/cglib/core/WeakCacheKey;[Lorg/objectweb/asm/Type;ZZLjava/lang/Long;)V
        MethodVisitor v = cv.visitMethod(access,
                                         sig.getName(),	/ 	<init>
                                         sig.getDescriptor(),	 / (Ljava/lang/String;[Ljava/lang/String;Lnet/sf/cglib/core/WeakCacheKey;[Lorg/objectweb/asm/Type;ZZLjava/lang/Long;)V
                                         null,
                                         TypeUtils.toInternalNames(exceptions));	/ exceptions=null
v	MethodWriter  (id=1606)	

        } else {
            return new CodeEmitter(this, v, access, sig, exceptions);
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 262	
            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,
                                            TypeUtils.parseConstructor(parameterTypes),
                                            null);
/d
            e.load_this();
/s
        mv.visitVarInsn(Constants.ALOAD, 0);
/t
            e.super_invoke_constructor();
/s
CodeEmitter.super_invoke_constructor() line: 487	
        invoke_constructor(ce.getSuperType());	/ ce.getSuperType()=ce.classinfo.val$superType=Type Lnet/sf/cglib/core/KeyFactory;
/s
CodeEmitter.invoke_constructor(Type) line: 483	
        invoke_constructor(type, CSTRUCT_NULL);	/ CSTRUCT_NULL=<init>()V
/s
CodeEmitter.invoke_constructor(Type, Signature) line: 528	
        emit_invoke(Constants.INVOKESPECIAL, type, sig);	/ type=Lnet/sf/cglib/core/KeyFactory;, sig=<init>()V
/s
        mv.visitMethodInsn(opcode,
                           type.getInternalName(),
                           sig.getName(),
                           sig.getDescriptor(),
                           opcode == Opcodes.INVOKEINTERFACE);
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 264	
						...
            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,
                                            TypeUtils.parseConstructor(parameterTypes),
                                            null);
            e.load_this();
            e.super_invoke_constructor();
/d
            e.load_this();
/s
        mv.visitVarInsn(Constants.ALOAD, 0);
/t
            List<FieldTypeCustomizer> fieldTypeCustomizers = getCustomizers(FieldTypeCustomizer.class);
[]
            Type[] parameterTypes = TypeUtils.getTypes(newInstance.getParameterTypes());
seed=0
            for (int i = 0; i < parameterTypes.length; i++) {
                Type parameterType = parameterTypes[i];
                Type fieldType = parameterType;
                seed += fieldType.hashCode();
-689322901
                ce.declare_field(Constants.ACC_PRIVATE | Constants.ACC_FINAL,
                                 getFieldName(i),	/ FIELD_0
                                 fieldType, / Ljava/lang/String;
                                 null);
/s
ClassEmitter.declare_field(int, String, Type, Object) line: 185	
        FieldInfo existing = (FieldInfo)fieldInfo.get(name);
null
        FieldInfo info = new FieldInfo(access, name, type, value);
access	18	
name	"FIELD_0" (id=1637)	
type	Type  (id=1067)	
value	null	
        } else {
            fieldInfo.put(name, info);
            cv.visitField(access, name, type.getDescriptor(), null, value);
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 277	
           for (int i = 0; i < parameterTypes.length; i++) {
                Type parameterType = parameterTypes[i];	/ Ljava/lang/String;
                Type fieldType = parameterType;
                seed += fieldType.hashCode();
                ce.declare_field(Constants.ACC_PRIVATE | Constants.ACC_FINAL,
                                 getFieldName(i),
                                 fieldType,
                                 null);
/d
                e.dup();
/s
    public void dup() { mv.visitInsn(Constants.DUP); }
/t
                e.load_arg(i);
/s
CodeEmitter.load_arg(int) line: 374	
       load_local(state.argumentTypes[index],
                   state.localOffset + skipArgs(index));
/s
CodeEmitter.load_local(Type, int) line: 398	
/=
    private void load_local(Type t, int pos) {
t	Type  (id=1649)	 / Ljava/lang/String;
pos	1	
        mv.visitVarInsn(t.getOpcode(Constants.ILOAD), pos);	/ aload, 1
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 282	
                e.load_arg(i);
                e.putfield(getFieldName(i));
/s
CodeEmitter.putfield(String) line: 429	
/=
    public void putfield(String name) { / name= "FIELD_0"
        ClassEmitter.FieldInfo info = ce.getFieldInfo(name);
/s
        FieldInfo field = (FieldInfo)fieldInfo.get(name);
field	ClassEmitter$FieldInfo  (id=1641)	
	access	18	
	name	"FIELD_0" (id=1637)	
	type	Type  (id=1067)	
	value	null	
/t
        int opcode = TypeUtils.isStatic(info.access) ? Constants.PUTSTATIC : Constants.PUTFIELD;
        emit_field(opcode, ce.getClassType(), name, info.type);
/s
        return classInfo.getType();
/t
/s
CodeEmitter.emit_field(int, Type, String, Type) line: 468	
       mv.visitFieldInsn(opcode, 				/ putfield
                          ctype.getInternalName(), / net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
                          name,	/ FIELD_0
                          ftype.getDescriptor()); / Ljava/lang/String;
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 267	
/ volgende,	
           for (int i = 0; i < parameterTypes.length; i++) {
                Type parameterType = parameterTypes[i];
                Type fieldType = parameterType;
                seed += fieldType.hashCode();
                ce.declare_field(Constants.ACC_PRIVATE | Constants.ACC_FINAL,
                                 getFieldName(i),
                                 fieldType,
                                 null);
                e.dup();
                e.load_arg(i);
                e.putfield(getFieldName(i));
            }
/ we geloven het	, 
            e.return_value();
/s
        mv.visitInsn(state.sig.getReturnType().getOpcode(Constants.IRETURN));	/ return 	, want state.sig.getReturnType()=V
/t
            e.end_method();
/s
        visitMaxs(0, 0);
/s
            mv.visitMaxs(0, 0);
/t
KeyFactory$Generator.generateClass(ClassVisitor) line: 288	
            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,
                                            TypeUtils.parseConstructor(parameterTypes),
                                            null);
						...
            e.end_method();
/d

/ 1313	. 

/ we gaan de hashCode method maken	, 

           // hash code
            e = ce.begin_method(Constants.ACC_PUBLIC, HASH_CODE, null);
            int hc = (constant != 0) ? constant : PRIMES[(int)(Math.abs(seed) % PRIMES.length)];
            int hm = (multiplier != 0) ? multiplier : PRIMES[(int)(Math.abs(seed * 13) % PRIMES.length)];
            e.push(hc);
            for (int i = 0; i < parameterTypes.length; i++) {
                e.load_this();
                e.getfield(getFieldName(i));
                EmitUtils.hash_code(e, parameterTypes[i], hm, customizers);
            }
            e.return_value();
            e.end_method();

/ 1313	. 

/ we gaan de equals mth maken 	, 

            // equals
            e = ce.begin_method(Constants.ACC_PUBLIC, EQUALS, null);
            Label fail = e.make_label();
            e.load_arg(0);
            e.instance_of_this();
            e.if_jump(e.EQ, fail);
            for (int i = 0; i < parameterTypes.length; i++) {
                e.load_this();
                e.getfield(getFieldName(i));
                e.load_arg(0);
                e.checkcast_this();
                e.getfield(getFieldName(i));
                EmitUtils.not_equals(e, parameterTypes[i], fail, customizers);
            }
            e.push(1);
            e.return_value();
            e.mark(fail);
            e.push(0);
            e.return_value();
            e.end_method();

/ 1313	. 

/ we gaan de toString mth maken	, 

            // toString
            e = ce.begin_method(Constants.ACC_PUBLIC, TO_STRING, null);
            e.new_instance(Constants.TYPE_STRING_BUFFER);	/ Ljava/lang/StringBuffer;
            e.dup();
            e.invoke_constructor(Constants.TYPE_STRING_BUFFER);
            for (int i = 0; i < parameterTypes.length; i++) {
                if (i > 0) {
                    e.push(", ");
                    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING); / APPEND_STRING=append(Ljava/lang/String;)Ljava/lang/StringBuffer;
                }
                e.load_this();
                e.getfield(getFieldName(i));
                EmitUtils.append_string(e, parameterTypes[i], EmitUtils.DEFAULT_DELIMITERS, customizers);
            }
            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);
            e.return_value();
            e.end_method();

            ce.end_class();
        }
/t
DefaultGeneratorStrategy.generate(ClassGenerator) line: 26	
        transform(cg).generateClass(cw);
/d
        return transform(cw.toByteArray());
/s
DebuggingClassWriter$1.run() line: 78	
      return (byte[]) java.security.AccessController.doPrivileged(
        new java.security.PrivilegedAction() {
            public Object run() {
                byte[] b = ((ClassWriter) DebuggingClassWriter.super.cv).toByteArray();	/ TODO super ipv this	,
this	DebuggingClassWriter$1  (id=1714)		/ new java.security.PrivilegedAction()'s class type	, 
	this$0	DebuggingClassWriter  (id=969)	
		api	327680	
		className	"net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72" (id=1201)	
		cv	ClassWriter  (id=1193)	
		superName	"net.sf.cglib.core.KeyFactory" (id=1202)	
/ is ASM method	, 
                return b;
/t
DefaultGeneratorStrategy.generate(ClassGenerator) line: 26	
        return transform(cw.toByteArray());
/pd
/ en transform doet NIETS	, 
/t
KeyFactory$Generator(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 330	
            byte[] b = strategy.generate(this);
/d
            String className = ClassNameReader.getClassName(new ClassReader(b)); / net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
            ProtectionDomain protectionDomain = getProtectionDomain();
ProtectionDomain  (file:/home/eric/.gradle/caches/modules-2/files-2.1/cglib/cglib/3.2.5/326f6509e4933ee1d5f7a92662bc5a0d8f21e3ec/cglib-3.2.5.jar <no signer certificates>)
 sun.misc.Launcher$AppClassLoader@18b4aac2
 <no principals>
 java.security.Permissions@2833cc44 (
 ("java.io.FilePermission" "/home/eric/.gradle/caches/modules-2/files-2.1/cglib/cglib/3.2.5/326f6509e4933ee1d5f7a92662bc5a0d8f21e3ec/cglib-3.2.5.jar" "read")
 ("java.lang.RuntimePermission" "exitVM")
)

               } else {
                    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);
/s
ReflectUtils.defineClass(String, byte[], ClassLoader, ProtectionDomain) line: 457	

/ intermezzo

/ 13	 .

/ tijdens debug, we proberen de byte[] b naar file te  write	, 

/ geef: java byte array to file
/ lees,	 
http://stackoverflow.com/questions/4350084/byte-to-file-in-java

Commons IO	, 
FileUtils.writeByteArrayToFile(new File("pathname"), myByteArray)

/ of	, 

FileOutputStream fos = new FileOutputStream("pathname");
fos.write(myByteArray);
fos.close();

/ 13	 .

/ we open in eclipse  Display	, en type
java.io.FileOutputStream fos = new java.io.FileOutputStream("/tmp/bytes.class");
fos.write(b);
fos.close();
/ right click , Execute 

/ we moeten /tmp/bytes.class op .class laten eindigen	, anders werkt javap -c niet	, 

/ Ga naar de command line, 	

[eric@almond asm-study]$ javap -c -verbose /tmp/bytes.class  > /tmp/bytes.disassem

  Compiled from "<generated>"
public class net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72 extends net.sf.cglib.core.KeyFactory implements net.sf.cglib.proxy.Enhancer$EnhancerKey
  minor version: 0
  major version: 46
  flags: ACC_PUBLIC
Constant pool:
    #1 = Utf8               net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
    #2 = Class              #1            // net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
    #3 = Utf8               net/sf/cglib/core/KeyFactory
    #4 = Class              #3            // net/sf/cglib/core/KeyFactory
    #5 = Utf8               net/sf/cglib/proxy/Enhancer$EnhancerKey
    #6 = Class              #5            // net/sf/cglib/proxy/Enhancer$EnhancerKey
    #7 = Utf8               <generated>
    #8 = Utf8               <init>
    #9 = Utf8               ()V
   #10 = NameAndType        #8:#9         // "<init>":()V
   #11 = Methodref          #4.#10        // net/sf/cglib/core/KeyFactory."<init>":()V
...

  public net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72();
    Code:
       0: aload_0
       1: invokespecial #11                 // Method net/sf/cglib/core/KeyFactory."<init>":()V
       4: return

  public java.lang.Object newInstance(java.lang.String, java.lang.String[], net.sf.cglib.core.WeakCacheKey, org.objectweb.asm.Type[], boolean, boolean, java.lang.Long);
    Code:
       0: new           #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
       3: dup
       4: aload_1
       5: aload_2
       6: aload_3
       7: aload         4
       9: iload         5
      11: iload         6
      13: aload         7
      15: invokespecial #16                 // Method "<init>":(Ljava/lang/String;[Ljava/lang/String;Lnet/sf/cglib/core/WeakCacheKey;[Lorg/objectweb/asm/Type;ZZLjava/lang/Long;)V
      18: areturn

  public net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72(java.lang.String, java.lang.String[], net.sf.cglib.core.WeakCacheKey, org.objectweb.asm.Type[], boolean, boolean, java.lang.Long);
    Code:
       0: aload_0
       1: invokespecial #11                 // Method net/sf/cglib/core/KeyFactory."<init>":()V
       4: aload_0
       5: dup
       6: aload_1
       7: putfield      #30                 // Field FIELD_0:Ljava/lang/String;
      10: dup
      11: aload_2
      12: putfield      #33                 // Field FIELD_1:[Ljava/lang/String;
      15: dup
      16: aload_3
      17: putfield      #37                 // Field FIELD_2:Lnet/sf/cglib/core/WeakCacheKey;
      20: dup
      21: aload         4
      23: putfield      #40                 // Field FIELD_3:[Lorg/objectweb/asm/Type;
      26: dup
      27: iload         5
      29: putfield      #44                 // Field FIELD_4:Z
      32: dup
      33: iload         6
      35: putfield      #47                 // Field FIELD_5:Z
      38: dup
      39: aload         7
      41: putfield      #51                 // Field FIELD_6:Ljava/lang/Long;
      44: return

  public int hashCode();
    Code:
       0: sipush        19289
       3: aload_0
       4: getfield      #30                 // Field FIELD_0:Ljava/lang/String;
       7: swap
       8: ldc           #54                 // int 641371
      10: imul
      11: swap
      12: dup
      13: ifnull        22
      16: invokevirtual #58                 // Method java/lang/Object.hashCode:()I
      19: goto          24
      22: pop
      23: iconst_0
      24: iadd
      25: aload_0
      26: getfield      #33                 // Field FIELD_1:[Ljava/lang/String;
      29: dup
      30: ifnull        72
      33: astore_1
      34: iconst_0
      35: istore_2
      36: goto          63
      39: aload_1
      40: iload_2
      41: aaload
      42: swap
      43: ldc           #54                 // int 641371
      45: imul
      46: swap
      47: dup
      48: ifnull        57
      51: invokevirtual #58                 // Method java/lang/Object.hashCode:()I
      54: goto          59
      57: pop
      58: iconst_0
      59: iadd
      60: iinc          2, 1
      63: iload_2
      64: aload_1
      65: arraylength
      66: if_icmplt     39
      69: goto          73
      72: pop
      73: aload_0
      74: getfield      #37                 // Field FIELD_2:Lnet/sf/cglib/core/WeakCacheKey;
      77: swap
      78: ldc           #54                 // int 641371
      80: imul
      81: swap
      82: dup
      83: ifnull        92
      86: invokevirtual #58                 // Method java/lang/Object.hashCode:()I
      89: goto          94
      92: pop
      93: iconst_0
      94: iadd
      95: aload_0
      96: getfield      #40                 // Field FIELD_3:[Lorg/objectweb/asm/Type;
      99: dup
     100: ifnull        145
     103: astore_3
     104: iconst_0
     105: istore        4
     107: goto          135
     110: aload_3
     111: iload         4
     113: aaload
     114: swap
     115: ldc           #54                 // int 641371
     117: imul
     118: swap
     119: dup
     120: ifnull        129
     123: invokevirtual #58                 // Method java/lang/Object.hashCode:()I
     126: goto          131
     129: pop
     130: iconst_0
     131: iadd
     132: iinc          4, 1
     135: iload         4
     137: aload_3
     138: arraylength
     139: if_icmplt     110
     142: goto          146
     145: pop
     146: aload_0
     147: getfield      #44                 // Field FIELD_4:Z
     150: swap
     151: ldc           #54                 // int 641371
     153: imul
     154: swap
     155: iconst_1
     156: ixor
     157: iadd
     158: aload_0
     159: getfield      #47                 // Field FIELD_5:Z
     162: swap
     163: ldc           #54                 // int 641371
     165: imul
     166: swap
     167: iconst_1
     168: ixor
     169: iadd
     170: aload_0
     171: getfield      #51                 // Field FIELD_6:Ljava/lang/Long;
     174: swap
     175: ldc           #54                 // int 641371
     177: imul
     178: swap
     179: dup
     180: ifnull        189
     183: invokevirtual #58                 // Method java/lang/Object.hashCode:()I
     186: goto          191
     189: pop
     190: iconst_0
     191: iadd
     192: ireturn

  public boolean equals(java.lang.Object);
    Code:
       0: aload_1
       1: instanceof    #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
       4: ifeq          348
       7: aload_0
       8: getfield      #30                 // Field FIELD_0:Ljava/lang/String;
      11: aload_1
      12: checkcast     #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
      15: getfield      #30                 // Field FIELD_0:Ljava/lang/String;
      18: dup2
      19: ifnonnull     29
      22: ifnonnull     35
      25: pop2
      26: goto          45
      29: ifnull        35
      32: goto          39
      35: pop2
      36: goto          348
      39: invokevirtual #64                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
      42: ifeq          348
      45: aload_0
      46: getfield      #33                 // Field FIELD_1:[Ljava/lang/String;
      49: aload_1
      50: checkcast     #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
      53: getfield      #33                 // Field FIELD_1:[Ljava/lang/String;
      56: dup2
      57: ifnonnull     67
      60: ifnonnull     73
      63: pop2
      64: goto          141
      67: ifnull        73
      70: goto          77
      73: pop2
      74: goto          348
      77: dup2
      78: arraylength
      79: swap
      80: arraylength
      81: if_icmpeq     88
      84: pop2
      85: goto          348
      88: astore_2
      89: astore_3
      90: iconst_0
      91: istore        4
      93: goto          134
      96: aload_2
      97: iload         4
      99: aaload
     100: aload_3
     101: iload         4
     103: aaload
     104: dup2
     105: ifnonnull     115
     108: ifnonnull     121
     111: pop2
     112: goto          131
     115: ifnull        121
     118: goto          125
     121: pop2
     122: goto          348
     125: invokevirtual #64                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
     128: ifeq          348
     131: iinc          4, 1
     134: iload         4
     136: aload_2
     137: arraylength
     138: if_icmplt     96
     141: aload_0
     142: getfield      #37                 // Field FIELD_2:Lnet/sf/cglib/core/WeakCacheKey;
     145: aload_1
     146: checkcast     #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
     149: getfield      #37                 // Field FIELD_2:Lnet/sf/cglib/core/WeakCacheKey;
     152: dup2
     153: ifnonnull     163
     156: ifnonnull     169
     159: pop2
     160: goto          179
     163: ifnull        169
     166: goto          173
     169: pop2
     170: goto          348
     173: invokevirtual #64                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
     176: ifeq          348
     179: aload_0
     180: getfield      #40                 // Field FIELD_3:[Lorg/objectweb/asm/Type;
     183: aload_1
     184: checkcast     #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
     187: getfield      #40                 // Field FIELD_3:[Lorg/objectweb/asm/Type;
     190: dup2
     191: ifnonnull     201
     194: ifnonnull     207
     197: pop2
     198: goto          280
     201: ifnull        207
     204: goto          211
     207: pop2
     208: goto          348
     211: dup2
     212: arraylength
     213: swap
     214: arraylength
     215: if_icmpeq     222
     218: pop2
     219: goto          348
     222: astore        5
     224: astore        6
     226: iconst_0
     227: istore        7
     229: goto          272
     232: aload         5
     234: iload         7
     236: aaload
     237: aload         6
     239: iload         7
     241: aaload
     242: dup2
     243: ifnonnull     253
     246: ifnonnull     259
     249: pop2
     250: goto          269
     253: ifnull        259
     256: goto          263
     259: pop2
     260: goto          348
     263: invokevirtual #64                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
     266: ifeq          348
     269: iinc          7, 1
     272: iload         7
     274: aload         5
     276: arraylength
     277: if_icmplt     232
     280: aload_0
     281: getfield      #44                 // Field FIELD_4:Z
     284: aload_1
     285: checkcast     #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
     288: getfield      #44                 // Field FIELD_4:Z
     291: if_icmpne     348
     294: aload_0
     295: getfield      #47                 // Field FIELD_5:Z
     298: aload_1
     299: checkcast     #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
     302: getfield      #47                 // Field FIELD_5:Z
     305: if_icmpne     348
     308: aload_0
     309: getfield      #51                 // Field FIELD_6:Ljava/lang/Long;
     312: aload_1
     313: checkcast     #2                  // class net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
     316: getfield      #51                 // Field FIELD_6:Ljava/lang/Long;
     319: dup2
     320: ifnonnull     330
     323: ifnonnull     336
     326: pop2
     327: goto          346
     330: ifnull        336
     333: goto          340
     336: pop2
     337: goto          348
     340: invokevirtual #64                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
     343: ifeq          348
     346: iconst_1
     347: ireturn
     348: iconst_0
     349: ireturn

  public java.lang.String toString();
    Code:
       0: new           #68                 // class java/lang/StringBuffer
       3: dup
       4: invokespecial #69                 // Method java/lang/StringBuffer."<init>":()V
       7: aload_0
       8: getfield      #30                 // Field FIELD_0:Ljava/lang/String;
      11: dup
      12: ifnull        24
      15: invokevirtual #71                 // Method java/lang/Object.toString:()Ljava/lang/String;
      18: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      21: goto          30
      24: pop
      25: ldc           #77                 // String null
      27: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      30: ldc           #79                 // String ,
      32: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      35: aload_0
      36: getfield      #33                 // Field FIELD_1:[Ljava/lang/String;
      39: dup
      40: ifnull        110
      43: swap
      44: ldc           #81                 // String {
      46: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      49: swap
      50: astore_1
      51: iconst_0
      52: istore_2
      53: goto          86
      56: aload_1
      57: iload_2
      58: aaload
      59: dup
      60: ifnull        72
      63: invokevirtual #71                 // Method java/lang/Object.toString:()Ljava/lang/String;
      66: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      69: goto          78
      72: pop
      73: ldc           #77                 // String null
      75: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      78: ldc           #79                 // String ,
      80: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      83: iinc          2, 1
      86: iload_2
      87: aload_1
      88: arraylength
      89: if_icmplt     56
      92: dup
      93: dup
      94: invokevirtual #84                 // Method java/lang/StringBuffer.length:()I
      97: iconst_2
      98: isub
      99: invokevirtual #88                 // Method java/lang/StringBuffer.setLength:(I)V
     102: ldc           #90                 // String }
     104: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     107: goto          116
     110: pop
     111: ldc           #77                 // String null
     113: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     116: ldc           #79                 // String ,
     118: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     121: aload_0
     122: getfield      #37                 // Field FIELD_2:Lnet/sf/cglib/core/WeakCacheKey;
     125: dup
     126: ifnull        138
     129: invokevirtual #71                 // Method java/lang/Object.toString:()Ljava/lang/String;
     132: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     135: goto          144
     138: pop
     139: ldc           #77                 // String null
     141: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     144: ldc           #79                 // String ,
     146: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     149: aload_0
     150: getfield      #40                 // Field FIELD_3:[Lorg/objectweb/asm/Type;
     153: dup
     154: ifnull        227
     157: swap
     158: ldc           #81                 // String {
     160: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     163: swap
     164: astore_3
     165: iconst_0
     166: istore        4
     168: goto          202
     171: aload_3
     172: iload         4
     174: aaload
     175: dup
     176: ifnull        188
     179: invokevirtual #71                 // Method java/lang/Object.toString:()Ljava/lang/String;
     182: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     185: goto          194
     188: pop
     189: ldc           #77                 // String null
     191: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     194: ldc           #79                 // String ,
     196: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     199: iinc          4, 1
     202: iload         4
     204: aload_3
     205: arraylength
     206: if_icmplt     171
     209: dup
     210: dup
     211: invokevirtual #84                 // Method java/lang/StringBuffer.length:()I
     214: iconst_2
     215: isub
     216: invokevirtual #88                 // Method java/lang/StringBuffer.setLength:(I)V
     219: ldc           #90                 // String }
     221: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     224: goto          233
     227: pop
     228: ldc           #77                 // String null
     230: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     233: ldc           #79                 // String ,
     235: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     238: aload_0
     239: getfield      #44                 // Field FIELD_4:Z
     242: invokevirtual #93                 // Method java/lang/StringBuffer.append:(Z)Ljava/lang/StringBuffer;
     245: goto          254
     248: nop
     249: nop
     250: nop
     251: nop
     252: nop
     253: athrow
     254: ldc           #79                 // String ,
     256: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     259: aload_0
     260: getfield      #47                 // Field FIELD_5:Z
     263: invokevirtual #93                 // Method java/lang/StringBuffer.append:(Z)Ljava/lang/StringBuffer;
     266: goto          275
     269: nop
     270: nop
     271: nop
     272: nop
     273: nop
     274: athrow
     275: ldc           #79                 // String ,
     277: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     280: aload_0
     281: getfield      #51                 // Field FIELD_6:Ljava/lang/Long;
     284: dup
     285: ifnull        297
     288: invokevirtual #71                 // Method java/lang/Object.toString:()Ljava/lang/String;
     291: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     294: goto          303
     297: pop
     298: ldc           #77                 // String null
     300: invokevirtual #75                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
     303: invokevirtual #94                 // Method java/lang/StringBuffer.toString:()Ljava/lang/String;
     306: areturn
}

/ Einde Intermezzo

/ Intermezzo

public class ReflectUtils {
    private static Method DEFINE_CLASS, DEFINE_CLASS_UNSAFE;
    static {
                defineClass = (Method) AccessController.doPrivileged(new PrivilegedExceptionAction() {
                    public Object run() throws Exception {
                            Class loader = Class.forName("java.lang.ClassLoader"); // JVM crash w/o this
                            Method defineClass = loader.getDeclaredMethod("defineClass",
                                                                    new Class[]{ String.class,
                                                                                 byte[].class,
                                                                                 Integer.TYPE,
                                                                                 Integer.TYPE,
                                                                                 ProtectionDomain.class });
                            defineClass.setAccessible(true);
                            return defineClass;
                    }
                });
        DEFINE_CLASS = defineClass;

/ Einde Intermezzo

/ we waren in 	,
/s
ReflectUtils.defineClass(String, byte[], ClassLoader, ProtectionDomain) line: 457	
/=
    public static Class defineClass(String className, byte[] b, ClassLoader loader, ProtectionDomain protectionDomain) throws Exception {
className=net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72

        if (DEFINE_CLASS != null) {
/j

            Object[] args = new Object[]{className, b, new Integer(0), new Integer(b.length), protectionDomain };
            c = (Class)DEFINE_CLASS.invoke(loader, args);
        // Force static initializers to run.
        Class.forName(className, true, loader);
/ TODO
/t
KeyFactory$Generator(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 339	
                } else {
                    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);
/d
                }
            }
            return gen;
/t


/ Intermezzo

/ Wat zijn we aan het doen?

/s
	AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator) line: 94	
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);	/ class net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
                            return gen.wrapCachedClass(klass);	<-	/ gen=net.sf.cglib.core.KeyFactory$Generator@544fe44c
/cb
	AbstractClassGenerator$ClassLoaderData$3.apply(Object) line: 91	
	LoadingCache$2.call() line: 54	
            task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);				<-
/cb
	FutureTask<V>.run() line: 266	
                    result = c.call();		/ c=LoadingCache$2
/cb
	LoadingCache<K,KK,e>.createEntry(K, KK, Object) line: 61	
            task = new FutureTask<V>(new Callable<V>() {			/ LoadingCache$2
                public V call() throws Exception {
                    return loader.apply(key);
                }
            });
                task.run();
/cb
	LoadingCache<K,KK,V>.get(K) line: 34	
        return createEntry(key, cacheKey, v);	/ key=net.sf.cglib.core.KeyFactory$Generator@544fe44c, cacheKey="net.sf.cglib.proxy.Enhancer$EnhancerKey"
/cb
	AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 116	
              Object cachedValue = generatedClasses.get(gen);
/cb
	KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 291	
            Object obj = data.get(this, getUseCache());
/ See (*) hieronder	, 
/cb
	KeyFactory$Generator.create() line: 221	
            return (KeyFactory)super.create(keyInterface.getName());
/cb
	KeyFactory.create(ClassLoader, Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 174	
        Generator gen = new Generator();	/ net.sf.cglib.core.KeyFactory$Generator@544fe44c
        gen.setInterface(keyInterface);
        gen.setClassLoader(loader);
        return gen.create();
/cb
	KeyFactory.create(Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 153	
        return create(keyInterface.getClassLoader(), keyInterface, first, next);	/ keyInterface=interface net.sf.cglib.proxy.Enhancer$EnhancerKey
/cb
	Enhancer.<clinit>() line: 73	
    private static final EnhancerKey KEY_FACTORY =
      (EnhancerKey)KeyFactory.create(EnhancerKey.class, KeyFactory.HASH_ASM_TYPE, null);
/cb
	SampleTest.testFixedValue() line: 23	
		Enhancer enhancer=new Enhancer();
/cb
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 498	
	FrameworkMethod$1.runReflectiveCall() line: 50	
	FrameworkMethod$1(ReflectiveCallable).run() line: 12	
	FrameworkMethod.invokeExplosively(Object, Object...) line: 47	
	InvokeMethod.evaluate() line: 17	
	ExpectException.evaluate() line: 19	
	BlockJUnit4ClassRunner(ParentRunner<T>).runLeaf(Statement, Description, RunNotifier) line: 325	
	BlockJUnit4ClassRunner.runChild(FrameworkMethod, RunNotifier) line: 78	
	BlockJUnit4ClassRunner.runChild(Object, RunNotifier) line: 57	
	ParentRunner$3.run() line: 290	
	ParentRunner$1.schedule(Runnable) line: 71	
	BlockJUnit4ClassRunner(ParentRunner<T>).runChildren(RunNotifier) line: 288	
	ParentRunner<T>.access$000(ParentRunner, RunNotifier) line: 58	
	ParentRunner$2.evaluate() line: 268	
	BlockJUnit4ClassRunner(ParentRunner<T>).run(RunNotifier) line: 363	
	JUnit4TestClassReference(JUnit4TestReference).run(TestExecution) line: 50	
	TestExecution.run(ITestReference[]) line: 38	
	RemoteTestRunner.runTests(String[], String, TestExecution) line: 459	
	RemoteTestRunner.runTests(TestExecution) line: 675	
	RemoteTestRunner.run() line: 382	
	RemoteTestRunner.main(String[]) line: 192	

/ (*)
data	AbstractClassGenerator$ClassLoaderData  (id=875)	
	classLoader	WeakReference<T>  (id=884)	
	generatedClasses	LoadingCache<K,KK,V>  (id=888)	
		keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=892)	
		loader	AbstractClassGenerator$ClassLoaderData$3  (id=887)	
		map	ConcurrentHashMap<K,V>  (id=896)	/ {net.sf.cglib.proxy.Enhancer$EnhancerKey=java.util.concurrent.FutureTask@31dc339b}
	reservedClassNames	HashSet<E>  (id=885)	
	uniqueNamePredicate	AbstractClassGenerator$ClassLoaderData$1  (id=890)	

abstract public class AbstractClassGenerator<T> implements ClassGenerator
    protected static class ClassLoaderData {


        private static final Function<AbstractClassGenerator, Object> GET_KEY = new Function<AbstractClassGenerator, Object>() {
            public Object apply(AbstractClassGenerator gen) {
                return gen.key;
            }
        };
/=
/ AbstractClassGenerator$ClassLoaderData$2  (id=892)	

        public ClassLoaderData(ClassLoader classLoader) {
            this.classLoader = new WeakReference<ClassLoader>(classLoader);
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);
                            return gen.wrapCachedClass(klass);
                        }
                    };
/= net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3@dc24521

            generatedClasses = new LoadingCache<AbstractClassGenerator, Object, Object>(GET_KEY, load);
        }


/ Einde Intermezzo

/t
AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator) line: 94	
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);
/d
gen	KeyFactory$Generator  (id=79)	
klass	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	

                            return gen.wrapCachedClass(klass);	
/s
KeyFactory$Generator(AbstractClassGenerator<T>).wrapCachedClass(Class) line: 123	
        return (T) new WeakReference(klass);
/t
LoadingCache$2.call() line: 54	
            task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);				<-
/d
/t
FutureTask<V>.run() line: 266	
                    result = c.call();
/d
result	WeakReference<T>  (id=1890)	
	referent	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	

                    ran = true;
                if (ran)
                    set(result);
/s
FutureTask<V>.set(V) line: 233	
            outcome = v;
/d
/t
LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 61	
                task.run();
/d
            result = task.get();
result	WeakReference<T>  (id=1890)	
	referent	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	

        if (creator) {
            map.put(cacheKey, result);

this	LoadingCache<K,KK,V>  (id=888)	
	keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=892)	
	loader	AbstractClassGenerator$ClassLoaderData$3  (id=887)	
		this$0	AbstractClassGenerator$ClassLoaderData  (id=875)	
			classLoader	WeakReference<T>  (id=884)	
			generatedClasses	LoadingCache<K,KK,V>  (id=888)	
				keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=892)	
				loader	AbstractClassGenerator$ClassLoaderData$3  (id=887)	
				map	ConcurrentHashMap<K,V>  (id=896)															<---|
			reservedClassNames	HashSet<E>  (id=885)																|	/ =
			uniqueNamePredicate	AbstractClassGenerator$ClassLoaderData$1  (id=890)	|
	map	ConcurrentHashMap<K,V>  (id=896)																		<---|
{net.sf.cglib.proxy.Enhancer$EnhancerKey=java.lang.ref.WeakReference@1b68ddbd
	referent	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	
}

        return result;
/t
LoadingCache<K,KK,V>.get(K) line: 34	
        return createEntry(key, cacheKey, v);
/d
AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 117	
              Object cachedValue = generatedClasses.get(gen);
/d
cachedValue	WeakReference<T>  (id=1890)	
	referent	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	

              return gen.unwrapCachedValue(cachedValue);
/s
KeyFactory$Generator(AbstractClassGenerator<T>).unwrapCachedValue(T) line: 127	
        return ((WeakReference) cached).get();
/t
KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 292	
            Object obj = data.get(this, getUseCache());
/d
obj	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	

            if (obj instanceof Class) {
                return firstInstance((Class) obj);
/s
KeyFactory$Generator.firstInstance(Class) line: 233	
            return ReflectUtils.newInstance(type);
/s
ReflectUtils.newInstance(Class) line: 277	
        return newInstance(type, Constants.EMPTY_CLASS_ARRAY, null);
/s
ReflectUtils.newInstance(Class, Class[], Object[]) line: 281	
        return newInstance(getConstructor(type, parameterTypes), args);

type	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	
parameterTypes	Class<T>[0]  (id=1998)	
args	null	

/s
ReflectUtils.getConstructor(Class, Class[]) line: 309	
            Constructor constructor = type.getDeclaredConstructor(parameterTypes);
constructor	Constructor<T>  (id=2008)		/ public net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72()

            constructor.setAccessible(true);
            return constructor;
/t
/s
ReflectUtils.newInstance(Constructor, Object[]) line: 286	
            Object result = cstruct.newInstance(args);
cstruct	Constructor<T>  (id=2008)	
args	null	
flag	true	
result	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2012)	
	FIELD_0	null	
	FIELD_1	null	
	FIELD_2	null	
	FIELD_3	null	
	FIELD_4	false	
	FIELD_5	false	
	FIELD_6	null	

            return result;
/t
KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 293	
            if (obj instanceof Class) {
                return firstInstance((Class) obj);
/d
/t
KeyFactory$Generator.create() line: 221	
            return (KeyFactory)super.create(keyInterface.getName());
/d
/t
KeyFactory.create(ClassLoader, Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 174	
        Generator gen = new Generator();
        gen.setInterface(keyInterface);
        gen.setClassLoader(loader);
        return gen.create();
/d
KeyFactory.create(Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 153	
        return create(keyInterface.getClassLoader(), keyInterface, first, next);
/d
Enhancer.<clinit>() line: 73	
   private static final EnhancerKey KEY_FACTORY =
      (EnhancerKey)KeyFactory.create(EnhancerKey.class, KeyFactory.HASH_ASM_TYPE, null);
/d
KEY_FACTORY	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2012)	

///////////////////////////////////////////////////////////
/ Einde UITSTAP 

    private static final Type OBJECT_TYPE = TypeUtils.parseType("Object");
/s
TypeUtils.parseType(String) line: 184	
        return Type.getType(map(s));	 / Type is ASM type	, 
/s
TypeUtils.map(String) line: 226	
/=
    private static String map(String type) {	/ type="Object"

        } else if (type.indexOf('.') < 0) {
            return map("java.lang." + type);			/ rec call
/s
TypeUtils.map(String) line: 235	
/=
    private static String map(String type) {	/ type="java.lang.Object"

        } else {
            StringBuffer sb = new StringBuffer();
            type = type.substring(0, type.length() - sb.length() * 2);
            sb.append('L').append(type.replace('.', '/')).append(';');
            return sb.toString();
/t
TypeUtils.parseType(String) line: 184	
        return Type.getType(map(s));	/ map(s)="Ljava/lang/Object;"
/pd
/d
/t
Enhancer.<clinit>() line: 95	
   private static final Type OBJECT_TYPE = TypeUtils.parseType("Object");
/d
	...
/t
SampleTest.testFixedValue() line: 23	
		Enhancer enhancer=new Enhancer();
/s
Enhancer.<init>() line: 173	
        super(SOURCE);
/s
Enhancer(AbstractClassGenerator<T>).<init>(AbstractClassGenerator$Source) line: 42	
    private static volatile Map<ClassLoader, ClassLoaderData> CACHE = new WeakHashMap<ClassLoader, ClassLoaderData>();

    private GeneratorStrategy strategy = DefaultGeneratorStrategy.INSTANCE;
    private NamingPolicy namingPolicy = DefaultNamingPolicy.INSTANCE;
        this.source = source;
source	AbstractClassGenerator$Source  (id=2047)	
	name	"net.sf.cglib.proxy.Enhancer" (id=2101)	

/t
SampleTest.testFixedValue() line: 24	
		Enhancer enhancer=new Enhancer();
/d
		enhancer.setSuperclass(Sample.class);
		enhancer.setCallback(new FixedValue() {
			@Override
			public Object loadObject() throws Exception {
				return testHello;
			}
		});

/ Intermezzo

package net.sf.cglib.proxy;

/**
 * {@link Enhancer} callback that simply returns the value to return
 * from the proxied method. No information about what method
 * is being called is available to the callback, and the type of
 * the returned object must be compatible with the return type of
 * the proxied method. This makes this callback primarily useful
 * for forcing a particular method (through the use of a {@link CallbackFilter}
 * to return a fixed value with little overhead.
 */
public interface FixedValue extends Callback {
    /**
     * Return the object which the original method invocation should
     * return. This method is called for <b>every</b> method invocation.
     * @return an object matching the type of the return value for every
     * method this callback is mapped to
     */
    Object loadObject() throws Exception;
}

/ Omdat	Sample's methods een String return, 
public class Sample {
	public String fct(String input){
		return "fct "+input;
	}
	public String fct2(String input){
		return "fct2 "+input;
	}
}
/ moet de methods van FixedValue dat ook	, 
		enhancer.setCallback(new FixedValue() {
			
			@Override
			public Object loadObject() throws Exception {
				return testHello;
			}
		});
/ TODO

/ Einde Intermezzo

/s
Enhancer.setCallback(Callback) line: 226	
/=
    public void setCallback(final Callback callback) { / callback	SampleTest$1  (id=2149)	
        setCallbacks(new Callback[]{ callback });
/s
Enhancer.setCallbacks(Callback[]) line: 243	
        this.callbacks = callbacks;
/t
SampleTest.testFixedValue() line: 32	
		enhancer.setCallback(new FixedValue() {
			
			@Override
			public Object loadObject() throws Exception {
				return testHello;
			}
		});
/d
		Sample sample=(Sample)enhancer.create();
/s
Enhancer.create() line: 303	
        classOnly = false;
        argumentTypes = null;
        return createHelper();
/s
Enhancer.createHelper() line: 471	
        preValidate();
/s
Enhancer.preValidate() line: 350	
        if (callbackTypes == null) {
            callbackTypes = CallbackInfo.determineTypes(callbacks, false);
/s
CallbackInfo.determineTypes(Callback[], boolean) line: 39	
        Type[] types = new Type[callbacks.length];
        for (int i = 0; i < types.length; i++) {
            types[i] = determineType(callbacks[i], checkAll);
/s
CallbackInfo.determineType(Callback, boolean) line: 77	
        return determineType(callback.getClass(), checkAll);
/s
CallbackInfo.determineType(Class, boolean) line: 84	

/ Intermezzo

/ CALLBACKINFO FixedValue, ...

class CallbackInfo
{
    private static final CallbackInfo[] CALLBACKS = {
        new CallbackInfo(NoOp.class, NoOpGenerator.INSTANCE),
        new CallbackInfo(MethodInterceptor.class, MethodInterceptorGenerator.INSTANCE),
        new CallbackInfo(InvocationHandler.class, InvocationHandlerGenerator.INSTANCE),
        new CallbackInfo(LazyLoader.class, LazyLoaderGenerator.INSTANCE),
        new CallbackInfo(Dispatcher.class, DispatcherGenerator.INSTANCE),
        new CallbackInfo(FixedValue.class, FixedValueGenerator.INSTANCE),
        new CallbackInfo(ProxyRefDispatcher.class, DispatcherGenerator.PROXY_REF_INSTANCE),
    };


/ Einde Intermezzo

callbackType	Class<T> (first.SampleTest$1) (id=2148)	 = new FixedValue(){...} in 	,	
/=
		enhancer.setCallback(new FixedValue() {				<-
			@Override
			public Object loadObject() throws Exception {
				return testHello;
			}
		});

        for (int i = 0; i < CALLBACKS.length; i++) {
            CallbackInfo info = CALLBACKS[i];
            if (info.cls.isAssignableFrom(callbackType)) {
                if (cur != null) {
                    throw new IllegalStateException("Callback implements both " + cur + " and " + info.cls);
                }
                cur = info.cls;	/ interface net.sf.cglib.proxy.FixedValue
                type = info.type;	/ Lnet/sf/cglib/proxy/FixedValue;	 / ASM type	,
               if (!checkAll) {
                    break;
        return type;
/t
CallbackInfo.determineTypes(Callback[], boolean) line: 43	
       for (int i = 0; i < types.length; i++) {
            types[i] = determineType(callbacks[i], checkAll);
/d
        }
        return types;
/t
Enhancer.preValidate() line: 351	
            callbackTypes = CallbackInfo.determineTypes(callbacks, false);
/d
this	Enhancer  (id=2099)	
	callbackTypes	Type[1]  (id=2242)	
		[0]	Type  (id=2202)				/ Lnet/sf/cglib/proxy/FixedValue;

            validateCallbackTypes = true;

       if (filter == null) {
            filter = ALL_ZERO;

/ Intermezzo

    private static final CallbackFilter ALL_ZERO = new CallbackFilter(){
        public int accept(Method method) {
            return 0;
        }
    };

/ Einde Intermezzo

/t
Enhancer.createHelper() line: 472	
        preValidate();
/d
        Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,	
                ReflectUtils.getNames(interfaces),
                filter == ALL_ZERO ? null : new WeakCacheKey<CallbackFilter>(filter),
                callbackTypes,
                useFactory,
                interceptDuringConstruction,
                serialVersionUID);
this	Enhancer  (id=2099)	
	callbackTypes	Type[1]  (id=2242)	
		[0]	Type  (id=2202)							/ Lnet/sf/cglib/proxy/FixedValue;
	interceptDuringConstruction	true	
	interfaces	null	
	serialVersionUID	null	
	superclass	Class<T> (first.Sample) (id=2146)	
	useFactory	true	
key	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	
	FIELD_0	"first.Sample" (id=2297)	
	FIELD_1	null	
	FIELD_2	null	
	FIELD_3	Type[1]  (id=2242)	/ [Lnet/sf/cglib/proxy/FixedValue;]
	FIELD_4	true	
	FIELD_5	true	
	FIELD_6	null	


/ Intermezzo

/ Boven bij javap -c -verbose zagen we dat newInstance <init> called	, en alle aloads deed	, 
/ Er is maar 1 <init> 	, en verschillende ctor in Java bepalen eig alleen welke aloads er worden gedaan	, 

key.getClass()=class net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72
"key.getClass()"	 (pending)	
	annotationData	null	
	annotationType	null	
	cachedConstructor	null	
	classLoader	Launcher$AppClassLoader  (id=43)	
	classRedefinedCount	0	
	classValueMap	null	
	enumConstantDirectory	null	
	enumConstants	null	
	genericInfo	null	
	name	"net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72" (id=2308)	
	newInstanceCallerCache	null	
	reflectionData	SoftReference<T>  (id=2309)	
		discovered	null	
		next	null	
		queue	ReferenceQueue$Null<S>  (id=1796)	
		referent	Class$ReflectionData<T>  (id=2317)	
		timestamp	1218905950	

key.getClass().getSuperclass()=class net.sf.cglib.core.KeyFactory
"key.getClass().getSuperclass()"	 (pending)	
	annotationData	null	
	annotationType	null	
	cachedConstructor	null	
	classLoader	Launcher$AppClassLoader  (id=43)	
	classRedefinedCount	0	
	classValueMap	null	
	enumConstantDirectory	null	
	enumConstants	null	
	genericInfo	null	
	name	"net.sf.cglib.core.KeyFactory" (id=98)	
	newInstanceCallerCache	null	
	reflectionData	null	

/ einde Intermezzo

        this.currentKey = key;
this	Enhancer  (id=2099)	
	currentKey	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	

        Object result = super.create(key);
/s
Enhancer(AbstractClassGenerator<T>).create(Object) line: 275	
            ClassLoader loader = getClassLoader();	/ sun.misc.Launcher$AppClassLoader@18b4aac2
            Map<ClassLoader, ClassLoaderData> cache = CACHE;
            ClassLoaderData data = cache.get(loader);
cache	WeakHashMap<K,V>  (id=868)	
	[0]	AbstractMap$SimpleEntry<K,V>  (id=2386)	
		key	Launcher$AppClassLoader  (id=43)	
		value	AbstractClassGenerator$ClassLoaderData  (id=875)	/ data	
			classLoader	WeakReference<T>  (id=884)	
			generatedClasses	LoadingCache<K,KK,V>  (id=888)	
				keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=892)	
				loader	AbstractClassGenerator$ClassLoaderData$3  (id=887)	
				map	ConcurrentHashMap<K,V>  (id=896)	
					[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2398)	
						key	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=866)	
						value	WeakReference<T>  (id=1890)	
							discovered	null	
							next	null	
							queue	ReferenceQueue$Null<S>  (id=1796)	
							referent	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	
			reservedClassNames	HashSet<E>  (id=885)	
			uniqueNamePredicate	AbstractClassGenerator$ClassLoaderData$1  (id=890)	


            this.key = key;
this	Enhancer  (id=2099)	
key	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	
	FIELD_0	"first.Sample" (id=2297)	
	FIELD_1	null	
	FIELD_2	null	
	FIELD_3	Type[1]  (id=2242)		/ [Lnet/sf/cglib/proxy/FixedValue;]
	FIELD_4	true	
	FIELD_5	true	
	FIELD_6	null	
            Object obj = data.get(this, getUseCache());
/s
AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 113	
           } else {
              Object cachedValue = generatedClasses.get(gen);	/ gen	Enhancer  (id=2099)	
/s
LoadingCache<K,KK,V>.get(K) line: 28	
        final KK cacheKey = keyMapper.apply(key);
/s
AbstractClassGenerator$ClassLoaderData$2.apply(AbstractClassGenerator) line: 81	
/=
AbstractClassGenerator.class
       private static final Function<AbstractClassGenerator, Object> GET_KEY = new Function<AbstractClassGenerator, Object>() {
            public Object apply(AbstractClassGenerator gen) {
                return gen.key;																	<-
            }
        };
gen	Enhancer  (id=2099)	
	key	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	
		FIELD_0	"first.Sample" (id=2297)	
		FIELD_1	null	
		FIELD_2	null	
		FIELD_3	Type[1]  (id=2242)	
		FIELD_4	true	
		FIELD_5	true	
		FIELD_6	null	
/t
LoadingCache<K,KK,V>.get(K) line: 29	
        final KK cacheKey = keyMapper.apply(key);
/d
cacheKey	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	
	FIELD_0	"first.Sample" (id=2297)	
	FIELD_1	null	
	FIELD_2	null	
	FIELD_3	Type[1]  (id=2242)	
	FIELD_4	true	
	FIELD_5	true	
	FIELD_6	null	

        Object v = map.get(cacheKey);
null
        return createEntry(key, cacheKey, v);	/ key=Enhancer
/s
LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 47	
            task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);
                }
            });
           Object prevTask = map.putIfAbsent(cacheKey, task);
null
            if (prevTask == null) {
                // creator does the load
                creator = true;
                task.run();
/s
LoadingCache$2.call() line: 54	
           task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);					<-
/s
AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator) line: 93	
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);		<-
/s
Enhancer.generate(AbstractClassGenerator$ClassLoaderData) line: 486	
        validate();
/s
Enhancer.validate() line: 386	
        } else if (callbacks != null) {
            callbackTypes = CallbackInfo.determineTypes(callbacks);
this	Enhancer  (id=2099)	
	callbacks	Callback[1]  (id=2156)	
		[0]	SampleTest$1  (id=2149)		  
this.callbacks[0].getClass().getInterfaces()=Class<T>[1] [interface net.sf.cglib.proxy.FixedValue]
...
/s
CallbackInfo.determineType(Class, boolean) line: 87	

/ Intermezzo

class CallbackInfo
    private static final CallbackInfo[] CALLBACKS = {
        new CallbackInfo(NoOp.class, NoOpGenerator.INSTANCE),
        new CallbackInfo(MethodInterceptor.class, MethodInterceptorGenerator.INSTANCE),
        new CallbackInfo(InvocationHandler.class, InvocationHandlerGenerator.INSTANCE),
        new CallbackInfo(LazyLoader.class, LazyLoaderGenerator.INSTANCE),
        new CallbackInfo(Dispatcher.class, DispatcherGenerator.INSTANCE),
        new CallbackInfo(FixedValue.class, FixedValueGenerator.INSTANCE),
        new CallbackInfo(ProxyRefDispatcher.class, DispatcherGenerator.PROXY_REF_INSTANCE),
    };

/ Einde Intermezzo

       for (int i = 0; i < CALLBACKS.length; i++) {
            CallbackInfo info = CALLBACKS[i];
            if (info.cls.isAssignableFrom(callbackType)) {
                cur = info.cls;
                type = info.type;
                if (!checkAll) {
                    break;
                }
            }
        }
        return type; / Type Lnet/sf/cglib/proxy/FixedValue;
    }
/t
Enhancer.generate(AbstractClassGenerator$ClassLoaderData) line: 487	
        validate();
/d
        if (superclass != null) {								/ first.Sample
            setNamePrefix(superclass.getName());
        return super.generate(data);

data	AbstractClassGenerator$ClassLoaderData  (id=875)	
	classLoader	WeakReference<T>  (id=884)	
	generatedClasses	LoadingCache<K,KK,V>  (id=888)	
		keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=892)	
		loader	AbstractClassGenerator$ClassLoaderData$3  (id=887)	
		map	ConcurrentHashMap<K,V>  (id=896)	
			[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2592)	
				key	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=866)	
				value	WeakReference<T>  (id=1890)	
					discovered	null	
					next	null	
					queue	ReferenceQueue$Null<S>  (id=1796)	
					referent	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	
			[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2593)																													/ TODO
				key	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	
				value	FutureTask<V>  (id=2541)	
					callable	LoadingCache$2  (id=2542)		/ (*) beneden	, 
					outcome	null	
					runner	Thread  (id=1)	
					state	0	
					waiters	null	
	reservedClassNames	HashSet<E>  (id=885)	
	uniqueNamePredicate	AbstractClassGenerator$ClassLoaderData$1  (id=890)	
/ (*)
            task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);
                }
            });

/s
Enhancer(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 307	
            ClassLoader classLoader = data.getClassLoader();
              String name = generateClassName(data.getUniqueNamePredicate()); / AbstractClassGenerator$ClassLoaderData$1  (id=890)	

/ Intermezzo

abstract public class AbstractClassGenerator<T> implements ClassGenerator {
    protected static class ClassLoaderData {
        private final Predicate uniqueNamePredicate = new Predicate() {
            public boolean evaluate(Object name) {
                return reservedClassNames.contains(name);
            }
        };

/ Einde Intermezzo

/s
Enhancer(AbstractClassGenerator<T>).generateClassName(Predicate) line: 154	
        return namingPolicy.getClassName(namePrefix, source.name, key, nameTestPredicate);
this	Enhancer  (id=2099)	
	key	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	
	namePrefix	"first.Sample" (id=2297)	
	source	AbstractClassGenerator$Source  (id=2047)	
		name	"net.sf.cglib.proxy.Enhancer" (id=2101)	
nameTestPredicate	AbstractClassGenerator$ClassLoaderData$1  (id=890)	
/s
DefaultNamingPolicy.getClassName(String, String, Object, Predicate) line: 46	

        String base =
            prefix + "$$" + 
            source.substring(source.lastIndexOf('.') + 1) +
            getTag() + "$$" +																						/ "ByCGLIB" 
            Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());
first.Sample$$EnhancerByCGLIB$$2fef46f3
        return attempt;
/t
Enhancer(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 317	
              String name = generateClassName(data.getUniqueNamePredicate());              
/d
              data.reserveName(name);	data.reservedClassNames=[net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72, first.Sample$$EnhancerByCGLIB$$2fef46f3]
              this.setClassName(name);	/ this=Enhancer	,

            byte[] b = strategy.generate(this);
/s
DefaultGeneratorStrategy.generate(ClassGenerator) line: 25	
        DebuggingClassWriter cw = getClassVisitor();
        transform(cg).generateClass(cw);	/ transform doet niets	, 
/s
Enhancer.generateClass(ClassVisitor) line: 562	
        Class sc = (superclass == null) ? Object.class : superclass;
first.Sample
        if (TypeUtils.isFinal(sc.getModifiers()))
/n
            throw new IllegalArgumentException("Cannot subclass final class " + sc.getName());
/n
        List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));
[public first.Sample()]
        filterConstructors(sc, constructors);
/s
    /**
     * Filter the list of constructors from the superclass. The
     * constructors which remain will be included in the generated
     * class. The default implementation is to filter out all private
     * constructors, but subclasses may extend Enhancer to override this
     * behavior.
     */
Enhancer.filterConstructors(Class, List) line: 664	
        CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true));
/s
VisibilityPredicate.<init>(Class, boolean) line: 27	
/=
    public VisibilityPredicate(Class source, boolean protectedOk) {
source	Class<T> (first.Sample) (id=2146)	
protectedOk	true	

        this.protectedOk = protectedOk;
        // same package is not ok for the bootstrap loaded classes.  In all other cases we are 
        // generating classes in the same classloader
        this.samePackageOk = source.getClassLoader() != null;
true
        pkg = TypeUtils.getPackageName(Type.getType(source));
first
/t
/s
CollectionUtils.filter(Collection, Predicate) line: 50	
/=
    public static Collection filter(Collection c, Predicate p) {
c	ArrayList<E>  (id=2693)	
	[0]	Constructor<T>  (id=2698)		public first.Sample()
p	VisibilityPredicate  (id=2704)	
	pkg	"first" (id=2713)	
	protectedOk	true	
	samePackageOk	true	

        Iterator it = c.iterator();
        while (it.hasNext()) {
            if (!p.evaluate(it.next())) {
/s
VisibilityPredicate.evaluate(Object) line: 35	
        Member member = (Member)arg;		/ public first.Sample()

/ Intermezzo
/**
 * Member is an interface that reflects identifying information about
 * a single member (a field or a method) or a constructor.
 *
 */
/ Einde Intermezzo

        if (Modifier.isPrivate(mod)) {
/n
        } else if (Modifier.isPublic(mod)) {
            return true;
/t
CollectionUtils.filter(Collection, Predicate) line: 56	
        Iterator it = c.iterator();
        while (it.hasNext()) {
            if (!p.evaluate(it.next())) {
/n
                it.remove();
/n
            }
        }
        return c; 	/ ze ( er is er maar 1) gaan allemaal door	, 
/ t
Enhancer.generateClass(ClassVisitor) line: 572	
        filterConstructors(sc, constructors);
/d
        // Order is very important: must add superclass, then
        // its superclass chain, then each interface and
        // its superinterfaces.
        List actualMethods = new ArrayList();
        List interfaceMethods = new ArrayList();
        final Set forcePublic = new HashSet();
        getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);
/s
Enhancer.getMethods(Class, Class[], List, List, Set) line: 540	
/=
    private static void getMethods(Class superclass, Class[] interfaces, List methods, List interfaceMethods, Set forcePublic)
superclass	Class<T> (first.Sample) (id=2146)	
interfaces	null	
methods	ArrayList<E>  (id=2736)	 	[]
interfaceMethods	ArrayList<E>  (id=2804)	 []
forcePublic	HashSet<E>  (id=2805)	

        ReflectUtils.addAllMethods(superclass, methods); 	/ methods=[]	nu, maar hier komen ze in 	,
/s
ReflectUtils.addAllMethods(Class, List) line: 413	
        } else
            list.addAll(java.util.Arrays.asList(type.getDeclaredMethods()));
list	ArrayList<E>  (id=2736)	
	[0]	Method  (id=2741) public java.lang.String first.Sample.fct(java.lang.String) 
	[1]	Method  (id=2742) public java.lang.String first.Sample.fct2(java.lang.String)

        Class superclass = type.getSuperclass();
        if (superclass != null) {
            addAllMethods(superclass, list);

list	ArrayList<E>  (id=2736)	
	[0]	Method  (id=2741) public java.lang.String first.Sample.fct(java.lang.String)	
	[1]	Method  (id=2742) public java.lang.String first.Sample.fct2(java.lang.String)	
	[2]	Method  (id=2776) public boolean java.lang.Object.equals(java.lang.Object)	
	[3]	Method  (id=2777) public java.lang.String java.lang.Object.toString()	
	[4]	Method  (id=2778) public native int java.lang.Object.hashCode()	
	[5]	Method  (id=2779) protected native java.lang.Object java.lang.Object.clone() throws java.lang.CloneNotSupportedException	

        Class[] interfaces = type.getInterfaces();
interfaces	Class<T>[0]  (id=2798)	

		return list;
/t
Enhancer.getMethods(Class, Class[], List, List, Set) line: 540	
        ReflectUtils.addAllMethods(superclass, methods);
/d
        List target = (interfaceMethods != null) ? interfaceMethods : methods;
[]
        if (interfaces != null) {
/n
            for (int i = 0; i < interfaces.length; i++) {
/n
                if (interfaces[i] != Factory.class) {
/n
                    ReflectUtils.addAllMethods(interfaces[i], target);
/n
        if (interfaceMethods != null) {
/j
[]
            if (forcePublic != null) {
/j
[]
                forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));	/ interfaceMethods=[]
/s
MethodWrapper.<clinit>() line: 23	
   private static final MethodWrapperKey KEY_FACTORY =
      (MethodWrapperKey)KeyFactory.create(MethodWrapperKey.class);
/s
KeyFactory.create(Class) line: 145	
        return create(keyInterface, null);
/s
KeyFactory.create(Class, Customizer) line: 149	
        return create(keyInterface.getClassLoader(), keyInterface,  customizer);
/s
KeyFactory.create(ClassLoader, Class, Customizer) line: 157	
        return create(loader, keyInterface, customizer, Collections.<KeyFactoryCustomizer>emptyList());
/s
KeyFactory.create(ClassLoader, Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 174	
/=
    public static KeyFactory create(ClassLoader loader, Class keyInterface, KeyFactoryCustomizer customizer,
                                    List<KeyFactoryCustomizer> next) {
loader	Launcher$AppClassLoader  (id=43)	
keyInterface	Class<T> (net.sf.cglib.core.MethodWrapper$MethodWrapperKey) (id=2828)	
customizer	null	
next	Collections$EmptyList<E>  (id=1624)	 []

        Generator gen = new Generator();
        gen.setInterface(keyInterface);
        gen.setClassLoader(loader);
        return gen.create();
/s
KeyFactory$Generator.create() line: 221	
            setNamePrefix(keyInterface.getName());
            return (KeyFactory)super.create(keyInterface.getName());
/s
KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 291	
/=
    protected Object create(Object key) {

            ClassLoader loader = getClassLoader();
            ClassLoaderData data = cache.get(loader);
data	AbstractClassGenerator$ClassLoaderData  (id=875)	
	classLoader	WeakReference<T>  (id=884)	
	generatedClasses	LoadingCache<K,KK,V>  (id=888)	
		keyMapper	AbstractClassGenerator$ClassLoaderData$2  (id=892)	
		loader	AbstractClassGenerator$ClassLoaderData$3  (id=887)	
		map	ConcurrentHashMap<K,V>  (id=896)	
			[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2848)	
				key	"net.sf.cglib.proxy.Enhancer$EnhancerKey" (id=866)	
				value	WeakReference<T>  (id=1890)	
					discovered	null	
					next	null	
					queue	ReferenceQueue$Null<S>  (id=1796)	
					referent	Class<T> (net.sf.cglib.proxy.Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72) (id=1771)	
			[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2849)	
				key	"net.sf.cglib.core.MethodWrapper$MethodWrapperKey" (id=2845)	
				value	FutureTask<V>  (id=2826)	
			[2]	ConcurrentHashMap$MapEntry<K,V>  (id=2850)	
				key	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=2296)	
				value	FutureTask<V>  (id=2541)	
	reservedClassNames	HashSet<E>  (id=885)	
	uniqueNamePredicate	AbstractClassGenerator$ClassLoaderData$1  (id=890)	

key	"net.sf.cglib.core.MethodWrapper$MethodWrapperKey" (id=2845)	

            Object obj = data.get(this, getUseCache());
/s
AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 116	
            } else {
              Object cachedValue = generatedClasses.get(gen);
/s
LoadingCache<K,KK,V>.get(K) line: 34	
        final KK cacheKey = keyMapper.apply(key);
        Object v = map.get(cacheKey);
null
        if (v != null && !(v instanceof FutureTask)) {
/n
        return createEntry(key, cacheKey, v);
/s
LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 61	
        } else {
            task = new FutureTask<V>(new Callable<V>() {	 / new Callable = FutureTask$2`,	
                public V call() throws Exception {
                    return loader.apply(key);
                }
            });
            Object prevTask = map.putIfAbsent(cacheKey, task);
            if (prevTask == null) {
                // creator does the load
                creator = true;
                task.run();
/s
FutureTask<V>.run() line: 266	
            Callable<V> c = callable;		/ FutureTask$2
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
/s
LoadingCache$2.call() line: 54	
            task = new FutureTask<V>(new Callable<V>() {
                public V call() throws Exception {
                    return loader.apply(key);								<-
/s
AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator) line: 93	
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);		<-
/s
KeyFactory$Generator(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 329	
            synchronized (classLoader) {
              String name = generateClassName(data.getUniqueNamePredicate());              
              data.reserveName(name);
              this.setClassName(name); "net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7"

            byte[] b = strategy.generate(this);
/s
DefaultGeneratorStrategy.generate(ClassGenerator) line: 25	
        DebuggingClassWriter cw = getClassVisitor();
        transform(cg).generateClass(cw);
/s
KeyFactory$Generator.generateClass(ClassVisitor) line: 241	
/ TODO Afmaken	, 
/t
DefaultGeneratorStrategy.generate(ClassGenerator) line: 26	
        transform(cg).generateClass(cw);
        return transform(cw.toByteArray());
/s
DebuggingClassWriter$1.run() line: 79	
                byte[] b = ((ClassWriter) DebuggingClassWriter.super.cv).toByteArray();	/ .toByteArray() is ASM method	,
                return b;


/ Intermezzo

/ in eclipse, Display	, 
java.io.FileOutputStream fos = new java.io.FileOutputStream("/home/eric/Devel/Java/cglib/method.class");
fos.write(b);
fos.close();
/ Doe right click , execute	 

[eric@almond cglib]$  pwd
/home/eric/Devel/Java/cglib
[eric@almond cglib]$ javap -c -verbose method.class >method.disassem
[eric@almond cglib]$ ls
enhancer.class  enhancer.disassem  method.class  method.disassem

/ Nu zijn er andere fields	 
/ TODO

$ vi method.disassem

Classfile /home/eric/Devel/Java/cglib/method.class
  Last modified Mar 28, 2017; size 2214 bytes
  MD5 checksum 4879249ffd45e22de045a04a2c5e93d4
  Compiled from "<generated>"
public class net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 extends net.sf.cglib.core.KeyFactory implements net.sf.cglib.core.MethodWrapper$MethodWrapperKey
  minor version: 0
  major version: 46
  flags: ACC_PUBLIC
Constant pool:
   #1 = Utf8               net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7
   #2 = Class              #1             // net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7
   #3 = Utf8               net/sf/cglib/core/KeyFactory
   #4 = Class              #3             // net/sf/cglib/core/KeyFactory
   #5 = Utf8               net/sf/cglib/core/MethodWrapper$MethodWrapperKey
   #6 = Class              #5             // net/sf/cglib/core/MethodWrapper$MethodWrapperKey
   #7 = Utf8               <generated>
   #8 = Utf8               <init>
   #9 = Utf8               ()V
  #10 = NameAndType        #8:#9          // "<init>":()V
  #11 = Methodref          #4.#10         // net/sf/cglib/core/KeyFactory."<init>":()V
  #12 = Utf8               newInstance
  #13 = Utf8               (Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
  #14 = Utf8               (Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V
  #15 = NameAndType        #8:#14         // "<init>":(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V
  #16 = Methodref          #2.#15         // net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7."<init>":(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V
  #17 = Utf8               FIELD_0
  #18 = Utf8               Ljava/lang/String;
  #19 = NameAndType        #17:#18        // FIELD_0:Ljava/lang/String;
  #20 = Fieldref           #2.#19         // net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7.FIELD_0:Ljava/lang/String;
  #21 = Utf8               FIELD_1
  #22 = Utf8               [Ljava/lang/String;
  #23 = NameAndType        #21:#22        // FIELD_1:[Ljava/lang/String;
  #24 = Fieldref           #2.#23         // net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7.FIELD_1:[Ljava/lang/String;
  #25 = Utf8               FIELD_2
  #26 = NameAndType        #25:#18        // FIELD_2:Ljava/lang/String;
  #27 = Fieldref           #2.#26         // net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7.FIELD_2:Ljava/lang/String;
  #28 = Utf8               hashCode
  #29 = Utf8               ()I
  #30 = Integer            938313161
  #31 = Integer            362693231
  #32 = Utf8               java/lang/Object
  #33 = Class              #32            // java/lang/Object
  #34 = NameAndType        #28:#29        // hashCode:()I
  #35 = Methodref          #33.#34        // java/lang/Object.hashCode:()I
  #36 = Utf8               java/lang/String
  #37 = Class              #36            // java/lang/String
  #38 = Class              #22            // "[Ljava/lang/String;"
  #39 = Utf8               equals
  #40 = Utf8               (Ljava/lang/Object;)Z
  #41 = NameAndType        #39:#40        // equals:(Ljava/lang/Object;)Z
  #42 = Methodref          #33.#41        // java/lang/Object.equals:(Ljava/lang/Object;)Z
  #43 = Utf8               toString
  #44 = Utf8               ()Ljava/lang/String;
  #45 = Utf8               java/lang/StringBuffer
  #46 = Class              #45            // java/lang/StringBuffer
  #47 = Methodref          #46.#10        // java/lang/StringBuffer."<init>":()V
  #48 = NameAndType        #43:#44        // toString:()Ljava/lang/String;
  #49 = Methodref          #33.#48        // java/lang/Object.toString:()Ljava/lang/String;
  #50 = Utf8               append
  #51 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuffer;
  #52 = NameAndType        #50:#51        // append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
  #53 = Methodref          #46.#52        // java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
  #54 = Utf8               null
  #55 = String             #54            // null
  #56 = Utf8               ,
  #57 = String             #56            // ,
  #58 = Utf8               {
  #59 = String             #58            // {
  #60 = Utf8               length
  #61 = NameAndType        #60:#29        // length:()I
  #62 = Methodref          #46.#61        // java/lang/StringBuffer.length:()I
  #63 = Utf8               setLength
  #64 = Utf8               (I)V
  #65 = NameAndType        #63:#64        // setLength:(I)V
  #66 = Methodref          #46.#65        // java/lang/StringBuffer.setLength:(I)V
  #67 = Utf8               }
  #68 = String             #67            // }
  #69 = Methodref          #46.#48        // java/lang/StringBuffer.toString:()Ljava/lang/String;
  #70 = Utf8               Code
  #71 = Utf8               StackMap
  #72 = Utf8               SourceFile
{
  public net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #11                 // Method net/sf/cglib/core/KeyFactory."<init>":()V
         4: return

  public java.lang.Object newInstance(java.lang.String, java.lang.String[], java.lang.String);
    descriptor: (Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
    flags: ACC_PUBLIC
    Code:
      stack=5, locals=4, args_size=4
         0: new           #2                  // class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7
         3: dup
         4: aload_1
         5: aload_2
         6: aload_3
         7: invokespecial #16                 // Method "<init>":(Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V
        10: areturn

  public net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7(java.lang.String, java.lang.String[], java.lang.String);
    descriptor: (Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=4, args_size=4
         0: aload_0
         1: invokespecial #11                 // Method net/sf/cglib/core/KeyFactory."<init>":()V
         4: aload_0
         5: dup
         6: aload_1
         7: putfield      #20                 // Field FIELD_0:Ljava/lang/String;
        10: dup
        11: aload_2
        12: putfield      #24                 // Field FIELD_1:[Ljava/lang/String;
        15: dup
        16: aload_3
        17: putfield      #27                 // Field FIELD_2:Ljava/lang/String;
        20: return

  public int hashCode();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=3, args_size=1
         0: ldc           #30                 // int 938313161
         2: aload_0
         3: getfield      #20                 // Field FIELD_0:Ljava/lang/String;
         6: swap
         7: ldc           #31                 // int 362693231
         9: imul
        10: swap
        11: dup
        12: ifnull        21
        15: invokevirtual #35                 // Method java/lang/Object.hashCode:()I
        18: goto          23
        21: pop
        22: iconst_0
        23: iadd
        24: aload_0
        25: getfield      #24                 // Field FIELD_1:[Ljava/lang/String;
        28: dup
        29: ifnull        71
        32: astore_1
        33: iconst_0
        34: istore_2
        35: goto          62
        38: aload_1
        39: iload_2
        40: aaload
        41: swap
        42: ldc           #31                 // int 362693231
        44: imul
        45: swap
        46: dup
        47: ifnull        56
        50: invokevirtual #35                 // Method java/lang/Object.hashCode:()I
        53: goto          58
        56: pop
        57: iconst_0
        58: iadd
        59: iinc          2, 1
        62: iload_2
        63: aload_1
        64: arraylength
        65: if_icmplt     38
        68: goto          72
        71: pop
        72: aload_0
        73: getfield      #27                 // Field FIELD_2:Ljava/lang/String;
        76: swap
        77: ldc           #31                 // int 362693231
        79: imul
        80: swap
        81: dup
        82: ifnull        91
        85: invokevirtual #35                 // Method java/lang/Object.hashCode:()I
        88: goto          93
        91: pop
        92: iconst_0
        93: iadd
        94: ireturn
      StackMap: number_of_entries = 10
        frame_type = 255 offset = 21
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ int, class java/lang/String ]
        frame_type = 255 offset = 23
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ int, int ]
        frame_type = 255 offset = 38
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ int ]
        frame_type = 255 offset = 56
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ int, class java/lang/String ]
        frame_type = 255 offset = 58
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ int, int ]
        frame_type = 255 offset = 62
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ int ]
        frame_type = 255 offset = 71
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ int, class "[Ljava/lang/String;" ]
        frame_type = 255 offset = 72
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ int ]
        frame_type = 255 offset = 91
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ int, class java/lang/String ]
        frame_type = 255 offset = 93
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ int, int ]

  public boolean equals(java.lang.Object);
    descriptor: (Ljava/lang/Object;)Z
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=5, args_size=2
         0: aload_1
         1: instanceof    #2                  // class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7
         4: ifeq          181
         7: aload_0
         8: getfield      #20                 // Field FIELD_0:Ljava/lang/String;
        11: aload_1
        12: checkcast     #2                  // class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7
        15: getfield      #20                 // Field FIELD_0:Ljava/lang/String;
        18: dup2
        19: ifnonnull     29
        22: ifnonnull     35
        25: pop2
        26: goto          45
        29: ifnull        35
        32: goto          39
        35: pop2
        36: goto          181
        39: invokevirtual #42                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
        42: ifeq          181
        45: aload_0
        46: getfield      #24                 // Field FIELD_1:[Ljava/lang/String;
        49: aload_1
        50: checkcast     #2                  // class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7
        53: getfield      #24                 // Field FIELD_1:[Ljava/lang/String;
        56: dup2
        57: ifnonnull     67
        60: ifnonnull     73
        63: pop2
        64: goto          141
        67: ifnull        73
        70: goto          77
        73: pop2
        74: goto          181
        77: dup2
        78: arraylength
        79: swap
        80: arraylength
        81: if_icmpeq     88
        84: pop2
        85: goto          181
        88: astore_2
        89: astore_3
        90: iconst_0
        91: istore        4
        93: goto          134
        96: aload_2
        97: iload         4
        99: aaload
       100: aload_3
       101: iload         4
       103: aaload
       104: dup2
       105: ifnonnull     115
       108: ifnonnull     121
       111: pop2
       112: goto          131
       115: ifnull        121
       118: goto          125
       121: pop2
       122: goto          181
       125: invokevirtual #42                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
       128: ifeq          181
       131: iinc          4, 1
       134: iload         4
       136: aload_2
       137: arraylength
       138: if_icmplt     96
       141: aload_0
       142: getfield      #27                 // Field FIELD_2:Ljava/lang/String;
       145: aload_1
       146: checkcast     #2                  // class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7
       149: getfield      #27                 // Field FIELD_2:Ljava/lang/String;
       152: dup2
       153: ifnonnull     163
       156: ifnonnull     169
       159: pop2
       160: goto          179
       163: ifnull        169
       166: goto          173
       169: pop2
       170: goto          181
       173: invokevirtual #42                 // Method java/lang/Object.equals:(Ljava/lang/Object;)Z
       176: ifeq          181
       179: iconst_1
       180: ireturn
       181: iconst_0
       182: ireturn
      StackMap: number_of_entries = 20
        frame_type = 255 offset = 29
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class java/lang/String, class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 35
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 39
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 45
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = []
        frame_type = 255 offset = 67
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class "[Ljava/lang/String;", class "[Ljava/lang/String;", class "[Ljava/lang/String;" ]
        frame_type = 255 offset = 73
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class "[Ljava/lang/String;", class "[Ljava/lang/String;" ]
        frame_type = 255 offset = 77
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class "[Ljava/lang/String;", class "[Ljava/lang/String;" ]
        frame_type = 255 offset = 88
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class "[Ljava/lang/String;", class "[Ljava/lang/String;" ]
        frame_type = 255 offset = 96
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object, class "[Ljava/lang/String;", class "[Ljava/lang/String;", int ]
          stack = []
        frame_type = 255 offset = 115
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object, class "[Ljava/lang/String;", class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/String, class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 121
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object, class "[Ljava/lang/String;", class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 125
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object, class "[Ljava/lang/String;", class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 131
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object, class "[Ljava/lang/String;", class "[Ljava/lang/String;", int ]
          stack = []
        frame_type = 255 offset = 134
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object, class "[Ljava/lang/String;", class "[Ljava/lang/String;", int ]
          stack = []
        frame_type = 255 offset = 141
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = []
        frame_type = 255 offset = 163
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class java/lang/String, class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 169
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 173
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = [ class java/lang/String, class java/lang/String ]
        frame_type = 255 offset = 179
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = []
        frame_type = 255 offset = 181
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class java/lang/Object ]
          stack = []

  public java.lang.String toString();
    descriptor: ()Ljava/lang/String;
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=3, args_size=1
         0: new           #46                 // class java/lang/StringBuffer
         3: dup
         4: invokespecial #47                 // Method java/lang/StringBuffer."<init>":()V
         7: aload_0
         8: getfield      #20                 // Field FIELD_0:Ljava/lang/String;
        11: dup
        12: ifnull        24
        15: invokevirtual #49                 // Method java/lang/Object.toString:()Ljava/lang/String;
        18: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
        21: goto          30
        24: pop
        25: ldc           #55                 // String null
        27: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
        30: ldc           #57                 // String ,
        32: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
        35: aload_0
        36: getfield      #24                 // Field FIELD_1:[Ljava/lang/String;
        39: dup
        40: ifnull        110
        43: swap
        44: ldc           #59                 // String {
        46: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
        49: swap
        50: astore_1
        51: iconst_0
        52: istore_2
        53: goto          86
        56: aload_1
        57: iload_2
        58: aaload
        59: dup
        60: ifnull        72
        63: invokevirtual #49                 // Method java/lang/Object.toString:()Ljava/lang/String;
        66: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
        69: goto          78
        72: pop
        73: ldc           #55                 // String null
        75: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
        78: ldc           #57                 // String ,
        80: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
        83: iinc          2, 1
        86: iload_2
        87: aload_1
        88: arraylength
        89: if_icmplt     56
        92: dup
        93: dup
        94: invokevirtual #62                 // Method java/lang/StringBuffer.length:()I
        97: iconst_2
        98: isub
        99: invokevirtual #66                 // Method java/lang/StringBuffer.setLength:(I)V
       102: ldc           #68                 // String }
       104: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
       107: goto          116
       110: pop
       111: ldc           #55                 // String null
       113: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
       116: ldc           #57                 // String ,
       118: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
       121: aload_0
       122: getfield      #27                 // Field FIELD_2:Ljava/lang/String;
       125: dup
       126: ifnull        138
       129: invokevirtual #49                 // Method java/lang/Object.toString:()Ljava/lang/String;
       132: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
       135: goto          144
       138: pop
       139: ldc           #55                 // String null
       141: invokevirtual #53                 // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
       144: invokevirtual #69                 // Method java/lang/StringBuffer.toString:()Ljava/lang/String;
       147: areturn
      StackMap: number_of_entries = 10
        frame_type = 255 offset = 24
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ class java/lang/StringBuffer, class java/lang/String ]
        frame_type = 255 offset = 30
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ class java/lang/StringBuffer ]
        frame_type = 255 offset = 56
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/StringBuffer ]
        frame_type = 255 offset = 72
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/StringBuffer, class java/lang/String ]
        frame_type = 255 offset = 78
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/StringBuffer ]
        frame_type = 255 offset = 86
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7, class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/StringBuffer ]
        frame_type = 255 offset = 110
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ class java/lang/StringBuffer, class "[Ljava/lang/String;" ]
        frame_type = 255 offset = 116
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ class java/lang/StringBuffer ]
        frame_type = 255 offset = 138
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ class java/lang/StringBuffer, class java/lang/String ]
        frame_type = 255 offset = 144
          locals = [ class net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 ]
          stack = [ class java/lang/StringBuffer ]
}
SourceFile: "<generated>"



/ Einde Intermezzo


/ Intermezzo

/ we zijn in 	,
/ stack
/s
Thread [main] (Suspended)	
	DebuggingClassWriter$1.run() line: 79	
	AccessController.doPrivileged(PrivilegedAction<T>) line: not available [native method]	
	DebuggingClassWriter.toByteArray() line: 73	
	DefaultGeneratorStrategy.generate(ClassGenerator) line: 26	
        transform(cg).generateClass(cw);
/d
        return transform(cw.toByteArray());
/cb
	KeyFactory$Generator(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 329	
            byte[] b = strategy.generate(this);
/cb
	AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator) line: 93	
/=
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);
                            return gen.wrapCachedClass(klass);									<-
/cb
	AbstractClassGenerator$ClassLoaderData$3.apply(Object) line: 91	
	LoadingCache$2.call() line: 54	
                    return loader.apply(key);
/cb
	FutureTask<V>.run() line: 266	
	LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 61	
	LoadingCache<K,KK,V>.get(K) line: 34	
	AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 116	
	KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 291	
	KeyFactory$Generator.create() line: 221	
	KeyFactory.create(ClassLoader, Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 174	
	KeyFactory.create(ClassLoader, Class, Customizer) line: 157	
	KeyFactory.create(Class, Customizer) line: 149	
	KeyFactory.create(Class) line: 145	
	MethodWrapper.<clinit>() line: 23	
   private static final MethodWrapperKey KEY_FACTORY =
      (MethodWrapperKey)KeyFactory.create(MethodWrapperKey.class);
/cb
	Enhancer.getMethods(Class, Class[], List, List, Set) line: 551	
                forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));	/ interfaceMethods==[]
/cb
	Enhancer.generateClass(ClassVisitor) line: 575	
this	Enhancer  (id=104)	
	className	"first.Sample$$EnhancerByCGLIB$$2fef46f3" (id=202)	

        getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);
/cb
	DefaultGeneratorStrategy.generate(ClassGenerator) line: 25	
	Enhancer(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 329	
	Enhancer.generate(AbstractClassGenerator$ClassLoaderData) line: 492	
	AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator) line: 93	
/=
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);			<-
/cb
	AbstractClassGenerator$ClassLoaderData$3.apply(Object) line: 91	
	LoadingCache$2.call() line: 54	
                    return loader.apply(key);
/cb
	FutureTask<V>.run() line: 266	
	LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 61	
	LoadingCache<K,KK,V>.get(K) line: 34	
	AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 116	
	Enhancer(AbstractClassGenerator<T>).create(Object) line: 291	
	Enhancer.createHelper() line: 480	
        Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,
                ReflectUtils.getNames(interfaces),
                filter == ALL_ZERO ? null : new WeakCacheKey<CallbackFilter>(filter),
                callbackTypes,
                useFactory,
                interceptDuringConstruction,
                serialVersionUID);
        Object result = super.create(key);
/cb
	Enhancer.create() line: 305	
	SampleTest.testFixedValue() line: 32	
		Sample sample=(Sample)enhancer.create();
/cb
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 498	
	FrameworkMethod$1.runReflectiveCall() line: 50	
	FrameworkMethod$1(ReflectiveCallable).run() line: 12	
	FrameworkMethod.invokeExplosively(Object, Object...) line: 47	
	InvokeMethod.evaluate() line: 17	
	ExpectException.evaluate() line: 19	
	BlockJUnit4ClassRunner(ParentRunner<T>).runLeaf(Statement, Description, RunNotifier) line: 325	
	BlockJUnit4ClassRunner.runChild(FrameworkMethod, RunNotifier) line: 78	
	BlockJUnit4ClassRunner.runChild(Object, RunNotifier) line: 57	
	ParentRunner$3.run() line: 290	
	ParentRunner$1.schedule(Runnable) line: 71	
	BlockJUnit4ClassRunner(ParentRunner<T>).runChildren(RunNotifier) line: 288	
	ParentRunner<T>.access$000(ParentRunner, RunNotifier) line: 58	
	ParentRunner$2.evaluate() line: 268	
	BlockJUnit4ClassRunner(ParentRunner<T>).run(RunNotifier) line: 363	
	JUnit4TestClassReference(JUnit4TestReference).run(TestExecution) line: 50	
	TestExecution.run(ITestReference[]) line: 38	
	RemoteTestRunner.runTests(String[], String, TestExecution) line: 459	
	RemoteTestRunner.runTests(TestExecution) line: 675	
	RemoteTestRunner.run() line: 382	
	RemoteTestRunner.main(String[]) line: 192	


/ Einde Intermezzo

/ we zijn nog in 	,
DebuggingClassWriter$1.run() line: 109	
                byte[] b = ((ClassWriter) DebuggingClassWriter.super.cv).toByteArray();
                return b;
/d
DefaultGeneratorStrategy.generate(ClassGenerator) line: 26	
        DebuggingClassWriter cw = getClassVisitor();
        transform(cg).generateClass(cw);
        return transform(cw.toByteArray());
/d
KeyFactory$Generator(AbstractClassGenerator<T>).generate(AbstractClassGenerator$ClassLoaderData) line: 329	
            byte[] b = strategy.generate(this);
/d
            String className = ClassNameReader.getClassName(new ClassReader(b));
/ ClassNameReader is cglib type, ClassReader is asm type, 
net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7

            synchronized (classLoader) { // just in case
                if (protectionDomain == null) {
/n
                } else {
                    gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);
ass net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7

            return gen;
/t
AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator) line: 94	
            Function<AbstractClassGenerator, Object> load =
                    new Function<AbstractClassGenerator, Object>() {
                        public Object apply(AbstractClassGenerator gen) {
                            Class klass = gen.generate(ClassLoaderData.this);
/d
                            return gen.wrapCachedClass(klass);
/s
KeyFactory$Generator(AbstractClassGenerator<T>).wrapCachedClass(Class) line: 123	
        return (T) new WeakReference(klass);
/t
LoadingCache$2.call() line: 54	
                    return loader.apply(key);
/d
/t
LoadingCache<K,KK,V>.createEntry(K, KK, Object) line: 61	
                task.run();
/d
            result = task.get();
result	WeakReference<T>  (id=228)	
	referent	Class<T> (net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7) (id=223)	

        if (creator) {
            map.put(cacheKey, result);	/ TODO
/t
LoadingCache<K,KK,V>.get(K) line: 34	
        return createEntry(key, cacheKey, v);
/d
/t
AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator, boolean) line: 117	
					else}
              Object cachedValue = generatedClasses.get(gen);
/d
cachedValue	WeakReference<T>  (id=228)	
              return gen.unwrapCachedValue(cachedValue);
/s
KeyFactory$Generator(AbstractClassGenerator<T>).unwrapCachedValue(T) line: 127	
        return ((WeakReference) cached).get();
/t
KeyFactory$Generator(AbstractClassGenerator<T>).create(Object) line: 292	
            Object obj = data.get(this, getUseCache());
/d
obj	Class<T> (net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7) (id=223)	

            if (obj instanceof Class) {
                return firstInstance((Class) obj);		/ calls default ctor	,
/t
KeyFactory$Generator.create() line: 221	
            return (KeyFactory)super.create(keyInterface.getName());
/d
/t
KeyFactory.create(ClassLoader, Class, KeyFactoryCustomizer, List<KeyFactoryCustomizer>) line: 174	
        return gen.create();
/d
/t
KeyFactory.create(ClassLoader, Class, Customizer) line: 157	
        return create(loader, keyInterface, customizer, Collections.<KeyFactoryCustomizer>emptyList());
/d
/t
KeyFactory.create(Class, Customizer) line: 149	
        return create(keyInterface.getClassLoader(), keyInterface,  customizer);
/d
/t
KeyFactory.create(Class) line: 145	
        return create(keyInterface, null);
/d
/t
MethodWrapper.<clinit>() line: 23	
   private static final MethodWrapperKey KEY_FACTORY =
      (MethodWrapperKey)KeyFactory.create(MethodWrapperKey.class);
/d
KEY_FACTORY	MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7  (id=273)	
	FIELD_0	null	
	FIELD_1	null	
	FIELD_2	null	
/t
MethodWrapper.createSet(Collection) line: 44	
        Set set = new HashSet();
        for (Iterator it = methods.iterator(); it.hasNext();) {
/n
        return set;
/t
Enhancer.getMethods(Class, Class[], List, List, Set) line: 551	
                forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));
/d
[]
            methods.addAll(interfaceMethods);
methods	ArrayList<E>  (id=118)	
	[0]	Method  (id=329)	
public java.lang.String first.Sample.fct(java.lang.String)
	[1]	Method  (id=330)	
public java.lang.String first.Sample.fct2(java.lang.String)
	[2]	Method  (id=331)	
public boolean java.lang.Object.equals(java.lang.Object)
	[3]	Method  (id=337)	
public java.lang.String java.lang.Object.toString()
	[4]	Method  (id=338)	
public native int java.lang.Object.hashCode()
	[5]	Method  (id=339)	
protected native java.lang.Object java.lang.Object.clone() throws java.lang.CloneNotSupportedException

        CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC));
/s
RejectModifierPredicate.<init>(int) line: 24	
        this.rejectMask = rejectMask;
/t
/s
CollectionUtils.filter(Collection, Predicate) line: 52	
        Iterator it = c.iterator();
        while (it.hasNext()) {
            if (!p.evaluate(it.next())) {
/n
                it.remove();
/n
			return c;
/t
Enhancer.getMethods(Class, Class[], List, List, Set) line: 556	
        CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC));
/d
        CollectionUtils.filter(methods, new VisibilityPredicate(superclass, true));
        CollectionUtils.filter(methods, new DuplicatesPredicate());
        CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_FINAL));
/ methods onveranderd	, 
/t
Enhancer.generateClass(ClassVisitor) line: 577	
        getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);
/d
/ sc = superclass=first.Sample
/ actualMethods is result bovenstaande calls, 	

/ we zijn in 	,
this	Enhancer  (id=104)	
	className	"first.Sample$$EnhancerByCGLIB$$2fef46f3" (id=202)	

/ en we zijn deze class aan het maken	, 

        List methods = CollectionUtils.transform(actualMethods, new Transformer() {		<-
            public Object transform(Object value) {
                Method method = (Method)value;
                int modifiers = Constants.ACC_FINAL
                    | (method.getModifiers()
                       & ~Constants.ACC_ABSTRACT
                       & ~Constants.ACC_NATIVE
                       & ~Constants.ACC_SYNCHRONIZED);
                if (forcePublic.contains(MethodWrapper.create(method))) {
                    modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;
                }
                return ReflectUtils.getMethodInfo(method, modifiers);
            }
        });
/ de transform mth wordt op iedere mth uit actualMethods uitgevoerd:	

/s
CollectionUtils.transform(Collection, Transformer) line: 61	
        List result = new ArrayList(c.size());
        for (Iterator it = c.iterator(); it.hasNext();) {
            result.add(t.transform(it.next()));
/s
        List methods = CollectionUtils.transform(actualMethods, new Transformer() {		
            public Object transform(Object value) {
                Method method = (Method)value;		<-			/ public java.lang.String first.Sample.fct(java.lang.String)
                int modifiers = Constants.ACC_FINAL			/ public final
                    | (method.getModifiers()
                       & ~Constants.ACC_ABSTRACT
                       & ~Constants.ACC_NATIVE
                       & ~Constants.ACC_SYNCHRONIZED);
                if (forcePublic.contains(MethodWrapper.create(method))) {
/s
MethodWrapper.create(Method) line: 34	
        return KEY_FACTORY.newInstance(method.getName(),			/ fct
                                       ReflectUtils.getNames(method.getParameterTypes()), / [java.lang.String]
                                       method.getReturnType().getName());	/ java.lang.String
/t
Enhancer$2.transform(Object) line: 585	
                if (forcePublic.contains(MethodWrapper.create(method))) {
/d
/n
                    modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;
/n
/ trouwens,
MethodWrapper.create(method)	class net.sf.cglib.core.MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7 
	FIELD_0	"fct" (id=1163)	
	FIELD_1	String[1]  (id=1193)		[java.lang.String]
	FIELD_2	"java.lang.String" (id=1172)	
/ newInstance calls ctor met args	, 

                return ReflectUtils.getMethodInfo(method, modifiers);
/s
ReflectUtils.getMethodInfo(Member, int) line: 481	
        final Signature sig = getSignature(member);
sig	Signature  (id=1248)	
	desc	"(Ljava/lang/String;)Ljava/lang/String;" (id=1250)	
	name	"fct" (id=1163)	
        return new MethodInfo() {
            private ClassInfo ci;
            public ClassInfo getClassInfo() {
                if (ci == null)
                    ci = ReflectUtils.getClassInfo(member.getDeclaringClass());
                return ci;
            }
            public int getModifiers() {
                return modifiers;
            }
            public Signature getSignature() {
                return sig;
            }
            public Type[] getExceptionTypes() {
                return ReflectUtils.getExceptionTypes(member);
            }
            public Attribute getAttribute() {
                return null;
            }
        };
/t
CollectionUtils.transform(Collection, Transformer) line: 62	
        List result = new ArrayList(c.size());
        for (Iterator it = c.iterator(); it.hasNext();) {
            result.add(t.transform(it.next()));
/d
result	ArrayList<E>  (id=1157)	
	[0]	ReflectUtils$5  (id=1254)		/ MethodInfo
		ci	null	
		val$member	Method  (id=329)	
		val$modifiers	17	
		val$sig	Signature  (id=1248)	

/ volgende methods	, 
        List result = new ArrayList(c.size());
        for (Iterator it = c.iterator(); it.hasNext();) {
            result.add(t.transform(it.next()));
/d
        return result;
/ van alle 6 een MethodInfo	, 
/t
Enhancer.generateClass(ClassVisitor) line: 592	
        List methods = CollectionUtils.transform(actualMethods, new Transformer() {
            public Object transform(Object value) {
                Method method = (Method)value;
                int modifiers = Constants.ACC_FINAL
                    | (method.getModifiers()
                       & ~Constants.ACC_ABSTRACT
                       & ~Constants.ACC_NATIVE
                       & ~Constants.ACC_SYNCHRONIZED);
                if (forcePublic.contains(MethodWrapper.create(method))) {
                    modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;
                }
                return ReflectUtils.getMethodInfo(method, modifiers);
            }
        });
/d
methods	ArrayList<E>  (id=1157)	
	[0]	ReflectUtils$5  (id=1254)	 / MethodInfo
	[1]	ReflectUtils$5  (id=1276)	
	[2]	ReflectUtils$5  (id=1362)	
	[3]	ReflectUtils$5  (id=1363)	
	[4]	ReflectUtils$5  (id=1370)	
	[5]	ReflectUtils$5  (id=1377)	

        ClassEmitter e = new ClassEmitter(v); / heeft methods begin_class, ...

/ Intermezzo

	public void testFixedValue(){
		Enhancer enhancer=new Enhancer();
		enhancer.setCallback(new FixedValue() {
			@Override
			public Object loadObject() throws Exception {
				return testHello;
			}
		});
		Sample sample=(Sample)enhancer.create();

/ De FixedValue inst is part of enhanced inst WH TODO


/ einde Intermezzo

this	Enhancer  (id=104)	
	arguments	null	
	argumentTypes	null	
	attemptLoad	false	
	callbacks	Callback[1]  (id=199)	
		[0]	SampleTest$1  (id=1435)			
			this$0	SampleTest  (id=33)	/ FixedValue
	callbackTypes	Type[1]  (id=200)	
		[0]	Type  (id=1418)	/ Lnet/sf/cglib/proxy/FixedValue;	
	classLoader	null	
	className	"first.Sample$$EnhancerByCGLIB$$2fef46f3" (id=202)	
	classOnly	false	
	currentData	null	
	currentKey	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=154)	
		FIELD_0	"first.Sample" (id=156)	
		FIELD_1	null	
		FIELD_2	null	
		FIELD_3	Type[1]  (id=1548)	/ [Lnet/sf/cglib/proxy/FixedValue;]	
		FIELD_4	true	
		FIELD_5	true	
		FIELD_6	null	
	filter	Enhancer$1  (id=206)	
	interceptDuringConstruction	true	
	interfaces	null	
	key	Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72  (id=154)	 /= currentKey
	namePrefix	"first.Sample" (id=156)	
	namingPolicy	DefaultNamingPolicy  (id=1533)	
	serialVersionUID	null	
	source	AbstractClassGenerator$Source  (id=1556)	
		name	"net.sf.cglib.proxy.Enhancer" (id=1593)	
	strategy	DefaultGeneratorStrategy  (id=69)	
	superclass	Class<T> (first.Sample) (id=125)	
	useCache	true	
	useFactory	true	
	validateCallbackTypes	true	


        if (currentData == null) {
        e.begin_class(Constants.V1_2,
                      Constants.ACC_PUBLIC,
                      getClassName(),		/ first.Sample$$EnhancerByCGLIB$$2fef46f3
                      Type.getType(sc),	/ Type Lfirst/Sample;
                      (useFactory ?	/ true
                       TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),
                      Constants.SOURCE_FILE);
/s
ClassEmitter.begin_class(int, int, String, Type, Type[], String) line: 68	
        final Type classType = Type.getType("L" + className.replace('.', '/') + ";"); / Lfirst/Sample$$EnhancerByCGLIB$$2fef46f3;
        classInfo = new ClassInfo() {
            public Type getType() {
                return classType;
            }
            public Type getSuperType() {
                return (superType != null) ? superType : Constants.TYPE_OBJECT;
            }
            public Type[] getInterfaces() {
                return interfaces;
            }
            public int getModifiers() {
                return access;
            }
        };
        cv.visit(version,
                 access,
                 classInfo.getType().getInternalName(),
                 null,
                 classInfo.getSuperType().getInternalName(),
                 TypeUtils.toInternalNames(interfaces));
       if (source != null)
source	"<generated>" (id=1687)	
            cv.visitSource(source, null);

        init(); / NIETS
/t
Enhancer.generateClass(ClassVisitor) line: 610	
        e.begin_class(Constants.V1_2,
                      Constants.ACC_PUBLIC,
                      getClassName(),
                      Type.getType(sc),
                      (useFactory ?
                       TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :
                       TypeUtils.getTypes(interfaces)),
                      Constants.SOURCE_FILE);
/d
        List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());
constructors	ArrayList<E>  (id=211)	
	[0]	Constructor<T>  (id=1710)	/ public first.Sample()
/s
CollectionUtils.transform(Collection, Transformer) line: 64	
        List result = new ArrayList(c.size());
        for (Iterator it = c.iterator(); it.hasNext();) {
            result.add(t.transform(it.next()));
        }
        return result;
result	ArrayList<E>  (id=1729)	
	[0]	ReflectUtils$5  (id=1740)	
		ci	null	
		val$member	Constructor<T>  (id=1710) public first.Sample()	
		val$modifiers	1	
		val$sig	Signature  (id=1742)	 <init>()V
/t
Enhancer.generateClass(ClassVisitor) line: 612	
        List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());
/d
        e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);

/ Intermezzo

public interface Opcodes {
    int ACC_PUBLIC = 0x0001; // class, field, method
    int ACC_PRIVATE = 0x0002; // class, field, method
    int ACC_PROTECTED = 0x0004; // class, field, method

public class Type {
    public static final int BOOLEAN = 1;

public class Enhancer extends AbstractClassGenerator
    private static final String BOUND_FIELD = "CGLIB$BOUND";
    private static final String FACTORY_DATA_FIELD = "CGLIB$FACTORY_DATA";
    private static final String THREAD_CALLBACKS_FIELD = "CGLIB$THREAD_CALLBACKS";
    private static final String STATIC_CALLBACKS_FIELD = "CGLIB$STATIC_CALLBACKS";
    private static final String SET_THREAD_CALLBACKS_NAME = "CGLIB$SET_THREAD_CALLBACKS";
    private static final String SET_STATIC_CALLBACKS_NAME = "CGLIB$SET_STATIC_CALLBACKS";
    private static final String CONSTRUCTED_FIELD = "CGLIB$CONSTRUCTED";

    private static final String CALLBACK_FILTER_FIELD = "CGLIB$CALLBACK_FILTER";


		private static final Type OBJECT_TYPE = TypeUtils.parseType("Object");
    private static final Type THREAD_LOCAL = TypeUtils.parseType("ThreadLocal");
    private static final Type CALLBACK = TypeUtils.parseType("net.sf.cglib.proxy.Callback");
    private static final Type CALLBACK_ARRAY = Type.getType(Callback[].class);

/ einde Intermezzo
is

/s
ClassEmitter.declare_field(int, String, Type, Object) line: 185	
/=
    public void declare_field(int access, String name, Type type, Object value) {
access	2												/ private
name	"CGLIB$BOUND" (id=319)	
type	Type  (id=1764)				/ boolean	,	
value	null				/ initial value, only for static fields, 
        } else {
            fieldInfo.put(name, info);
            cv.visitField(access, name, type.getDescriptor(), null, value);
/ null is signature	,

        FieldInfo existing = (FieldInfo)fieldInfo.get(name);
null
        FieldInfo info = new FieldInfo(access, name, type, value);
/t
Enhancer.generateClass(ClassVisitor) line: 613	
        e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);
/d
        e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);
        if (!interceptDuringConstruction) {
/n
        e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);
        e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);
        if (serialVersionUID != null) {
/n
        for (int i = 0; i < callbackTypes.length; i++) {
this	Enhancer  (id=104)	
	callbackTypes	Type[1]  (id=200)	
		[0]	Type  (id=1418)	 					/ Lnet/sf/cglib/proxy/FixedValue;

            e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);
/s
Enhancer.getCallbackField(int) line: 1317	
        return "CGLIB$CALLBACK_" + index;		/ CGLIB$CALLBACK_0
/t
Enhancer.generateClass(ClassVisitor) line: 613	
        // This is declared private to avoid "public field" pollution
        e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);

        if (currentData == null) {
/j
            emitMethods(e, methods, actualMethods);
actualMethods	ArrayList<E>  (id=118)	
	[0]	Method  (id=329)	
	[1]	Method  (id=330)	
	[2]	Method  (id=331)	
	[3]	Method  (id=337)	
	[4]	Method  (id=338)	
	[5]	Method  (id=339)	
methods	ArrayList<E>  (id=1157)	
	[0]	ReflectUtils$5  (id=1254)	
	[1]	ReflectUtils$5  (id=1276)	
	[2]	ReflectUtils$5  (id=1362)	
	[3]	ReflectUtils$5  (id=1363)	
	[4]	ReflectUtils$5  (id=1370)	
	[5]	ReflectUtils$5  (id=1377)	
/s
Enhancer.emitMethods(ClassEmitter, List, List) line: 1094	
        CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);
this	Enhancer  (id=104)	
	callbackTypes	Type[1]  (id=200)	
		[0]	Type  (id=1418)					/ Lnet/sf/cglib/proxy/FixedValue;
/s
CallbackInfo.getGenerators(Type[]) line: 49	
        CallbackGenerator[] generators = new CallbackGenerator[callbackTypes.length];
        for (int i = 0; i < generators.length; i++) {
            generators[i] = getGenerator(callbackTypes[i]);
/s
CallbackInfo.getGenerator(Type) line: 106	
/=
    private static CallbackGenerator getGenerator(Type callbackType) { / Lnet/sf/cglib/proxy/FixedValue;

    private static final CallbackInfo[] CALLBACKS = {
        new CallbackInfo(NoOp.class, NoOpGenerator.INSTANCE),
        new CallbackInfo(MethodInterceptor.class, MethodInterceptorGenerator.INSTANCE),
        new CallbackInfo(InvocationHandler.class, InvocationHandlerGenerator.INSTANCE),
        new CallbackInfo(LazyLoader.class, LazyLoaderGenerator.INSTANCE),
        new CallbackInfo(Dispatcher.class, DispatcherGenerator.INSTANCE),
        new CallbackInfo(FixedValue.class, FixedValueGenerator.INSTANCE),
        new CallbackInfo(ProxyRefDispatcher.class, DispatcherGenerator.PROXY_REF_INSTANCE),
    };

       for (int i = 0; i < CALLBACKS.length; i++) {
            CallbackInfo info = CALLBACKS[i];
            if (info.type.equals(callbackType)) {
                return info.generator;
/t
CallbackInfo.getGenerators(Type[]) line: 51	
        for (int i = 0; i < generators.length; i++) {
            generators[i] = getGenerator(callbackTypes[i]);
/d
        }
        return generators;
generators	CallbackGenerator[1]  (id=1949)	
	[0]	FixedValueGenerator  (id=1893)	
/t
Enhancer.emitMethods(ClassEmitter, List, List) line: 1096	
        CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);
/d
        final Map positions = CollectionUtils.getIndexMap(methods);
/ hash map {ReflectUtils$5 inst: Integer}

        final Map declToBridge = new HashMap();

        Iterator it1 = methods.iterator();
        Iterator it2 = (actualMethods != null) ? actualMethods.iterator() : null;

        while (it1.hasNext()) {
            MethodInfo method = (MethodInfo)it1.next();
fct(Ljava/lang/String;)Ljava/lang/String;
            Method actualMethod = (it2 != null) ? (Method)it2.next() : null;
public java.lang.String first.Sample.fct(java.lang.String)
            int index = filter.accept(actualMethod);
/s
public class Enhancer extends AbstractClassGenerator
    private static final CallbackFilter ALL_ZERO = new CallbackFilter(){
        public int accept(Method method) {
            return 0;
        }
    };
/t
Enhancer.emitMethods(ClassEmitter, List, List) line: 1109	
        while (it1.hasNext()) {
            MethodInfo method = (MethodInfo)it1.next();
            Method actualMethod = (it2 != null) ? (Method)it2.next() : null;
            int index = filter.accept(actualMethod);
/d
0
            originalModifiers.put(method, new Integer((actualMethod != null) ? actualMethod.getModifiers() : method.getModifiers()));
{fct(Ljava/lang/String;)Ljava/lang/String;=1}
            indexes.put(method, new Integer(index));	/ index==0

            List group = (List)groups.get(generators[index]); generators==[net.sf.cglib.proxy.FixedValueGenerator@6b57696f]
null
            if (group == null) {
                groups.put(generators[index], group = new ArrayList(methods.size()));	/ methods.size()==6
            }
            group.add(method); / fct(Ljava/lang/String;)Ljava/lang/String;

            if (TypeUtils.isBridge(actualMethod.getModifiers())) {
/n
/ volgende	, 
        while (it1.hasNext()) {
...

        final Map bridgeToTarget = new BridgeMethodResolver(declToBridge, getClassLoader()).resolveAll();
/ declToBridge=={}
        CodeEmitter se = ce.getStaticHook();
/s
ClassEmitter.getStaticHook() line: 95	
         if (TypeUtils.isInterface(getAccess())) {
/n
/ Zit interface in classInfo.modifiers, die nu 1 is (public)	?
/ TODO

         if (staticHook == null) {
             staticHookSig = new Signature("CGLIB$STATICHOOK" + getNextHook(), "()V");
this	ClassEmitter  (id=1401)	
	staticHookSig	Signature  (id=2078)	/ CGLIB$STATICHOOK1()V

             staticHook = begin_method(Constants.ACC_STATIC, staticHookSig, null);
/s
ClassEmitter.begin_method(int, Signature, Type[]) line: 144	
        MethodVisitor v = cv.visitMethod(access,		/ 8 ==ACC_STATIC
                                         sig.getName(),	/ CGLIB$STATICHOOK1
                                         sig.getDescriptor(), / ()V 
                                         null,
                                         TypeUtils.toInternalNames(exceptions));
        } else if (sig.equals(staticHookSig)) {
            return new CodeEmitter(this, v, access, sig, exceptions) {
                public boolean isStaticHook() {
                    return true;
                }
            };
/t
ClassEmitter.getStaticHook() line: 107	
             staticHook = begin_method(Constants.ACC_STATIC,
                                       staticHookSig,
                                       null);
this	ClassEmitter  (id=1401)	
	staticHook	ClassEmitter$3  (id=2094)		/ CodeEmitter	,
/d
         return staticHook;
/t
Enhancer.emitMethods(ClassEmitter, List, List) line: 1136	
        CodeEmitter se = ce.getStaticHook();
/d
        se.new_instance(THREAD_LOCAL);
        se.dup();
        se.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL);
        se.putfield(THREAD_CALLBACKS_FIELD);

/ intermezzo

public class Enhancer extends AbstractClassGenerator
    private static final String THREAD_CALLBACKS_FIELD = "CGLIB$THREAD_CALLBACKS";

    private static final Type THREAD_LOCAL = TypeUtils.parseType("ThreadLocal");
    private static final Signature CSTRUCT_NULL = TypeUtils.parseConstructor(""); 	/ <init>()V

/ Einde intermezzo

        CallbackGenerator.Context context = new CallbackGenerator.Context() {
					...
        for (int i = 0; i < callbackTypes.length; i++) {
            CallbackGenerator gen = generators[i]; / net.sf.cglib.proxy.FixedValueGenerator@6b57696f
            if (!seenGen.contains(gen)) {
/j
                seenGen.add(gen);
                final List fmethods = (List)groups.get(gen);
groups	HashMap<K,V>  (id=1963)	
	[0]	HashMap$Node<K,V>  (id=2129)	
		key	FixedValueGenerator  (id=1893)	
		value	ArrayList<E>  (id=2141)	
			[0]	ReflectUtils$5  (id=1254)	
			[1]	ReflectUtils$5  (id=1276)	
			[2]	ReflectUtils$5  (id=1362)	
			[3]	ReflectUtils$5  (id=1363)	
			[4]	ReflectUtils$5  (id=1370)	
			[5]	ReflectUtils$5  (id=1377)	

                if (fmethods != null) {
                    try {
                        gen.generate(ce, context, fmethods);
/s
FixedValueGenerator.generate(ClassEmitter, CallbackGenerator$Context, List) line: 30		/ In FixedValueGenerator	, 

/ we gaan	, 
       for (Iterator it = methods.iterator(); it.hasNext();) {
            MethodInfo method = (MethodInfo)it.next();
            CodeEmitter e = context.beginMethod(ce, method);
            context.emitCallback(e, context.getIndex(method));			/ TODO
            e.invoke_interface(FIXED_VALUE, LOAD_OBJECT);						/ TODO
            e.unbox_or_zero(e.getReturnType());
            e.return_value();
            e.end_method();
        }
/ nl,	 
        for (Iterator it = methods.iterator(); it.hasNext();) {
            MethodInfo method = (MethodInfo)it.next();	/ fct(Ljava/lang/String;)Ljava/lang/String;
            CodeEmitter e = context.beginMethod(ce, method);
/s
Enhancer$6.beginMethod(ClassEmitter, MethodInfo) line: 1196	
                CodeEmitter e = EmitUtils.begin_method(ce, method);
...
/s
ClassEmitter.begin_method(int, Signature, Type[]) line: 142	
        MethodVisitor v = cv.visitMethod(access,			/ 17= public final
                                         sig.getName(), / fct
                                         sig.getDescriptor(), / (Ljava/lang/String;)Ljava/lang/String;
                                         null,
                                         TypeUtils.toInternalNames(exceptions));
        } else {
            return new CodeEmitter(this, v, access, sig, exceptions);
/t
Enhancer$6.beginMethod(ClassEmitter, MethodInfo) line: 1196	
                CodeEmitter e = EmitUtils.begin_method(ce, method);
/d
                if (!interceptDuringConstruction &&
/n
                return e;
/t
Enhancer$6.beginMethod(ClassEmitter, MethodInfo) line: 1196	
						CodeEmitter e = EmitUtils.begin_method(ce, method);	/ fct(Ljava/lang/String;)Ljava/lang/String;
/d
            context.emitCallback(e, context.getIndex(method));
/s
Enhancer$6.emitCallback(CodeEmitter, int) line: 1153	
/=
        CallbackGenerator.Context context = new CallbackGenerator.Context() {
            public void emitCallback(CodeEmitter e, int index) {
                emitCurrentCallback(e, index);
/s
Enhancer.emitCurrentCallback(CodeEmitter, int) line: 1255					/ de gewone Enhancer class	, 
/=
    private void emitCurrentCallback(CodeEmitter e, int index) {	/ index==0

        e.load_this();
/s
        	mv.visitVarInsn(Constants.ALOAD, 0);
/t
        e.getfield(getCallbackField(index));	/ CGLIB$CALLBACK_0 , Type Lnet/sf/cglib/proxy/FixedValue;	, private
/s
CodeEmitter.getfield(String) line: 425	
        ClassEmitter.FieldInfo info = ce.getFieldInfo(name);
        int opcode = TypeUtils.isStatic(info.access) ? Constants.GETSTATIC : Constants.GETFIELD; / GETFIELD
        emit_field(opcode, ce.getClassType(), name, info.type);	
opcode==Constants.GETFIELD
ce.getClassType()=Lfirst/Sample$$EnhancerByCGLIB$$2fef46f3;
name=CGLIB$CALLBACK_0
info.type=Lnet/sf/cglib/proxy/FixedValue;
/t
        e.dup();
        Label end = e.make_label();	/  
/s
        	return new Label();		/ Label is asm type	,
/t
        e.ifnonnull(end);
/s
    			public void ifnonnull(Label label) { mv.visitJumpInsn(Constants.IFNONNULL, label); }
/t
        e.pop(); // stack height
        e.load_this();
        e.invoke_static_this(BIND_CALLBACKS);	/ CGLIB$BIND_CALLBACKS(Ljava/lang/Object;)V
        e.load_this();
        e.getfield(getCallbackField(index));
        e.mark(end);

/ Intermezzo

Enhancer.class
    private static final Signature BIND_CALLBACKS =
      TypeUtils.parseSignature("void CGLIB$BIND_CALLBACKS(Object)");

/ Einde Intermezzo

/t
FixedValueGenerator.generate(ClassEmitter, CallbackGenerator$Context, List) line: 34	
            context.emitCallback(e, context.getIndex(method));
/d
            e.invoke_interface(FIXED_VALUE, LOAD_OBJECT);

/ Intermezzo

FixedValueGenerator.class
    private static final Type FIXED_VALUE =
      TypeUtils.parseType("net.sf.cglib.proxy.FixedValue");
    private static final Signature LOAD_OBJECT =
      TypeUtils.parseSignature("Object loadObject()");

/ Einde Intermezzo

/s
public class CodeEmitter extends LocalVariablesSorter {
    public void invoke_interface(Type owner, Signature sig) {
        emit_invoke(Constants.INVOKEINTERFACE, owner, sig);
/s
        mv.visitMethodInsn(opcode,
                           type.getInternalName(),	/ net/sf/cglib/proxy/FixedValue
                           sig.getName(),	/ loadObject 
                           sig.getDescriptor(),	/ ()Ljava/lang/Object;
                           opcode == Opcodes.INVOKEINTERFACE);
/t
FixedValueGenerator.generate(ClassEmitter, CallbackGenerator$Context, List) line: 35	
            e.invoke_interface(FIXED_VALUE, LOAD_OBJECT);
/d
            e.unbox_or_zero(e.getReturnType());
/s
CodeEmitter.getReturnType() line: 126	
        return state.sig.getReturnType();	/ Ljava/lang/String;
/t
/s
CodeEmitter.unbox_or_zero(Type) line: 836	
            checkcast(type);
/t
FixedValueGenerator.generate(ClassEmitter, CallbackGenerator$Context, List) line: 36	
            e.unbox_or_zero(e.getReturnType());
/d
            e.return_value();
/s
        			mv.visitInsn(state.sig.getReturnType().getOpcode(Constants.IRETURN));	/ ARETURN
/t
            e.end_method();
/s
        			visitMaxs(0, 0);
/t
FixedValueGenerator.generate(ClassEmitter, CallbackGenerator$Context, List) line: 31	
/ volgende,  zo alle 6 in het totaal	,	
       for (Iterator it = methods.iterator(); it.hasNext();) {
            MethodInfo method = (MethodInfo)it.next();
            CodeEmitter e = context.beginMethod(ce, method);
            context.emitCallback(e, context.getIndex(method));			
            e.invoke_interface(FIXED_VALUE, LOAD_OBJECT);					
            e.unbox_or_zero(e.getReturnType());
            e.return_value();
            e.end_method();
        }
/ we geloven het	, 
/t
Enhancer.emitMethods(ClassEmitter, List, List) line: 1220	
                        gen.generate(ce, context, fmethods);	/  gen	FixedValueGenerator  (id=1893)	
/d
                        gen.generateStatic(se, context, fmethods);	 / leeg	,  voor FixedValueGenerator	,
/ volgende, 	
        for (int i = 0; i < callbackTypes.length; i++) {
/ is er niet	, 
        se.return_value();
/s
        	mv.visitInsn(state.sig.getReturnType().getOpcode(Constants.IRETURN));	/ RETURN
/t
        se.end_method();
/t
Enhancer.generateClass(ClassVisitor) line: 631	
            emitMethods(e, methods, actualMethods);
/d
            emitConstructors(e, constructorInfo);
/s
Enhancer.emitConstructors(ClassEmitter, List) line: 912	
        for (Iterator it = constructors.iterator(); it.hasNext();) {
            MethodInfo constructor = (MethodInfo)it.next();	/ <init>()V
            CodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);
            e.load_this();
            e.dup();
            e.load_args();
            Signature sig = constructor.getSignature();
            seenNull = seenNull || sig.getDescriptor().equals("()V");	/ true
            e.super_invoke_constructor(sig);
/s
CodeEmitter.super_invoke_constructor(Signature) line: 536	
        invoke_constructor(ce.getSuperType(), sig);		/ ce.getSuperType()=Lfirst/Sample;
/s
CodeEmitter.invoke_constructor(Type, Signature) line: 528	
        emit_invoke(Constants.INVOKESPECIAL, type, sig);
/s
CodeEmitter.emit_invoke(int, Type, Signature) line: 500	
        mv.visitMethodInsn(opcode,	  
                           type.getInternalName(),	/ first/Sample
                           sig.getName(),		/ <init>
                           sig.getDescriptor(),	/ ()V
                           opcode == Opcodes.INVOKEINTERFACE);	/ false
/t

            if (currentData == null) {
                e.invoke_static_this(BIND_CALLBACKS);
                if (!interceptDuringConstruction) {
                    e.load_this();
                    e.push(1);
                    e.putfield(CONSTRUCTED_FIELD);
                }
            }
            e.return_value();
            e.end_method();
        }







/ 7	 

/ Lees	,
http://blog.rseiler.at/2014/06/explanation-how-cglip-proxies-work.html

DebuggingClassWriter$1.run() line: 79	
                byte[] b = ((ClassWriter) DebuggingClassWriter.super.cv).toByteArray();
/d

/ we doen in eclipse, in Display view	,
java.io.FileOutputStream fos = new java.io.FileOutputStream("/home/eric/Devel/Java/cglib/sample_enhanced.class");
fos.write(b);
fos.close();

/ Let op -p	, anders zien we de def van CGLIB$BIND_CALLBACKS niet	, 
[eric@almond cglib]$ javap -p -c -verbose sample_enhanced.class >sample_enhanced.disassem 


Classfile /home/eric/Devel/Java/cglib/sample_enhanced.class
  Last modified Apr 1, 2017; size 3198 bytes
  MD5 checksum be41585abeadb73e8a34db531a452ef7
  Compiled from "<generated>"
public class first.Sample$$EnhancerByCGLIB$$2fef46f3 extends first.Sample implements net.sf.cglib.proxy.Factory
  minor version: 0
  major version: 46
  flags: ACC_PUBLIC
Constant pool:
    #1 = Utf8               first/Sample$$EnhancerByCGLIB$$2fef46f3
    #2 = Class              #1            // first/Sample$$EnhancerByCGLIB$$2fef46f3
    #3 = Utf8               first/Sample
    #4 = Class              #3            // first/Sample
    #5 = Utf8               net/sf/cglib/proxy/Factory
    #6 = Class              #5            // net/sf/cglib/proxy/Factory
    #7 = Utf8               <generated>
    #8 = Utf8               CGLIB$BOUND
    #9 = Utf8               Z
   #10 = Utf8               CGLIB$FACTORY_DATA
   #11 = Utf8               Ljava/lang/Object;
   #12 = Utf8               CGLIB$THREAD_CALLBACKS
   #13 = Utf8               Ljava/lang/ThreadLocal;
   #14 = Utf8               CGLIB$STATIC_CALLBACKS
   #15 = Utf8               [Lnet/sf/cglib/proxy/Callback;
   #16 = Utf8               CGLIB$CALLBACK_0
   #17 = Utf8               Lnet/sf/cglib/proxy/FixedValue;
   #18 = Utf8               CGLIB$CALLBACK_FILTER
   #19 = Utf8               CGLIB$STATICHOOK1
   #20 = Utf8               ()V
   #21 = Utf8               java/lang/ThreadLocal
   #22 = Class              #21           // java/lang/ThreadLocal
   #23 = Utf8               <init>
   #24 = NameAndType        #23:#20       // "<init>":()V
   #25 = Methodref          #22.#24       // java/lang/ThreadLocal."<init>":()V
   #26 = NameAndType        #12:#13       // CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
   #27 = Fieldref           #2.#26        // first/Sample$$EnhancerByCGLIB$$2fef46f3.CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
   #28 = Utf8               fct
   #29 = Utf8               (Ljava/lang/String;)Ljava/lang/String;
   #30 = NameAndType        #16:#17       // CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
   #31 = Fieldref           #2.#30        // first/Sample$$EnhancerByCGLIB$$2fef46f3.CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
   #32 = Utf8               CGLIB$BIND_CALLBACKS
   #33 = Utf8               (Ljava/lang/Object;)V
   #34 = NameAndType        #32:#33       // CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
   #35 = Methodref          #2.#34        // first/Sample$$EnhancerByCGLIB$$2fef46f3.CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
   #36 = Utf8               net/sf/cglib/proxy/FixedValue
   #37 = Class              #36           // net/sf/cglib/proxy/FixedValue
   #38 = Utf8               loadObject
   #39 = Utf8               ()Ljava/lang/Object;
   #40 = NameAndType        #38:#39       // loadObject:()Ljava/lang/Object;
   #41 = InterfaceMethodref #37.#40       // net/sf/cglib/proxy/FixedValue.loadObject:()Ljava/lang/Object;
   #42 = Utf8               java/lang/String
   #43 = Class              #42           // java/lang/String
   #44 = Utf8               fct2
   #45 = Utf8               equals
   #46 = Utf8               (Ljava/lang/Object;)Z
   #47 = Utf8               java/lang/Boolean
   #48 = Class              #47           // java/lang/Boolean
   #49 = Utf8               booleanValue
   #50 = Utf8               ()Z
   #51 = NameAndType        #49:#50       // booleanValue:()Z
   #52 = Methodref          #48.#51       // java/lang/Boolean.booleanValue:()Z
   #53 = Utf8               java/lang/Object
   #54 = Class              #53           // java/lang/Object
   #55 = Utf8               toString
   #56 = Utf8               ()Ljava/lang/String;
   #57 = Utf8               hashCode
   #58 = Utf8               ()I
   #59 = Utf8               java/lang/Number
   #60 = Class              #59           // java/lang/Number
   #61 = Utf8               intValue
   #62 = NameAndType        #61:#58       // intValue:()I
   #63 = Methodref          #60.#62       // java/lang/Number.intValue:()I
   #64 = Utf8               clone
   #65 = Utf8               java/lang/CloneNotSupportedException
   #66 = Class              #65           // java/lang/CloneNotSupportedException
   #67 = Methodref          #4.#24        // first/Sample."<init>":()V
   #68 = Utf8               CGLIB$SET_THREAD_CALLBACKS
   #69 = Utf8               ([Lnet/sf/cglib/proxy/Callback;)V
   #70 = Utf8               set
   #71 = NameAndType        #70:#33       // set:(Ljava/lang/Object;)V
   #72 = Methodref          #22.#71       // java/lang/ThreadLocal.set:(Ljava/lang/Object;)V
   #73 = Utf8               CGLIB$SET_STATIC_CALLBACKS
   #74 = NameAndType        #14:#15       // CGLIB$STATIC_CALLBACKS:[Lnet/sf/cglib/proxy/Callback;
   #75 = Fieldref           #2.#74        // first/Sample$$EnhancerByCGLIB$$2fef46f3.CGLIB$STATIC_CALLBACKS:[Lnet/sf/cglib/proxy/Callback;
   #76 = NameAndType        #8:#9         // CGLIB$BOUND:Z
   #77 = Fieldref           #2.#76        // first/Sample$$EnhancerByCGLIB$$2fef46f3.CGLIB$BOUND:Z
   #78 = Utf8               get
   #79 = NameAndType        #78:#39       // get:()Ljava/lang/Object;
   #80 = Methodref          #22.#79       // java/lang/ThreadLocal.get:()Ljava/lang/Object;
   #81 = Class              #15           // "[Lnet/sf/cglib/proxy/Callback;"
   #82 = Utf8               newInstance
   #83 = Utf8               ([Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;
   #84 = NameAndType        #68:#69       // CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
   #85 = Methodref          #2.#84        // first/Sample$$EnhancerByCGLIB$$2fef46f3.CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
   #86 = Methodref          #2.#24        // first/Sample$$EnhancerByCGLIB$$2fef46f3."<init>":()V
   #87 = Utf8               (Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;
   #88 = Utf8               net/sf/cglib/proxy/Callback
   #89 = Class              #88           // net/sf/cglib/proxy/Callback
   #90 = Utf8               ([Ljava/lang/Class;[Ljava/lang/Object;[Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;
   #91 = Utf8               java/lang/IllegalArgumentException
   #92 = Class              #91           // java/lang/IllegalArgumentException
   #93 = Utf8               Constructor not found
   #94 = String             #93           // Constructor not found
   #95 = Utf8               (Ljava/lang/String;)V
   #96 = NameAndType        #23:#95       // "<init>":(Ljava/lang/String;)V
   #97 = Methodref          #92.#96       // java/lang/IllegalArgumentException."<init>":(Ljava/lang/String;)V
   #98 = Utf8               [Ljava/lang/Class;
   #99 = Class              #98           // "[Ljava/lang/Class;"
  #100 = Utf8               [Ljava/lang/Object;
  #101 = Class              #100          // "[Ljava/lang/Object;"
  #102 = Utf8               getCallback
  #103 = Utf8               (I)Lnet/sf/cglib/proxy/Callback;
  #104 = Utf8               setCallback
  #105 = Utf8               (ILnet/sf/cglib/proxy/Callback;)V
  #106 = Utf8               getCallbacks
  #107 = Utf8               ()[Lnet/sf/cglib/proxy/Callback;
  #108 = Utf8               setCallbacks
  #109 = Utf8               <clinit>
  #110 = NameAndType        #19:#20       // CGLIB$STATICHOOK1:()V
  #111 = Methodref          #2.#110       // first/Sample$$EnhancerByCGLIB$$2fef46f3.CGLIB$STATICHOOK1:()V
  #112 = Utf8               java/lang/Throwable
  #113 = Class              #112          // java/lang/Throwable
  #114 = Utf8               Code
  #115 = Utf8               StackMap
  #116 = Utf8               Exceptions
  #117 = Utf8               SourceFile
{
  private boolean CGLIB$BOUND;
    descriptor: Z
    flags: ACC_PRIVATE

  public static java.lang.Object CGLIB$FACTORY_DATA;
    descriptor: Ljava/lang/Object;
    flags: ACC_PUBLIC, ACC_STATIC

  private static final java.lang.ThreadLocal CGLIB$THREAD_CALLBACKS;
    descriptor: Ljava/lang/ThreadLocal;
    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL

  private static final net.sf.cglib.proxy.Callback[] CGLIB$STATIC_CALLBACKS;
    descriptor: [Lnet/sf/cglib/proxy/Callback;
    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL

  private net.sf.cglib.proxy.FixedValue CGLIB$CALLBACK_0;
    descriptor: Lnet/sf/cglib/proxy/FixedValue;
    flags: ACC_PRIVATE

  private static java.lang.Object CGLIB$CALLBACK_FILTER;
    descriptor: Ljava/lang/Object;
    flags: ACC_PRIVATE, ACC_STATIC

  static void CGLIB$STATICHOOK1();
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=2, locals=0, args_size=0
         0: new           #22                 // class java/lang/ThreadLocal
         3: dup
         4: invokespecial #25                 // Method java/lang/ThreadLocal."<init>":()V
         7: putstatic     #27                 // Field CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
        10: return
        11: athrow
      StackMap: number_of_entries = 2
        frame_type = 255 offset = 0
          locals = []
          stack = []
        frame_type = 255 offset = 11
          locals = []
          stack = [ class java/lang/Throwable ]

  public final java.lang.String fct(java.lang.String);
    descriptor: (Ljava/lang/String;)Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_FINAL
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        17: invokeinterface #41,  1           // InterfaceMethod net/sf/cglib/proxy/FixedValue.loadObject:()Ljava/lang/Object;
        22: checkcast     #43                 // class java/lang/String
        25: areturn
      StackMap: number_of_entries = 1
        frame_type = 255 offset = 17
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class java/lang/String ]
          stack = [ class net/sf/cglib/proxy/FixedValue ]

  public final java.lang.String fct2(java.lang.String);
    descriptor: (Ljava/lang/String;)Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_FINAL
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        17: invokeinterface #41,  1           // InterfaceMethod net/sf/cglib/proxy/FixedValue.loadObject:()Ljava/lang/Object;
        22: checkcast     #43                 // class java/lang/String
        25: areturn
      StackMap: number_of_entries = 1
        frame_type = 255 offset = 17
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class java/lang/String ]
          stack = [ class net/sf/cglib/proxy/FixedValue ]

  public final boolean equals(java.lang.Object);
    descriptor: (Ljava/lang/Object;)Z
    flags: ACC_PUBLIC, ACC_FINAL
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        17: invokeinterface #41,  1           // InterfaceMethod net/sf/cglib/proxy/FixedValue.loadObject:()Ljava/lang/Object;
        22: dup
        23: ifnonnull     31
        26: pop
        27: iconst_0
        28: goto          37
        31: checkcast     #48                 // class java/lang/Boolean
        34: invokevirtual #52                 // Method java/lang/Boolean.booleanValue:()Z
        37: ireturn
      StackMap: number_of_entries = 3
        frame_type = 255 offset = 17
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class java/lang/Object ]
          stack = [ class net/sf/cglib/proxy/FixedValue ]
        frame_type = 255 offset = 31
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class java/lang/Object ]
          stack = [ class java/lang/Object ]
        frame_type = 255 offset = 37
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class java/lang/Object ]
          stack = [ int ]

  public final java.lang.String toString();
    descriptor: ()Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_FINAL
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        17: invokeinterface #41,  1           // InterfaceMethod net/sf/cglib/proxy/FixedValue.loadObject:()Ljava/lang/Object;
        22: checkcast     #43                 // class java/lang/String
        25: areturn
      StackMap: number_of_entries = 1
        frame_type = 255 offset = 17
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
          stack = [ class net/sf/cglib/proxy/FixedValue ]

  public final int hashCode();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_FINAL
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        17: invokeinterface #41,  1           // InterfaceMethod net/sf/cglib/proxy/FixedValue.loadObject:()Ljava/lang/Object;
        22: dup
        23: ifnonnull     31
        26: pop
        27: iconst_0
        28: goto          37
        31: checkcast     #60                 // class java/lang/Number
        34: invokevirtual #63                 // Method java/lang/Number.intValue:()I
        37: ireturn
      StackMap: number_of_entries = 3
        frame_type = 255 offset = 17
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
          stack = [ class net/sf/cglib/proxy/FixedValue ]
        frame_type = 255 offset = 31
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
          stack = [ class java/lang/Object ]
        frame_type = 255 offset = 37
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
          stack = [ int ]

  protected final java.lang.Object clone() throws java.lang.CloneNotSupportedException;
    descriptor: ()Ljava/lang/Object;
    flags: ACC_PROTECTED, ACC_FINAL
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        17: invokeinterface #41,  1           // InterfaceMethod net/sf/cglib/proxy/FixedValue.loadObject:()Ljava/lang/Object;
        22: areturn
      StackMap: number_of_entries = 1
        frame_type = 255 offset = 17
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
          stack = [ class net/sf/cglib/proxy/FixedValue ]
    Exceptions:
      throws java.lang.CloneNotSupportedException

  public first.Sample$$EnhancerByCGLIB$$2fef46f3();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: dup
         2: invokespecial #67                 // Method first/Sample."<init>":()V
         5: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
         8: return

  public static void CGLIB$SET_THREAD_CALLBACKS(net.sf.cglib.proxy.Callback[]);
    descriptor: ([Lnet/sf/cglib/proxy/Callback;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #27                 // Field CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
         3: aload_0
         4: invokevirtual #72                 // Method java/lang/ThreadLocal.set:(Ljava/lang/Object;)V
         7: return

  public static void CGLIB$SET_STATIC_CALLBACKS(net.sf.cglib.proxy.Callback[]);
    descriptor: ([Lnet/sf/cglib/proxy/Callback;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: putstatic     #75                 // Field CGLIB$STATIC_CALLBACKS:[Lnet/sf/cglib/proxy/Callback;
         4: return

  private static final void CGLIB$BIND_CALLBACKS(java.lang.Object);
    descriptor: (Ljava/lang/Object;)V
    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=3, locals=2, args_size=1
         0: aload_0
         1: checkcast     #2                  // class first/Sample$$EnhancerByCGLIB$$2fef46f3
         4: astore_1
         5: aload_1
         6: getfield      #77                 // Field CGLIB$BOUND:Z
         9: ifne          52
        12: aload_1
        13: iconst_1
        14: putfield      #77                 // Field CGLIB$BOUND:Z
        17: getstatic     #27                 // Field CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
        20: invokevirtual #80                 // Method java/lang/ThreadLocal.get:()Ljava/lang/Object;
        23: dup
        24: ifnonnull     39
        27: pop
        28: getstatic     #75                 // Field CGLIB$STATIC_CALLBACKS:[Lnet/sf/cglib/proxy/Callback;
        31: dup
        32: ifnonnull     39
        35: pop
        36: goto          52
        39: checkcast     #81                 // class "[Lnet/sf/cglib/proxy/Callback;"
        42: aload_1
        43: swap
        44: iconst_0
        45: aaload
        46: checkcast     #37                 // class net/sf/cglib/proxy/FixedValue
        49: putfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        52: return
      StackMap: number_of_entries = 2
        frame_type = 255 offset = 39
          locals = [ class java/lang/Object, class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
          stack = [ class java/lang/Object ]
        frame_type = 255 offset = 52
          locals = [ class java/lang/Object, class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
          stack = []

  public java.lang.Object newInstance(net.sf.cglib.proxy.Callback[]);
    descriptor: ([Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_1
         1: invokestatic  #85                 // Method CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
         4: new           #2                  // class first/Sample$$EnhancerByCGLIB$$2fef46f3
         7: dup
         8: invokespecial #86                 // Method "<init>":()V
        11: aconst_null
        12: invokestatic  #85                 // Method CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
        15: areturn

  public java.lang.Object newInstance(net.sf.cglib.proxy.Callback);
    descriptor: (Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=2, args_size=2
         0: iconst_1
         1: anewarray     #89                 // class net/sf/cglib/proxy/Callback
         4: dup
         5: iconst_0
         6: aload_1
         7: aastore
         8: invokestatic  #85                 // Method CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
        11: new           #2                  // class first/Sample$$EnhancerByCGLIB$$2fef46f3
        14: dup
        15: invokespecial #86                 // Method "<init>":()V
        18: aconst_null
        19: invokestatic  #85                 // Method CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
        22: areturn

  public java.lang.Object newInstance(java.lang.Class[], java.lang.Object[], net.sf.cglib.proxy.Callback[]);
    descriptor: ([Ljava/lang/Class;[Ljava/lang/Object;[Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;
    flags: ACC_PUBLIC
    Code:
      stack=5, locals=4, args_size=4
         0: aload_3
         1: invokestatic  #85                 // Method CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
         4: new           #2                  // class first/Sample$$EnhancerByCGLIB$$2fef46f3
         7: dup
         8: aload_1
         9: dup
        10: arraylength
        11: tableswitch   { // 0 to 0
                       0: 28
                 default: 35
            }
        28: pop
        29: invokespecial #86                 // Method "<init>":()V
        32: goto          49
        35: goto          38
        38: pop
        39: new           #92                 // class java/lang/IllegalArgumentException
        42: dup
        43: ldc           #94                 // String Constructor not found
        45: invokespecial #97                 // Method java/lang/IllegalArgumentException."<init>":(Ljava/lang/String;)V
        48: athrow
        49: aconst_null
        50: invokestatic  #85                 // Method CGLIB$SET_THREAD_CALLBACKS:([Lnet/sf/cglib/proxy/Callback;)V
        53: areturn
      StackMap: number_of_entries = 4
        frame_type = 255 offset = 28
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class "[Ljava/lang/Class;", class "[Ljava/lang/Object;", class "[Lnet/sf/cglib/proxy/Callback;" ]
          stack = [ uninitialized 4, uninitialized 4, class "[Ljava/lang/Class;" ]
        frame_type = 255 offset = 35
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class "[Ljava/lang/Class;", class "[Ljava/lang/Object;", class "[Lnet/sf/cglib/proxy/Callback;" ]
          stack = [ uninitialized 4, uninitialized 4, class "[Ljava/lang/Class;" ]
        frame_type = 255 offset = 38
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class "[Ljava/lang/Class;", class "[Ljava/lang/Object;", class "[Lnet/sf/cglib/proxy/Callback;" ]
          stack = [ uninitialized 4, uninitialized 4, class "[Ljava/lang/Class;" ]
        frame_type = 255 offset = 49
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, class "[Ljava/lang/Class;", class "[Ljava/lang/Object;", class "[Lnet/sf/cglib/proxy/Callback;" ]
          stack = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]

  public net.sf.cglib.proxy.Callback getCallback(int);
    descriptor: (I)Lnet/sf/cglib/proxy/Callback;
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
         4: aload_0
         5: iload_1
         6: tableswitch   { // 0 to 0
                       0: 24
                 default: 30
            }
        24: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        27: goto          32
        30: pop
        31: aconst_null
        32: areturn
      StackMap: number_of_entries = 3
        frame_type = 255 offset = 24
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, int ]
          stack = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
        frame_type = 255 offset = 30
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, int ]
          stack = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3 ]
        frame_type = 255 offset = 32
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, int ]
          stack = [ class net/sf/cglib/proxy/FixedValue ]

  public void setCallback(int, net.sf.cglib.proxy.Callback);
    descriptor: (ILnet/sf/cglib/proxy/Callback;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1
         1: tableswitch   { // 0 to 0
                       0: 20
                 default: 31
            }
        20: aload_0
        21: aload_2
        22: checkcast     #37                 // class net/sf/cglib/proxy/FixedValue
        25: putfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        28: goto          31
        31: return
      StackMap: number_of_entries = 2
        frame_type = 255 offset = 20
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, int, class net/sf/cglib/proxy/Callback ]
          stack = []
        frame_type = 255 offset = 31
          locals = [ class first/Sample$$EnhancerByCGLIB$$2fef46f3, int, class net/sf/cglib/proxy/Callback ]
          stack = []

  public net.sf.cglib.proxy.Callback[] getCallbacks();
    descriptor: ()[Lnet/sf/cglib/proxy/Callback;
    flags: ACC_PUBLIC
    Code:
      stack=5, locals=1, args_size=1
         0: aload_0
         1: invokestatic  #35                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
         4: aload_0
         5: iconst_1
         6: anewarray     #89                 // class net/sf/cglib/proxy/Callback
         9: dup
        10: iconst_0
        11: aload_0
        12: getfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        15: aastore
        16: areturn

  public void setCallbacks(net.sf.cglib.proxy.Callback[]);
    descriptor: ([Lnet/sf/cglib/proxy/Callback;)V
    flags: ACC_PUBLIC
    Code:
      stack=5, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: dup2
         3: iconst_0
         4: aaload
         5: checkcast     #37                 // class net/sf/cglib/proxy/FixedValue
         8: putfield      #31                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        11: return

  static {};
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=0, locals=0, args_size=0
         0: invokestatic  #111                // Method CGLIB$STATICHOOK1:()V
         3: return
}
SourceFile: "<generated>"

/ 13	. 

Field CGLIB$CALLBACK_0 = FixedValue

CGLIB$THREAD_CALLBACKS = ThreadLocal

CGLIB$STATIC_CALLBACKS=[Lnet/sf/cglib/proxy/Callback;



/ 13	. 

[eric@almond bin]$ pwd
/home/eric/Devel/Java/cglib/3.2.5/bin
[eric@almond bin]$ find . -name "*.class" | xargs -I % bash -c "echo %;javap -c -verbose %| grep 'CGLIB\$BIND_CALLBACKS'"
/ Let op de \$ in de grep
/ TODO

./net/sf/cglib/proxy/Enhancer.class
   #321 = String             #904         // void CGLIB$BIND_CALLBACKS(Object)
   #904 = Utf8               void CGLIB$BIND_CALLBACKS(Object)
       373: ldc_w         #321                // String void CGLIB$BIND_CALLBACKS(Object)

/ 13	. 

/ scala ide
/ ws ...
/ proj cglib-study

$ vi SampleTest.java

public class SampleTest {
	@Test(expected=ClassCastException.class)
	public void testInvocationHandler(){
		Enhancer enhancer=new Enhancer();
		enhancer.setSuperclass(Sample.class);
		enhancer.setCallback(new InvocationHandler() {
			
			@Override
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				if(method.getDeclaringClass()!=Object.class 			<- we komen hier	, method=Sample.fct
						&& method.getReturnType()==String.class){
					return testHello;														<- we override Sample.fct	, 
				}
				else return "Foo Bar";
			}
		});
		Sample sample=(Sample)enhancer.create();
		String result=sample.fct("foo");						<-	 we zitten hier in	,
		Assert.assertEquals(testHello, result);
		result=sample.fct2("foo");
		Assert.assertEquals(testHello, result);
		result=sample.toString();
		Assert.assertNotEquals(testHello, result);
		sample.hashCode();

	}

/ stack
/s
Thread [main] (Suspended (breakpoint at line 51 in SampleTest$2))	
	SampleTest$2.invoke(Object, Method, Object[]) line: 51	
	Sample$$EnhancerByCGLIB$$b242b624.fct(String) line: not available	
	SampleTest.testInvocationHandler() line: 59	
		String result=sample.fct("foo");
/cb
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 498	
	FrameworkMethod$1.runReflectiveCall() line: 50	
	FrameworkMethod$1(ReflectiveCallable).run() line: 12	
	FrameworkMethod.invokeExplosively(Object, Object...) line: 47	
	InvokeMethod.evaluate() line: 17	
	ExpectException.evaluate() line: 19	
	BlockJUnit4ClassRunner(ParentRunner<T>).runLeaf(Statement, Description, RunNotifier) line: 325	
	BlockJUnit4ClassRunner.runChild(FrameworkMethod, RunNotifier) line: 78	
	BlockJUnit4ClassRunner.runChild(Object, RunNotifier) line: 57	
	ParentRunner$3.run() line: 290	
	ParentRunner$1.schedule(Runnable) line: 71	
	BlockJUnit4ClassRunner(ParentRunner<T>).runChildren(RunNotifier) line: 288	
	ParentRunner<T>.access$000(ParentRunner, RunNotifier) line: 58	
	ParentRunner$2.evaluate() line: 268	
	BlockJUnit4ClassRunner(ParentRunner<T>).run(RunNotifier) line: 363	
	JUnit4TestClassReference(JUnit4TestReference).run(TestExecution) line: 50	
	TestExecution.run(ITestReference[]) line: 38	
	RemoteTestRunner.runTests(String[], String, TestExecution) line: 459	
	RemoteTestRunner.runTests(TestExecution) line: 675	
	RemoteTestRunner.run() line: 382	
	RemoteTestRunner.main(String[]) line: 192	
/debug	,
/s
SampleTest$2.invoke(Object, Method, Object[]) line: 51	
		enhancer.setCallback(new InvocationHandler() {
			@Override
			public Object invoke(Object proxy, Method method, Object[] args)		/ method is de orig method	,

this	SampleTest$2  (id=108)	
proxy	Sample$$EnhancerByCGLIB$$b242b624  (id=160)	
	CGLIB$CALLBACK_FILTER	Enhancer$1  (id=164)	
	CGLIB$FACTORY_DATA	Enhancer$EnhancerFactoryData  (id=166)	
		generatedClass	Class<T> (first.Sample$$EnhancerByCGLIB$$b242b624) (id=159)	
		primaryConstructor	Constructor<T>  (id=195)	
		primaryConstructorArgTypes	Class<T>[0]  (id=197)	
		setThreadCallbacks	Method  (id=199)	/ public static void first.Sample$$EnhancerByCGLIB$$b242b624.CGLIB$SET_THREAD_CALLBACKS(net.sf.cglib.proxy.Callback[])
	CGLIB$BOUND	true	
	CGLIB$CALLBACK_0	SampleTest$2  (id=108)		/ this
method	Method  (id=167)	/ public java.lang.String first.Sample.fct(java.lang.String)
args	Object[1]  (id=176)	[foo]

/ 1313	. 

/ CLASS FILES CGLIB IN FS

/ In run config in eclipse
Arguments
VM arguments
-Dcglib.debugLocation=/tmp/cglib

/ Als we de test run	, 
[eric@almond Logs]$ find /tmp/cglib/
/tmp/cglib/first
/tmp/cglib/first/Sample$$EnhancerByCGLIB$$1f65f7fc.class
/tmp/cglib/net/sf/cglib/core
/tmp/cglib/net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7.class
/tmp/cglib/net/sf/cglib/proxy
/tmp/cglib/net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72.class

/ en deze kunnen we bekijken met $ javap -c -p -verbose 

/ we zien 	,
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

/ Hoe zien we in de bytecodes hoe de args op de stack worden set	?

/ In de ConstantPool, 	
   #33 = Fieldref           #2.#32        // first/Sample$$EnhancerByCGLIB$$b242b624.CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/InvocationHandler;
/ In de class first/Sample$$EnhancerByCGLIB$$b242b624 is field CGLIB$CALLBACK_0 die van type Lnet/sf/cglib/proxy/InvocationHandler; is	, 

   #39 = Fieldref           #2.#38        // first/Sample$$EnhancerByCGLIB$$b242b624.CGLIB$fct$0:Ljava/lang/reflect/Method;
/ In de class first/Sample$$EnhancerByCGLIB$$b242b624 is field  CGLIB$fct$0 die van type Ljava/lang/reflect/Method; is	, 

/ Dit zijn de bytecodes van fct met MethodInterceptor	, ipv InvocationHandler
         0: aload_0
         1: getfield      #40                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #44                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #40                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
        17: dup
        18: ifnull        45
        21: aload_0
        22: getstatic     #46                 // Field CGLIB$fct$0$Method:Ljava/lang/reflect/Method;
        25: iconst_1
        26: anewarray     #48                 // class java/lang/Object
        29: dup
        30: iconst_0
        31: aload_1
        32: aastore
        33: getstatic     #50                 // Field CGLIB$fct$0$Proxy:Lnet/sf/cglib/proxy/MethodProxy;
        36: invokeinterface #56,  5           // InterfaceMethod net/sf/cglib/proxy/MethodInterceptor.intercept:(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;Lnet/sf/cglib/proxy/MethodProxy;)Ljava/lang/Object;

/ we zien	, 
        0: aload_0
         1: getfield      #40                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
/ aload_0=first/Sample$$EnhancerByCGLIB$$b242b624	, en heeft inderdaad field CGLIB$CALLBACK_0	,  

/ WH blijft aload_0  op de stack staan, en is 1ste arg invokeinterface	, want we zien intercept(Object obj, ... en obj==first/Sample$$EnhancerByCGLIB$$b242b624	, 
/ de MethodInterceptor is de callback	, is this	,
/ we zien	, 
        21: aload_0
        22: getstatic     #46                 // Field CGLIB$fct$0$Method:Ljava/lang/reflect/Method;
/wH staan er nu 2 insts op de stack (omdat getstatic niets met aload_0 doet)	, 
/ met getfield wordt WH aload_0 vervangen door het field	, 


/ 1313	. 

	@Test
	public void testMethodInterceptor(){
		Enhancer enhancer=new Enhancer();
		enhancer.setSuperclass(Sample.class);
		enhancer.setCallback(new MethodInterceptor() {
			
			@Override
			public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
				if(method.getDeclaringClass()!=Object.class 
						&& method.getReturnType()==String.class){
					return testHello;
				}
				else{
					return proxy.invokeSuper(obj, args);
				}
			}
		});
		Sample sample=(Sample)enhancer.create();
		String result=sample.fct("foo");							<- 
		Assert.assertEquals(testHello, result);
		result=sample.fct2("foo");										<-
		Assert.assertEquals(testHello, result);
		result=sample.toString();											<-
		Assert.assertNotEquals(testHello, result);
		sample.hashCode();

/ method is weliswaar Sample.fct	, maar zijn bytecode is aangepast, dus is de proxied method	, 
/ MethodProxy TODO	, maar MethodProxy.invokeSuper calls de eigenlijke fct, dus komt in de bytecode op een bepaalde plek uit	, 
/ TODO
/ (maar een orig method call wordt een proxied method call:, alleen via de proxiedMethod's invokeSuper kun je de orig method call, via zichzelf gaat het niet meer , want cglib heeft de bytecode van de orig method aangepast	, TODO hoe werkt proxy.invokeSuper?)
/ als we	niet, 
				else{
					return proxy.invokeSuper(obj, args);
/ maar 	,
				else{
					return method.invoke(obj, args);
/ dan komen we in oneindige loops  terecht, 
/ want we doen net als  in de test 	, 
		result=sample.toString();	
/ waar dus de proxied method wordt called	,   want de bytecode van toString is aangepast	,
/ en dat gaat hier dus steeds door	, 
/ vandaar proxy.invokeSuper	,


/ debug	, 
SampleTest.testMethodInterceptor() line: 93	
		String result=sample.fct("foo");						
/ of	, 
		result=sample.toString();
/s
SampleTest$3.intercept(Object, Method, Object[], MethodProxy) line: 79	
			@Override
			public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
this	SampleTest$3  (id=939)	
obj	Sample$$EnhancerByCGLIB$$1f65f7fc  (id=940)			/ heet proxy in InvocationHandler.invoke	
	CGLIB$CALLBACK_FILTER	Enhancer$1  (id=948)	
	CGLIB$FACTORY_DATA	Enhancer$EnhancerFactoryData  (id=949)	
	CGLIB$BOUND	true	
	CGLIB$CALLBACK_0	SampleTest$3  (id=939)	
method	Method  (id=942)								/ public java.lang.String first.Sample.fct(java.lang.String)	
args	Object[1]  (id=943)					/ [foo]
proxy	MethodProxy  (id=945)	
	createInfo	MethodProxy$CreateInfo  (id=956)	
		attemptLoad	false	
		c1	Class<T> (first.Sample) (id=112)	
		c2	Class<T> (first.Sample$$EnhancerByCGLIB$$1f65f7fc) (id=938)	
		namingPolicy	DefaultNamingPolicy  (id=965)	
		strategy	DefaultGeneratorStrategy  (id=64)	
	fastClassInfo	null	
	initLock	Object  (id=959)	
	sig1	Signature  (id=961)		
fct(Ljava/lang/String;)Ljava/lang/String;	
/ of	,
toString()Ljava/lang/String;
	sig2	Signature  (id=963)	 
CGLIB$fct$0(Ljava/lang/String;)Ljava/lang/String;	
/ of	, 
CGLIB$toString$3()Ljava/lang/String;

				if(method.getDeclaringClass()!=Object.class 
						&& method.getReturnType()==String.class){
					return testHello;
				}
				else{
/j
toString
					return proxy.invokeSuper(obj, args);

/ we zien  met MethodInterceptor	, 

[eric@almond cglib]$ find
.
./$java
./$java/lang
./$java/lang/Object$$FastClassByCGLIB$$3f697993.class
./first
./first/Sample$$EnhancerByCGLIB$$1f65f7fc$$FastClassByCGLIB$$1c9284e0.class
./first/Sample$$EnhancerByCGLIB$$1f65f7fc.class
./net
./net/sf
./net/sf/cglib
./net/sf/cglib/core
./net/sf/cglib/core/MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7.class
./net/sf/cglib/proxy
./net/sf/cglib/proxy/Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72.class




/ 1313	,

/ we deden hierboven	, 

		Enhancer enhancer=new Enhancer();
		enhancer.setSuperclass(Sample.class);
		enhancer.setCallback(new MethodInterceptor() {
			@Override
			public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
				if(method.getDeclaringClass()!=Object.class 
						&& method.getReturnType()==String.class){
					return testHello;
				}
				else{
					return proxy.invokeSuper(obj, args);
				}
			}
		});
		Sample sample=(Sample)enhancer.create();
		String result=sample.fct("foo");




/ we kunnen hetzelfde	, maar zo	,

		Enhancer enhancer=new Enhancer();
		CallbackHelper helper=new CallbackHelper(Sample.class, new Class[0]) {
			
			@Override
			protected Object getCallback(Method method) {	/ hij komt hier 5 keer, voor elke method 
									/ zoals Sample.fct,	 en Object.equals	, ...

				if(method.getDeclaringClass()!=Object.class && method.getReturnType()==String.class){
																						/ hier komt hij 2 keer, voor Sample.fct en .fct2	, 
					return new FixedValue() {
						@Override
						public Object loadObject() throws Exception {
							return testHello;
						}
					};
				}
				else{													/ hier komt hij 3 keer	,  voor Object.equals	, ...
					return NoOp.INSTANCE;
				}

			}
		};
		enhancer.setSuperclass(Sample.class);
		enhancer.setCallbackFilter(helper);
		enhancer.setCallbacks(helper.getCallbacks());

		Sample sample=(Sample)enhancer.create();
		String result=sample.fct("foo");

/ we zien 2 FixedValue subclasses	, en 3 NoOP subclasses	, dit zijn de 5 callbacks	, 

/ we zien dat de enhanced fct eenvoudiger is	, maar de CGLIB$BIND_CALLBACKS is ingewikkelder	, 
/ (Maar er wordt bij MethodInvocation een FastClass created, en dat is nu niet)	,

  public final java.lang.String fct(java.lang.String);
    descriptor: (Ljava/lang/String;)Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_FINAL
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: getfield      #37                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
         4: dup
         5: ifnonnull     17
         8: pop
         9: aload_0
        10: invokestatic  #41                 // Method CGLIB$BIND_CALLBACKS:(Ljava/lang/Object;)V
        13: aload_0
        14: getfield      #37                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        17: invokeinterface #47,  1           // InterfaceMethod net/sf/cglib/proxy/FixedValue.loadObject:()Ljav
a/lang/Object;
        22: checkcast     #49                 // class java/lang/String
        25: areturn

 private static final void CGLIB$BIND_CALLBACKS(java.lang.Object);
    descriptor: (Ljava/lang/Object;)V
    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL
    Code:
      stack=5, locals=2, args_size=1
         0: aload_0
         1: checkcast     #2                  // class first/Sample$$EnhancerByCGLIB$$c50c2b9
         4: astore_1
         5: aload_1
         6: getfield      #63                 // Field CGLIB$BOUND:Z
         9: ifne          97
        12: aload_1
        13: iconst_1
        14: putfield      #63                 // Field CGLIB$BOUND:Z
        17: getstatic     #33                 // Field CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
        20: invokevirtual #66                 // Method java/lang/ThreadLocal.get:()Ljava/lang/Object;
        23: dup
        24: ifnonnull     39
        27: pop
        28: getstatic     #61                 // Field CGLIB$STATIC_CALLBACKS:[Lnet/sf/cglib/proxy/Callback;
        31: dup
        32: ifnonnull     39
        35: pop
        36: goto          97
        39: checkcast     #67                 // class "[Lnet/sf/cglib/proxy/Callback;"
        42: aload_1
        43: swap
        44: dup2
        45: iconst_5
        46: aaload
        47: checkcast     #69                 // class net/sf/cglib/proxy/NoOp
        50: putfield      #71                 // Field CGLIB$CALLBACK_5:Lnet/sf/cglib/proxy/NoOp;
        53: dup2
        54: iconst_4
        55: aaload
        56: checkcast     #69                 // class net/sf/cglib/proxy/NoOp
        59: putfield      #73                 // Field CGLIB$CALLBACK_4:Lnet/sf/cglib/proxy/NoOp;
        62: dup2
        63: iconst_3
        64: aaload
        65: checkcast     #69                 // class net/sf/cglib/proxy/NoOp
        68: putfield      #75                 // Field CGLIB$CALLBACK_3:Lnet/sf/cglib/proxy/NoOp;
        71: dup2
        72: iconst_2
        73: aaload
        74: checkcast     #69                 // class net/sf/cglib/proxy/NoOp
        77: putfield      #77                 // Field CGLIB$CALLBACK_2:Lnet/sf/cglib/proxy/NoOp;
        80: dup2
:       81: iconst_1
        82: aaload
        83: checkcast     #43                 // class net/sf/cglib/proxy/FixedValue
        86: putfield      #52                 // Field CGLIB$CALLBACK_1:Lnet/sf/cglib/proxy/FixedValue;
        89: iconst_0
        90: aaload
        91: checkcast     #43                 // class net/sf/cglib/proxy/FixedValue
        94: putfield      #37                 // Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/FixedValue;
        97: return



























































	






















