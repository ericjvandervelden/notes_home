/ See DUMPS & INDEXES
/ See SIZES
/ See GEOB-691
/ See TYPE CASTS
/ See QUOTED STRINGS IN TEXT FIELDS 
/ See FUNCTIONS CREATE

/ See IMPLICIT CAST IN ACTION 

/ See SOURCE CODE
/ See WEB PAGES
/ See SQL
/ See PRIMARY KEY
/ See SERIAL
/ See GENERATE SERIES 
/ See STORED PROCEDURES
/ See ARRAYS
/ See JOINS

/ See GENERATE_SERIES ARRAYS GENERATE_SUBSCRIPTS 	<-
/ See ROW TYPES ANYELEMENTS
/ 	See SELECT INTO
/ ROW TYPES COMPOSITE TYPES
/ ALIAS FUNCTIONS WHICH RETURN A SINGLE COLUMN	, 
/ See FUNCTIONS


/ OID

/ Lees	,
https://www.postgresql.org/docs/9.3/static/datatype-oid.html

[eric@localhost Dsvfms]$ PGPASSWORD=foo psql -U foo

foo=>  \d club
                                 Table "public.club"
 Column |          Type          |                     Modifiers                      
--------+------------------------+----------------------------------------------------
 id_    | bigint                 | not null default nextval('club_id__seq'::regclass)
 name_  | character varying(255) | 
Indexes:
    "club_pkey" PRIMARY KEY, btree (id_)
Referenced by:
    TABLE "sporter" CONSTRAINT "fk_1k67yd2nymaoofah9faoxj0cl" FOREIGN KEY (club_) REFERENCES club(id_)

foo=> \d pg_attribute
    Table "pg_catalog.pg_attribute"
    Column     |   Type    | Modifiers 
---------------+-----------+-----------
 attrelid      | oid       | not null
 attname       | name      | not null
 atttypid      | oid       | not null
 attstattarget | integer   | not null
 attlen        | smallint  | not null
 attnum        | smallint  | not null
 attndims      | integer   | not null
 attcacheoff   | integer   | not null
 atttypmod     | integer   | not null
 attbyval      | boolean   | not null
 attstorage    | "char"    | not null
 attalign      | "char"    | not null
 attnotnull    | boolean   | not null
 atthasdef     | boolean   | not null
 attisdropped  | boolean   | not null
 attislocal    | boolean   | not null
 attinhcount   | integer   | not null
 attcollation  | oid       | not null
 attacl        | aclitem[] | 
 attoptions    | text[]    | 
 attfdwoptions | text[]    | 
Indexes:
    "pg_attribute_relid_attnam_index" UNIQUE, btree (attrelid, attname)
    "pg_attribute_relid_attnum_index" UNIQUE, btree (attrelid, attnum)

foo=> \d sporter
                                 Table "public.sporter"
 Column |          Type          |                       Modifiers                       
--------+------------------------+-------------------------------------------------------
 id_    | bigint                 | not null default nextval('sporter_id__seq'::regclass)
 name_  | character varying(255) | 
 club_  | bigint                 | not null
Indexes:
    "sporter_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_1k67yd2nymaoofah9faoxj0cl" FOREIGN KEY (club_) REFERENCES club(id_)



foo=> SELECT * FROM pg_attribute WHERE attrelid = 'club'::regclass;
/=
foo=>  SELECT * FROM pg_attribute
foo->   WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'club');

 attrelid | attname  | atttypid | attstattarget | attlen | attnum | attndims | attcacheoff | atttypmod | attbyval | attstorage | a
ttalign | attnotnull | atthasdef | attisdropped | attislocal | attinhcount | attcollation | attacl | attoptions | attfdwoptions 
----------+----------+----------+---------------+--------+--------+----------+-------------+-----------+----------+------------+--
--------+------------+-----------+--------------+------------+-------------+--------------+--------+------------+---------------
  3293212 | tableoid |       26 |             0 |      4 |     -7 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293212 | cmax     |       29 |             0 |      4 |     -6 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293212 | xmax     |       28 |             0 |      4 |     -5 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293212 | cmin     |       29 |             0 |      4 |     -4 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293212 | xmin     |       28 |             0 |      4 |     -3 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293212 | ctid     |       27 |             0 |      6 |     -1 |        0 |          -1 |        -1 | f        | p          | s
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293212 | id_      |       20 |            -1 |      8 |      1 |        0 |          -1 |        -1 | t        | p          | d
        | t          | t         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293212 | name_    |     1043 |            -1 |     -1 |      2 |        0 |          -1 |       259 | f        | x          | i
        | f          | f         | f            | t          |           0 |          100 | NULL   | NULL       | NULL
(8 rows)

/ we zien id_, name_	, maar er zijn ook anderen	, 

foo=> SELECT * FROM pg_attribute WHERE attrelid = 'sporter'::regclass;
/=
foo=>  SELECT * FROM pg_attribute
foo->   WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'sporter');

 attrelid | attname  | atttypid | attstattarget | attlen | attnum | attndims | attcacheoff | atttypmod | attbyval | attstorage | a
ttalign | attnotnull | atthasdef | attisdropped | attislocal | attinhcount | attcollation | attacl | attoptions | attfdwoptions 
----------+----------+----------+---------------+--------+--------+----------+-------------+-----------+----------+------------+--
--------+------------+-----------+--------------+------------+-------------+--------------+--------+------------+---------------
  3293291 | tableoid |       26 |             0 |      4 |     -7 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | cmax     |       29 |             0 |      4 |     -6 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | xmax     |       28 |             0 |      4 |     -5 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | cmin     |       29 |             0 |      4 |     -4 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | xmin     |       28 |             0 |      4 |     -3 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | ctid     |       27 |             0 |      6 |     -1 |        0 |          -1 |        -1 | f        | p          | s
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | id_      |       20 |            -1 |      8 |      1 |        0 |          -1 |        -1 | t        | p          | d
        | t          | t         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | name_    |     1043 |            -1 |     -1 |      2 |        0 |          -1 |       259 | f        | x          | i
        | f          | f         | f            | t          |           0 |          100 | NULL   | NULL       | NULL
  3293291 | club_    |       20 |            -1 |      8 |      3 |        0 |          -1 |        -1 | t        | p          | d
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
(9 rows)

23 = int
21=smallint
20=bigint
1043=varchar
1082=date

/ in jdbc	,
public class Oid {
    public static final int UNSPECIFIED = 0;
    public static final int INT2 = 21;
    public static final int INT2_ARRAY = 1005;
    public static final int INT4 = 23;
    public static final int INT4_ARRAY = 1007;
    public static final int INT8 = 20;
    public static final int INT8_ARRAY = 1016;
	...
    public static final int VARCHAR = 1043;




foo=> create table you(i serial,s varchar(32));
foo=> create table ryou (i serial,s varchar(32),r int);
foo=> commit;
foo=> insert into you(s) values('foo');
foo=> insert into you(s) values('foo2');
foo=> insert into ryou(s,i) values('bar',1);
foo=> commit;

foo=> select tableoid,cmax,xmax,cmin,xmin,ctid,i,s from you;
 tableoid | cmax | xmax | cmin |  xmin  | ctid  | i |  s   
----------+------+------+------+--------+-------+---+------
  3293363 |    0 |    0 |    0 | 782423 | (0,1) | 1 | foo
  3293363 |    1 |    0 |    1 | 782423 | (0,2) | 2 | foo2
(2 rows)

foo=> select tableoid,cmax,xmax,cmin,xmin,ctid,i,s from ryou;
 tableoid | cmax | xmax | cmin |  xmin  | ctid  | i |  s  
----------+------+------+------+--------+-------+---+-----
  3293369 |    0 |    0 |    0 | 782425 | (0,1) | 1 | bar
(1 row)

/ Einde OID

/ SQL 

drop table if exists seo;
create table seo(i int primary key);
drop table if exists evt;
create table evt(i int primary key,r int references seo(i)not null);
insert into seo values(1),(2);
insert into evt values(1,1),(2,1),(3,2),(4,1);
commit;

foo=> select*from seo;
 i 
---
 1
 2
(2 rows)

foo=> select*from evt;
 i | r 
---+---
 1 | 1
 2 | 1
 3 | 2
 4 | 1
(4 rows)

/ pak de evt bij elke seo die de kleinste i heeft	,
select e.i,e.r
from evt e
where e.i=(
	select min(i)
	from evt e2 
	where e.r=e2.r)
;
 i | r 
---+---
 1 | 1
 3 | 2
(2 rows)

select r,min(i)
from evt
group by r
;
 r | min 
---+-----
 1 |   1
 2 |   3
(2 rows)







/ Einde SQL 

/ POSTGRESQL COLUMNS IN TABLE

/ lees	,
http://dba.stackexchange.com/questions/22362/how-do-i-list-all-columns-for-a-specified-table

SELECT attrelid::regclass, attnum, attname
FROM   pg_attribute
WHERE  attrelid = 'shipment_order'::regclass
AND    attnum > 0
AND    NOT attisdropped
and		attname like '%instr%'					<-
ORDER  BY attnum;

    attrelid    | attnum |          attname           
----------------+--------+----------------------------
 shipment_order |    145 | instruction_group_systemid
(1 row)

/ XPOMS-201

$ op pnl-app-p	, 
[vanderveldene@pnl-app-p Backup]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH pg_dump -U pnllogistics -h localhost -n public -Fc pnllogistics > ~/Backup/pnllogistics-p-$(date +%F).dump

/ op pnl-app-a2	, 
[vanderveldene@pnl-app-a Backup]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH pg_dump -U pnllogistics -h localhost  -n public -Fc pnllogistics > ~/Backup/pnllogistics-a2-$(date +%F).dump

/ Overslaan	, 
/ we halen de productie backup over 
[eric@localhost bin]$ scp vanderveldene@pnl-app-p.intermax.mp-objects.com:Backup/pnllogistics-p-2017-03-01.backup.gz /home/eric/DB_TAP/Postgres/Backup/

/ Maar we hoeven helemaal niet via de laptop van productie naar acc	, 
[vanderveldene@pnl-app-a2 ~]$ scp vanderveldene@pnl-app-p.intermax.mp-objects.com:Backup/pnllogistics-p-2017-03-01.backup.gz Backup/
vanderveldene@pnl-app-p.intermax.mp-objects.com's password: h^Zgcyr&Q
/ OK

[vanderveldene@pnl-app-a2 Backup]$ ls -l
total 8146756
-rw-rw-r-- 1 vanderveldene vanderveldene 8342274048 Mar  1 11:58 pnllogistics-p-2017-03-01.backup.gz

[vanderveldene@pnl-app-a2 Backup]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH psql -U pnllogistics -h localhost
pnllogistics=> alter schema public rename to public_old2;
pnllogistics=> create schema public;

pnllogistics=> GRANT ALL ON SCHEMA public TO admin WITH GRANT OPTION;		/ TODO
GRANT
pnllogistics=> GRANT USAGE ON SCHEMA public TO reader;						/ TODO
GRANT
pnllogistics=> GRANT USAGE ON SCHEMA public TO writer;						/ TODO
GRANT

pnllogistics=> \q

[vanderveldene@pnl-app-a2 ~]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH pg_restore -U pnllogistics -h localhost -d pnllogistics --no-acl --no-owner Backup/pnllogistics-p-2017-03-08.dump 2>&1 | tee LOG_pg_restore.txt


/ 13	. 

/ we doen nog een keer	,
[vanderveldene@pnl-app-p ~]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH pg_dump -U pnllogistics -h localhost -n public -Fc pnllogistics > ~/Backup/pnllogistics-p-$(date +%F).dump
[vanderveldene@pnl-app-a2 ~]$ scp vanderveldene@pnl-app-p.intermax.mp-objects.com:Backup/pnllogistics-p-2017-03-02.dump Backup/

/ we konden NIET	,
[vanderveldene@pnl-app-p ~]$ scp Backup/pnllogistics-p-2017-03-02.dump vanderveldene@pnl-app-a2.intermax.mp-objects.com:Backup
/ TODO

[vanderveldene@pnl-app-a2 ~]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH psql -U pnllogistics -h localhost pnllogistics 
pnllogistics=> drop schema public cascade;
pnllogistics=> alter schema public_old2 rename to public_old;
pnllogistics=> create schema public;

[vanderveldene@pnl-app-a2 ~]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH pg_restore -U pnllogistics -h localhost -d pnllogistics --no-acl --no-owner  Backup/pnllogistics-p-2017-03-02.dump 
/ we zien	, 
...
pg_restore: [archiver (db)] Error from TOC entry 5495; 1259 1614368 INDEX ragreement_testvalue_ragreement_test_systemid_idx pnllogistics
pg_restore: [archiver (db)] could not execute query: ERROR:  could not extend file "base/89250/12684": No space left on device
HINT:  Check free disk space.
    Command was: CREATE INDEX ragreement_testvalue_ragreement_test_systemid_idx ON ragreement_testvalue USING btree (ragreement_test_systemid...
pg_restore: [archiver (db)] Error from TOC entry 5499; 1259 1614369 INDEX rate_agreement_organization_systemid_idx pnllogistics
pg_restore: [archiver (db)] could not execute query: ERROR:  could not extend file "base/89250/12684": No space left on device
HINT:  Check free disk space.
    Command was: CREATE INDEX rate_agreement_organization_systemid_idx ON rate_agreement USING btree (organization_systemid);

/ 7	. 

[vanderveldene@pnl-app-a2 ~]$ PGPASSWORD=RHKKxd-xFqvC4UibbW2ylnnK8H2BNWAH pg_restore -U pnllogistics -h localhost -d pnllogistics --no-acl --no-owner ~/Backup/pnllogistics-p-2017-03-08.dump 2>&1 | tee LOG_pg_restore.txt &


/ Einde XPOMS-201

/ GEOB-691

/ 13	. 

[eric@localhost bin]$ PGPASSWORD=taxchange@mpo  psql -U taxchange -h mposerv8 -p 5434
psql: FATAL:  LDAP authentication failed for user "taxchange"
FATAL:  LDAP authentication failed for user "taxchange"

[eric@localhost bin]$ PGPASSWORD=eric987@MPO  psql -U eric -h mposerv8 -p 5434 taxchange
taxchange=> \du
                               List of roles
  Role name  |                   Attributes                   |  Member of  
-------------+------------------------------------------------+-------------
 eric        |                                                | {admin}
 taxchange   |                                                | {}

/ 13	. 

/ because of versions of postgres	,
On mposerv8:
eric@mposerv8:~$ PGPASSWORD=taxchange@mpo /usr/lib/postgresql/9.4/bin/pg_dump -U taxchange -h mposerv8 -n public -p 5434 -Fc taxchange > ~/Backup/taxchange-t-$(date +%F).dump
/ OK

[eric@localhost bin]$ PGPASSWORD=eric987@MPO  pg_dump -U eric -h mposerv8 -p 5434 -n public -Fc taxchange > ~/DB_TAP/Postgres/Backup/taxchange-t-$(date +%F).dump
pg_dump: server version: 9.4.4; pg_dump version: 9.3.5
pg_dump: aborting because of server version mismatch

/ Because on my laptop the pg version is low,	 when it is higher, eg. 5, then OK	, 
/ for pg_dump this is an ERR	, for pgsl NOT	, 


[eric@localhost bin]$ PGPASSWORD=eric987@MPO  psql -U eric -h mposerv8 -p 5434 taxchange
taxchange=> select pg_database_size('taxchange')
;
 pg_database_size 
------------------
      75621771936
(1 row)

taxchange=> select pg_size_pretty(pg_database_size('taxchange'));
 pg_size_pretty 
----------------
 70 GB
(1 row)


/ Einde GEOB-691

/ DUMPS & INDEXES

/ 13	. 

[eric@localhost bin]$ PGPASSWORD=foo psql -U foo

geosco0919t=> select pg_size_pretty(pg_database_size('geosco0919t'));
 pg_size_pretty 
----------------
 448 MB
(1 row)
/ dit mag foo	, 

[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo pg_dump  -U mpopostgres -h localhost -Fc geosco0919t >~/DB_TAP/Postgres/Backup/geosco0919t-$(date +%F).dump
[eric@localhost bin]$ ls -lh ~/tmp/geosco0919t-2017-03-02.dump 
-rw-rw-r--. 1 eric eric 211M Mar  2 15:54 /home/eric/tmp/geosco0919t-2017-03-02.dump
/ de helft	, 

bakker20160207_t=# create database geosco_restore tablespace scs;
ERROR:  permission denied for tablespace scs
/ Dit mag foo niet	,
sco0919t=> select*from inco_term;
ERROR:  permission denied for relation inco_term
/ Dit mag foo niet	,

[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo psql  -U mpopostgres bakker20160207_t
bakker20160207_t=# create database geosco_restore tablespace scs;

[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo pg_restore -U mpopostgres -h localhost -d geosco_restore ~/DB_TAP/Postgres/Backup/geosco0919t-2017-03-02.dump 
/ we zien indexes in bijv shipment_order	, met \d+	, 

geosco_restore=# drop database geosco_restore;
ERROR:  cannot drop the currently open database
geosco_restore=# \c geosco0919t 
You are now connected to database "geosco0919t" as user "mpopostgres".
geosco0919t=# drop database geosco_restore;

[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo pg_dump  -U mpopostgres -Fc geosco0919t >~/DB_TAP/Postgres/Backup/geosco0919t-$(date +%F).dump
bakker20160207_t=# create database geosco_restore tablespace scs;
[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo pg_restore -U mpopostgres -d geosco_restore ~/DB_TAP/Postgres/Backup/geosco0919t-2017-03-02.dump 
geosco_restore=# \c geosco0919t 
geosco0919t=# drop database geosco_restore;

[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo pg_dump  -U mpopostgres -h localhost -n public -Fc geosco0919t >~/DB_TAP/Postgres/Backup/geosco0919t-$(date +%F).dump
bakker20160207_t=# create database geosco_restore tablespace scs;
[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo pg_restore -U mpopostgres -h localhost -d geosco_restore --no-acl --no-owner ~/DB_TAP/Postgres/Backup/geosco0919t-2017-03-02.dump 
geosco_restore=# \c geosco0919t 
geosco0919t=# drop database geosco_restore;


/ Einde DUMPS & INDEXES

/ SIZES

/ Lees over hoe size van schema te bepalen		, 
http://stackoverflow.com/questions/4418403/list-of-schema-with-sizes-relative-and-absolute-in-a-postgresql-databasek



/ Einde SIZES


/ DROP TABLE & CONSTRAINTS

/ 13	. 

/ als we de table rm, worden de constraints op deze table ook rm	, 

foo=> create table par(s varchar(32), i int);
CREATE TABLE
foo=> alter table par add primary key(i);
ALTER TABLE
/ of in 1 keer	,
foo=> create table par(s varchar(32), i int primary key);
CREATE TABLE
foo=> \d+ par
                                 Table "public.par"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 s      | character varying(32) |           | extended |              | 
 i      | integer               | not null  | plain    |              | 
Indexes:
    "par_pkey" PRIMARY KEY, btree (i)
Has OIDs: no

foo=> create table refs(t varchar(32),j int);
CREATE TABLE
foo=> alter table refs add primary key(j);
ALTER TABLE
foo=> alter table refs add foreign  key(j) references par;
ALTER TABLE

foo=> \d+ refs
                                Table "public.refs"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 t      | character varying(32) |           | extended |              | 
 j      | integer               | not null  | plain    |              | 
Indexes:
    "refs_pkey" PRIMARY KEY, btree (j)
Foreign-key constraints:
    "refs_j_fkey" FOREIGN KEY (j) REFERENCES par(i)
Has OIDs: no

foo=> select*from pg_constraint where conrelid='par'::regclass;
 conname  | connamespace | contype | condeferrable | condeferred | convalidated | conrelid | contypid | conindid | confrelid | confupdtype | confdelty
pe | confmatchtype | conislocal | coninhcount | connoinherit | conkey | confkey | conpfeqop | conppeqop | conffeqop | conexclop | conbin | consrc 
----------+--------------+---------+---------------+-------------+--------------+----------+----------+----------+-----------+-------------+----------
---+---------------+------------+-------------+--------------+--------+---------+-----------+-----------+-----------+-----------+--------+--------
 par_pkey |         2200 | p       | f             | f           | t            |  3661632 |        0 |  3661635 |         0 |             |          
   |               | t          |           0 | t            | {2}    | NULL    | NULL      | NULL      | NULL      | NULL      | NULL   | NULL
(1 row)
foo=> select*from pg_constraint where conrelid='refs'::regclass;
   conname   | connamespace | contype | condeferrable | condeferred | convalidated | conrelid | contypid | conindid | confrelid | confupdtype | confde
ltype | confmatchtype | conislocal | coninhcount | connoinherit | conkey | confkey | conpfeqop | conppeqop | conffeqop | conexclop | conbin | consrc 
-------------+--------------+---------+---------------+-------------+--------------+----------+----------+----------+-----------+-------------+-------
------+---------------+------------+-------------+--------------+--------+---------+-----------+-----------+-----------+-----------+--------+--------
 refs_j_fkey |         2200 | f       | f             | f           | t            |  3661601 |        0 |  3661635 |   3661632 | a           | a     
      | s             | t          |           0 | t            | {2}    | {2}     | {96}      | {96}      | {96}      | NULL      | NULL   | NULL
 refs_pkey   |         2200 | p       | f             | f           | t            |  3661601 |        0 |  3661637 |         0 |             |       
      |               | t          |           0 | t            | {2}    | NULL    | NULL      | NULL      | NULL      | NULL      | NULL   | NULL
(2 rows)

foo=> drop table refs;
DROP TABLE
foo=> commit;
COMMIT
/ We zien dat de constraints ook we zijn	, 
foo=> select*from pg_constraint where  conname like 'refs%';
 conname | connamespace | contype | condeferrable | condeferred | convalidated | conrelid | contypid | conindid | confrelid | confupdtype | confdeltyp
e | confmatchtype | conislocal | coninhcount | connoinherit | conkey | confkey | conpfeqop | conppeqop | conffeqop | conexclop | conbin | consrc 
---------+--------------+---------+---------------+-------------+--------------+----------+----------+----------+-----------+-------------+-----------
--+---------------+------------+-------------+--------------+--------+---------+-----------+-----------+-----------+-----------+--------+--------
(0 rows)

=> drop table par;
DROP TABLE
foo=> commit;
COMMIT
foo=> select*from pg_constraint where  conname like 'par%';
  conname   | connamespace | contype | condeferrable | condeferred | convalidated | conrelid | contypid | conindid | confrelid | confupdtype | confdel
type | confmatchtype | conislocal | coninhcount | connoinherit | conkey | confkey | conpfeqop | conppeqop | conffeqop | conexclop | conbin | consrc 
------------+--------------+---------+---------------+-------------+--------------+----------+----------+----------+-----------+-------------+--------
-----+---------------+------------+-------------+--------------+--------+---------+-----------+-----------+-----------+-----------+--------+--------
 party_pkey |         2200 | p       | f             | f           | t            |   360666 |        0 |   360669 |         0 |             |        
     |               | t          |           0 | t            | {1}    | NULL    | NULL      | NULL      | NULL      | NULL      | NULL   | NULL
(1 row)

/ 13	. 

foo=> create table par(s varchar(32), i int);
CREATE TABLE
foo=> alter table par add primary key(i);
ALTER TABLE
foo=> create table refs(t varchar(32),j int);
CREATE TABLE
foo=> alter table refs add primary key(j);
ALTER TABLE
foo=> alter table refs add foreign  key(j) references par;
ALTER TABLE
foo=> commit;
COMMIT

foo=> \d+ par
                                 Table "public.par"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 s      | character varying(32) |           | extended |              | 
 i      | integer               | not null  | plain    |              | 
Indexes:
    "par_pkey" PRIMARY KEY, btree (i)
Referenced by:
    TABLE "refs" CONSTRAINT "refs_j_fkey" FOREIGN KEY (j) REFERENCES par(i)
Has OIDs: no

foo=> \d+ refs
                                Table "public.refs"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 t      | character varying(32) |           | extended |              | 
 j      | integer               | not null  | plain    |              | 
Indexes:
    "refs_pkey" PRIMARY KEY, btree (j)
Foreign-key constraints:
    "refs_j_fkey" FOREIGN KEY (j) REFERENCES par(i)
Has OIDs: no

foo=> drop table par;
ERROR:  cannot drop table par because other objects depend on it
DETAIL:  constraint refs_j_fkey on table refs depends on table par
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
foo=> rollback ;
ROLLBACK
foo=> drop table par cascade;
NOTICE:  drop cascades to constraint refs_j_fkey on table refs
DROP TABLE

foo=> \d+ par
Did not find any relation named "par".
foo=> \d+ refs
                                Table "public.refs"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 t      | character varying(32) |           | extended |              | 
 j      | integer               | not null  | plain    |              | 
Indexes:
    "refs_pkey" PRIMARY KEY, btree (j)
Has OIDs: no
/ we zien dat de fk is verdwenen van refs	, 

/ 13	. 

foo=> create table par(s varchar(32), i int);
CREATE TABLE
foo=> alter table par add primary key(i);
ALTER TABLE
foo=> create table refs(t varchar(32),j int);
CREATE TABLE
foo=> alter table refs add primary key(j);
ALTER TABLE
foo=> alter table refs add foreign  key(j) references par;
ALTER TABLE
foo=> commit;
COMMIT

foo=> drop table refs;
/=
foo=> drop table refs cascade;
DROP TABLE
/ OK
/ Er zijn geen fk's die ref naar refs	, 
/ of views die refs use	, TODO

foo=> rollback;
ROLLBACK
/ maakt ongedaan	, 
drop table refs 



/ Einde DROP TABLE & CONSTRAINTS

/ DELETE CASCADE 

foo=> create table par(s varchar(32), i int);
CREATE TABLE
foo=> alter table par add primary key(i);
ALTER TABLE
foo=> create table refs(t varchar(32),j int);
CREATE TABLE
foo=> alter table refs add primary key(j);
ALTER TABLE
foo=> alter table refs add foreign  key(j) references par;
ALTER TABLE
foo=> create table refs2(t varchar(32),j int);
CREATE TABLE
foo=> alter table refs2 add primary key(j);
ALTER TABLE
foo=> alter table refs2 add foreign  key(j) references par;
ALTER TABLE
foo=> commit;
COMMIT

foo=> insert into par values('foo', 7),('bar',13);
INSERT 0 2
foo=> commit;
COMMIT
foo=> insert into refs values('foo',7),('bar',13);
INSERT 0 2
foo=> insert into refs2 values('foo',7),('bar',13);
INSERT 0 2

/ we doen op bli-app-t	, 

[vanderveldene@bli-app-t ~]$ mkdir Backup
[vanderveldene@bli-app-t ~]$ PGPASSWORD=fbf2e4870aabf1f24cd7a9d7b40d2adf pg_dump -U bakker -Fc -h  localhost bakker >~/Backup/bakker-t-$(date +%F).dump
[vanderveldene@bli-app-t ~]$ ls -lh Backup/
total 40M
-rw-rw-r-- 1 vanderveldene vanderveldene 40M Mar  9 10:41 bakker-t-2017-03-09.dump

/ 13	. 

/ Lees	, 
http://stackoverflow.com/questions/10356484/how-to-add-on-delete-cascade-constraints

foo=> alter table refs drop constraint refs_j_fkey;
ALTER TABLE
foo=> alter table refs add for

foo=> alter table refs add foreign key(j)references par(i) on delete cascade;
ALTER TABLE
foo=> commit;
COMMIT
foo=> \d+ refs
                                Table "public.refs"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 t      | character varying(32) |           | extended |              | 
 j      | integer               | not null  | plain    |              | 
Indexes:
    "refs_pkey" PRIMARY KEY, btree (j)
Foreign-key constraints:
    "refs_j_fkey" FOREIGN KEY (j) REFERENCES par(i) ON DELETE CASCADE


=> \d+ par
                                 Table "public.par"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 s      | character varying(32) |           | extended |              | 
 i      | integer               | not null  | plain    |              | 
Indexes:
    "par_pkey" PRIMARY KEY, btree (i)
Referenced by:
    TABLE "refs2" CONSTRAINT "refs2_j_fkey" FOREIGN KEY (j) REFERENCES par(i)
    TABLE "refs" CONSTRAINT "refs_j_fkey" FOREIGN KEY (j) REFERENCES par(i) ON DELETE CASCADE

/ 13	.

foo=> delete from par where i=7;
ERROR:  update or delete on table "par" violates foreign key constraint "refs2_j_fkey" on table "refs2"
DETAIL:  Key (i)=(7) is still referenced from table "refs2".

/ Dus de fk in refs is OK	, omdat deze ON DELETE CASCADE  is	, 

/ we veranderen ook 	,

foo=> alter table refs2 drop constraint refs2_j_fkey;
ALTER TABLE
foo=> alter table refs2 add foreign key(j)references par(i)on delete cascade;
ALTER TABLE
foo=> commit;
COMMIT

foo=> delete from par where i=7;
DELETE 1
foo=> select*from par;
  s  | i  
-----+----
 bar | 13
(1 row)

foo=> select*from refs;
  t  | j  
-----+----
 bar | 13
(1 row)

foo=> select*from refs2;
  t  | j  
-----+----
 bar | 13
(1 row)

/ Lees	, 
http://stackoverflow.com/questions/11504699/postgresql-on-delete-cascade

/ we set weer terug	, voor volgende	,

foo=> rollback ;
ROLLBACK
foo=> select*from par;
  s  | i  
-----+----
 foo |  7
 bar | 13
(2 rows)

foo=> select*from refs2;
  t  | j  
-----+----
 foo |  7
 bar | 13
(2 rows)

foo=> select*from refs;
  t  | j  
-----+----
 foo |  7
 bar | 13
(2 rows)

foo=> \d+ par
                                 Table "public.par"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 s      | character varying(32) |           | extended |              | 
 i      | integer               | not null  | plain    |              | 
Indexes:
    "par_pkey" PRIMARY KEY, btree (i)
Referenced by:
    TABLE "refs2" CONSTRAINT "refs2_j_fkey" FOREIGN KEY (j) REFERENCES par(i) ON DELETE CASCADE
    TABLE "refs" CONSTRAINT "refs_j_fkey" FOREIGN KEY (j) REFERENCES par(i) ON DELETE CASCADE


foo=> alter table refs drop constraint refs_j_fkey;
ALTER TABLE
foo=> alter table refs2 drop constraint refs2_j_fkey;
ALTER TABLE
foo=> alter table refs2 add foreign key(j) references par(i);
ALTER TABLE
foo=> alter table refs add foreign key(j) references par(i);
ALTER TABLE
foo=> commit;
COMMIT
foo=> \d+ par;
                                 Table "public.par"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 s      | character varying(32) |           | extended |              | 
 i      | integer               | not null  | plain    |              | 
Indexes:
    "par_pkey" PRIMARY KEY, btree (i)
Referenced by:
    TABLE "refs2" CONSTRAINT "refs2_j_fkey" FOREIGN KEY (j) REFERENCES par(i)
    TABLE "refs" CONSTRAINT "refs_j_fkey" FOREIGN KEY (j) REFERENCES par(i)





/ Einde DELETE CASCADE 

/ DELETE WITH JOIN

/ Lees	,
http://stackoverflow.com/questions/11753904/postgresql-delete-with-inner-join

/ we doen zonder fk met on delete cascade 	, 

delete from refs
where j in (
	select i 
	from par 
	where i=7
)
/ OK	,
foo=> select*from refs;
  t  | j  
-----+----
 bar | 13
(1 row)

foo=> rollback ;
ROLLBACK
foo=> select*from refs2;
  t  | j  
-----+----
 foo |  7
 bar | 13
(2 rows)

delete from refs
using par
where refs.j=par.i
and par.i=7;

foo=> select*from refs;
  t  | j  
-----+----
 bar | 13
(1 row)
/ OK

/ Bij joins kunnen we using alleen zo	, 
foo=> select *from refs join refs2 using(j) where refs.j=7;
 j |  t  |  t  
---+-----+-----
 7 | foo | foo
(1 row)

/ 7	. 

/ Nog een niveau	, 

foo=> create table seclvl(s varchar(32),k int);
CREATE TABLE
foo=> alter table seclvl add primary key(k);
ALTER TABLE
foo=> alter table seclvl add foreign key(k)references refs(j);
ALTER TABLE
foo=> commit;
COMMIT

foo=> insert into seclvl values('foo',7), ('bar', 13);
INSERT 0 2
foo=> commit;
COMMIT

delete 
from seclvl
using refs
where seclvl.k=refs.j
and refs.j=7;
DELETE 1							/ OK
foo=> rollback ;
ROLLBACK

delete 
from seclvl
using refs,par
where seclvl.k=refs.j
and refs.j=par.i
and par.i=7;
DELETE 1							/ OK
Einde





/ Einde DELETE WITH JOIN

/ WITH

/ Lees	,
https://www.tutorialspoint.com/postgresql/postgresql_with_clause.htm
https://www.postgresql.org/docs/9.3/static/queries-with.html
http://www.craigkerstiens.com/2013/11/18/best-postgres-feature-youre-not-using/

/ foo db	, 
$ psql -U foo

with cte as(
	select s,i	 / of select *
	from par
)
select*from cte;
  s  | i  
-----+----
 foo |  7
 bar | 13
(2 rows)

WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL										--- of UNION	, TODO
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t;		---  of min	, max	, 

/ 13	. 

/ Lees	, 
http://www.postgresqltutorial.com/postgresql-recursive-query/

create table employees(
	employee_id serial primary key,
	name varchar not null,
	manager_id int);

foo=> \d employees
                                Table "public.employees"
   Column   |       Type        |                       Modifiers                        
------------+-------------------+--------------------------------------------------------
 employee_id| integer           | not null default nextval('employees_employee_id_seq'::regclass)
 name       | character varying | not null
 manager_id | integer           | 
Indexes:
    "employees_pkey" PRIMARY KEY, btree (employee_id)

/ Intermezzo

CREATE TABLE tablename (
    colname SERIAL
);
/=
CREATE SEQUENCE tablename_colname_seq;
CREATE TABLE tablename (
    colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')
);
ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;

/ Einde Intermezzo

/ Lees	, 
http://stackoverflow.com/questions/787722/postgresql-autoincrement

alter sequence employees_id_seq restart with 1; 	--- cannot rollback	,

delete from employees;
insert into employees(name,manager_id)				--- (name,manager_id)
values('Foo Bar',0);
insert into employees(name,manager_id)
values('Megan Berry',1);
insert into employees(name,manager_id)
values('Bella Tucker',2);
insert into employees(name,manager_id)
values('Ryan Henderson',2);
insert into employees(name,manager_id)
values('Frank Tukker',2);
insert into employees(name,manager_id)
values('Nathan Ferguson',2);
insert into employees(name,manager_id)
values('Kevin Rampling',2);
select*from employees;
 id |      name       | manager_id 
----+-----------------+------------
 36 | Foo Bar         |          0
 37 | Megan Berry     |          1
 38 | Bella Tucker    |          2
 39 | Ryan Henderson  |          2
 40 | Frank Tukker    |          2
 41 | Nathan Ferguson |          2
 42 | Kevin Rampling  |          2
(7 rows)

/ of	,  we geven de employee_id op 	, dat mag ook	,

INSERT INTO employees (
 employee_id,
 full_name,
 manager_id
)
VALUES
 (1, 'Michael North', NULL),
 (2, 'Megan Berry', 1),
 (3, 'Sarah Berry', 1),
 (4, 'Zoe Black', 1),
 (5, 'Tim James', 1),
 (6, 'Bella Tucker', 2),
 (7, 'Ryan Metcalfe', 2),
 (8, 'Max Mills', 2),
 (9, 'Benjamin Glover', 2),
 (10, 'Carolyn Henderson', 3),
 (11, 'Nicola Kelly', 3),
 (12, 'Alexandra Climo', 3),
 (13, 'Dominic King', 3),
 (14, 'Leonard Gray', 4),
 (15, 'Eric Rampling', 4),
 (16, 'Piers Paige', 7),
 (17, 'Ryan Henderson', 7),
 (18, 'Frank Tucker', 8),
 (19, 'Nathan Ferguson', 8),
 (20, 'Kevin Rampling', 8);
commit;

select*From employees;
 employee_id |     full_name     | manager_id 
-------------+-------------------+------------
           1 | Michael North     |       NULL
           2 | Megan Berry       |          1
           3 | Sarah Berry       |          1
           4 | Zoe Black         |          1
           5 | Tim James         |          1
           6 | Bella Tucker      |          2
           7 | Ryan Metcalfe     |          2
           8 | Max Mills         |          2
           9 | Benjamin Glover   |          2
          10 | Carolyn Henderson |          3
          11 | Nicola Kelly      |          3
          12 | Alexandra Climo   |          3
          13 | Dominic King      |          3
          14 | Leonard Gray      |          4
          15 | Eric Rampling     |          4
          16 | Piers Paige       |          7
          17 | Ryan Henderson    |          7
          18 | Frank Tucker      |          8
          19 | Nathan Ferguson   |          8
          20 | Kevin Rampling    |          8

WITH RECURSIVE subordinates AS (
 SELECT
 employee_id,
 manager_id,
 full_name
 FROM
 employees
 WHERE
 employee_id = 2
 UNION
 SELECT
 e.employee_id,
 e.manager_id,
 e.full_name
 FROM
 employees e
 INNER JOIN subordinates s ON s.employee_id = e.manager_id
) SELECT
 *
FROM
 subordinates;
 employee_id | manager_id |    full_name    
-------------+------------+-----------------
           2 |          1 | Megan Berry
           6 |          2 | Bella Tucker
           7 |          2 | Ryan Metcalfe
           8 |          2 | Max Mills
           9 |          2 | Benjamin Glover
          16 |          7 | Piers Paige
          17 |          7 | Ryan Henderson
          18 |          8 | Frank Tucker
          19 |          8 | Nathan Ferguson
          20 |          8 | Kevin Rampling
(10 rows)
/ TODO



/ Intermezzo

/ alter sequence cannot be rolled back	,

create table tmp2(i serial,s varchar);	 --- can be rollback 
delete from tmp2;							--- can be rollback 
insert into tmp2(s)values('foo');		--- can be rollback 
insert into tmp2(s)values('bar');
insert into tmp2(s)values('baz');
select*from tmp2;

/ Lees	, 
http://www.postgresqltutorial.com/postgresql-alter-table/

alter table tmp2 add comment varchar;		--- can be rollback 
alter sequence tmp2_i_seq restart with 1;
select*from tmp2;
 i  |  s  
----+-----
 25 | foo
 26 | bar
 27 | baz
(3 rows)
insert into tmp2(s)values('foo');       --- can be rollback
insert into tmp2(s)values('bar');
insert into tmp2(s)values('baz');
select*from tmp2;
 i  |  s  
----+-----
 25 | foo
 26 | bar
 27 | baz
  1 | foo
  2 | bar
  3 | baz
(6 rows)

foo=> commit;
COMMIT
foo=> alter sequence tmp2_i_seq restart with 1;
ALTER SEQUENCE
foo=> rollback ;
ROLLBACK
insert into tmp2(s)values('foo');       --- can be rollback
insert into tmp2(s)values('bar');
insert into tmp2(s)values('baz');
select*from tmp2;
 i  |  s  
----+-----
 25 | foo
 26 | bar
 27 | baz
  1 | foo
  2 | bar
  3 | baz
  4 | foo
  5 | bar
  6 | baz
(9 rows)

To avoid blocking of concurrent transactions that obtain numbers from the same sequence, ALTER SEQUENCE's effects on the sequence generation parameters are never rolled back; those changes take effect immediately and are not reversible. However, the OWNED BY, OWNER TO, RENAME TO, and SET SCHEMA clauses cause ordinary catalog updates that can be rolled back.

/ Einde Intermezzo

SELECT
 e.employee_id,
 e.manager_id,
 e.full_name
 FROM
 employees e
	where 



/ Einde WITH

/ UNION

/ Lees	, 
http://www.postgresqltutorial.com/postgresql-union/

/ union removes duplicates	, union all niet	,

/ 13	. 

select(
    select employee_id
    from employees
    limit 1
)
 employee_id
-------------
           1
/ er mag maar 1 value uitkomen  , logisch   ,

foo=> select 7;
 ?column?
----------
        7
(1 row)

foo=> select(select 7);
 ?column?
----------
        7
(1 row)

/ 13	. 

foo=> select*from employees;
 employee_id |     full_name     | manager_id 
-------------+-------------------+------------
           1 | Michael North     |       NULL
           2 | Megan Berry       |          1
           3 | Sarah Berry       |          1
           4 | Zoe Black         |          1
           5 | Tim James         |          1
           6 | Bella Tucker      |          2
           7 | Ryan Metcalfe     |          2
           8 | Max Mills         |          2
           9 | Benjamin Glover   |          2
          10 | Carolyn Henderson |          3
          11 | Nicola Kelly      |          3
          12 | Alexandra Climo   |          3
          13 | Dominic King      |          3
          14 | Leonard Gray      |          4
          15 | Eric Rampling     |          4
          16 | Piers Paige       |          7
          17 | Ryan Henderson    |          7
          18 | Frank Tucker      |          8
          19 | Nathan Ferguson   |          8
          20 | Kevin Rampling    |          8
(20 rows)


/ als je limit use	, dan moeten er () omheen	,
(select employee_id
from employees
limit 2)
union all
(select manager_id 
from employees
limit 3)
 employee_id 
-------------
           1
           2
        NULL
           1
           1
(5 rows)

(select employee_id
from employees
limit 2)
union
(select manager_id 
from employees
limit 3)
 employee_id 
-------------
        NULL
           1
           2
(3 rows)

select employee_id
from employees
union
select manager_id
from employees
;
 employee_id 
-------------
        NULL
          17
          15
           6
          20
          11
          12
           5
           1
           9
          10
           8
           7
          18
           2
          13
          19
          16
           4
           3
          14
(21 rows)


select employee_id
from employees
union all
select manager_id
from employees
;
 employee_id 
-------------
           1
           2
           3
           4
           5
           6
           7
           8
           9
          10
          11
          12
          13
          14
          15
          16
          17
          18
          19
          20
        NULL
           1
           1
           1
           1
           2
           2
           2
           2
           3
           3
           3
           3
           4
           4
           7
           7
           8
           8
           8
(40 rows)
/ Je kunt deze query order by employee_id	, want zo heet de column van het antwoord	, 


/ 13	. 

drop table part1;
drop table part2;
create table if not exists part1(s varchar,t varchar);
create table if not exists part2(s varchar,t varchar);
insert into part1 values('foo11','bar11 ');
insert into part1 values('foo12','bar12');
insert into part2 values('foo21','bar21');
insert into part2 values('foo22','bar22');
select*from part1;
select*from part2;



foo=> select s from part1
foo-> union
foo-> select s from part2;
   s   
-------
 foo11
 foo12
 foo21
 foo22
(4 rows)

foo=> select s from part1
union
select t from part1;
   s    
--------
 foo11
 foo12
 bar12
 bar11 
(4 rows)


drop table part1;
drop table part2;
create table if not exists part1(i int,j int);
create table if not exists part2(i int,j int);
insert into part1 values(13,7);
insert into part1 values(6,14);
insert into part2 values(8,10);
insert into part2 values(2,15);
select*from part1;
select*from part2;
 i  | j  
----+----
 13 |  7
  6 | 14
(2 rows)

 i | j  
---+----
 8 | 10
 2 | 15
(2 rows)

select i from part1
union
select i from part2
;
 i  
----
  6
  8
  2
 13
(4 rows)


select i from part1
union
select j from part1
;
 i  
----
  7
 14
  6
 13
(4 rows)

select i from part1
union
select i from part2
order by i
 i  
----
  2
  6
  8
 13
(4 rows)


select i from part1
union
select j from part1
order by i
;
 i  
----
  6
  7
 13
 14
(4 rows)




/ Einde UNION

/ FUNCTIONS 

/ lees	,
https://www.postgresql.org/docs/9.3/static/functions.html
System information functions
System administration functions	/ pg_database_size, pg_size_pretty	, 

bakker20160207_t=# \dfS *size*
                                   List of functions
   Schema   |          Name          | Result data type | Argument data types |  Type  
------------+------------------------+------------------+---------------------+--------
 pg_catalog | pg_column_size         | integer          | "any"               | normal
 pg_catalog | pg_database_size       | bigint           | name                | normal
 pg_catalog | pg_database_size       | bigint           | oid                 | normal
 pg_catalog | pg_indexes_size        | bigint           | regclass            | normal
 pg_catalog | pg_relation_size       | bigint           | regclass            | normal
 pg_catalog | pg_relation_size       | bigint           | regclass, text      | normal
 pg_catalog | pg_size_pretty         | text             | bigint              | normal
 pg_catalog | pg_size_pretty         | text             | numeric             | normal
 pg_catalog | pg_table_size          | bigint           | regclass            | normal
 pg_catalog | pg_tablespace_size     | bigint           | name                | normal
 pg_catalog | pg_tablespace_size     | bigint           | oid                 | normal
 pg_catalog | pg_total_relation_size | bigint           | regclass            | normal
(12 rows)

bakker20160207_t=# \sf pg_size_pretty(numeric)
CREATE OR REPLACE FUNCTION pg_catalog.pg_size_pretty(numeric)
 RETURNS text
 LANGUAGE internal
 STRICT
AS $function$pg_size_pretty_numeric$function$
/ TODO

/ Einde FUNCTIONS 

/ DATE FUNCTIONS

/ 7	. 

mposcs2=# select system_entry_date from shipment_order where shipment_order_id='SH000002440';
    system_entry_date    
-------------------------
 2016-09-19 09:23:06.226
(1 row)

mposcs2=# select system_entry_date - interval '1 day' from shipment_order where shipment_order_id='SH000002440';
        ?column?         
-------------------------
 2016-09-18 09:23:06.226
(1 row)

mposcs2=# select now()-interval'1 day';
           ?column?            
-------------------------------
 2017-03-27 07:18:22.136847-04
(1 row)

/ 7	 

foo=> create table if not exists dts2(ts timestamp);
CREATE TABLE
foo=> \d dts2
               Table "public.dts2"
 Column |            Type             | Modifiers 
--------+-----------------------------+-----------
 ts     | timestamp without time zone | 

foo=> insert into dts2 values(now()-interval'1 day');
INSERT 0 1
foo=> commit;
COMMIT
foo=> select*from dts2;
            ts             
---------------------------
 2017-03-27 07:24:33.02031
(1 row)

/ 7	. 


/ Einde DATE FUNCTIONS

/ FUNCTIONS CREATE

/ 7	. 

/ we hadden al	, 

foo=> \sf int2
ERROR:  more than one function named "int2"

foo=> \sf int2(boolean)
CREATE OR REPLACE FUNCTION public.int2(boolean)
 RETURNS smallint
 LANGUAGE plpgsql
AS $function$
begin
if $1 then return 1; else return 0; end if;
end;
$function$

/ invoke	, 
j
foo=> select int2('t');
ERROR:  invalid input syntax for integer: "t"
LINE 1: select int2('t');

foo=> select public.int2('t');
 int2 
------
    1
(1 row)

/ we moeten explicit de schema opgeven	? 
/ TODO

/ 13	

/ we doen 

create or replace function mycast(boolean)returns smallint as $$
begin
if $1 then return 1;else return 0;end if;
end;
$$
language plpgsql;
commit

/ we hoeven geen schema te geven	, 

foo=> select mycast('true');
 mycast 
--------
      1
(1 row)

foo=> select mycast(TRUE) is of (smallint);
 ?column? 
----------
 t
(1 row)


foo=> rollback ;
ROLLBACK
foo=> select public. int2('true');
 int2 
------
    1
(1 row)

create or replace function mycast(smallint)returns boolean as $$
begin
if $1 > 7 then return TRUE ;else return FALSE;end if;
end;
$$
language plpgsql;
commit;

foo=> select mycast(13);
ERROR:  function mycast(integer) does not exist
foo=> select mycast(cast(13 as smallint));
 mycast 
--------
 t
(1 row)
/ TODO

/ Inderdaad	,

/ Lees	, 
http://www.postgresql-archive.org/how-do-i-query-the-type-of-an-object-td2472717.html

foo=> select 7 is of (integer)
foo-> ;
 ?column? 
----------
 t
(1 row)

foo=> select 7 is of (smallint)
;
 ?column? 
----------
 f
(1 row)

foo=> select pg_typeof(7);
 pg_typeof 
-----------
 integer
(1 row)

foo=> select pg_typeof(0);
 pg_typeof 
-----------
 integer
(1 row)

/ Lees	, 
https://www.postgresql.org/docs/9.3/static/plpgsql-control-structures.html


drop function if exists mycast(integer);
create or replace function mycast(integer)returns boolean 
as $$ begin
if $1 > 7 then return TRUE;		--;
else return FALSE;				--;
end if;							--;
end	$$ language plpgsql;
commit;

foo=> select mycast(13);
 mycast 
--------
 t
(1 row)

/ 13	. 

foo=> \sf int2(boolean)
CREATE OR REPLACE FUNCTION public.int2(boolean)
 RETURNS smallint
 LANGUAGE plpgsql
AS $function$
begin
if $1 then return 1; else return 0; end if;
end;
$function$

foo=> select int2(TRUE);
 int2 
------
    1
(1 row)

foo=> select int2('t');
ERROR:  invalid input syntax for integer: "t"

foo=> rollback ;
foo=> select public.int2('t');
 int2 
------
    1
(1 row)

foo=> select mycast('t');
ERROR:  function mycast(unknown) is not unique
LINE 1: select mycast('t');
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
/ TODO

/ 13	. 

/////////////////////////////////////////////
/ Kan fct niet goed kiezen	, als we  alternative rm dan OK	, 

drop function if exists mynewfct(boolean);
create or replace function mynewfct(boolean)returns integer			-- or public.mynewfct
as $$ begin
if $1 then return 7; 
else return 13; 
end if;		
end	$$ language plpgsql;
commit;

foo=> select mynewfct('false');
 mynewfct 
----------
       13
(1 row)

drop function if exists mynewfct(integer);
create or replace function mynewfct(integer)returns boolean 
as $$ begin
if $1 >7 then return TRUE; 
else return FALSE; 
end if;		
end	$$ language plpgsql;
commit;

foo=>  select mynewfct('false');
ERROR:  function mynewfct(unknown) is not unique
LINE 1: select mynewfct('false');
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.

foo=> drop function if exists mynewfct(integer);
DROP FUNCTION
foo=> select mynewfct('true');
 mynewfct 
----------
        7
(1 row)
/ TODO cast van 'false' naar integer?
/ WH NIET	, want	, 
foo=> select cast('true' as integer);
ERROR:  invalid input syntax for integer: "true"

/ 1313	. 

foo=> drop function if exists mynewfct(boolean);
foo=> \df mynewfct
 public | mynewfct | boolean          | integer             | normal

foo=> select mynewfct('true');
ERROR:  invalid input syntax for integer: "true"
LINE 1: select mynewfct('true');
/ Klopt	, postgres kan 'true' NIET cast naar integer	, 

/ 1313	. 

foo=> select cast('true' as integer);
ERROR:  invalid input syntax for integer: "true"
LINE 1: select cast('true' as integer);
                    ^
foo=> select cast('true' as boolean);
 bool 
------
 t
(1 row)

/ 13	.

foo=> drop function if exists mynewfct(integer);
foo=> \df mynewfct
                          List of functions
 Schema |   Name   | Result data type | Argument data types |  Type  
--------+----------+------------------+---------------------+--------
 public | mynewfct | integer          | boolean             | normal

foo=> select public.mynewfct('true');
 mynewfct 
----------
        7
(1 row)

/ als we nu mynewfct(boolean ) maken	, dan kan postgres niet kiezen	, 
ERROR:  function mynewfct(unknown) is not unique
/ Dit is een andere fout als we alleen mynewfct(integer) zouden hebben : 
ERROR:  invalid input syntax for integer: "true"

/ 13	. 

/ we maken pg_catalog.mynewfct	 , maar dat maakt niet uit	,

[eric@localhost bin]$ sudo su - postgres -c psql / Superuser	, 
# \c foo															-- pg_catalog gaat per db	, dus connect eerst met foo	, 
drop function if exists pg_catalog.mynewfct(integer);							
create or replace function pg_catalog.mynewfct(integer)returns boolean 		
as $$ begin
if $1 >7 then return TRUE; 
else return FALSE; 
end if;		
end	$$ language plpgsql;
commit;
# \q

foo=> \df mynewfct
                            List of functions
   Schema   |   Name   | Result data type | Argument data types |  Type  
------------+----------+------------------+---------------------+--------
 pg_catalog | mynewfct | boolean          | integer             | normal
 public     | mynewfct | integer          | boolean             | normal

foo=> select mynewfct('true');
ERROR:  function mynewfct(unknown) is not unique
foo=> select public.mynewfct('true');
 mynewfct 
----------
        7
(1 row)

/ 13	. 

foo=>  select int2('true');
ERROR:  invalid input syntax for integer: "true"

foo=# \df mynewfct
                            List of functions
   Schema   |   Name   | Result data type | Argument data types |  Type  
------------+----------+------------------+---------------------+--------
 pg_catalog | mynewfct | boolean          | integer             | normal
 public     | mynewfct | integer          | boolean             | normal
(2 rows)


/ postgres (Superuser) moet ook explicit create function pg_catalog.mynewfct(integer)	, anders als create  function mynewfct(integer), dan in public schema	,

/ MORGENOCHTEND


////////////////////////////////////////////


/ 13	. 

=> \df+ int2
                                                                                     List of functions
   Schema   | Name | Result data type | Argument data types |  Type  | Security | Volatility |  Owner   | Language |        
         Source code                 |       Description       
------------+------+------------------+---------------------+--------+----------+------------+----------+----------+--------
-------------------------------------+-------------------------
 pg_catalog | int2 | smallint         | bigint              | normal | invoker  | immutable  | postgres | internal | int82  
                                     | convert int8 to int2
 pg_catalog | int2 | smallint         | double precision    | normal | invoker  | immutable  | postgres | internal | dtoi2  
                                     | convert float8 to int2
 pg_catalog | int2 | smallint         | integer             | normal | invoker  | immutable  | postgres | internal | i4toi2 
                                     | convert int4 to int2
 pg_catalog | int2 | smallint         | numeric             | normal | invoker  | immutable  | postgres | internal | numeric
_int2                                | convert numeric to int2
 pg_catalog | int2 | smallint         | real                | normal | invoker  | immutable  | postgres | internal | ftoi2  
                                     | convert float4 to int2
 public     | int2 | smallint         | boolean             | normal | invoker  | volatile   | foo      | plpgsql  |        
                                    +| 
            |      |                  |                     |        |          |            |          |          | begin  
                                    +| 
            |      |                  |                     |        |          |            |          |          | if $1 t
hen return 1; else return 0; end if;+| 
            |      |                  |                     |        |          |            |          |          | end;   
                                    +| 
            |      |                  |                     |        |          |            |          |          |        
                                     | 
(6 rows)

foo=>  select int2(cast(7 as bigint));
 int2 
------
    7
(1 row)

foo=>  select int2(7.13);
 int2 
------
    7
(1 row)

foo=> select pg_typeof(7.13);
 pg_typeof 
-----------
 numeric
(1 row)

/ 13	. 

drop function if exists mynewfct(varchar);
create or replace function mynewfct(varchar)returns boolean as 
$$ begin
if $1 = 'foo'  then return TRUE; 
else return FALSE; 
end if;		
end	$$ language plpgsql;
commit;

/ 7	. 

/ we gaan int2 nadoen	, 

drop function if exists myint2(bigint);
create or replace function myint2(bigint) returns smallint as 
$$ begin
return $1;
end	$$ language plpgsql;
commit;

foo=> select myint2(7);
 myint2 
--------
      7
(1 row)
/ Dit kan dus	, 


drop function if exists myint2(integer);
create or replace function myint2(integer) returns smallint as 
$$ begin
return $1;
end	$$ language plpgsql;
commit;

/ 7	. 

drop function if exists mytext(bigint);
create or replace function mytext(bigint) returns text as 
$$ begin
return 'from bigint'; 
end	$$ language plpgsql;

foo=> select mytext(9223372036854775807);
   mytext    
-------------
 from bigint
(1 row)

foo=> select mytext(9);
   mytext    
-------------
 from bigint
(1 row)

drop function if exists mytext(integer);
create or replace function mytext(integer) returns text as 
$$ begin
return 'from integer'; 
end	$$ language plpgsql;

foo=> select mytext(9223372036854775807);
   mytext    
-------------
 from bigint
(1 row)

foo=> select mytext(2147483647);
    mytext    
--------------
 from integer
(1 row)

drop function if exists mytext(boolean);
create or replace function mytext(boolean) returns text as 
$$ begin
return 'from boolean'; 
end	$$ language plpgsql;

foo=> select mytext('true');
ERROR:  function mytext(unknown) is not unique
LINE 1: select mytext('true');
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.

drop function if exists mytext(double precision);
create or replace function mytext(double precision) returns text as 
$$ begin
return 'from double precision'; 
end	$$ language plpgsql;

drop function if exists mytext(numeric);
create or replace function mytext(numeric) returns text as 
$$ begin
return 'from numeric'; 
end	$$ language plpgsql;

drop function if exists mytext(real);
create or replace function mytext(real) returns text as 
$$ begin
return 'from real'; 
end	$$ language plpgsql;

/ 7	 

drop function if exists myint2(bigint);
drop function if exists myint2(double precision);
drop function if exists myint2(integer);
drop function if exists myint2(numeric);
drop function if exists myint2(real);

create or replace function pg_catalog.myint2(bigint) returns smallint as 
$$ begin
return 7; 
end	$$ language plpgsql;

create or replace function pg_catalog.myint2(integer) returns smallint as 
$$ begin
return 7; 
end	$$ language plpgsql;

create or replace function pg_catalog.myint2(double precision) returns smallint as 
$$ begin
return 7; 
end	$$ language plpgsql;

create or replace function pg_catalog.myint2(numeric) returns smallint as 
$$ begin
return 7; 
end	$$ language plpgsql;

create or replace function pg_catalog.myint2(real) returns smallint as 
$$ begin
return 7; 
end	$$ language plpgsql;

create or replace function myint2(boolean) returns smallint as 
$$ begin
return 7; 
end	$$ language plpgsql;

foo=> \df myint2
                           List of functions
   Schema   |  Name  | Result data type | Argument data types |  Type  
------------+--------+------------------+---------------------+--------
 pg_catalog | myint2 | smallint         | bigint              | normal
 pg_catalog | myint2 | smallint         | double precision    | normal
 pg_catalog | myint2 | smallint         | integer             | normal
 pg_catalog | myint2 | smallint         | numeric             | normal
 pg_catalog | myint2 | smallint         | real                | normal
 public     | myint2 | smallint         | boolean             | normal
(6 rows)

foo=> select myint2('true');
ERROR:  function myint2(unknown) is not unique
LINE 1: select myint2('true');
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.

/ Dit is een andere ERROR dan	, 

foo=> \df int2
                          List of functions
   Schema   | Name | Result data type | Argument data types |  Type  
------------+------+------------------+---------------------+--------
 pg_catalog | int2 | smallint         | bigint              | normal
 pg_catalog | int2 | smallint         | double precision    | normal
 pg_catalog | int2 | smallint         | integer             | normal
 pg_catalog | int2 | smallint         | numeric             | normal
 pg_catalog | int2 | smallint         | real                | normal
 public     | int2 | smallint         | boolean             | normal
(6 rows)

foo=> select int2(7);
 int2 
------
    7
(1 row)

foo=> select int2('true');
ERROR:  invalid input syntax for integer: "true"
LINE 1: select int2('true');

/ Net als	, 
foo=> select cast('true' as integer);
ERROR:  invalid input syntax for integer: "true"

/ MORGENOCHTEND

/ Einde FUNCTIONS CREATE

/ SOURCE CODE

[eric@localhost source]$ pwd
/home/eric/Devel/Postgres/source
[eric@localhost source]$ git clone git://git.postgresql.org/git/postgresql.git

foo=> \dfS+ int2
  Schema   | Name | Result data type | Argument data types |  Type  | Security | Volatility |  Owner   | Language |                 Source code                 
|       Description       
------------+------+------------------+---------------------+--------+----------+------------+----------+----------+---------------------------------------------
+-------------------------
 pg_catalog | int2 | smallint         | bigint              | normal | invoker  | immutable  | postgres | internal | int82                                       
| convert int8 to int2
 pg_catalog | int2 | smallint         | double precision    | normal | invoker  | immutable  | postgres | internal | dtoi2                                       
| convert float8 to int2
 pg_catalog | int2 | smallint         | integer             | normal | invoker  | immutable  | postgres | internal | i4toi2                                      
| convert int4 to int2
 pg_catalog | int2 | smallint         | numeric             | normal | invoker  | immutable  | postgres | internal | numeric_int2                                
| convert numeric to int2
 pg_catalog | int2 | smallint         | real                | normal | invoker  | immutable  | postgres | internal | ftoi2                                       
| convert float4 to int2
 public     | int2 | smallint         | boolean             | normal | invoker  | volatile   | foo      | plpgsql  |                                            +
| 
            |      |                  |                     |        |          |            |          |          | begin                                      +
| 
            |      |                  |                     |        |          |            |          |          | if $1 then return 1; else return 0; end if;+
| 
            |      |                  |                     |        |          |            |          |          | end;                                       +
| 
            |      |                  |                     |        |          |            |          |          |                                             
| 
(6 rows)


[eric@localhost postgresql]$ git checkout  REL9_3_5
[eric@localhost postgresql]$ find -name "*.c" | xargs grep 'invalid input syntax for integer'
./src/backend/utils/adt/numutils.c:				 errmsg("invalid input syntax for integer: \"%s\"",
./src/backend/utils/adt/numutils.c:				 errmsg("invalid input syntax for integer: \"%s\"",
./src/backend/utils/adt/numutils.c:				 errmsg("invalid input syntax for integer: \"%s\"",
./src/backend/utils/adt/int8.c:					 errmsg("invalid input syntax for integer: \"%s\"",
./src/backend/utils/adt/int8.c:					 errmsg("invalid input syntax for integer: \"%s\"",



/ Einde SOURCE CODE

/ WEB PAGES

https://lauris.github.io/database/alter-column-differences-between-mysql-postgresql
https://www.postgresql.org/docs/9.3/static/multibyte.html			/ character sets
https://www.postgresql.org/docs/9.1/static/datatype-numeric.html
https://www.postgresql.org/docs/9.3/static/sql-createfunction.html							<- lees	, 
https://www.postgresql.org/docs/9.3/static/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS		<- lees	,
https://www.postgresql.org/docs/9.1/static/sql-dropcast.html
https://www.postgresql.org/docs/9.1/static/sql-altertable.html
https://www.postgresql.org/docs/9.1/static/sql-update.html

/ Lees	, 
http://stackoverflow.com/questions/4760759/postgresql-create-cast-character-varying-to-integer
https://www.postgresql.org/docs/9.3/static/ddl-schemas.html




/ Einde WEB PAGES

/ SQL

/ 7	. 

foo=> create table literals(s text );
CREATE TABLE
foo=> insert into literals values($$foo'bar$$);
INSERT 0 1
foo=> select*from literals;
    s    
---------
 foo'bar
(1 row)

/ 7	. 

/ Lees	, 
https://www.postgresql.org/docs/9.3/static/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS

CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- No cast needed since only one getf1() exists
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Now we need a cast to indicate which function to call:
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)

/ TODO

/ 7	.

/ gebruik in alter table altijd: add

/ we hoeven in in create table in de column alleen te write: references , 
/ in alter table moeten we ook write: foreign key	, 

/ 13	. 

/ PRIMARY KEY

/ primary key

foo=> create table par2(s text primary key);
CREATE TABLE
foo=> \d par2
    Table "public.par2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | not null
Indexes:
    "par2_pkey" PRIMARY KEY, btree (s)

/ of	,

foo=> rollback ;
ROLLBACK
foo=> create table par2(s text);
CREATE TABLE
foo=> alter table par2 add primary key(s);		-- in alter table altijd : add
ALTER TABLE
foo=> \d par2
    Table "public.par2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | not null
Indexes:
    "par2_pkey" PRIMARY KEY, btree (s)



/ 13	. 

/ een foreign key moet ref naar een unique column, 	not null hoeft niet	, en de foreign key zelf hoeft ook niet not null	, 

/ 1313	. 

foo=> create table if not exists par2(s text not null);
foo=> create table if not exists chld2(s text references par2(s));
ERROR:  there is no unique constraint matching given keys for referenced table "par2"

/ 1313	. 

foo=> create table if not exists par2(s text not null unique);
CREATE TABLE
foo=> create table if not exists chld2(s text references par2);		-- par2	, GEEN par2(s)
ERROR:  there is no primary key for referenced table "par2"

/ 1313	. 

foo=> create table if not exists par2(s text primary key,t text not null unique);
foo=> create table if not exists chld2(s text references par2,t text references par2(t));		-- of s text references par2(s) mag ook	, bij t moet het	, 
foo=> \d chld2
   Table "public.chld2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | 
 t      | text | 
Foreign-key constraints:
    "chld2_s_fkey" FOREIGN KEY (s) REFERENCES par2(s)
    "chld2_t_fkey" FOREIGN KEY (t) REFERENCES par2(t)

/ 1313	. 

foo=> create table if not exists par2(s text  unique);
foo=> create table if not exists chld2(s text references par2(s));
foo=> insert into par2 values('foo'),(null),(null);
foo=> select*from par2;
  s   
------
 foo
 NULL
 NULL
(3 rows)

foo=> insert into chld2 values('foo'),(null),(null);
foo=> insert into chld2 values('foo'),(null),(null);
foo=> select *from par2;
foo=> select *from chld2;
  s   
------
 foo
 NULL
 NULL
 foo
 NULL
 NULL
(6 rows)

foo=> insert into chld2 values('bar');
ERROR:  insert or update on table "chld2" violates foreign key constraint "chld2_s_fkey"


/ 1313	. 


foo=> create table if not exists par2(s text not null unique);
foo=> create table if not exists chld2(s text references par2(s));
/ OK
foo=> alter table par2 add unique(s);                  
ALTER TABLE
foo=> \d par2
    Table "public.par2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | not null
Indexes:
    "par2_s_key" UNIQUE CONSTRAINT, btree (s)

/ of	, 
foo=> create table if not exists par2(s text not null);
foo=> alter table par2 add constraint constr2 unique(s);
foo=> \d par2
    Table "public.par2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | not null
Indexes:
    "constr2" UNIQUE CONSTRAINT, btree (s)

/ of	, 
foo=> create table if not exists par2(s text not null unique);
CREATE TABLE
foo=> \d par2
    Table "public.par2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | not null
Indexes:
    "par2_s_key" UNIQUE CONSTRAINT, btree (s)

/ 13	. 

/ create foreign key	, kan null zijn	, (tenzij we een constraint op de fk set)	, 
/ we hoeven niet foreign key te write	, 

/ c

foo=> create table if not exists par2(s text not null unique);
foo=> create table chld2(s text references par2(s));
foo=> \d chld2
   Table "public.chld2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | 
Foreign-key constraints:
    "chld2_s_fkey" FOREIGN KEY (s) REFERENCES par2(s)

foo=> insert into chld2 values(null);
INSERT 0 1

/ 13	. 

/ add primary met alter table	,

foo=> create table if not exists par2(s text);
CREATE TABLE
foo=> alter table par2 add primary key(s);
ALTER TABLE
foo=> \d par2
    Table "public.par2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | not null
Indexes:
    "par2_pkey" PRIMARY KEY, btree (s)

foo=> create table if not exists par2(s text);
CREATE TABLE
foo=> alter table par2 add unique(s);						<- we moeten wel : add	,
ALTER TABLE
foo=> \d par2;
    Table "public.par2"
 Column | Type | Modifiers 
--------+------+-----------
 s      | text | 
Indexes:
    "par2_s_key" UNIQUE CONSTRAINT, btree (s)

/ Wat is verschil tussen PRIMARY KEY en  UNIQUE CONSTRAINT?
/ TODO


foo=> create table if not exists par2(s text unique);
foo=> alter table chld2 add foreign key(s) references par2(s);		-- foreign key is ERR	, foreign key(s) is OK	, 





/ Einde SQL

/ PSQL

/ Zonder arg is er een verschil tussen \df en \dfS	, 
foo=> \dfS
 pg_catalog | RI_FKey_cascade_del                          | trigger                           | ... 

/ Maar met arg zijn ze hetzelfde	,                                                                                                    

foo=> \df int2
foo=> \dfS int2
                          List of functions
   Schema   | Name | Result data type | Argument data types |  Type  
------------+------+------------------+---------------------+--------
 pg_catalog | int2 | smallint         | bigint              | normal
 pg_catalog | int2 | smallint         | double precision    | normal
 pg_catalog | int2 | smallint         | integer             | normal
 pg_catalog | int2 | smallint         | numeric             | normal
 pg_catalog | int2 | smallint         | real                | normal
 public     | int2 | smallint         | boolean             | normal
(6 rows)

=> \dTS
                                              List of data types
   Schema   |            Name             |                            Description                            
------------+-----------------------------+-------------------------------------------------------------------
 pg_catalog | abstime                     | absolute, limited-range date and time (Unix system time)
...
 pg_catalog | character varying           | varchar(length), non-blank-padded string, variable storage length



=> create table charsets(first varchar(32) character set utf8);
ERROR:  type "pg_catalog.varchar_utf8" does not exist
/ Klopt, die hebben we niet gezien in \dTS	, 

/ we kunnen ook	, 
 pg_catalog.pg_type

/ Einde PSQL

/ COLUMNS

/ Lees	, 
https://www.postgresql.org/message-id/4DC534E1.40801@lelarge.info

foo=> \dOS+
 pg_catalog | nl_AW                 | nl_AW                 | nl_AW                 | 
 pg_catalog | nl_AW.utf8            | nl_AW.utf8            | nl_AW.utf8            | 
 pg_catalog | nl_BE                 | nl_BE.utf8            | nl_BE.utf8            | 
 pg_catalog | nl_BE.utf8            | nl_BE.utf8            | nl_BE.utf8            | 
 pg_catalog | nl_NL                 | nl_NL.utf8            | nl_NL.utf8            | 
 pg_catalog | nl_NL.utf8            | nl_NL.utf8            | nl_NL.utf8            | 

foo=> create table colls(s text collate "en_US");
CREATE TABLE
/ OK
foo=> create table colls(s text collate "nl_NL");
/ OK

/ Lees	, 
http://dba.stackexchange.com/questions/29943/how-to-determine-the-collation-of-a-table-in-postgresql

foo=> select table_schema, 
foo->        table_name, 
foo->        column_name,
foo->        collation_name
foo-> from information_schema.columns
foo-> where collation_name is not null
foo-> order by table_schema,
foo->          table_name,
foo->          ordinal_position;
 table_schema | table_name | column_name | collation_name 
--------------+------------+-------------+----------------
 public       | colls      | s           | nl_NL
(1 row)

foo=> create table colls(s text collate "foo_BAR");
ERROR:  collation "foo_BAR" for encoding "UTF8" does not exist

foo=> select datname, 
       datcollate
from pg_database;
      datname      | datcollate  
-------------------+-------------
 template1         | en_US.UTF-8
 template0         | en_US.UTF-8
 postgres          | en_US.UTF-8
 mpo               | en_US.UTF-8
...

/ Lees	, 
update pg_database set encoding = pg_char_to_encoding('UTF8') where datname = 'thedb'

foo=> select pg_char_to_encoding('UTF8') ;
 pg_char_to_encoding 
---------------------
                   6
(1 row)

/ 7	.
https://www.postgresql.org/docs/9.3/static/infoschema-character-sets.html

The view character_sets iden...

/ In information_schema	, 

foo=> \dtS information_schema.*
                        List of relations
       Schema       |          Name           | Type  |  Owner   
--------------------+-------------------------+-------+----------
 information_schema | sql_features            | table | postgres
 information_schema | sql_implementation_info | table | postgres
 information_schema | sql_languages           | table | postgres
 information_schema | sql_packages            | table | postgres
 information_schema | sql_parts               | table | postgres
 information_schema | sql_sizing              | table | postgres
 information_schema | sql_sizing_profiles     | table | postgres
(7 rows)

foo=> \dvS+ information_schema.*
                                          List of relations
       Schema       |                 Name                  | Type |  Owner   |  Size   | Description 
--------------------+---------------------------------------+------+----------+---------+-------------
 information_schema | _pg_foreign_data_wrappers             | view | postgres | 0 bytes | 
 information_schema | _pg_foreign_servers                   | view | postgres | 0 bytes | 
 information_schema | _pg_foreign_table_columns             | view | postgres | 0 bytes | 
 information_schema | _pg_foreign_tables                    | view | postgres | 0 bytes | 
 information_schema | _pg_user_mappings                     | view | postgres | 0 bytes | 
 information_schema | administrable_role_authorizations     | view | postgres | 0 bytes | 
 information_schema | applicable_roles                      | view | postgres | 0 bytes | 
 information_schema | attributes                            | view | postgres | 0 bytes | 
 information_schema | character_sets                        | view | postgres | 0 bytes | 
 information_schema | check_constraint_routine_usage        | view | postgres | 0 bytes | 
 information_schema | check_constraints                     | view | postgres | 0 bytes | 
 information_schema | collation_character_set_applicability | view | postgres | 0 bytes | 
 information_schema | collations                            | view | postgres | 0 bytes | 
 information_schema | column_domain_usage                   | view | postgres | 0 bytes | 
 information_schema | column_options                        | view | postgres | 0 bytes | 
 information_schema | column_privileges                     | view | postgres | 0 bytes | 
 information_schema | column_udt_usage                      | view | postgres | 0 bytes | 
 information_schema | columns                               | view | postgres | 0 bytes | 
 information_schema | constraint_column_usage               | view | postgres | 0 bytes | 
 information_schema | constraint_table_usage                | view | postgres | 0 bytes | 
 information_schema | data_type_privileges                  | view | postgres | 0 bytes | 
 information_schema | domain_constraints                    | view | postgres | 0 bytes | 
 information_schema | domain_udt_usage                      | view | postgres | 0 bytes | 
 information_schema | domains                               | view | postgres | 0 bytes | 
 information_schema | element_types                         | view | postgres | 0 bytes | 
 information_schema | enabled_roles                         | view | postgres | 0 bytes | 
 information_schema | foreign_data_wrapper_options          | view | postgres | 0 bytes | 
 information_schema | foreign_data_wrappers                 | view | postgres | 0 bytes | 
 information_schema | foreign_server_options                | view | postgres | 0 bytes | 
 information_schema | foreign_servers                       | view | postgres | 0 bytes | 
 information_schema | foreign_table_options                 | view | postgres | 0 bytes | 
 information_schema | foreign_tables                        | view | postgres | 0 bytes | 
 information_schema | information_schema_catalog_name       | view | postgres | 0 bytes | 
 information_schema | key_column_usage                      | view | postgres | 0 bytes | 
 information_schema | parameters                            | view | postgres | 0 bytes | 
 information_schema | referential_constraints               | view | postgres | 0 bytes | 
 information_schema | role_column_grants                    | view | postgres | 0 bytes | 
 information_schema | role_routine_grants                   | view | postgres | 0 bytes | 
 information_schema | role_table_grants                     | view | postgres | 0 bytes | 
 information_schema | role_udt_grants                       | view | postgres | 0 bytes | 
 information_schema | role_usage_grants                     | view | postgres | 0 bytes | 
 information_schema | routine_privileges                    | view | postgres | 0 bytes | 
 information_schema | routines                              | view | postgres | 0 bytes | 
 information_schema | schemata                              | view | postgres | 0 bytes | 
 information_schema | sequences                             | view | postgres | 0 bytes | 
 information_schema | table_constraints                     | view | postgres | 0 bytes | 
 information_schema | table_privileges                      | view | postgres | 0 bytes | 
 information_schema | tables                                | view | postgres | 0 bytes | 
 information_schema | triggered_update_columns              | view | postgres | 0 bytes | 
 information_schema | triggers                              | view | postgres | 0 bytes | 
 information_schema | udt_privileges                        | view | postgres | 0 bytes | 
 information_schema | usage_privileges                      | view | postgres | 0 bytes | 
 information_schema | user_defined_types                    | view | postgres | 0 bytes | 
 information_schema | user_mapping_options                  | view | postgres | 0 bytes | 
 information_schema | user_mappings                         | view | postgres | 0 bytes | 
 information_schema | view_column_usage                     | view | postgres | 0 bytes | 
 information_schema | view_routine_usage                    | view | postgres | 0 bytes | 
 information_schema | view_table_usage                      | view | postgres | 0 bytes | 
 information_schema | views                                 | view | postgres | 0 bytes | 
(59 rows)

foo=> select*from information_schema.character_sets;
 character_set_catalog | character_set_schema | character_set_name | character_repertoire | form_of_use | default_collate_catalog | default_collate_schema | defa
ult_collate_name 
-----------------------+----------------------+--------------------+----------------------+-------------+-------------------------+------------------------+-----
-----------------
 NULL                  | NULL                 | UTF8               | UCS                  | UTF8        | foo                     | NULL                   | NULL
(1 row)

/ MORGENOCHTEND


/ TODO

/ Einde COLUMNS

/ CASTS

/ hoe kunnen we de def van een cast zien	?

[eric@localhost bin]$ PGPASSWORD=mpopostgres@mpo psql -E -U  mpopostgres mposcs2

/ 7	. 

mposcs2=# \sf compat.int2
CREATE OR REPLACE FUNCTION compat.int2(boolean)
 RETURNS smallint
 LANGUAGE plpgsql
AS $function$
        begin
                if $1 then return 1; else return 0; end if;
        end;
$function$

/ 7	. 

/ 13	. 

/ waarom zien we compat.int2 niet?

mposcs2=# \df int2
********* QUERY **********
SELECT n.nspname as "Schema",
  p.proname as "Name",
  pg_catalog.pg_get_function_result(p.oid) as "Result data type",
  pg_catalog.pg_get_function_arguments(p.oid) as "Argument data types",
 CASE
  WHEN p.proisagg THEN 'agg'
  WHEN p.proiswindow THEN 'window'
  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN 'trigger'
  ELSE 'normal'
 END as "Type"
FROM pg_catalog.pg_proc p
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE p.proname ~ '^(int2)$'
  AND pg_catalog.pg_function_is_visible(p.oid)									-- <-
ORDER BY 1, 2, 4;
**************************

                          List of functions
   Schema   | Name | Result data type | Argument data types |  Type  
------------+------+------------------+---------------------+--------
 pg_catalog | int2 | smallint         | bigint              | normal
 pg_catalog | int2 | smallint         | double precision    | normal
 pg_catalog | int2 | smallint         | integer             | normal
 pg_catalog | int2 | smallint         | numeric             | normal
 pg_catalog | int2 | smallint         | real                | normal
(5 rows)

/ TODO

/ we doen met de hand ( we laten de laatste AND weg)	, 
/ nu zien we compat.int2 WEL	,

SELECT n.nspname as "Schema",
  p.proname as "Name",
  pg_catalog.pg_get_function_result(p.oid) as "Result data type",
  pg_catalog.pg_get_function_arguments(p.oid) as "Argument data types",
 CASE
  WHEN p.proisagg THEN 'agg'
  WHEN p.proiswindow THEN 'window'
  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN 'trigger'
  ELSE 'normal'
 END as "Type"
FROM pg_catalog.pg_proc p
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE p.proname ~ '^(int2)$'
;

   Schema   | Name | Result data type | Argument data types |  Type  
------------+------+------------------+---------------------+--------
 pg_catalog | int2 | smallint         | double precision    | normal
 pg_catalog | int2 | smallint         | real                | normal
 pg_catalog | int2 | smallint         | integer             | normal
 pg_catalog | int2 | smallint         | bigint              | normal
 pg_catalog | int2 | smallint         | numeric             | normal
 compat     | int2 | smallint         | boolean             | normal
(6 rows)


/ 13	. 

mposcs2=# \df compat.*
********* QUERY **********
SELECT n.nspname as "Schema",
  p.proname as "Name",
  pg_catalog.pg_get_function_result(p.oid) as "Result data type",
  pg_catalog.pg_get_function_arguments(p.oid) as "Argument data types",
 CASE
  WHEN p.proisagg THEN 'agg'
  WHEN p.proiswindow THEN 'window'
  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN 'trigger'
  ELSE 'normal'
 END as "Type"
FROM pg_catalog.pg_proc p
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE n.nspname ~ '^(compat)$'
ORDER BY 1, 2, 4;
**************************

                        List of functions
 Schema | Name | Result data type | Argument data types |  Type  
--------+------+------------------+---------------------+--------
 compat | int2 | smallint         | boolean             | normal
(1 row)

/ 13	. 

mposcs2=# \dC
********* QUERY **********
SELECT pg_catalog.format_type(castsource, NULL) AS "Source type",
       pg_catalog.format_type(casttarget, NULL) AS "Target type",
       CASE WHEN castfunc = 0 THEN '(binary coercible)'
            ELSE p.proname
       END as "Function",
       CASE WHEN c.castcontext = 'e' THEN 'no'
            WHEN c.castcontext = 'a' THEN 'in assignment'
            ELSE 'yes'
       END as "Implicit?"FROM pg_catalog.pg_cast c LEFT JOIN pg_catalog.pg_proc p
     ON c.castfunc = p.oid
     LEFT JOIN pg_catalog.pg_type ts
     ON c.castsource = ts.oid
     LEFT JOIN pg_catalog.pg_namespace ns
     ON ns.oid = ts.typnamespace
     LEFT JOIN pg_catalog.pg_type tt
     ON c.casttarget = tt.oid
     LEFT JOIN pg_catalog.pg_namespace nt
     ON nt.oid = tt.typnamespace
WHERE ( (true  AND pg_catalog.pg_type_is_visible(ts.oid)
) OR (true  AND pg_catalog.pg_type_is_visible(tt.oid)
) )
ORDER BY 1, 2;
**************************

                                         List of casts
         Source type         |         Target type         |      Function      |   Implicit?   
-----------------------------+-----------------------------+--------------------+---------------
 abstime                     | date                        | date               | in assignment
 abstime                     | integer                     | (binary coercible) | no
...




/ Einde CASTS

/ SEARCH PATH

foo=> show search_path
;
  search_path   
----------------
 "$user",public
(1 row)

foo=> set search_path to public,pg_catalog;
SET

foo=> select*from pg_proc;
/ OK

/ Einde SEARCH PATH

/ PREPARE STATEMENTS

/ Lees	,
http://chirupgadmin.blogspot.nl/
http://chirupgadmin.blogspot.nl/2013/05/prepared-statements-on-postgresql.html

foo=> create table prep(s text,i integer, b boolean);
CREATE TABLE
foo=> insert into prep values('foo', 7, TRUE);
INSERT 0 1
foo=> insert into prep values('bar',13,'false');
INSERT 0 1
foo=> commit;

prepare myplan(text,integer,boolean)as insert into prep values($1,$2,$3);		/ we kunnen NIET rollback	,
execute myplan('baz',77,'t');
/ OK
foo=> deallocate myplan;		/ kunnen we NIET rollback	,

/ Einde PREPARE STATEMENTS

/ PERMISSIONS

/ 7	 

/ create role is niet transactional, 	kan niet rollback	, 

[eric@localhost 14]$ sudo su - postgres -c psql
postgres=# create role grp2 createdb createrole;

/ 7	.  

postgres=# create role usr2 password 'usr2';
CREATE ROLE
postgres=# \du
 usr2        | Cannot login                                   | {}

/ doe daarom daarna	, 

postgres=# alter role usr2 login;
ALTER ROLE
postgres=# \du
 usr2        |                                                | {}

postgres=# \q
[eric@localhost bin]$ PGPASSWORD=usr2 psql -U usr2 foo
/ OK

foo=> create table usr2_t(s varchar);
foo=> \dt
 public | usr2_t             | table | usr2
foo=> insert into usr2_t values('foo');
INSERT 0 1
foo=> commit;
COMMIT
foo=> drop table usr2_t;
DROP TABLE
foo=> commit;
COMMIT
foo=> create database usr2_db;
ERROR:  permission denied to create database

=> grant grp2 to usr2;
ERROR:  must have admin option on role "grp2"
[eric@localhost bin]$ sudo su - postgres -c psql
postgres=# grant grp2 to usr2;
GRANT ROLE
postgres=# \q
[eric@localhost bin]$ PGPASSWORD=usr2 psql -U usr2 foo
foo=> create database usr2_db;
ERROR:  permission denied to create database
foo=> select current_user;
 current_user 
--------------
 usr2

/ Intermezzo

/ set role can be rollback	, 

foo=> set role grp2;
SET
foo=> select current_user;
 current_user 
--------------
 grp2
(1 row)

foo=> rollback ;
ROLLBACK
foo=> select current_user;
 current_user 
--------------
 usr2
(1 row)

/ Einde Intermezzo

/ revoke is transactional	, 

foo=> revoke grp2 from usr2;
REVOKE ROLE
foo=> \du
 usr2        |                                                | {}

foo=> rollback ;
NOTICE:  there is no transaction in progress
ROLLBACK
foo=> \du
 usr2        |                                                | {grp2}

/ 7	 

eric@mposerv8:~$ PGPASSWORD=mqi8o0e6aeg56tpghje2bo0gehgthoi6 psql -U mposcs_dev -p 5433 -h localhost mposcs-dev

mposcs-dev=> \du
 santenm          | Password valid until infinity                  | {writer}

mposcs-dev=> revoke writer from santenm;
ERROR:  must have admin option on role "writer"
/ TODO with admin option

/ Lees docs ,
GRANT on Database Objects
If WITH GRANT OPTION is specified, the recipient of the privilege can in turn grant it to others. Without a grant option, the recipient cannot do that. Grant options cannot be granted to PUBLIC.

GRANT on Roles
If WITH ADMIN OPTION is specified, the member can in turn grant membership in the role to others, and revoke membership in the role as well. Without the admin option, ordinary users cannot do that. A role is not considered to hold WITH ADMIN OPTION on itself, but it may grant or revoke membership in itself from a database session where the session user matches the role. Database superusers can grant or revoke membership in any role to anyone. Roles having CREATEROLE privilege can grant or revoke membership in any role that is not a superuser.

/ We oef	, 

[eric@localhost bin]$ sudo su - postgres -c psql
postgres=# grant grp2 to usr2;
postgres=# \q
[eric@localhost bin]$ psql -U usr2 foo
Password for user usr2: usr2
foo=> revoke grp2 from usr2;
ERROR:  must have admin option on role "grp2"

[eric@localhost bin]$ sudo su - postgres -c psql
postgres=# revoke grp2 from usr2;
postgres=# grant grp2 to usr2 with admin option;
postgres=# \q
[eric@localhost bin]$ psql -U usr2 foo
Password for user usr2: 
foo=> revoke grp2 from usr2;
REVOKE ROLE
/ OK

/ Dus in db mposcs-dev op mposerv8 heeft role mposcs_dev NIET de admin option op de writer role	, dus kan mposcs_dev  niet de writer role revoke van santenm	, 




/ 7	. 

$ vi ~/.psqlrc

\set AUTOCOMMIT off
\pset null 'NULL'

/ Als we 
$ PGPASSWORD=foo psql -U foo
foo=> \set
AUTOCOMMIT = 'off'

/ Maar als	, 
[eric@localhost bin]$ sudo su - postgres -c psql
postgres=# \set
AUTOCOMMIT = 'on'

/ TODO

/ 7	. 

[eric@localhost scs]$ sudo su - postgres
-bash-4.2$ pwd
/var/lib/pgsql
-bash-4.2$ less data/pg_hba.conf 
# "local" is for Unix domain socket connections only
local   all            postgres                                 peer
local   all             eric                                    peer
local   all             all                                     md5     
# IPv4 local connections:
host    all             all             127.0.0.1/32           md5 

[eric@localhost bin]$ psql -U postgres geosco0706p
psql: FATAL:  Peer authentication failed for user "postgres"		/ vanwege peer	,
[eric@localhost bin]$ psql -U postgres -h localhost foo
Password for user postgres: 											/ als we -h geven, dan ipv4 local connection, geen unix domain socket connection	, 

[eric@localhost scs]$ sudo su - postgres
-bash-4.2$ psql foo 										/ OK
foo=# \q


/ Lees	, 
http://serverfault.com/questions/110154/whats-the-default-superuser-username-password-for-postgres-after-a-new-install

     sudo, sudoedit — execute a command as another user
       su - run a command with substitute user and group ID

/ 13	. 

[eric@localhost scs]$ sudo -u postgres psql
postgres=# 

[eric@localhost scs]$ sudo su - postgres psql
postgres=# 

[eric@localhost scs]$ sudo visudo
%wheel  ALL=(ALL)       ALL


/ TODO

/ Einde PERMISSIONS

/ TYPE CASTS

foo=> create table if not exists tc(s varchar(32));
CREATE TABLE
foo=> insert into tc values('5000');
INSERT 0 1
foo=> select *from tc where s<10000;
ERROR:  operator does not exist: character varying < integer
LINE 1: select *from tc where s<10000;
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.

foo=> select *from tc where cast(s as int)<10000;
/=
foo=> select *from tc where cast(s as integer)<10000;
/ of	,
foo=> select *from tc where cast(s as smallint)<10000;

  s   
------
 5000
(1 row)

/ 7	. 

/ voorbeeld	, 

foo=> select cast(0 as boolean);
 bool 
------
 f
(1 row)

/ en	, 

foo=> \d bools
     Table "public.bools"
 Column |  Type   | Modifiers 
--------+---------+-----------
 b      | boolean | 

foo=> insert into bools values(cast(0 as boolean));
INSERT 0 1
foo=> select*from bools;
 b 
---
...
 f
(3 rows)

/ 7	. 

/ voorbeeld

foo=> \d bools
     Table "public.bools"
 Column |  Type   | Modifiers 
--------+---------+-----------
 b      | boolean | 

foo=> insert into bools values('true');
INSERT 0 1
foo=> insert into bools values('t');
INSERT 0 1
foo=> insert into bools values(TRUE);
INSERT 0 1


/ we hadden eerder	, 
foo=> \sf int2(boolean)
CREATE OR REPLACE FUNCTION public.int2(boolean)
 RETURNS smallint
 LANGUAGE plpgsql
AS $function$
begin
if $1 then return 1; else return 0; end if;
end;
$function$

foo=> select public.int2(TRUE);
/ of	, 
foo=> select public.int2('true');
 int2 
------
    1
(1 row)

/ 13	. 

/////////////////////////////////////////////
/ IMPLICIT CAST IN ACTION 

/ we hebben 	, als foo	,

CREATE OR REPLACE FUNCTION int2(boolean)
RETURNS smallint AS
$BODY$
begin
if $1 then return 1; else return 0; end if;
end;
$BODY$
LANGUAGE plpgsql;

COMMIT

[eric@localhost bin]$ sudo su - postgres -c psql 
LINE 1: drop cast int2(boolean);

foo=> insert into smallints values(TRUE);
ERROR:  column "si" is of type smallint but expression is of type boolean
LINE 1: insert into smallints values(TRUE);
                                     ^
HINT:  You will need to rewrite or cast the expression.

foo=# CREATE CAST (boolean AS smallint)
foo-# WITH FUNCTION public.int2(boolean)                          -- let op public.
foo-# AS IMPLICIT;

foo=> insert into smallints values(TRUE);
INSERT 0 1

/ Maar we kunnen NIET	, 
foo=> insert into smallints values('t');

/ we kunnen WEL	, 
foo=> select public.int2('t');
 int2 
------
    1
(1 row)


/ Einde IMPLICIT CAST IN ACTION 

/ 13	. 





foo=> create table smallints (si smallint);
CREATE TABLE
foo=> commit;
COMMIT






/ 7	. 

/ we doen in foo	,

CREATE OR REPLACE FUNCTION int2(boolean)
RETURNS smallint AS
$BODY$
begin
if $1 then return 1; else return 0; end if;
end;
$BODY$
LANGUAGE plpgsql;

COMMIT

foo=> \df
                                          List of functions
 Schema |     Name     |     Result data type     |           Argument data types            |  Type  
--------+--------------+--------------------------+------------------------------------------+--------
 public | int2         | smallint                 | boolean                                  | normal

foo=# select public.int2('f');
 int2 
------
    0
(1 row)

foo=# select int2('f');
ERROR:  invalid input syntax for integer: "f"
LINE 1: select int2('f');

/ we moeten explicit de schema geven in de call?
/ TODO

/ 7	. 

foo=# \dC int2
                         List of casts
   Source type    |   Target type    | Function |   Implicit?   
------------------+------------------+----------+---------------
 bigint           | smallint         | int2     | in assignment
 boolean          | smallint         | int2     | yes						<-
 double precision | smallint         | int2     | in assignment
 integer          | smallint         | int2     | in assignment
 numeric          | smallint         | int2     | in assignment
 real             | smallint         | int2     | in assignment
 smallint         | bigint           | int8     | yes
 smallint         | double precision | float8   | yes
 smallint         | integer          | int4     | yes
 smallint         | numeric          | numeric  | yes
 smallint         | oid              | int4     | yes
 smallint         | real             | float4   | yes
 smallint         | regclass         | int4     | yes
 smallint         | regconfig        | int4     | yes
 smallint         | regdictionary    | int4     | yes
 smallint         | regoper          | int4     | yes
 smallint         | regoperator      | int4     | yes
 smallint         | regproc          | int4     | yes
 smallint         | regprocedure     | int4     | yes
 smallint         | regtype          | int4     | yes
(20 rows)

foo=# drop cast (boolean as smallint);




/ Lees	, 
https://www.postgresql.org/docs/9.1/static/sql-createcast.html
To be able to create a cast, you must own the source or the target data type. To create a binary-coercible cast, you must be superuser. (This restriction is made because an erroneous binary-coercible cast conversion can easily crash the server.)

[eric@localhost bin]$ sudo su - postgres -c psql
postgres=# \c foo

CREATE CAST (boolean AS smallint)
WITH FUNCTION public.int2(boolean)							-- let op public.
AS IMPLICIT;

/ Klopt, bij ons in postgres autocommit	

foo=# \q
[eric@localhost bin]$ psql -U foo

/ MAANDAGOCHTEND

foo=> \sf int2(boolean)
CREATE OR REPLACE FUNCTION public.int2(boolean)
 RETURNS smallint
 LANGUAGE plpgsql
AS $function$
begin
if $1 then return 1; else return 0; end if;
end;
$function$

/ Intermezzo

/ Lees	, 
http://www.postgresqltutorial.com/postgresql-recursive-query/
http://postgres.cz/wiki/PostgreSQL_SQL_Tricks
https://www.postgresql.org/docs/9.1/static/sql-syntax-calling-funcs.html
https://www.postgresql.org/docs/9.1/static/sql-dropcast.html
http://stackoverflow.com/questions/11989465/sql-how-to-cast-a-select-query

CREATE OR REPLACE FUNCTION public.boolcast_varchar(boolean)
 RETURNS character varying
 LANGUAGE sql
AS $$
  SELECT CASE WHEN $1 THEN 't' ELSE 'f' END 
$$

UPDATE pg_cast SET castfunc='boolcast_varchar'::regproc, 
                   castcontext='i' 
  WHERE castsource=16 and casttarget=1043;

CREATE TABLE test(a varchar(1));
INSERT INTO test VALUES(true);

/ TODO

/ lees	,
https://www.postgresql.org/docs/9.1/static/sql-syntax-calling-funcs.html
https://www.postgresql.org/docs/9.1/static/sql-dropcast.html
http://stackoverflow.com/questions/11989465/sql-how-to-cast-a-select-query
SELECT cast(yourNumber as varchar(10))
FROM yourTable
Then if you want to JOIN based on it, you can use:
/ or	, 
SELECT *
FROM yourTable t1
INNER JOIN yourOtherTable t2
    on cast(t1.yourNumber as varchar(10)) = t2.yourString

/ Einde Intermezzo

/ 7	. 

/ Lees	 
https://system.mp-objects.com/xwiki/bin/view/Technology/PostgreSQL

scstest2=> \dn
  List of schemas
  Name  |  Owner   
--------+----------
 compat | scstest
 public | postgres
(2 rows)

scstest2=> \df compat.*
                        List of functions
 Schema | Name | Result data type | Argument data types |  Type  
--------+------+------------------+---------------------+--------
 compat | int2 | smallint         | boolean             | normal
(1 row)
scstest2=> \sf compat.int2
CREATE OR REPLACE FUNCTION compat.int2(boolean)
 RETURNS smallint
 LANGUAGE plpgsql
AS $function$
        begin
                if $1 then return 1; else return 0; end if;
        end;
$function$



/ Einde TYPE CASTS

/ QUOTED STRINGS IN TEXT FIELDS 

/ Use een extra quote: '''foo''',	, of $$'foo'$$	,   

foo=> create table if not exists chrs(s varchar(32));
CREATE TABLE
foo=> commit;
COMMIT
foo=> insert into chrs values('''foo''');
INSERT 0 1
foo=> select*from chrs;
   s   
-------
 'foo'
(1 row)

foo=> insert into chrs values($$'bar'$$);
INSERT 0 1
foo=> select*from chrs;
   s   
-------
 'foo'
 'bar'
(2 rows)

/ Einde QUOTED STRINGS IN TEXT FIELDS 

/ BOOLS

foo=> create table bools(b boolean);
CREATE TABLE
foo=> commit;
COMMIT
foo=> insert into bools values('f');
INSERT 0 1
foo=> insert into bools values('1');
INSERT 0 1
foo=> insert into bools values('0');
INSERT 0 1
foo=> insert into bools values('y');
INSERT 0 1
foo=> insert into bools values(1);
ERROR:  column "b" is of type boolean but expression is of type integer


/ Einde BOOLS

/ SERIAL

/ Lees	, 
http://www.postgresqltutorial.com/postgresql-serial/

/ autoincrement column	,

foo=> create table par7 (i serial, s text);

foo=> insert into par7(s) values('bar');
/ of	,
foo=> insert into par7 values(default,'bar');

foo=> insert into par7 values(default,'bar') returning i;
 i 
---
 5
(1 row)

/ Als we 
foo=> insert into par7 values(0,'bar');
/ dan insert hij inderdaad (0,'bar')	,




/ Einde SERIAL

/ DVDRENTAL

/ Lees	,
http://www.postgresqltutorial.com/postgresql-sample-database/
http://www.postgresqltutorial.com/load-postgresql-sample-database/




/ Einde DVDRENTAL

/ GENERATE SERIES 

/ Lees	, 
http://stackoverflow.com/questions/3371503/sql-populate-table-with-random-data

foo=> select generate_series(1,10);
 generate_series 
-----------------
               1
               2
               3
               4
               5
               6
               7
               8
               9
              10
(10 rows)

http://stackoverflow.com/questions/37076406/how-to-select-all-dates-in-sql-query

foo=> select random();
      random      
------------------
 0.47103154566139
(1 row)
foo=> select md5(cast(random()as text));
               md5                
----------------------------------
 a70c40e44b9059aa401c576a88386f8a
(1 row)

foo=> select generate_series(1,10),md5(cast(random()as text));
 generate_series |               md5                
-----------------+----------------------------------
               1 | 59730691a5b832144cf3e0296269405c
               2 | 069d1c8c366ea4e290106ac4214408e9
               3 | 173fe51de727823011a12fe5d1c02606
               4 | 34a30058d1ae19194ae9352f1e131b3d
               5 | c343a6fc702cb4ec9568da408701264e
               6 | 3b63f9061f78fed6c8d3e26310bf27ea
               7 | 6568e72eeded8458edffaa54f7c6c809
               8 | 1ef30ac7739f0bcb05252f0538f2b825
               9 | 2bc772836eac17ac02f7c34a2dd42865
              10 | 8aa5e8e926f7b7c67296df97ae5804e2
(10 rows)

/ 7	. 

select x
from generate_series(-3.5,3.5,1);

/ Einde GENERATE SERIES 

/ TYPES

/ 7	.

/ Lees	,
https://www.postgresql.org/docs/9.6/static/datatype-numeric.html

/ numeric heeft variable aantal bytes	, 
/ decimal==numeric

/ real en double precision zijn floating-point types	,

foo=> select pg_typeof(3.5);
 pg_typeof 
-----------
 numeric
(1 row)

/ TODO while loop -3.5, tot 3.5


/ Einde TYPES

/ STORED PROCEDURES

/ 7	. 

/ Lees	,
http://www.postgresqltutorial.com/postgresql-functions/

create or replace function random_between(low int,high int)returns int as $$	/ as moet	, in sql bij alias kunnen we as weglaten	, 
begin
	return floor(random()*(high-low)+1);
end $$ language plpgsql strict;
/ Zonder: strict is ook OK	,

create or replace function random_between(low int,high int)returns double precision as $$
begin
	return random()*(high-low)+1;
end $$ language plpgsql strict;
/ OK, maar we kunnen deze niet direct achter die erboven staat doen	, want de return types zijn verschillend	,

/ Doe rollback	, of (let op de args) 	,
foo=> drop function random_between(int,int);

/ 7	. 

/  PL/pgSQL is similar to the Oracle PL/SQL

create or replace function inc(i int)returns int as $$ 
begin
	return i+1;
end
$$ language plpgsql;

foo=> select inc(inc(20));
 inc 
-----
  22
(1 row)


/ Dit mag ook	,	 (as$$ mag NIET)	,
create function random_between(low int,high int)returns double precision as $$begin
	return random()*(high-low)+1;
end$$language plpgsql strict;

/ Dit is ook OK	, de 'begin ... end' tussen '...'	, 
create function random_between(low int,high int)returns double precision as 'begin
	return random()*(high-low)+1;
end' language plpgsql;

/ 7	. 

/ out param	,

/ geen return	,

create or replace function high_low(a numeric,b numeric,c numeric,out high numeric,out low numeric)as $$ begin
	high:=greatest(a,b,c);
	low:=least(a,b,c);
end $$ language plpgsql;
	
foo=> select high_low(-1.7, 13.13, 3.141529);
   high_low   
--------------
 (13.13,-1.7)
(1 row)

foo=> select pg_typeof(high_low(-1.7, 13.13, 3.141529));
 pg_typeof 
-----------
 record
(1 row)

/ record is WH row	,

/ Lees	, 
https://www.postgresql.org/docs/9.3/static/rowtypes.html
/ See here about ROW
/ TODO

/ 7	. 

create or replace function current_my()returns date as $$ begin
	return current_date;
end $$ language plpgsql;

/ call	,
foo=> select current_my();
 current_my 
------------
 2017-05-21
(1 row)

/ Dus NIET in de fct	,
	return select current_date;

/ 7	.  

/ current_date is geen fct	, 

foo=> select pg_typeof(current_date);
 pg_typeof 
-----------
 date
(1 row)

foo=> select pg_typeof(current_my);
ERROR:  column "current_my" does not exist
/ 

/ 7	. 

select generate_series(1,4);
/ of	,
select * 
from generate_series(1,4);
/ of	,
select x 
from generate_series(1,4)x;
/ of	,
select x.*
from generate_series(1,4)x;
/ TODO

foo=> select pg_typeof(generate_series(1,4));
 pg_typeof 
-----------
 integer
 integer
 integer
 integer
(4 rows)

/ 7	. 

create function myfct()returns void as $$ begin
	drop table if exists foo;
	create table foo(i int);
end $$ 
language plpgsql;
/ Hier moet plpgsql staat	, geen sql	, 

/ Lees	,
https://www.postgresql.org/docs/9.5/static/xplang.html

/ Lees	,
http://stackoverflow.com/questions/24755468/difference-between-language-sql-and-language-plpgsql-in-postgresql-functions

create function myfct()returns void as $$ 
	drop table if exists foo;
	create table foo(i int);
	--insert into foo values(7),(13);
	--select*from foo;
$$ 
language sql;
/ omdat er begin, end staan	, kunnen we : language sql
/ de insert regel geeft ERR bij exec:  relation with OID 3267568 does not exist
/ TODO
/ de select regel geef ERR bij def: return type mismatch in function declared to return void , DETAIL:  Final statement must return exactly one column.
/ TODO

/ in plpgsql kan select	, maar alleen met into erna	,

/ 7	. 

/ generate_subscripts

/ Lees	, 
https://www.postgresql.org/docs/9.1/static/functions-srf.html

SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1); 
 generate_subscripts 
---------------------
                   1
                   2
                   3
                   4
/we moeten ::int[]	, dat heeft niets met die NULLs te maken	, 

/ 13	. 

foo=> create table arrays(l int[]);
CREATE TABLE
foo=> insert into arrays values ('{-1,-2}'::int[]),('{100,200,300}'::int[]);
INSERT 0 2
foo=> select pg_typeof(l)from arrays;
 pg_typeof 
-----------
 integer[]
 integer[]
(2 rows)

foo=> select l from arrays;
       l       
---------------
 {-1,-2}
 {100,200,300}
(2 rows)

foo=> insert into arrays values('{1,3,5}');
foo=> insert into arrays values('{1,3}');

foo=> select*from arrays;
       l       
---------------
 {-1,-2}
 {100,200,300}
 {1,3,5}
 {1,3}
(4 rows)

foo=> select generate_subscripts(l,1)from arrays;
 generate_subscripts 
---------------------
                   1
                   2
                   1
                   2
                   3
                   1
                   2
                   3
                   1
                   2
(10 rows)

/ we hoeven geen 
create table arrays2(i int[][])
/ te create	, om 2 dim arrays te insert	, 
create table arrays(i int[]) is OK	, en die hebben we al	, 

foo=> insert into arrays2 values('{{1,2,3},{1,2,3}}');
foo=> insert into arrays2 values('{{1,2,3,4},{1,2,3,4}}');
/ OK	, ze moeten even groot zijn	, maar onderling niet	, 

foo=> insert into arrays values('{{1,2,3},{1,2,3}}');
foo=> insert into arrays values('{{1,2,3,4},{1,2,3,4}}');

foo=> select*from arrays;
           l           
-----------------------
 {-1,-2}
 {100,200,300}
 {{1,2,3},{1,2,3}}
 {{1,2,3,4},{1,2,3,4}}
(4 rows)

foo=> select generate_subscripts(l,1)from arrays;
 generate_subscripts 
---------------------
                   1
                   2
                   1
                   2
                   3
                   1
                   2
                   1
                   2
(9 rows)
foo=> select generate_subscripts(l,2)from arrays;
 generate_subscripts 
---------------------
                   1
                   2
                   3
                   1
                   2
                   3
                   4
(7 rows)

/ Dus 1 dim arrays zijn rows	, en moeten we staand denken	, 
{1,2,3}=
1
2
3
/ 2 dim ook : {{1,2,3},{4,5,6}}: 2 rows	, met elk 3 columns	, 
1 2 3
4 5 6

-1
-2
100
200
300
1 2 3
1 2 3
1 2 3 4
1 2 3 4

/ daarom 1ste index	,
1
2
1
2
3
1
2
1
2

/ de 2de index	bij
-1
-2
/ is er niet
/ TODO 
/ we zien dus alleen	, 
1
2
3
1
2
3
4

/ 13	. 

foo=> select generate_subscripts('{{1,2,3},{3,4,5}}'::int[],1);
 generate_subscripts 
---------------------
                   1
                   2
(2 rows)
foo=> select generate_subscripts('{{1,2,3},{3,4,5}}'::int[],2);
 generate_subscripts 
---------------------
                   1
                   2
                   3
(3 rows)
/ Klopt	, '{{1,2,3},{3,4,5}}'::int[] zou een column kunnen zijn in arrays	,






select l,s,l[s]
from(
	select generate_subscripts(l,1)s,l			/ bij alias hoeft  niet: as	, as s is ook OK	, maar s is ook OK	,
														/ 2de arg is dimension	,
	from arrays
)_;												/ we moeten een alias	, _ bij ons geven: subquery in FROM must have an alias
       l       | s |  l  
---------------+---+-----
 {-1,-2}       | 1 |  -1
 {-1,-2}       | 2 |  -2
 {100,200,300} | 1 | 100
 {100,200,300} | 2 | 200
 {100,200,300} | 3 | 300
(5 rows)

/ 13	. 

foo=> select ARRAY[[1,2],[3,4]];
/=
foo=> select '{{1,2},{3,4}}'::int[];
     array     
---------------
 {{1,2},{3,4}}
(1 row)
foo=> select pg_typeof(ARRAY[[1,2],[3,4]]);
 pg_typeof 
-----------
 integer[]
(1 row)
foo=> select pg_typeof( '{{1,2},{3,4}}'::int[]);
 pg_typeof 
-----------
 integer[]
(1 row)

foo=> select ROW('fuzzy dice', 42, 1.99);
          row           
------------------------
 ("fuzzy dice",42,1.99)
(1 row)
foo=> select pg_typeof(ROW('fuzzy dice', 42, 1.99));
 pg_typeof 
-----------
 record																/ net als out param in plpgsql function	, TODO
(1 row)

/ 13	. 

/ Lees	,
https://www.postgresql.org/docs/9.1/static/functions-srf.html

CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$					/ setof TODO
select $1[i][j]
   from generate_subscripts($1,1) g1(i),		/ g1 TODO
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
/ TODO

SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
---------
       1
       2
       3
       4
(4 rows)

/ Open in chrome	,
https://www.postgresql.org/docs/9.3/static/rowtypes.html	/ ROW
https://www.postgresql.org/docs/9.1/static/functions-srf.html	/ generate_subscripts
https://www.postgresql.org/docs/9.3/static/datatype-numeric.html	/ numeric
https://www.postgresql.org/docs/9.3/static/plpgsql-structure.html	/ plpgsql
http://stackoverflow.com/questions/3371503/sql-populate-table-with-random-data	/ generate_series
https://www.postgresql.org/docs/9.1/static/arrays.html
http://www.postgresqltutorial.com/plpgsql-function-parameters/

/ Lees	, how to create random strings	,
http://stackoverflow.com/questions/3970795/how-do-you-create-a-random-string-thats-suitable-for-a-session-id-in-postgresql
http://stackoverflow.com/questions/19530736/how-can-i-generate-a-unique-string-per-record-in-a-table-in-postgres

/ 7	. 

create function sum_avg(variadic list numeric[],out total numeric,out average numeric)as $$ begin
	select into total sum(list[i]) from generate_subscripts(list,1)g(i);		-- g is alias	, _(i) is ook OK	,
	select into average avg(list[i]) from generate_subscripts(list,1)g(i);
end $$
language plpgsql;
/ TODO

select*from sum_avg(10,20,30);
 total |       average       
-------+---------------------
    60 | 20.0000000000000000
(1 row)

/ MORGENOCHTEND
http://www.postgresqltutorial.com/plpgsql-function-parameters/	

/ 7	. 

/ GENERATE_SERIES ARRAYS GENERATE_SUBSCRIPTS 

/ Lees	, 
https://www.postgresql.org/docs/9.1/static/functions-srf.html

/ we proberen te begrijpen	, 

select s.a from generate_series(0,2) as s(a);	-- onnodig	, 	  select s from generate_series(0,2) as s; is OK	, 

CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;

/ 13	. 

bij een table moet je de tbl en de column alias: als je eerst	

foo=> select * into gs7 from generate_series(0,2) ;  
foo=> select s from gs7 s;
  s  
-----
 (0)
 (1)
 (2)
(3 rows)
foo=> select s.a from gs7 s(a);
 a 
---
 0
 1
 2
(3 rows)

/ Maar generate_series(0,2) is geen table	, 

foo=> select s from generate_series(0,2) as s;
 s 
---
 0
 1
 2
(3 rows)

foo=> select pg_typeof(s) from gs7 s;
 pg_typeof 
-----------
 gs7
 gs7
 gs7
(3 rows)
foo=> select pg_typeof(s) from generate_series(0,2) as s;
 pg_typeof 
-----------
 integer
 integer
 integer
(3 rows)



/ 13	. 

////////////////////////////////////////
/ we alias hier de table en column tegelijk	, we alias gs3 naar s en de column generate_series naar a	,
foo=> select s.a from gs3 s(a);
 a 
---
 0
 1
 2
(3 rows)

/ we maken een table met 2 columns	, 
foo=> select * into gsrd from gs,rd ;
foo=> select*from gsrd;
 generate_series |               md5                
-----------------+----------------------------------
               1 | f807a37f8f8e2157ec36c8c0cc67bcf3
               2 | f807a37f8f8e2157ec36c8c0cc67bcf3
               3 | f807a37f8f8e2157ec36c8c0cc67bcf3
(3 rows)
foo=> select * from gsrd  gr(a,b);						-- we alias de table en columns tegelijk	, 
/=
foo=> select gr.a,gr.b from gsrd  gr(a,b);

 a |                b                 
---+----------------------------------
 1 | f807a37f8f8e2157ec36c8c0cc67bcf3
 2 | f807a37f8f8e2157ec36c8c0cc67bcf3
 3 | f807a37f8f8e2157ec36c8c0cc67bcf3
(3 rows)

/ 1313	. 

foo=> select * into gs1 from  generate_subscripts('{{1,2,3},{4,5,6}}'::int[],1);
foo=> select * into gs2 from  generate_subscripts('{{1,2,3},{4,5,6}}'::int[],2);

foo=> select*from gs1;
 generate_subscripts 
--------------------- 1
                   2
(2 rows)
foo=> select*from gs2;
 generate_subscripts 
---------------------
                   1
                   2
                   3
(3 rows)

/////////////////////////////////////////////////////////////////////////////////////
/ we alias van beide tables uit de join de table en de column	, en we join	, g en h zijn tables, i en j zijn columns	,
select * from generate_subscripts('{{1,2,3},{4,5,6}}'::int[],1) g(i),generate_subscripts('{{1,2,3},{4,5,6}}'::int[],2)h(j);
foo=> select i,j from generate_subscripts('{{1,2,3},{4,5,6}}'::int[],1) g(i),generate_subscripts('{{1,2,3},{4,5,6}}'::int[],2)h(j);
/=
foo=> select g.i,h.j from generate_subscripts('{{1,2,3},{4,5,6}}'::int[],1) g(i),generate_subscripts('{{1,2,3},{4,5,6}}'::int[],2)h(j);
 i | j 
---+---
 1 | 1
 1 | 2
 1 | 3
 2 | 1
 2 | 2
 2 | 3
(6 rows)

///////////////////////////////////////////////////////////////////////////

/ we moeten (...) zetten om het array	, 
foo=> select ('{{1,2,3},{4,5,6}}'::int[])[1][2];
 int4 
------
    2
(1 row)

foo=> select ('{{1,2,3},{4,5,6}}'::int[])[2][2];
 int4 
------
    5
(1 row)

/ want anders worden de [1][2] niet gezien	, 
foo=> select '{{1,2,3},{4,5,6}}'::int[][1][2];
/=
foo=> select '{{1,2,3},{4,5,6}}'::int[];
       int4        
-------------------
 {{1,2,3},{4,5,6}}
(1 row)

/ 13	. 

CREATE OR REPLACE FUNCTION unnest2(int[])													-- hoeft geen naam	, use $1 in function 	, 
RETURNS table (_ int, _2 int, _3 int) AS $$													-- namen MOETEN	, altijd in een table,	
select a,b,$1[a][b] from generate_subscripts($1,1) g(a), generate_subscripts($1,2) h(b);
$$ LANGUAGE sql; 
/=
CREATE OR REPLACE FUNCTION unnest2(arr int[])												-- mag wel naam	, 
RETURNS table (_ int, _2 int, _3 int) AS $$
select a,b,arr[a][b] from generate_subscripts(arr,1) g(a), generate_subscripts(arr,2) h(b);
$$ LANGUAGE sql; 

foo=> select unnest2('{{11,12,13},{21,22,23}}'::int[]);
 unnest2  
----------
 (1,1,11)
 (1,2,12)
 (1,3,13)
 (2,1,21)
 (2,2,22)
 (2,3,23)
(6 rows)


/ Einde GENERATE_SERIES ARRAYS GENERATE_SUBSCRIPTS 

/ ROW TYPES ANYELEMENTS

/ Intermezzo

foo=> select (1,2);
  row  
-------
 (1,2)
(1 row)
foo=> select pg_typeof((1,2));		-- let op ()	, 
 pg_typeof 
-----------
 record
(1 row)

foo=> select (1,2)::point;
ERROR:  cannot cast type record to point
foo=>  select '(1,2)'::point;
 point 
-------
 (1,2)
(1 row)
foo=>  select '(1,2)'::record;
ERROR:  input of anonymous composite types is not implemented
/ TODO

foo=>  select '(1,2.5)'::point p;
    p    
---------
 (1,2.5)
(1 row)
/ TODO numerics?

/ Einde Intermezzo

/ Intermezzo

/ '' hebben niets met strings te maken	, 

foo=> create function id(anyelement) returns anyelement as $$			-- any ipv anyelement is ERR	, TODO 
select $1
$$
language sql ;
/ OK						

foo=> select id('foo'::text);
 id  
-----
 foo
(1 row)

foo=> select id('foo');
ERROR:  could not determine polymorphic type because input has type "unknown"
/ In tables gaat dit altijd OK	, omdat de column type bekend is	, dus als je doet 
	create table t(s text);
	insert into t values('foo')
/ OK	, want hij weet dat de type text is	, dus hoeven we niet insert into t values('foo'::text)	, 

foo=> create table pts(p point);
CREATE TABLE
foo=> insert into pts values('(1,2)');
INSERT 0 1

/ Maar met een id functie ertussen gaat het OK	,

foo=> select s into pts from id('foo'::text)s;
/ OK
foo=> select s into pts from 'foo'::text s;
ERROR:  syntax error at or near "'foo'"
foo=> select s into pts from id('foo')s;
ERROR:  could not determine polymorphic type because input has type "unknown"

foo=> create table  pts as select s from id('foo'::text)s;
SELECT 1
foo=> select*from pts;
  s  
-----
 foo
(1 row)
/ TODO how function which return multiple anyelements	?

/ 131313

create or replace function id2(anyelement,anyelement)returns anyarray as $$
select array[$1,$2]
$$ language sql;
foo=> select id2('foo'::text,'bar'::text);
    id2    
-----------
 {foo,bar}
(1 row)
/ OK	, maar blijkbaar als moet de 2 anyelement van het zelfde type	, 
foo=> select id2(7,13);
  id2   
--------
 {7,13}
(1 row)
foo=> select id2('foo'::text,3);
ERROR:  function id2(text, integer) does not exist
/ TODO Heeft dit met array te maken	, dat elements in een array maar van 1 type kunnen zijn	? 

/ 131313	. 

foo=> create type mix as (s text, i int);							-- as MOET	,
CREATE TYPE
foo=> create or replace function id3(text,int)returns mix as $$
select $1,$2
$$ language sql;
CREATE FUNCTION
foo=> select id3('foo',13);
   id3    
----------
 (foo,13)
(1 row)

foo=> select pg_typeof(id3('foo',13));
 pg_typeof 
-----------
 mix
(1 row)


/ 131313	. 

/ SELECT INTO

/ select into	, create table as	,

/ select into: altijd from 	, 
/ je kunt een sub query achter from: altijd tussen (...) en alias hem : (...)_
/ of je zet er een functie achter	, een id fct bijv	,

LINE 1: select*into pts2 from '(1,2)'::point;						
/ ERR 
/ HIER HIER HIER

foo=> select*into pts2 from id('(1,2)'::point);			-- select into: altijd: from	, 
															-- hier met functie	, beneden met select	,  
SELECT 1
/ OK
foo=> select pg_typeof(p)from pts2;
 pg_typeof 
-----------
 point
(1 row)

/ Lees	, 
https://www.postgresql.org/docs/9.5/static/sql-select.html		/ select	,
/ from_item is een 
table
query
select
rows from
function

/ Lees	, 
https://www.postgresql.org/docs/9.3/static/sql-createtableas.html
create table table_name 
as query

create table pts2 as select '(1,2)'::point p;							/ makkelijkst	,
/ OK

/ je kunt ook meerdere columns	, 
foo=> create table pts2 as select '(1,2)'::point p,13 i;
foo=> \d pts2
     Table "public.pts2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 p      | point   | 
 i      | integer | 
foo=> select *from pts2;
   p   | i  
-------+----
 (1,2) | 13
(1 row)


select * into pts2 from (select '(1,2)'::point p)_;				/ select into: sub query altijd om (...) heen	, en we moeten hem alias TODO
/ of	,
select p into pts2 from (select '(1,2)'::point p)_;
foo=> \d pts2
    Table "public.pts2"
 Column | Type  | Modifiers 
--------+-------+-----------
 p      | point | 

select p into pts2 from (select '(1,2)'::point p)_;

foo=> select '(1,2)'::point;
 point 
-------
 (1,2)
(1 row)
/ OK
foo=> select pg_typeof('(1,2)'::point);
 pg_typeof 
-----------
 point
(1 row)
foo=> select _ into pts2 from (select '(1,2)'::point)_;
ERROR:  column "_" has pseudo-type record
foo=> select * into pts2 from (select '(1,2)'::point);
ERROR:  subquery in FROM must have an alias

/ of multiple columns	, 

foo=> select * into pts2 from (select '(1,2)'::point p,13 i)_;
/=
foo=> select p,i into pts2 from (select '(1,2)'::point p,13 i)_;
foo=> select*from pts2;
   p   | i  
-------+----
 (1,2) | 13
(1 row)

/ 13	. 

/ plpgsql rowtype, record

/ Lees	, 
https://www.postgresql.org/docs/9.0/static/plpgsql-declarations.html

CREATE FUNCTION merge_fields(e emp) RETURNS text AS $$
DECLARE
    p pts2%ROWTYPE;
BEGIN
    SELECT * INTO p  FROM pts2;
    RETURN e.cubicle || p.i; 
END;
$$ LANGUAGE plpgsql;
foo=> select merge_fields(emp.*) from emp;
ERROR:  function merge_fields(emp) does not exist
/ TODO

/ record in plpgsql vergl met record type	, 
/ TODO


/ 13	. 

/ Lees	, 
https://www.postgresql.org/message-id/CAMr3DCMJfbxFAK08rpOZSoGKNMCA%2BfM%2BYO6X%3DRkTeczrX_8sLQ@mail.gmail.com

foo=> select 1 as a, 2 as b;
/=
foo=> select 1 a, 2 b;
 a | b 
---+---
 1 | 2
(1 row)

foo=> select 1 a,2 b x;
/ ERR
foo=> (select 1 a,2 b )x;
/ ERR

foo=> select x.* from (select 1 as a, 2 as b)x;
 a | b 
---+---
 1 | 2
(1 row)
foo=> select x from (select 1 as a, 2 as b)x
;
   x   
-------
 (1,2)
(1 row)

foo=>  select * from (select x from (select 1 as a, 2 as b)x)t;
   x   
-------
 (1,2)
(1 row)

foo=>  select t from (select x from (select 1 as a, 2 as b)x)t;
     t     
-----------
 ("(1,2)")
(1 row)
/ een record met records	, 

foo=>  select t.* from (select x from (select 1 as a, 2 as b)x)t;
   x   
-------
 (1,2)
(1 row)

foo=>  select pg_typeof(t) from (select x from (select 1 as a, 2 as b)x)t;
 pg_typeof 
-----------
 record
(1 row)
foo=>  select pg_typeof(t.x) from (select x from (select 1 as a, 2 as b)x)t;
 pg_typeof 
-----------
 record
(1 row)

foo=>  select pg_typeof((t).x.a) from (select x from (select 1 as a, 2 as b)x)t;	-- () om t moet in (t).x.a
/ of	, 
foo=>  select pg_typeof((t.*).x.a) from (select x from (select 1 as a, 2 as b)x)t;
 pg_typeof 
-----------
 integer
(1 row)

/ HIER HIER HIER

/ 13	. 





	
/ 13	. 

/ Lees	, 
https://www.postgresql.org/docs/9.6/static/sql-createtype.html

CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;

/ TODO verband met row	,

/ Einde ROW TYPES ANYELEMENTS

/ ROW TYPES COMPOSITE TYPES

/ Lees	, 
https://www.postgresql.org/docs/9.3/static/rowtypes.html


/ Lees	, 
https://www.postgresql.org/docs/9.6/static/sql-createtype.html

create type inventory_item as(				-- as MOET
	name text,
	supplier_id integer,
	price numeric
);

create table on_hand(
	item inventory_item,
	count integer
);
insert into on_hand values(row('foo bar',42,1.99),100);

insert into on_hand values(row('me you',23,4.23)::inventory_item,1000);
/ OK
/ Maar hoeft niet	, row(...) is een record	, maar in on_hand is 1ste column  een inventory_item	, dus wordt ::inventory_item al gedaan	,


foo=> select (row('foo bar'::text,23,2.49)::inventory_item).name;	
			-- row('foo bar'::text,23,2.49) is een record	, row('foo bar'::text,23,2.49)::inventory_item is een inventory_item	,
			-- notice de (...)	,
  name   
---------
 foo bar
(1 row)

////////////////////////////////////////////////////
foo=> select (item).name from  on_hand;							-- notice () om item	,
  name   
---------
 foo bar
(1 row)
/ OK

foo=> select item.name from  on_hand;						-- zonder () ERR	,
ERROR:  missing FROM-clause entry for table "item"
/ TODO

/ 1313	. 

create function price_extension(inventory_item,integer)returns numeric as '
	select $1.price * $2
' language sql;

foo=> select*from on_hand;
        item         | count 
---------------------+-------
 ("foo bar",42,1.99) |   100
 ("me you",23,4.23)  |  1000
(2 rows)

select price_extension(item,10)from on_hand;
 price_extension 
-----------------
           19.90
           42.30
(2 rows)

/ 1313	. 

foo=> \dT
          List of data types
 Schema |      Name      | Description 
--------+----------------+-------------
 public | inventory_item | 
 public | mix            | 
(2 rows)

foo=> drop type inventory_item;
ERROR:  cannot drop type inventory_item because other objects depend on it
DETAIL:  table on_hand column item depends on type inventory_item

foo=>  drop table on_hand;
foo=> drop type inventory_item;

create table inventory_item(
	name text,
	supplier_id integer,
	price numeric check(price>0)
);
create table on_hand(
	item inventory_item,
	count integer
);
insert into on_hand values(row('foo bar',42,1.99),100);
insert into on_hand values(row('me you',23,4.23)::inventory_item,1000);

foo=> select*from on_hand;
        item         | count 
---------------------+-------
 ("foo bar",42,1.99) |   100
 ("me you",23,4.23)  |  1000
(2 rows)
/ we zien ""	, maar dat is wat de composite type module doet	, 




foo=> select (item).name from on_hand;		-- notice ()	,
  name   
---------
 foo bar
 me you
(2 rows)
/ Hetzelfde	, 

foo=> \d on_hand
       Table "public.on_hand"
 Column |      Type      | Modifiers 
--------+----------------+-----------
 item   | inventory_item | 
 count  | integer        | 

foo=> \dT
     List of data types
 Schema | Name | Description 
--------+------+-------------
 public | mix  | 
(1 row)
/ inventory_item staat er dus niet bij	, 

/ 13	. 

/ Lees	, 
https://www.postgresql.org/docs/9.4/static/sql-syntax-lexical.html
/ Als je een ' in een string wilt	, use 2 ' in '...'	, 

foo=> select '''';
 ?column? 
----------
 '
(1 row)
foo=> select 'foo '' bar';
 ?column?  
-----------
 foo ' bar
(1 row)


foo=> select '("foo bar",42,1.99)'::inventory_item;		-- pg_typeof = inventory_item	,
/=
foo=> select '("foo bar",42,1.99)';		-- pg_typeof = record	, 
   inventory_item    
---------------------
 ("foo bar",42,1.99)
(1 row)


foo=> select ('("foo bar",42,1.99)'::inventory_item).name;		-- notice ()	, 
  name   
---------
 foo bar
(1 row)

/ we kunnen ook	, 
foo=> select $$(foo bar,42,1.99)$$;
     ?column?      
-------------------
 (foo bar,42,1.99)
(1 row)
foo=> select ($$(foo bar,42,1.99)$$::inventory_item).name like 'foo bar';
 ?column? 
----------
 t
(1 row)
/ Dus $$ en helemaal geen quotes om foo bar	, ::inventory_item will make is of type text	,

foo=> select ($$("foo bar",42,1.99)$$::inventory_item).name like 'foo bar';
 ?column? 
----------
 t
(1 row)
/ we kunnen "" om foo bar	, en dat heeft geen effect	met $$	, 
foo=> select ($$('foo bar',42,1.99)$$::inventory_item).name like $$'foo bar'$$;
/ of	,
foo=> select ($$('foo bar',42,1.99)$$::inventory_item).name like '''foo bar''';
 ?column? 
----------
 t
(1 row)

/ we kunnen NIET	, 
foo=> select ($$('foo bar',42,1.99)$$::inventory_item).name like "'foo bar'";
ERROR:  column "'foo bar'" does not exist

foo=> select '("foo bar",,)';
   ?column?    
---------------
 ("foo bar",,)
(1 row)

foo=> select '("",42,)';
 ?column? 
----------
 ("",42,)
(1 row)

foo=> select row('foo bar',42,1.99);
         row         
---------------------
 ("foo bar",42,1.99)
(1 row)

foo=> select row("foo bar",42,1.99);
ERROR:  column "foo bar" does not exist

foo=> select ('foo bar',42,1.99);
         row         
---------------------
 ("foo bar",42,1.99)
(1 row)


foo=> select $$("foo bar",42,1.99)$$::inventory_item;
   inventory_item    
---------------------
 ("foo bar",42,1.99)
(1 row)

/ 1313	. 

/ nogmaals	, 

/ 131313	. 

select '("fuzzy dice",42,)'				-- we hoeven geen NULL 	,
/=
select row('fuzzy dice',42,NULL)
/=
select ('fuzzy dice',42,NULL)


/ 131313	.

foo=> select '(foo bar,19,7.13)';	-- dit kan	, 
     ?column?      
-------------------
 (foo bar,19,7.13)
(1 row)

foo=> select row(foo bar, 19,7.13);		-- dit kan niet	,
ERROR:  syntax error at or near "bar"

foo=> select '(''foo bar'',19,7.13)';	-- kan, maar is iets anders	,
      ?column?       
---------------------
 ('foo bar',19,7.13)
(1 row)

foo=> select '(foo bar,19,7.13)'::inventory_item
foo-> ;
   inventory_item    
---------------------
 ("foo bar",19,7.13)
(1 row)
/ ineens ""	, 

foo=> select '("foo bar",19,7.13)';		-- dit kan ook "" om foo bar	,
      ?column?       
---------------------
 ("foo bar",19,7.13)
(1 row)
foo=> select '("foo bar",19,7.13)'::inventory_item;		-- resultaat is hetzelfde: wel of geen "" om foo bar	, 
   inventory_item    
---------------------
 ("foo bar",19,7.13)
(1 row)

foo=> select row('foo bar',19,7.13);	-- kan wel	, 
         row         
---------------------
 ("foo bar",19,7.13)
(1 row)

foo=> select row("foo bar",19,7.13);	-- kan niet	, 
ERROR:  column "foo bar" does not exist




/ 131313	.

foo=> select '("foo bar",19,7.13)';
      ?column?       
---------------------
 ("foo bar",19,7.13)
(1 row)

foo=> select '(foo bar,19,7.13)' == '(foo bar,19,7.13)';  
HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.



/ 1313	. 


/ Maar	,
foo=> select $$('foo bar',42,1.99)$$::inventory_item;
    inventory_item     
-----------------------
 ("'foo bar'",42,1.99)
(1 row)
/ TODO we zien "" en '	, 
/ Moeten we 

foo=> select (('("foo bar",42,1.99)'::inventory_item).name) like 'foo bar';
 ?column? 
----------
 t
(1 row)
/ == ERR	, 
/ TODO

/ Lees	, 
https://wiki.postgresql.org/wiki/Things_to_find_out_about_when_moving_from_MySQL_to_PostgreSQL

/ Intermezzo

foo=> select $r$($i$foo bar$i$,42,1.99)$r$::inventory_item;
      inventory_item       
---------------------------
 ("$i$foo bar$i$",42,1.99)
(1 row)

/ Einde Intermezzo

/ 13	. 

/ Verder op 	,
https://www.postgresql.org/docs/9.3/static/rowtypes.html

/ we hadden eerder	, 

insert into on_hand values(row('foo bar',42,1.99),100);
insert into on_hand values(row('me you',23,4.23)::inventory_item,1000);

foo=> select*from on_hand;
        item         | count 
---------------------+-------
 ("foo bar",42,1.99) |   100
 ("me you",23,4.23)  |  1000
(2 rows)

foo=> insert into on_hand(item) values(('foo bar',7, 13.13));		-- let op () om record heen	,
/ of	, 
foo=> insert into on_hand values(('foo bar',7, 13.13),NULL);
/ of	,
foo=> insert into on_hand values(row('foo bar',7, 13.13),NULL);
/ of	, 
foo=> insert into on_hand values('("foo bar",7, 13.13)',NULL);

INSERT 0 1

foo=> select*from on_hand;
        item         | count 
---------------------+-------
 ("foo bar",42,1.99) |   100
 ("me you",23,4.23)  |  1000
 ("foo bar",7,13.13) |  NULL
(3 rows)

foo=> update on_hand set item='("one two three",13,7.13)' where count=100;
/ of	,
foo=> update on_hand set item=row('one two three',13,7.13) where count=100;
/ of	,
foo=> update on_hand set item=('one two three',13,7.13) where count=100;

update on_hand set item.price=(item).price+1.99 where (item).supplier_id=23;
/ OK
foo=> select*from on_hand;
           item            | count 
---------------------------+-------
 ("one two three",13,7.13) |   100
 ("foo bar",7,13.13)       |  NULL
 ("foo bar",7,13.13)       |  NULL
 ("me you",23,6.22)        |  1000						<-
(4 rows)

/ 1313	. 

In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row

create or replace function myfct(supplier_id integer)returns inventory_item as '
	select item from on_hand where (item).supplier_id=supplier_id
' language sql;	

foo=> select myfct(42)from on_hand;
        myfct        
---------------------
 ("foo bar",42,1.99)
 ("foo bar",42,1.99)
(2 rows)

foo=> select (myfct(42)).price from on_hand;
 price 
-------
  1.99
  1.99
(2 rows)


/ 1313	. 

/ myfct(42).* doet myfct(42).name,myfct(42).supplier_id,myfct(42).price	, als hij staat in de select list, of een returning list	, ... 
/ In andere gevallen doet .* gewoon niets	, bijv in arg van fct is fct(item.*)=fct(item)

/ 1313	. 

foo=> select item from on_hand;
/=
foo=> select (item) from on_hand;
        item         
---------------------
 ("foo bar",42,1.99)
 ("me you",23,4.23)
(2 rows)

foo=> select (item).supplier_id from on_hand where (item).price>3;
/=
foo=> select (item).supplier_id from on_hand where price(item)>3;
/=
foo=> select supplier_id(item) from on_hand where price(item)>3;
 supplier_id 
-------------
          23
(1 row)


/ Intermezzo

foo=> select row('foo'::text,13);
   row    
----------
 (foo,13)
(1 row)
/ Hoe 1ste field te krijgen?
/ TODO



/ google: postgresql create type member
/ Lees	, 
http://okbob.blogspot.nl/2013/10/using-custom-composite-types-in.html

/ Einde Intermezzo

/ 13	. 

/ Einde ROW TYPES COMPOSITE TYPES

/ ALIAS FUNCTIONS WHICH RETURN A SINGLE COLUMN	, 


/ Intermezzo

foo=> select * from gs;
 generate_series 
-----------------
               1
               2
               3
(3 rows)
foo=> select s.a from gs s(a);
 a 
---
 1
 2
 3
(3 rows)



foo=> select  generate_subscripts('{{1,2,3},{4,5,6}}'::integer[],2) ;
 generate_subscripts 
---------------------
                   1
                   2
                   3
(3 rows)
foo=> select s.a from   generate_subscripts('{{1,2,3},{4,5,6}}'::integer[],2) s(a) ;		-- let op : from 	,
 a 
---
 1
 2
 3
(3 rows)

foo=>  select s from generate_subscripts('{{1,2,3},{4,5,6}}'::integer[],2) s;  		
 s 
---
 1																							-- we hadden (1) verwacht	, 
 2
 3
(3 rows)
/ Dit doet het ook	, maar 

foo=> select s from gs s;
  s  
-----
 (1)
 (2)
 (3)
(3 rows)

/ 1313	. 

/ 131313	.

/ Lees	, 
https://stackoverflow.com/questions/44257856/when-aliasing-a-function-i-do-not-see-composite-types
-> 
https://www.postgresql.org/docs/current/static/queries-table-expressions.html#QUERIES-TABLEFUNCTIONS

/ table functions

foo=> create table foo(fooid int,foosubid int,fooname text);
foo=> create function getfoo(int)returns setof foo as '
foo'> select*from foo where fooid=$1
foo'> ' language sql;
foo=> insert into foo values(1,1,'bar'),(2,1,'bar2'),(3,1,'bar3');

foo=> select*from foo;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | bar
     2 |        1 | bar2
     3 |        1 | bar3
(3 rows)

foo=> select s from getfoo(1)s;
     s     
-----------
 (1,1,bar)													-- OK	, als de table fct een composite type returns , dan OK	, 
															-- als de table fct een base type is  zien we 1 ipv (1)	, en dat was de vraag	, 
(1 row)

foo=> select s.a from getfoo(1) s(a);
 a 
---
 1
(1 row)

foo=> select s.a,s.b from getfoo(1) s(a,b);
 a | b 
---+---
 1 | 1
(1 row)

foo=> select s.a,s.b,s.c from getfoo(1) s(a,b,c);
 a | b |  c  
---+---+-----
 1 | 1 | bar
(1 row)



SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );
/ TODO

foo=> create type _2ints as (x int,y int);	 	-- as MOET	,
/ OK
foo=> create type _3ints (int,int,int);
ERROR:  must be superuser to create a base type
/ TODO




/ 131313	.

What is not covered though, is the case, when you supply a table alias, but not a column alias (for a single-columned SRF). In that case, the column alias will be the same as the table alias, so you can't access the function's row-type (composite type) explicitly (its reference is hidden by the column alias).
/ kunnen we ons voorstellen: bij een base type is er geen composite type, row	, dus de alias is de column	,  

foo=> select s.a from generate_subscripts('{{1,2,3},{4,5,6}}'::integer[],2) s ;
ERROR:  column s.a does not exist

foo=> select s.s from generate_subscripts('{{1,2,3},{4,5,6}}'::integer[],2) s ;
 s 
---
 1
 2
 3
(3 rows)

foo=> select s,a from generate_subscripts('{{1,2,3},{4,5,6}}'::integer[],2) s(a) ;
 s | a 
---+---
 1 | 1
 2 | 2
 3 | 3
(3 rows)


/ Einde Intermezzo

/ Einde ALIAS FUNCTIONS WHICH RETURN A SINGLE COLUMN	, 

/ FUNCTIONS FINAL

/ Lees	, 
https://www.postgresql.org/docs/9.1/static/xfunc-sql.html

/ Intermezzo

/ Lees	, 
https://www.postgresql.org/docs/9.4/static/datatype-geometric.html

foo=> select '(1,2)'::point;
 point 
-------
 (1,2)
(1 row)
foo=> select '(1,2.3)'::point;
  point  
---------
 (1,2.3)
(1 row)

/ Einde Intermezzo


foo=> CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);
foo=> INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

foo=> select*from emp;
 name | salary | age | cubicle 
------+--------+-----+---------
 Bill |   4200 |  45 | (2,1)
 Foo  |   3900 |  53 | (3,7)
(2 rows)

foo=> select emp from emp;
          emp           
------------------------
 (Bill,4200,45,"(2,1)")
 (Foo,3900,53,"(3,7)")
(2 rows)

/ 13	. 

foo=> create table pts2 as select '(1,2)'::point p,13 i;
/ of	,
foo=> select p,i into pts2 from (select '(1,2)'::point p,13 i)_;

create or replace function ret()returns int as $$
update  pts2 set i=13											-- GEEN ;
returning i
$$ language sql;
/ of	,
create or replace function ret()returns int as $$
update  pts2 set i=13	;
select i from pts2
$$ language sql;

foo=> select ret();
 ret 
-----
   13
(1 row)

foo=> select *from pts2;
   p   | i  
-------+----
 (1,2) | 13
(1 row)

/ Lees	, 
https://www.postgresql.org/docs/9.4/static/gist-builtin-opclasses.html
/ ~= is operation on points	,

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;


select emp from emp where cubicle ~=point '(2,1)';			 
          emp           
------------------------
 (Bill,4200,45,"(2,1)")
(1 row)
																		/ deze 2 zijn anders, 	
foo=>   select emp.* from emp where cubicle ~=point '(2,1)';
 name | salary | age | cubicle 
------+--------+-----+---------
 Bill |   4200 |  45 | (2,1)
(1 row)

/ maar	, 
foo=> select pg_typeof(emp)from emp;
/=
foo=> select pg_typeof(emp.*)from emp;	-- in functions is .*  niets	, dus emp != emp.* 	, want emp.*=emp.f1,emp.f2	, 
														-- maar in pg_typeof is WH emp.*=emp	,
 pg_typeof 
-----------
 emp
 emp
(2 rows)
/ TODO
																		/ Maar als je double_salary calls 	, dan maakt het niet uit	, 
foo=>   select double_salary(emp) from emp where cubicle ~=point '(2,1)';
/=
foo=>   select double_salary(emp.*) from emp where cubicle ~=point '(2,1)';
 double_salary 
---------------
          8400
(1 row)


create function double_salary(emp)returns numeric as $$ 	-- vergeet niet: function
	select $1.salary*2 as salary;							-- geen: begin, end; 	geef: select	, niet : return
$$ language sql;

=> select double_salary(emp.*);
ERROR:  missing FROM-clause entry for table "emp"
foo=> select double_salary(emp);
ERROR:  column "emp" does not exist

foo=> select row(name, salary*1.1, age, cubicle) from emp;
/=
foo=> select (name, salary*1.1, age, cubicle) from emp;
           row            
--------------------------
 (Bill,4620.0,45,"(2,1)")
(1 row)

foo=>  select pg_typeof(row(name, salary*1.1, age, cubicle)) from emp;
/=
foo=>  select pg_typeof((name, salary*1.1, age, cubicle)) from emp;
 pg_typeof 
-----------
 record
 record
(2 rows)

foo=>  select double_salary(row(name, salary*1.1, age, cubicle)) from emp;
/=
foo=>  select double_salary((name, salary*1.1, age, cubicle)) from emp;
 double_salary 
---------------
        9240.0
        8580.0
(2 rows)




/ 13	. 

foo=> select row('Foo',3900,53,'(3,7)');
          row          
-----------------------
 (Foo,3900,53,"(3,7)")
(1 row)

foo=> insert into emp values(row('Foo',3900,53,'(3,7)'));
/ of	,
foo=> insert into emp values(('Foo',3900,53,'(3,7)'));
INSERT 0 1
foo=> select*from emp;
         name          | salary | age  | cubicle 
-----------------------+--------+------+---------
 Bill                  |   4200 |   45 | (2,1)
 (Foo,3900,53,"(3,7)") |   NULL | NULL | NULL
(2 rows)
/ dit was niet de bedoeling	, 

/ 13	. 

foo=> select row(name, salary*1.1, age, cubicle) from emp;
           row            
--------------------------
 (Bill,4620.0,45,"(2,1)")
(1 row)
foo=> SELECT name, double_salary(row(name, salary*1.1, age, cubicle)) AS dream
/=
foo=> SELECT name, double_salary((name, salary*1.1, age, cubicle)) AS dream
foo->     FROM emp;
 name | dream  
------+--------
 Bill | 9240.0
(1 row)


=> SELECT name, double_salary(name, salary*1.1, age, cubicle) AS dream
    FROM emp;
ERROR:  function double_salary(text, numeric, integer, point) does not exist

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/ Je kunt emp of emp.* geven als arg aan double_salary	, of een record	, row(name, salary*1.1, age, cubicle) , niet name, salary*1.1, age, cubicle
/ want

/ Lees	, 
https://www.postgresql.org/docs/9.3/static/rowtypes.html
In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row.

/ in fct doet .* niets	, dus in fct is emp=emp.*	,  en hierboven staat dat emp niet de table is	, maar een composite value	, een row	, 
/ in select is emp.*=f1,f2,f3 	, dus maar dit dan geen arg zijn van double_salary	, dus als in een fct emp.*=f1,f2,f3	, dan had het wel gekund	,

/ 13	.

foo=>create function my_add(int,int)returns int as $$
	select $1+$2;
$$ language sql;
foo=> select my_add(3,7);
 my_add 
--------
     10
(1 row)
/ 2 keer select	, 
/ TODO

/ 13	. 

create or replace function new_emp() returns emp as $$
    select text 'None' as name,
        1000.0 as salary,
        25 as age,
        point '(2,2)' as cubicle;
$$ language sql; 
/=
create or replace function new_emp() returns emp as $$
    select 'None'::text, 1000.0 , 25 , '(2,1)'::point							-- ::text en ::point moet	,
$$ language sql; 


foo=> select new_emp();
         new_emp          
--------------------------
 (None,1000.0,25,"(2,2)")													-- "" om (2,2) komt uit de composite type module
(1 row)


foo=> select pg_typeof(new_emp());
 pg_typeof 
-----------
 emp
(1 row)

foo=> select (new_emp()).name;
 name 
------
 None
(1 row)

/ 13	.

/ Als we een fct(emp) maken	, is het arg een composite value	, see	, 
https://www.postgresql.org/docs/9.3/static/rowtypes.html	, 8.16.5. Using Composite Types in Queries

create function getname(emp)returns text as '
	select $1.name
' language sql;

select getname(new_emp());
 getname 
---------
 None
(1 row)

/ 13	. 

create function sum_n_product(x int,y int, out sum int, out product int) as '
	select x+y,x*y
' language sql;

select sum_n_product(11,42)s_n_p;
/=
foo=> select s_n_p from sum_n_product(11,42)s_n_p;
  s_n_p   
---------------
 (53,462)
(1 row)

/ we kunnen ipv out ook return	, 
/ in dit geval 2 outs	, dus moeten we zelf een type create	, en die return	, 

create type _2ints as(
	sum int,								-- names zoals sum MOET	,
	product int
);
create function sum_n_product2(x int,y int)returns _2ints as '
	select $1+$2,x*y
' language sql;
foo=> select sum_n_product2(11,42);
 sum_n_product2 
----------------
 (53,462)
(1 row)
eric=> select sum from sum_n_product2(11,42);            	-- hier use de name van de column	,  
 sum 
-----
  53
(1 row)


/ 13	. 

/ variadic

/ variadic arr integer[] : variable aantal args	,

create or replace function mleast(variadic numeric[])returns numeric as '
	select min($1[a]) from generate_subscripts($1,1) gs(a)
' language sql;
foo=> select mleast(10,-1, 3,7);
 mleast 
--------
     -1
(1 row)

/ 1313	. 

/ par 36.4.5 van 9.6

/ met variadic kunnen we alleen een list van numerics geven, en een array alleen als we variadic erbij schrijven:

drop function mleast2(numeric[]); 
create or replace function mleast2(variadic numeric[])returns numeric[] as '			-- WEL variadic
  select $1 from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2(10,-1,3,7);
   mleast2   
-------------
 {10,-1,3,7}
(1 row)
eric=> select pg_typeof(mleast2(10,-1,3,7));
 pg_typeof 
-----------
 numeric[]

(1 row)

/ we kunnen ook: 
eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
   mleast2   
-------------
 {10,-1,3,7}
(1 row)

/ want	zonder:
eric=> select mleast2('{10,-1,3,7}'::numeric[]);
ERROR:  function mleast2(numeric[]) does not exist


drop function mleast2(numeric[]); 
create or replace function mleast2(numeric[])returns numeric[] as '			-- GEEN variadic
  select $1 from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
/ of	,
eric=> select mleast2('{10,-1,3,7}'::numeric[]);
   mleast2   
-------------
 {10,-1,3,7}
(1 row)

eric=> select mleast2(10,-1,3,7);
ERROR:  function mleast2(integer, integer, integer, integer) does not exist

/ 1313	. 

/ je return type moet OK zijn	, 
/ als je alle values wilt zien in een fct	, dus net als bij select wat we altijd doen	, moet je in de return type: setof	,
/ doe je GEEN setof	, dan zie je alleen de 1ste	,
/ returns setof integer != returns integer[]	,  je krijgt dan een 1 composite type terug	, {10,-1,3,7}

drop function mleast2(numeric[]); 
create or replace function mleast2(numeric[])returns setof integer as '					-- WEL setof	 !
  select a from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2('{10,-1,3,7}'::numeric[]);
 mleast2 
---------
       1
       2
       3
       4
(4 rows)

drop function mleast2(numeric[]); 
create or replace function mleast2(numeric[])returns integer as '					-- GEEN setof	 !
  select a from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2('{10,-1,3,7}'::numeric[]);
 mleast2 
---------
       1
(1 row)

drop function mleast2(numeric[]); 
create or replace function mleast2(variadic numeric[])returns numeric[] as '					-- numeric[] 
  select $1
' language sql;

drop function mleast2(numeric[]); 
create or replace function mleast2(variadic numeric[])returns numeric[] as '					-- numeric[] 
  select $1
' language sql;

eric=> select mleast2(10,-1, 3,7);
   mleast2   
-------------
 {10,-1,3,7}
(1 row)

eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
   mleast2   
-------------
 {10,-1,3,7}

/ 131313	. 

drop function mleast2(numeric[]); 
create or replace function mleast2(variadic numeric[])returns setof numeric[] as '					-- setof numeric[] 
  select $1
' language sql;
/ Verzin een goed voorbeeld	,



/ 1313	. 

/ max, min op subscripts, en op array	, zonder variadic	,

drop function mleast2(numeric[]); 
create or replace function mleast2(numeric[])returns integer as '		
  select max(a) from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2('{10,-1,3,7}'::numeric[]);
 mleast2 
---------
       4
(1 row)

drop function mleast2(numeric[]); 
create or replace function mleast2(numeric[])returns numeric as '		
  select max($1[a]) from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2('{10,-1,3,7}'::numeric[]);
 mleast2 
---------
      10
(1 row)

drop function mleast2(numeric[]); 
create or replace function mleast2(numeric[])returns numeric as '		
  select min($1[a]) from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2('{10,-1,3,7}'::numeric[]);
 mleast2 
---------
      -1
(1 row)

/ 1313	. 

/ max, min op subscripts, en op array	, met variadic	,

/ 131313	.

/ set

drop function mleast2(numeric[]); 
create or replace function mleast2(variadic numeric[])returns setof integer as '					-- WEL setof	 !
  select a from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
 mleast2 
---------
       1
       2
       3
       4
(4 rows)

eric=> select mleast2(-10,-1,3,7);
 mleast2 
---------
       1
       2
       3
       4
(4 rows)


/ 131313	.

drop function mleast2(numeric[]); 
create or replace function mleast2(variadic numeric[])returns integer as '		
  select max(a) from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2('{10,-1,3,7}'::numeric[]);
ERROR:  function mleast2(numeric[]) does not exist

eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
 mleast2 
---------
       4
(1 row)

eric=> select mleast2(-10,-1,3,7);
 mleast2 
---------
       4
(1 row)

/ 131313	.

drop function mleast2(numeric[]); 
create or replace function mleast2(variadic numeric[])returns numeric as '		
  select max($1[a]) from generate_subscripts($1,1) gs(a)
' language sql;

eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
 mleast2 
---------
      10
(1 row)

eric=> select mleast2(10,-1,3,7);
 mleast2 
---------
      10
(1 row)


drop function mleast2(numeric[]); 
create or replace function mleast2(numeric[])returns numeric as '		
  select min($1[a]) from generate_subscripts($1,1) gs(a)
' language sql;


eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
 mleast2 
---------
      -1
(1 row)
eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
 mleast2 
---------
      -1
(1 row)


/ 1313	. 

eric=> select min('{1,-1}'::int[]);
  min   
--------
 {1,-1}
(1 row)

/ 1313	.

/ setof of niet	,

drop function mleast2(numeric[]);
create or replace function mleast2(variadic numeric[])returns numeric as '
  select $1[a] from generate_subscripts($1,1) a
' language sql;

select mleast2(10,-1, 3,7);
 mleast2 
---------
      10
(1 row)

drop function mleast2(numeric[]);
create or replace function mleast2(variadic numeric[])returns setof numeric as '
  select $1[a] from generate_subscripts($1,1) a
' language sql;

eric=> select mleast2(variadic '{10,-1,3,7}'::numeric[]);
 mleast2 
---------
      10
      -1
       3
       7
(4 rows)


/ 1313	. 

create or replace function mleast(variadic numeric[])returns numeric as '
	select min($1[a]) from generate_subscripts($1,1) a 
' language sql;
eric=> select mleast(10,-1, 3,7);
 mleast 
--------
     -1
(1 row)


/ 13	. 

eric=> create table tab(i int,j int);
eric=> insert into tab values (1, 2), (3, 4), (5, 6), (7, 8);

drop function if exists s_n_p_with_tab(int);
create function s_n_p_with_tab(int,out int,out int) returns setof record as '		-- out int	, out int MOET
	select $1+i,$1+j 																									-- or: select $1+tab.i,$1+tab.j
	from tab
' language sql;
create function s_n_p_with_tab(int,out int,out int) returns setof record as '		-- out int	, out int MOET
	select $1+i,$1+j
	from tab
' language sql;

select*from s_n_p_with_tab(10);

eric=> select*from s_n_p_with_tab(10);
 column1 | column2 
---------+---------
      11 |      12
      13 |      14
      15 |      16
      17 |      18
(4 rows)

/ Als we de out's weglaten	, 
eric=> create function s_n_p_with_tab(int) returns setof record as '
  select $1+tab.i,$1+tab.j
  from tab
' language sql;
/ OK
eric=> select*from s_n_p_with_tab(10);
ERROR:  a column definition list is required for functions returning "record"

/ 1313

/ we hadden eerder 
create type _2ints(i int,j int);

drop function if exists s_n_p_with_2ints(int);
create function s_n_p_with_2ints(int) returns setof _2ints as '			-- GEEN 2 out	,	 
																																		-- we hebben de columns al def in de type	, 
	select $1+i,$1+j
	from tab 
' language sql;

select*from s_n_p_with_2ints(10);
 sum | product 
-----+---------
  11 |      12
  13 |      14
  15 |      16
  17 |      18
(4 rows)

/ we kunnen NIET met een composite type	, 
eric=> insert into _2ints values (1, 2), (3, 4), (5, 6), (7, 8);
ERROR:  "_2ints" is a composite type
/ we kunnen ook niet	, 
	select $1+i,$1+j
	from _2ints 



eric=> insert into _2ints values (1, 2), (3, 4), (5, 6), (7, 8);

	







/ 13	. 

foo=> select * into emp2 from new_emp();
SELECT 1
foo=> select*from emp2;
 name | salary | age | cubicle 
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)
(1 row)

foo=> \d emp2;
      Table "public.emp2"
 Column  |  Type   | Modifiers 
---------+---------+-----------
 name    | text    | 
 salary  | numeric | 
 age     | integer | 
 cubicle | point   | 

/ Einde FUNCTIONS FINAL





/ 13	. 

/ Lees	, 
https://www.postgresql.org/docs/9.1/static/functions-srf.html

/ Lees 
https://www.postgresql.org/docs/8.4/static/datatype-pseudo.html
anyarray
anyelement


select generate_subscripts('{{1,2,3},{3,4,5}}'::int[],1);
 generate_subscripts 
---------------------
                   1
                   2
(2 rows)
select generate_subscripts('{{1,2,3},{3,4,5}}'::int[],2);
 generate_subscripts 
---------------------
                   1
                   2
                   3
(3 rows)

select generate_subscripts('{{1,2,3},{3,4,5}}'::int[],2) _(1);

-- unnest a 2D array
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql; 

foo=> select unnest2(array[[11,12,13],[24,25,26]]);
 unnest2 
---------
      11
      12
      13
      24
      25
      26
(6 rows)

/ 13. 

select s.a from generate_series(0,14,7) as s(a);

/ 13	. 

foo=> select * from generate_series(0,2);
/ of	,
foo=> select generate_series(0,2);			-- het kan allebei	,
 generate_series 
-----------------
               0
               1
               2
(3 rows)

//////////////////////////////////////////////////////////////
/ Let op verschil	,

foo=> select generate_series(1,2),md5(cast(random()as text));
 generate_series |               md5                
-----------------+----------------------------------
               1 | 0bbfa0c1f370cdbcdc1f59891d6b58d4
               2 | 707a8995c7e91ac8dc6a43ec33e45628
(2 rows)

foo=> select * from generate_series(1,2),md5(cast(random()as text));
 generate_series |               md5                
-----------------+----------------------------------
               1 | 9f01028877e5dd8a041eaeed8b28c499
               2 | 9f01028877e5dd8a041eaeed8b28c499
(2 rows)

/ 13	. 




/ 13	. 

foo=> select * from generate_series(0,2) as t(a,b);
ERROR:  too many column aliases specified for function generate_series

select generate_series(1,10),md5(random()::text);

foo=> select *from generate_series(1,10),md5(random()::text) as s(a,b);
ERROR:  too many column aliases specified for function md5
foo=> select *from generate_series(1,10)as s(a),md5(random()::text) as s(b);
ERROR:  table name "s" specified more than once
foo=> select *from generate_series(1,10) join md5(random()::text) ;
ERROR:  syntax error at or near ";"


foo=> select * into gs from generate_series(1,3);
/ OK

/ vergl met 	,
	select into total sum(list[i]) from generate_subscripts(list,1)g(i);		-- g is alias	, _(i) is ook OK	,
	select into average avg(list[i]) from generate_subscripts(list,1)g(i);

foo=> select * into gs2 from generate_series(1,10),md5(random()::text);
/ OK

foo=> select * from md5(random()::text);
               md5                
----------------------------------
 f47c79217f5415e151207f1a7ffe44a9
(1 row)

foo=> select * into rd from md5(random()::text);
/ OK

/ 13	. 

/ we hadden	, 
foo=> select * into gs from generate_series(1,3);
foo=> select * into rd from md5(random()::text);

foo=> select s.a,t.b from gs as s(a),rd as t(b) ;
 a |                b                 
---+----------------------------------
 1 | f807a37f8f8e2157ec36c8c0cc67bcf3
 2 | f807a37f8f8e2157ec36c8c0cc67bcf3
 3 | f807a37f8f8e2157ec36c8c0cc67bcf3
(3 rows)

foo=> select s.a,b from gs as s(a),rd as b ; 
 a |                 b                  
---+------------------------------------
 1 | (f807a37f8f8e2157ec36c8c0cc67bcf3)
 2 | (f807a37f8f8e2157ec36c8c0cc67bcf3)
 3 | (f807a37f8f8e2157ec36c8c0cc67bcf3)
(3 rows)

foo=> select a,b from gs as a,rd as b ; 
  a  |                 b                  
-----+------------------------------------
 (1) | (f807a37f8f8e2157ec36c8c0cc67bcf3)
 (2) | (f807a37f8f8e2157ec36c8c0cc67bcf3)
 (3) | (f807a37f8f8e2157ec36c8c0cc67bcf3)
(3 rows)

foo=> select pg_typeof(s.a),pg_typeof(t.b) from gs as s(a),rd as t(b) ;
 pg_typeof | pg_typeof 
-----------+-----------
 integer   | text
 integer   | text
 integer   | text
(3 rows)

foo=> select pg_typeof(s.a),pg_typeof(b) from gs as s(a),rd as b ;
 pg_typeof | pg_typeof 
-----------+-----------
 integer   | rd
 integer   | rd
 integer   | rd
(3 rows)

foo=> select pg_typeof(a),pg_typeof(b) from gs as a,rd as b ;
 pg_typeof | pg_typeof 
-----------+-----------
 gs        | rd
 gs        | rd
 gs        | rd
(3 rows)

/ 1313	. 

foo=> select s.a,t.* from gs as s(a),rd as t ;
 a |               md5                
---+----------------------------------
 1 | f807a37f8f8e2157ec36c8c0cc67bcf3
 2 | f807a37f8f8e2157ec36c8c0cc67bcf3
 3 | f807a37f8f8e2157ec36c8c0cc67bcf3
(3 rows)

foo=> select s.a,pg_typeof(t.*) from gs as s(a),rd as t ;
 a | pg_typeof 
---+-----------
 1 | rd
 2 | rd
 3 | rd
(3 rows)

/ TODO (Klopt niet met elkaar)	, 

/ 1313	,

foo=> select * into gs3 from generate_series(0,2); 
SELECT 3
foo=> select s from gs3 as s ;
  s  
-----
 (0)
 (1)
 (2)
(3 rows)

foo=>  select * into gs4 from generate_series(0,2) as s; 
SELECT 3
foo=> select s from gs4 as s;	/ WH doet deze alias niets, TODO	
/=
foo=> select s from gs4; 
 s 
---
 0
 1
 2
(3 rows)
foo=> select t from gs4 as t;
  t  
-----
 (0)
 (1)
 (2)
(3 rows)
foo=> select t.s from gs4 as t;
 s 
---
 0
 1
 2
(3 rows)

/ Lees	, 
https://www.w3schools.com/sql/sql_alias.asp
/ we kunnen tables of columns alias	,

/ Alias Column Syntax
SELECT column_name AS alias_name
FROM table_name;

/ Alias Table Syntax
SELECT column_name(s)
FROM table_name AS alias_name;


foo=> \d gs3
          Table "public.gs3"
     Column      |  Type   | Modifiers 
-----------------+---------+-----------
 generate_series | integer | 

foo=> \d gs4
      Table "public.gs4"
 Column |  Type   | Modifiers 
--------+---------+-----------
 s      | integer | 

foo=> select pg_typeof(t) from gs4 as t;
 pg_typeof 
-----------
 gs4
 gs4
 gs4
(3 rows)
foo=> select pg_typeof(s) from gs4 as s;
 pg_typeof 
-----------
 integer
 integer
 integer
(3 rows)

/ Maar	, 

foo=> SELECT a  FROM generate_series(0,14,7) AS a;
 a  
----
  0
  7
 14
(3 rows)

foo=> SELECT pg_typeof(a)  FROM generate_series(0,14,7) AS a;
 pg_typeof 
-----------
 integer
 integer
 integer
(3 rows)
/ Het is alsof generate_series(0,14,7) een table is met column a	, 
/ TODO

/ 1313	. 

foo=> SELECT s FROM generate_series(0,14,7) s;
 s  
----
  0
  7
 14
(3 rows)
/ Het is dus alsof generate_series(0,14,7) een table is met column s	, 
/ want	, 

foo=> select * into gs3 from generate_series(0,2); 
foo=>  select * into gs4 from generate_series(0,2) as s; 
/ g4 heeft column name s	, g3 niet	, 


/ gs3 identies aan gs	,




/ 1313	. 

CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[]						-- text[][] hoeft WH niet	,
);
INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');

foo=> select*from sal_emp;
 name  |      pay_by_quarter       |                 schedule                 
-------+---------------------------+------------------------------------------
 Carol | {20000,25000,25000,25000} | {{breakfast,consulting},{meeting,lunch}}
(1 row)
foo=> select generate_subscripts(schedule,1) from sal_emp;
 generate_subscripts 
---------------------
                   1
                   2
(2 rows)
foo=> select generate_subscripts(schedule,2) from sal_emp;
 generate_subscripts 
---------------------
                   1
                   2
(2 rows)


/ 1313	. 


foo=> SELECT s FROM gs3 s;
  s  
-----
 (0)
 (1)
 (2)
(3 rows)

foo=> select s from gs4;
 s 
---
 0
 1
 2
(3 rows)


foo=> SELECT t FROM gs4 t;
  t  
-----
 (0)
 (1)
 (2)
(3 rows)

foo=> SELECT t.s FROM gs4 t;
 s 
---
 0
 1
 2
(3 rows)








/ 13	. 

foo=> select s.* from gs as s;
/ of	,
foo=> select s.a from gs as s(a);

 generate_series 
-----------------
               1
               2
               3
(3 rows)
foo=> select s from gs as s;
  s  
-----
 (1)
 (2)
 (3)
(3 rows)
/ TODO

/ 13	. 

CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j] from generate_subscripts($1,1) g1(i), generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql; 

CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS table (i1 int, i2 int, e int) AS $$
select i,j,$1[i][j] from generate_subscripts($1,1) g1(i), generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql; 

foo=> select unnest2('{{1,2,3},{4,5,6}}'::int[]);
 unnest2 
---------
 (1,1,1)
 (1,2,2)
 (1,3,3)
 (2,1,4)
 (2,2,5)
 (2,3,6)
(6 rows)


CREATE OR REPLACE FUNCTION unnest2(int[])
RETURNS table (_ int, _2 int, _3 int) AS $$
select a,b,$1[a][b] from generate_subscripts($1,1) g(a), generate_subscripts($1,2) h(b);
$$ LANGUAGE sql; 






/ 13	.

/ Als 
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1),
        generate_subscripts($1,2);
$$ LANGUAGE sql; 

/ 7	. 




 


/ Einde STORED PROCEDURES

/ TRIGGERS

/ Lees	,
https://www.tutorialspoint.com/postgresql/postgresql_triggers.htm

/ Einde TRIGGERS

/ ARRAYS

/ 7	. 

/ betekenis dimension arg in generate_subscripts

foo=> create table arrays2(i int[][]);
foo=> insert into arrays2 values('{{1,2,3},{4,5,6}}'::int[][]);
foo=> select generate_subscripts(i,1) from arrays2; 
 generate_subscripts 
---------------------
                   1
                   2
(2 rows)

foo=> select generate_subscripts(i,2) from arrays2; 
 generate_subscripts 
---------------------
                   1
                   2
                   3
(3 rows)



/ Einde ARRAYS

/ JOINS

/ 7	. 

foo=> create table s4(i int unique);
CREATE TABLE
foo=> create table t4(j int references s4(i));
CREATE TABLE

foo=> create table s4(i int unique);
foo=> create table t4(j int references s4);
ERROR:  there is no primary key for referenced table "s4"
/ Als we geen column geven waarnaar we ref	, verwacht pg een primary key	,

foo=> select *from s4 s join t4 t on s.i=t.j;
/ Dus we alias rows	, 

foo=> select s,t from s4 s join t4 t on s.i=t.j;
  s  |  t  
-----+-----
 (7) | (7)
(1 row)





/ Einde JOINS

