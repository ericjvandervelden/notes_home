/ JDBC BATCH PREPARE

/ 7     .

/ batch statements

/ Lees  ,
http://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html

/ Lees  ,
http://docs.oracle.com/javase/tutorial/jdbc/basics/retrieving.html

[eric@localhost prepare]$ pwd
/home/eric/Devel/Java/Jdbc/prepare
[eric@localhost prepare]$ java -cp .:../postgresql-9.3-1102.jdbc4.jar first

/ in first.java	,

/ basic jdbc	,

        try{
                String url="jdbc:postgresql://localhost/foo?user=foo&password=foo";
                Connection con=DriverManager.getConnection(url);
                con.setAutoCommit(false);

                Statement stmt=con.createStatement();
                String dml="delete from pre";
                stmt.executeUpdate(dml);

                dml="insert into pre values(1,'foo'||1)";
                stmt.executeUpdate(dml);

                dml="create table if not exists pro(id int, name varchar(32))";
                stmt.executeUpdate(dml);

                //con.rollback();
                con.commit();

                dml="select*from pre";
                ResultSet rs=stmt.executeQuery(dml);
                while(rs.next()){
                        int id=rs.getInt("id");
                        String str=rs.getString("str");
                        System.out.println(id+":"+str);
                }



/ in batch.java ,

                String url="jdbc:postgresql://localhost/foo?user=foo&password=foo";
                Connection con=DriverManager.getConnection(url);
                con.setAutoCommit(false);

                Statement stmt=con.createStatement();
                String dml="delete from pre";
                stmt.addBatch(dml);
                dml="insert into pre values(1,'foo'||1)";
                stmt.addBatch(dml);
                dml="insert into pre values(2,'foo'||2)";
               	stmt.addBatch(dml);

                int[]cnt=stmt.executeBatch();
                //stmt.executeUpdate(dml);

                con.rollback();
                //con.commit();

/  we moeten    ,
                int[]cnt=stmt.executeBatch();
/ ipv   ,
                stmt.executeUpdate(dml);

/ 7     .

/ in prepare.java

                String url="jdbc:postgresql://localhost/foo?user=foo&password=foo";
                Connection con=DriverManager.getConnection(url);
                con.setAutoCommit(false);

                Statement stmt=con.createStatement();
                String dml="delete from pre";
                stmt.executeUpdate(dml);

                dml="insert into pre values(?,?)";
                PreparedStatement pstmt=con.prepareStatement(dml);
                pstmt.setInt(1,1);
                pstmt.setString(2,"'foo'||1");

                //stmt.executeUpdate(dml);
                pstmt.executeUpdate();

                dml="select*from pre";
                ResultSet rs=stmt.executeQuery(dml);
                while(rs.next()){
                        int id=rs.getInt("id");
                        String str=rs.getString("str");
                        System.out.println(id+":"+str);
                }

                //con.rollback();
                con.commit();

/ we moeten 	,
                pstmt.executeUpdate();
/ ipv,
                stmt.executeUpdate(dml);

/ Als we rollback, geeft de query toch 1:foo||1
/ TODO

                pstmt.setString(2,"'foo'||1");
/ Geeft foo||1 ipv foo1	,
/ TODO

/ 7	.

/ prepare & batch	,

/ in preparebatch.java	,

                String url="jdbc:postgresql://localhost/foo?user=foo&password=foo";
                Connection con=DriverManager.getConnection(url);
                con.setAutoCommit(false);

                String dml="delete from pre";
                PreparedStatement pstmt=con.prepareStatement(dml);
                pstmt.addBatch();
                int[]cnt=pstmt.executeBatch();

                dml="insert into pre values(?,?)";
                PreparedStatement pstmt2=con.prepareStatement(dml);
                pstmt2.setInt(1,1);
                pstmt2.setString(2,"foo");
                pstmt2.addBatch();
                pstmt2.setInt(1,2);
                pstmt2.setString(2,"bar");
                pstmt2.addBatch();
                cnt=pstmt2.executeBatch();

                //con.rollback();
                con.commit();

                Statement stmt=con.createStatement();
                dml="select*from pre";
                ResultSet rs=stmt.executeQuery(dml);
                while(rs.next()){
                        int id=rs.getInt("id");
                        String str=rs.getString("str");
                        System.out.println(id+":"+str);
                }

/ een select kan niet een prepared statement	,

/ SAMENVATTING

/ basic	,
                Statement stmt=con.createStatement();
                stmt.executeUpdate(dml);
/ prepare	,
                PreparedStatement pstmt=con.prepareStatement(dml);
                pstmt.executeUpdate();
/ batch	,
                Statement stmt=con.createStatement();
                stmt.executeBatch();
/ prepare & batch	,
                PreparedStatement pstmt=con.prepareStatement(dml);
                pstmt.executeUpdate();

/ uitgebreider	,

/ first	,
                Statement stmt=con.createStatement();
                String dml="delete from pre";
                stmt.executeUpdate(dml);

/ prepare	,
              	String dml="insert into pre values(?,?)";
                PreparedStatement pstmt=con.prepareStatement(dml);
                pstmt.setInt(1,1);
                pstmt.setString(2,"'foo'||1");
                pstmt.executeUpdate();
                pstmt.setInt(1,2);
                pstmt.setString(2,"'foo'||2");
                pstmt.executeUpdate();

/ batch	,
              	Statement stmt=con.createStatement();
                String dml="delete from pre";
                stmt.addBatch(dml);
                dml="insert into pre values(1,'foo'||1)";
                stmt.addBatch(dml);
                dml="insert into pre values(2,'foo'||2)";
                stmt.addBatch(dml);
                int[]cnt=stmt.executeBatch();

/ prepare & batch	,
                String dml="insert into pre values(?,?)";
                PreparedStatement pstmt2=con.prepareStatement(dml);
                pstmt2.setInt(1,1);
                pstmt2.setString(2,"foo");
                pstmt2.addBatch();
                pstmt2.setInt(1,2);
                pstmt2.setString(2,"bar");
                pstmt2.addBatch();
                cnt=pstmt2.executeBatch();


 



/ Einde SAMENVATTING

/ Einde JDBC BATCH PREPARE

/ JDBC DEBUG

/ Lees	, 
http://stackoverflow.com/questions/310720/get-source-jar-files-attached-to-eclipse-for-maven-managed-dependencies

/ right click project in explorer, 
Maven 
	Download Sources

/ we zien 	,
[eric@localhost Jdbc]$ ls ~/.m2/repository/org/postgresql/postgresql/9.3-1102-jdbc41/
m2e-lastUpdated.properties
_maven.repositories
postgresql-9.3-1102-jdbc41.jar
postgresql-9.3-1102-jdbc41.jar.sha1
postgresql-9.3-1102-jdbc41.pom
postgresql-9.3-1102-jdbc41.pom.sha1
postgresql-9.3-1102-jdbc41-sources.jar
postgresql-9.3-1102-jdbc41-sources.jar.sha1
_remote.repositories

/ NIET werkte	,
Window, preferences
Maven
	Download Artifact Sources
/ TODO

/ Lees	,
http://stackoverflow.com/questions/2059431/get-source-jars-from-maven-repository

mvn dependency:sources
/ of	,
mvn dependency:resolve -Dclassifier=javadoc

/ MISSCHIEN OOK	,
/ selecteer project, jdbc bijv	,
Project, properties, Java Build Path
	Libraries , Maven dependencies	,
Kies postgres-9.3-1102-jdbc41.jar, click +
Source Attachment
/ Hier kunnen we een local source.jar add	, maar die uit de Maven repo hierboven staat er al bij	,

/ we install 
[eric@localhost hibernate-book-tmp]$ sudo yum install java-1.7.0-openjdk-src

Installing:
 java-1.7.0-openjdk-src                    x86_64               1:1.7.0.65-2.5.1.2.fc20               updates                39 M
Updating for dependencies:
 java-1.7.0-openjdk                        x86_64               1:1.7.0.65-2.5.1.2.fc20               updates               214 k
 java-1.7.0-openjdk-devel                  x86_64               1:1.7.0.65-2.5.1.2.fc20               updates               9.2 M
 java-1.7.0-openjdk-headless               x86_64               1:1.7.0.65-2.5.1.2.fc20               updates                25 M

Warning: RPMDB altered outside of yum.
  Updating   : 1:java-1.7.0-openjdk-1.7.0.65-2.5.1.2.fc20.x86_64                                                              1/7 
  Updating   : 1:java-1.7.0-openjdk-headless-1.7.0.65-2.5.1.2.fc20.x86_64                                                     2/7 
  Updating   : 1:java-1.7.0-openjdk-devel-1.7.0.65-2.5.1.2.fc20.x86_64                                                        3/7 
  Installing : 1:java-1.7.0-openjdk-src-1.7.0.65-2.5.1.2.fc20.x86_64                                                          4/7 
  Cleanup    : 1:java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64                                                              5/7 
  Cleanup    : 1:java-1.7.0-openjdk-headless-1.7.0.60-2.4.7.0.fc20.x86_64                                                     6/7 
  Cleanup    : 1:java-1.7.0-openjdk-devel-1.7.0.60-2.4.7.0.fc20.x86_64                                                        7/7 
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/tapset/jstack-1.7.0.60-2.4.7.0.fc20.stp: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/tapset/hotspot_jni-1.7.0.60-2.4.7.0.fc20.stp: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/tapset/hotspot_gc-1.7.0.60-2.4.7.0.fc20.stp: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/tapset/hotspot-1.7.0.60-2.4.7.0.fc20.stp: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/tapset: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/tools.jar: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/sa-jdi.jar: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/orb.idl: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/jexec: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/jconsole.jar: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/ir.idl: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/dt.jar: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/ct.sym: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/amd64/jli/libjli.so: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/amd64/jli: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib/amd64: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/lib: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/linux/jni_md.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/linux/jawt_md.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/linux: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/jvmticmlr.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/jvmti.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/jni.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/jdwpTransport.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/jawt.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include/classfile_constants.h: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/include: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/xjc: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/wsimport: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/wsgen: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/unpack200: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/tnameserv: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/servertool: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/serialver: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/schemagen: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/rmiregistry: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/rmid: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/rmic: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/policytool: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/pack200: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/orbd: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/native2ascii: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/keytool: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jstatd: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jstat: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jstack: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jsadebugd: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jrunscript: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jps: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jmap: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jinfo: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jhat: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jdb: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jconsole: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jcmd: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/javap: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/javah: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/javadoc: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/javac: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/java-rmi.cgi: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/java: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jarsigner: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/jar: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/idlj: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/extcheck: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/apt: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin/appletviewer: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/bin: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/THIRD_PARTY_README: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/LICENSE: remove failed: No such file or directory
warning: file /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64/ASSEMBLY_EXCEPTION: remove failed: No such file or directory
  Verifying  : 1:java-1.7.0-openjdk-src-1.7.0.65-2.5.1.2.fc20.x86_64                                                          1/7 
  Verifying  : 1:java-1.7.0-openjdk-devel-1.7.0.65-2.5.1.2.fc20.x86_64                                                        2/7 
  Verifying  : 1:java-1.7.0-openjdk-1.7.0.65-2.5.1.2.fc20.x86_64                                                              3/7 
  Verifying  : 1:java-1.7.0-openjdk-headless-1.7.0.65-2.5.1.2.fc20.x86_64                                                     4/7 
  Verifying  : 1:java-1.7.0-openjdk-headless-1.7.0.60-2.4.7.0.fc20.x86_64                                                     5/7 
  Verifying  : 1:java-1.7.0-openjdk-devel-1.7.0.60-2.4.7.0.fc20.x86_64                                                        6/7 
  Verifying  : 1:java-1.7.0-openjdk-1.7.0.60-2.4.7.0.fc20.x86_64                                                              7/7 

Installed:
  java-1.7.0-openjdk-src.x86_64 1:1.7.0.65-2.5.1.2.fc20                                                                           

Dependency Updated:
  java-1.7.0-openjdk.x86_64 1:1.7.0.65-2.5.1.2.fc20                 java-1.7.0-openjdk-devel.x86_64 1:1.7.0.65-2.5.1.2.fc20       
  java-1.7.0-openjdk-headless.x86_64 1:1.7.0.65-2.5.1.2.fc20       

Complete!

/ Nu als in eclipse, dan valt hij in src code van java.sql.DriverManager	,

/ 7	. 

/ first.java	,

		String url="jdbc:postgresql://localhost/foo?user=foo&password=foo";
		Connection con=DriverManager.getConnection(url);
		con.setAutoCommit(false);

		Statement stmt=con.createStatement();
		String dml="delete from pre";
		stmt.executeUpdate(dml);
			
		dml="insert into pre values(1,'foo'||1)";
		stmt.executeUpdate(dml);

		dml="create table if not exists pro(id int, name varchar(32))";
		stmt.executeUpdate(dml);
			
	

		dml="select*from pre";
		ResultSet rs=stmt.executeQuery(dml);
		while(rs.next()){
			int id=rs.getInt("id");
			String str=rs.getString("str");
			System.out.println(id+":"+str);
		}

		//con.rollback();	
		con.commit();

/ we nemen in pom.xml	,

<!-- <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>9.3-1102-jdbc41</version>
</dependency> -->

<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>9.3-1102-jdbc3</version>
</dependency> 

/ want in de source van 9.3-1102-jdbc41 of 9.3-1102-jdbc4 zit NIET 	,
package org.postgresql.jdbc3g;
public abstract class AbstractJdbc3gConnection extends org.postgresql.jdbc3.AbstractJdbc3Connection


/ We gaan debug	,
		Connection con=DriverManager.getConnection(url);
/s
 /OpenJDK
DriverManager.getConnection(String) line: 233	
        return (getConnection(url, info, Reflection.getCallerClass()));
/s
DriverManager.getConnection(String, Properties, Class<?>) line: 571	
        for(DriverInfo aDriver : registeredDrivers) {
                    Connection con = aDriver.driver.connect(url, info);
/s
/ Postgresql	,
Driver.connect(String, Properties) line: 232	
        if ((props = parseURL(url, props)) == null)
{user=foo, PGDBNAME=foo, password=foo, PGPORT=5432, PGHOST=localhost}

                return makeConnection(url, props);
/s
Driver.makeConnection(String, Properties) line: 410	
        return new org.postgresql.jdbc3g.Jdbc3gConnection(hostSpecs(props),
                                      user(props), database(props),
                                      props, url);
    }

/s
...
Jdbc3gConnection(AbstractJdbc2Connection).<init>(HostSpec[], String, String, Properties, String) line: 73	
    public boolean autoCommit = true;
///////////////////////

           prepareThreshold = Integer.parseInt(info.getProperty("prepareThreshold", "5"));
5
       
        boolean binaryTransfer = true;

       // Now make the initial connection and set up local state
        this.protoConnection = ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
/ s
/ Ook Postgresql	,
ConnectionFactory.openConnection(HostSpec[], String, String, Properties, Logger) line: 55	

            ConnectionFactory factory = (ConnectionFactory) versions[i][1];
            ProtocolConnection connection = factory.openConnectionImpl(hostSpecs, user, database, info, logger);
/s
package org.postgresql.core.v3;
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 54	

            newStream = new PGStream(hostSpec, connectTimeout);
/s
PGStream.<init>(HostSpec, int) line: 62	
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort()), timeout);
Socket[addr=localhost/127.0.0.1,port=5432,localport=48552]

        changeSocket(socket);
/s
PGStream.changeSocket(Socket) line: 111	
        this.connection = socket;

/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 178	

            newStream = new PGStream(hostSpec, connectTimeout);
/ D
newStream	PGStream  (id=52)	
	connection	Socket  (id=53)	


            // Do final startup.
            ProtocolConnectionImpl protoConnection = new ProtocolConnectionImpl(newStream, user, database, info, logger, connectTimeout);
/s
ProtocolConnectionImpl.<init>(PGStream, String, String, Properties, Logger, int) line: 31	
       this.pgStream = pgStream;
        this.executor = new QueryExecutorImpl(this, pgStream, info, logger);
/s
QueryExecutorImpl.<init>(ProtocolConnectionImpl, PGStream, Properties, Logger) line: 34	
            this.allowEncodingChanges = false;

/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 178	
            readStartupMessages(newStream, protoConnection, logger);
/s
ConnectionFactoryImpl.readStartupMessages(PGStream, ProtocolConnectionImpl, Logger) line: 610	
        while (true)
        {
            int beresp = pgStream.ReceiveChar();
            switch (beresp)
            {
              break;

            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
...
                else if (name.equals("client_encoding"))
                {
                    pgStream.setEncoding(Encoding.getDatabaseEncoding("UTF8"));

/ veel name:value's doet jdbc niets mee	,

/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 187	

encoding	Encoding  (id=91)	
	encoding	"UTF-8" (id=101)	
	fastASCIINumbers	true	
	writeBuffer	null	
encodingWriter	OutputStreamWriter  (id=94)	
	lock	PGStream$1  (id=105)	
	se	StreamEncoder  (id=108)	
	writeBuffer	null	
	writeBufferSize	1024	
/ TODO

            runInitialQueries(protoConnection, info, logger);
/ NIETS
	return protoConnection;

/t
ConnectionFactory.openConnection(HostSpec[], String, String, Properties, Logger) line: 64	
            ProtocolConnection connection = factory.openConnectionImpl(hostSpecs, user, database, info, logger);
/ D
connection	ProtocolConnectionImpl  (id=54)	
	executor	QueryExecutorImpl  (id=59)	
	logger	Logger  (id=56)	
	pgStream	PGStream  (id=51)	

                return connection;

/t
Jdbc3gConnection(AbstractJdbc2Connection).<init>(HostSpec[], String, String, Properties, String) line: 145	
        this.protoConnection = ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
/ D
       // Formats that currently have binary protocol support
        Set<Integer> binaryOids = new HashSet<Integer>();
        if (binaryTransfer && protoConnection.getProtocolVersion() >= 3) {
            binaryOids.add(Oid.BYTEA);
            binaryOids.add(Oid.INT2);
            binaryOids.add(Oid.INT4);
            binaryOids.add(Oid.INT8);
            binaryOids.add(Oid.FLOAT4);
            binaryOids.add(Oid.FLOAT8);
            binaryOids.add(Oid.TIME);
            binaryOids.add(Oid.DATE);
            binaryOids.add(Oid.TIMETZ);
            binaryOids.add(Oid.TIMESTAMP);
            binaryOids.add(Oid.TIMESTAMPTZ);
            binaryOids.add(Oid.INT2_ARRAY);
            binaryOids.add(Oid.INT4_ARRAY);
            binaryOids.add(Oid.INT8_ARRAY);
            binaryOids.add(Oid.FLOAT4_ARRAY);
            binaryOids.add(Oid.FLOAT8_ARRAY);
            binaryOids.add(Oid.FLOAT8_ARRAY);
            binaryOids.add(Oid.VARCHAR_ARRAY);
            binaryOids.add(Oid.TEXT_ARRAY);
            binaryOids.add(Oid.POINT);
            binaryOids.add(Oid.BOX);
            binaryOids.add(Oid.UUID);
        }        
...
        protoConnection.setBinaryReceiveOids(useBinaryReceiveForOids);

this	Jdbc3gConnection  (id=24)	
	useBinaryReceiveForOids	HashSet<E>  (id=157)	
[1016, 1184, 1021, 1022, 2950, 1009, 1015, 17, 1083, 1082, 700, 701, 1005, 1266, 21, 20, 23, 1007, 1114, 600, 603]
	useBinarySendForOids	HashSet<E>  (id=193)	
[1016, 1184, 1021, 1022, 2950, 1009, 1015, 17, 1083, 700, 701, 1005, 1266, 21, 20, 23, 1007, 1114, 600, 603]

/ en this.protoConnection krijgt ze ook	,

            bindStringAsVarchar = haveMinimumCompatibleVersion("8.0");
true

        commitQuery = getQueryExecutor().createSimpleQuery("COMMIT");
commitQuery	SimpleQuery  (id=300)	
	protoConnection	ProtocolConnectionImpl  (id=54)	
		pgStream	PGStream  (id=51)	
			connection	Socket  (id=324)	
	fragments	String[1]  (id=289)	
[COMMIT]


/t
Jdbc3gConnection(AbstractJdbc3gConnection).<init>(HostSpec[], String, String, Properties, String) line: 24	
       	super(hostSpecs, user, database, info, url);
/ D
        TypeInfo types = getTypeInfo();
this	Jdbc3gConnection  (id=24)	
types	TypeInfoCache  (id=380)	
	_arrayOidToDelimiter	HashMap<K,V>  (id=385)	
{790=,, 1184=,, 1700=,, 1083=,, 17=,, 1082=,, 16=,, 19=,, 700=,, 701=,, 18=,, 1266=,, 21=,, 1560=,, 20=,, 23=,, 1114=,, 25=,, 1043=,, 26=,, 1042=,}
	_conn	Jdbc3gConnection  (id=24)	
	_getArrayDelimiterStatement	null	
	_getArrayElementOidStatement	null	
	_getNameStatement	null	
	_getOidStatement	null	
	_getTypeInfoStatement	null	
	_oidToPgName	HashMap<K,V>  (id=404)	
{790=money, 1184=timestamptz, 1700=numeric, 1083=time, 17=bytea, 1082=date, 16=bool, 19=name, 700=float4, 701=float8, 18=char, 1266=timetz, 21=int2, 1560=bit, 20=int8, 23=int4, 1114=timestamp, 25=text, 1043=varchar, 26=oid, 1042=bpchar}
	_pgArrayToPgType	HashMap<K,V>  (id=406)	
{1016=20, 791=790, 1185=1184, 1021=700, 1022=701, 1009=25, 1231=1700, 1028=26, 1014=1042, 1015=1043, 1270=1266, 1001=17, 1000=16, 1003=19, 1002=18, 1561=1560, 1005=21, 1115=1114, 1007=23, 1182=1082, 1183=1083}
	_pgNameToJavaClass	HashMap<K,V>  (id=408)	
{numeric=java.math.BigDecimal, char=java.lang.String, _float8=java.sql.Array, _oid=java.sql.Array, _timestamp=java.sql.Array, float8=java.lang.Double, _float4=java.sql.Array, _bool=java.sql.Array, float4=java.lang.Float, _bytea=java.sql.Array, timestamptz=java.sql.Timestamp, polygon=org.postgresql.geometric.PGpolygon, _money=java.sql.Array, time=java.sql.Time, _text=java.sql.Array, _int8=java.sql.Array, _int4=java.sql.Array, _time=java.sql.Array, lseg=org.postgresql.geometric.PGlseg, hstore=java.util.Map, _int2=java.sql.Array, text=java.lang.String, int8=java.lang.Long, int4=java.lang.Integer, int2=java.lang.Integer, bit=java.lang.Boolean, _varchar=java.sql.Array, _bit=java.sql.Array, bpchar=java.lang.String, interval=org.postgresql.util.PGInterval, timetz=java.sql.Time, _name=java.sql.Array, line=org.postgresql.geometric.PGline, circle=org.postgresql.geometric.PGcircle, date=java.sql.Date, timestamp=java.sql.Timestamp, _timestamptz=java.sql.Array, oid=java.lang.Long, _numeric=java.sql.Array, name=java.lang.String, money=org.postgresql.util.PGmoney, path=org.postgresql.geometric.PGpath, _date=java.sql.Array, varchar=java.lang.String, _char=java.sql.Array, _timetz=java.sql.Array, point=org.postgresql.geometric.PGpoint, bytea=[B, box=org.postgresql.geometric.PGbox, bool=java.lang.Boolean, _bpchar=java.sql.Array}
	_pgNameToOid	HashMap<K,V>  (id=410)	
{text=25, numeric=1700, bpchar=1042, timetz=1266, int8=20, char=18, int4=23, float8=701, date=1082, float4=700, timestamptz=1184, int2=21, timestamp=1114, bit=1560, time=1083, bytea=17, oid=26, name=19, money=790, bool=16, varchar=1043}
	_pgNameToPgObject	HashMap<K,V>  (id=412)	
{polygon=class org.postgresql.geometric.PGpolygon, point=class org.postgresql.geometric.PGpoint, interval=class org.postgresql.util.PGInterval, money=class org.postgresql.util.PGmoney, path=class org.postgresql.geometric.PGpath, line=class org.postgresql.geometric.PGline, box=class org.postgresql.geometric.PGbox, circle=class org.postgresql.geometric.PGcircle, lseg=class org.postgresql.geometric.PGlseg}
	_pgNameToSQLType	Collections$SynchronizedMap<K,V>  (id=414)	
{numeric=2, bpchar=1, timetz=92, char=1, _timestamp=2003, _oid=2003, _float8=2003, _name=2003, float8=8, _bool=2003, _float4=2003, date=91, _bytea=2003, float4=7, timestamptz=93, timestamp=93, _money=2003, _timestamptz=2003, time=92, _text=2003, _int8=2003, _numeric=2003, oid=-5, name=12, money=8, _date=2003, _int4=2003, _time=2003, varchar=12, _int2=2003, text=12, int8=-5, int4=4, _char=2003, int2=5, _timetz=2003, bit=-7, bytea=-2, _bit=2003, _varchar=2003, bool=-7, _bpchar=2003}
	_unknownLength	2147483647	

       if (haveMinimumServerVersion("8.3")) {
            types.addCoreType("uuid", Oid.UUID, java.sql.Types.OTHER, "java.util.UUID", Oid.UUID_ARRAY);

/t
DriverManager.getConnection(String, Properties, Class<?>) line: 572	
                    Connection con = aDriver.driver.connect(url, info);
/ D
                        return (con);

/t
first.<init>() line: 10	
		Connection con=DriverManager.getConnection(url);
/ D
		con.setAutoCommit(false);
/s
Jdbc3gConnection(AbstractJdbc2Connection).setAutoCommit(boolean) line: 785	
        this.autoCommit = autoCommit;

/t
first.<init>() line: 12	
		con.setAutoCommit(false);
/ D
		Statement stmt=con.createStatement();
/s
Jdbc3gConnection(AbstractJdbc2Connection).createStatement() line: 310	
        return createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY);
/s
Jdbc3gConnection(AbstractJdbc3Connection).createStatement(int, int) line: 231	
        return createStatement(resultSetType, resultSetConcurrency, getHoldability());
/s
    public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException
resultSetHoldability	2	
/ TODO

        Jdbc3gStatement s = new Jdbc3gStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability);
...
/s
Jdbc3gStatement(AbstractJdbc2Statement).<init>(AbstractJdbc2Connection, int, int) line: 143	
   {
        this.connection = c;
        this.preparedQuery = null;
        this.preparedParameters = null;
        this.lastSimpleQuery = null;
        forceBinaryTransfers |= c.getForceBinary();
        resultsettype = rsType;
        concurrency = rsConcurrency;

/ Maar eerst buiten de ctor def props	,


    protected ArrayList batchStatements = null;
    protected ArrayList batchParameters = null;
    protected final int resultsettype;   // the resultset type to return (ResultSet.TYPE_xxx)
    protected final int concurrency;   // is it updateable or not?     (ResultSet.CONCUR_xxx)
    protected int fetchdirection = ResultSet.FETCH_FORWARD;  // fetch direction hint (currently ignored)

    /** Maximum number of rows to return, 0 = unlimited */
    protected int maxrows = 0;

    /** Number of rows to get in a batch. */
    protected int fetchSize = 0;

   /** The current results. */
    protected ResultWrapper result = null;

/ TODO

/t
first.<init>() line: 14	
		Statement stmt=con.createStatement();
/ D
		String dml="delete from pre";
		stmt.executeUpdate(dml);
/s
Jdbc3gStatement(AbstractJdbc2Statement).executeUpdate(String) line: 324	
/=
    public int executeUpdate(String p_sql) throws SQLException

        executeWithFlags(p_sql, QueryExecutor.QUERY_NO_RESULTS);
/s
Jdbc3gStatement(AbstractJdbc2Statement).executeWithFlags(String, int) line: 402	
        Query simpleQuery = connection.getQueryExecutor().createSimpleQuery(p_sql);
/s
QueryExecutorImpl.createSimpleQuery(String) line: 111	
        return parseQuery(sql, false);
/s
QueryExecutorImpl.parseQuery(String, boolean) line: 198	
...
      if (statementList.size() == 1)
        {
            // Only one statement.
            return new SimpleQuery((String[]) statementList.get(0), protoConnection);
/s
SimpleQuery.<init>(String[], ProtocolConnectionImpl) line: 27	
       	this.fragments = fragments;
[delete from pre]
        this.protoConnection = protoConnection;

/t
Jdbc3gStatement(AbstractJdbc2Statement).executeWithFlags(String, int) line: 405	
       	Query simpleQuery = connection.getQueryExecutor().createSimpleQuery(p_sql);
/ D
        execute(simpleQuery, null, QueryExecutor.QUERY_ONESHOT | flags);
/s
Jdbc3gStatement(AbstractJdbc2Statement).execute(Query, ParameterList, int) line: 513	

       if (fetchSize > 0 ...
/ NEE
/TODO

        StatementResultHandler handler = new StatementResultHandler();
           connection.getQueryExecutor().execute(queryToExecute,
                                                  queryParameters,
                                                  handler,
                                                  maxrows,
                                                  fetchSize,
                                                  flags);
/ s
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 228	
        if (parameters == null)
            parameters = SimpleQuery.NO_PARAMETERS;

        ((V3ParameterList)parameters).convertFunctionOutParameters();
/s
SimpleParameterList.convertFunctionOutParameters() line: 229	
/ NIETS
 /paramTypes is leeg
/ TODO

/t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 228	
            ((V3ParameterList)parameters).checkAllParametersSet();
/ NIETS

                handler = sendQueryPreamble(handler, flags);

/ Dit is BEGIN

/s
QueryExecutorImpl.sendQueryPreamble(ResultHandler, int) line: 419	
       if ((flags & QueryExecutor.QUERY_ONESHOT) != 0) {
          beginFlags |= QueryExecutor.QUERY_ONESHOT;

        sendOneQuery(beginTransactionQuery, SimpleQuery.NO_PARAMETERS, 0, 0, beginFlags);
beginTransactionQuery	SimpleQuery  (id=71)	
BEGIN

/ s
QueryExecutorImpl.sendOneQuery(SimpleQuery, SimpleParameterList, int, int, int) line: 1557	
       	boolean noResults = (flags & QueryExecutor.QUERY_NO_RESULTS) != 0;
false
        boolean noMeta = (flags & QueryExecutor.QUERY_NO_METADATA) != 0;
true
        boolean describeOnly = (flags & QueryExecutor.QUERY_DESCRIBE_ONLY) != 0;
false
        boolean usePortal = (flags & QueryExecutor.QUERY_FORWARD_CURSOR) != 0 && !noResults && !noMeta && fetchSize > 0 && !describeOnly;
false
        boolean oneShot = (flags & QueryExecutor.QUERY_ONESHOT) != 0 && !usePortal;
true
        boolean noBinaryTransfer = (flags & QUERY_NO_BINARY_TRANSFER) != 0;
false

       else if (!usePortal)
/ TODO
/ JA
        {
            rows = maxRows;       // Not using a portal -- fetchSize is irrelevant

        sendParse(query, params, oneShot);
...
        sendBind(query, params, portal, noBinaryTransfer);
/ BEGIN heeft geen params,	
        sendExecute(query, portal, rows);

       return new ResultHandler() {
                   private boolean sawBegin = false;
                   public void handleResultRows(Query fromQuery, Field[] fields, List tuples, ResultCursor cursor) {
                       if (sawBegin)
                           delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
                   }
...

/t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 251	
                handler = sendQueryPreamble(handler, flags);
/ D
handler	QueryExecutorImpl$1  (id=825)	
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/s
QueryExecutorImpl.sendQuery(V3Query, V3ParameterList, int, int, int, QueryExecutorImpl$ErrorTrackingResultHandler) line: 1120	
                sendOneQuery((SimpleQuery)query, (SimpleParameterList)parameters, maxRows, fetchSize, flags);
/s
QueryExecutorImpl.sendOneQuery(SimpleQuery, SimpleParameterList, int, int, int) line: 1557	

/ dit is DELETE FROM PRE

        sendParse(query, params, oneShot);
/s
QueryExecutorImpl.sendParse(SimpleQuery, SimpleParameterList, boolean) line: 1269	
        pgStream.SendChar('P'); // Parse
/s
   public void SendChar(int val) throws IOException
    {
        pg_output.write(val);
/ s
   public synchronized void write(int b) throws IOException {
        if (count >= buf.length) {
            flushBuffer();
        }
        buf[count++] = (byte)b;
    }

/t
QueryExecutorImpl.sendOneQuery(SimpleQuery, SimpleParameterList, int, int, int) line: 1557	
        sendBind(query, params, portal, noBinaryTransfer);
        sendExecute(query, portal, rows);

this	QueryExecutorImpl  (id=51)	
	pgStream	PGStream  (id=119)	
		pg_input	VisibleBufferedInputStream  (id=836)	
			buffer	(id=838)	
[49, 0, 0, 0, 4, 50, 0, 0, 0, 4, 67, 0, 0, 0, 8, 83, 69, 84, 0, 90, 0, 0, 0, 5, 73, 95, 110, 97, 109, 101, 0, 0, 83, 0, 0, 0, 25, 99, 108, 105, 101, 110, 116, 95, 101, 110, 99, 111, 100, 105, 110, 103, 0, 85, 84, 70, 56, 0, 83, 0, 0, 0, 23, 68, 97, 116, 101, 83, 116, 121, 108, 101, 0, 73, 83, 79, 44, 32, 77, 68, 89, 0, 83, 0, 0, 0, 25, 105, 110, 116, 101, 103, 101, 114, 95, 100, 97, 116, 101, 116, 105, 109, 101, 115, 0, 111, 110, 0, 83, 0, 0, 0, 27, 73, 110, 116, 101, 114, 118, 97, 108, 83, 116, 121, 108, 101, 0, 112, 111, 115, 116, 103, 114, 101, 115, 0, 83, 0, 0, 0, 21, 105, 115, 95, 115, 117, 112, 101, 114, 117, 115, 101, 114, 0, 111, 102, 102, 0, 83, 0, 0, 0, 25, 115, 101, 114, 118, 101, 114, 95, 101, 110, 99, 111, 100, 105, 110, 103, 0, 85, 84, 70, 56, 0, 83, 0, 0, 0, 25, 115, 101, 114, 118, 101, 114, 95, 118, 101, 114, 115, 105, 111, 110, 0, 57, 46, 51, 46, 52, 0, 83, 0, 0, 0, 30, 115, 101, 115, 115, 105, 111, 110, 95, 97, 117, 116, 104, 111, 114, 105, 122, 97, 116, 105, 111, 110, 0, 102, 111, 111, 0, 83, 0, 0, 0, 35, 115, 116, 97, 110, 100, 97, 114, 100, 95, 99, 111, 110, 102, 111, 114, 109, 105, 110, 103, 95, 115, 116, 114, 105, 110, 103, 115, 0, 111, 110, 0, 83, 0, 0, 0, 30, 84, 105, 109, 101, 90, 111, 110, 101, 0, 69, 117, 114, 111, 112, 101, 47, 65, 109, 115, 116, 101, 114, 100, 97, 109, 0, 75, 0, 0, 0, 12, 0, 0, 117, 56, 74, 0, -94, -5, 90, 0, 0, 0, 5, 73, 0, 0, 0, 0, 0, 0, ...

			endIndex	25	
			index	25	
/ TODO
			wrapped	SocketInputStream  (id=840)	


/t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 254	
               	sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/ D
                sendSync();
/s
   private void sendSync() throws IOException {
        if (logger.logDebug())
            logger.debug(" FE=> Sync");

        pgStream.SendChar('S');     // Sync
        pgStream.SendInteger4(4); // Length
        pgStream.flush();
/s
PGStream.flush() line: 531	
       if (encodingWriter != null)
            encodingWriter.flush();
/ TODO
        pg_output.flush();
BufferedOutputStream.flush() line: 140	
   public synchronized void flush() throws IOException {
        flushBuffer();
/s
BufferedOutputStream.flushBuffer() line: 82	
        if (count > 0) {
            out.write(buf, 0, count);
	count=0;
/s
SocketOutputStream.write(byte[], int, int) line: 159	
        socketWrite(b, off, len);
/s
SocketOutputStream.socketWrite(byte[], int, int) line: 102	
            socketWrite0(fd, b, off, len);
            bytesWritten = len;
/ 96

/t
BufferedOutputStream.flush() line: 141	
       flushBuffer();
/ D
        out.flush();
/ {}	, SocketOutputStream.flush={}



            count = 0;
        }
    }
        out.flush();

\t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 255	
               sendSync();
/ D
                processResults(handler, flags);
/s
QueryExecutorImpl.processResults(ResultHandler, int) line: 1749	

/ TODO (Afmaken)

/ Eindn JDBC DEBUG

/ EHCACHE

/ 7	. 

/ Verschil batch of niet	, bij meerdere updates	,
/ Welke query gen?

/ 7	.

/ Lees	,
http://stackoverflow.com/questions/722221/how-to-log-postgres-sql-queries

/ we veranderen maar 1 setting	,

[eric@localhost merge2]$ sudo vi  /var/lib/pgsql/data/postgresql.conf
# [ERICJ]
log_statement = 'all'                   # none, ddl, mod, all

[eric@localhost merge2]$ sudo -iu postgres pg_ctl reload

/ de log file postgresql-Sun.log wordt opnieuw create	,

/ run first in jdbc maven proj	,

[root@localhost pgsql]# less data/pg_log/postgresql-Sun.log 

LOG:  unexpected EOF on client connection with an open transaction
LOG:  received SIGHUP, reloading configuration files
LOG:  parameter "log_statement" changed to "all"
LOG:  execute <unnamed>: SET extra_float_digits = 3
LOG:  execute <unnamed>: BEGIN
LOG:  execute <unnamed>: delete from pre
LOG:  execute <unnamed>: insert into pre values(1,'foo'||1)
LOG:  execute <unnamed>: create table if not exists pro(id int, name varchar(32))
LOG:  execute <unnamed>: select*from pre
LOG:  execute S_1: COMMIT

/ run batch in jdbc maven proj	,

LOG:  execute <unnamed>: SET extra_float_digits = 3
LOG:  execute <unnamed>: BEGIN
LOG:  execute <unnamed>: delete from pre
LOG:  execute <unnamed>: insert into pre values(1,'foo'||1)
LOG:  execute <unnamed>: insert into pre values(2,'foo'||2)
LOG:  execute S_1: COMMIT
LOG:  execute <unnamed>: BEGIN
LOG:  execute <unnamed>: select*from pre
LOG:  unexpected EOF on client connection with an open transaction

/ 7	.
 
/ we kunnen ook	,
[eric@localhost merge2]$ sudo -iu postgres
-bash-4.2$ pwd
/var/lib/pgsql
-bash-4.2$ cat data/pg_log/postgresql-Sun.log 
...

/ 7	.

/ als we	,

		String url="jdbc:postgresql://localhost/foo?user=foo&password=foo";
		Connection con=DriverManager.getConnection(url);
		con.setAutoCommit(false);
...
		con.commit();

		dml="select*from pre";
		ResultSet rs=stmt.executeQuery(dml);
		while(rs.next()){
			int id=rs.getInt("id");
			String str=rs.getString("str");
			System.out.println(id+":"+str);
		}

/ Dan zien we in de postgres log	,

LOG:  unexpected EOF on client connection with an open transaction
/ TODO (Debug JDBC driver)	,

/ we hoeven zelf niet 
	conn.close()
/ of	,
	stmt.close()
/ Dat gebeurt wel, maar dat doet JDBC WH,	

/ 7	.

/ we maken in eclipse	,
File , new, Maven project	,
Use default workspace location : uncheck
/ create en Kies	,
/home/eric/Devel/Java/Ehcache/ 
/ Kies archetype org.apache.maven.archetypes:maven-archetype-quickstart
groupId: my.own.test
artifactId: ehcache

/ we zien  
src/main/java
	my.own.test.ehcache
		App.java

/ edit de pom file	, 4.11 ipv. 3.8.1	,
     <groupId>junit</groupId>
     <artifactId>junit</artifactId>
     <version>4.11</version>
     <scope>test</scope> 

/ we zien meteen onder Maven dependencies in Project explorer	,
/home/eric/.m2/repository/junit/junit/4.11/junit-4.11.jar
/home/eric/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar

/ we geven in pom.xml	,
   <dependency>
    <groupId>net.sf.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>2.8.3</version>
</dependency>

/ we zien in maven dependencies	,
/home/eric/.m2/repository/net/sf/ehcache/ehcache/2.8.3/ehcache-2.8.3.jar
/home/eric/.m2/repository/org/slf4j/slf4j-api/1.6.6/slf4j-api-1.6.6.jar

/ 7	.


/ Lees	,
http://howtodoinjava.com/2013/07/04/hibernate-ehcache-configuration-tutorial/
/ STRAKS

/ Lees	,
http://java-success.blogspot.nl/2013/10/ehcache-beginner-level-tutorial.html
/ NU

/ we zien ehcache versie 2.8.3 en ehcache-core versie 2.6.9	,
/ TODO

/ we veranderen	 pom.xml	,

    <groupId>net.sf.ehcache</groupId>
    <artifactId>ehcache-core</artifactId>
    <version>2.6.9</version>

/ 7	. 

/ In eclipse , maven, select proj, 
File, new , Class
/ het package is al gekozen	,

/ 7	. 

/ we hebben zelf create	,
[eric@localhost ehcache]$ pwd
/home/eric/Devel/Java/Ehcache/ehcache
[eric@localhost ehcache]$ vi src/main/resources/ehcache.xml 

<ehcache name="EmployeeCache">

      <defaultCache
          maxElementsInMemory="10000"
          eternal="false"
          timeToIdleSeconds="120"
          timeToLiveSeconds="120"
          overflowToDisk="true"
          diskSpoolBufferSizeMB="30"
          maxElementsOnDisk="10000000"
          diskPersistent="false"
          diskExpiryThreadIntervalSeconds="120"
          memoryStoreEvictionPolicy="LRU"/>

      <cache name="employees"
             maxElementsInMemory="100"
             maxElementsOnDisk="0"
             eternal="false"
             timeToIdleSeconds="120"
             timeToLiveSeconds="0"
             memoryStoreEvictionPolicy="LFU">
      </cache>


</ehcache>

$ vi src/main/java/my/own/test/ehcache/App2.java

	private CacheManager cacheManager;
		
    public static void main( String[] args )
    {
        new App2();
    }
    public App2() {
    	
    	ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    	InputStream inputStream=classLoader.getResourceAsStream("ehcache.xml");
    	cacheManager=CacheManager.create(inputStream);
    	
    	Ehcache cache=cacheManager.getEhcache("employees");
    	{
	    	Employee employee=new Employee(1, "foo", "Foo");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(2, "bar", "Bar");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(3, "baz", "Baz");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}
    	Element element=cache.get(1);
    	Employee employee=(Employee)element.getObjectValue();

Failed to load class "org.slf4j.impl.StaticLoggerBinder".

/ 7	. 

/ Lees	,
http://www.javablog.fr/javaehcache-a-simple-example-of-use-of-ehcache-2-6-2.html

[eric@localhost Ehcache]$ unzip ~/Downloads/test_divers-EHCACHE.zip 

/ 7	.

     <cache name="employees"
             maxElementsInMemory="100"
             maxElementsOnDisk="10"
             eternal="false"
             diskSpoolBufferSizeMB="30"
             timeToIdleSeconds="3"
             timeToLiveSeconds="10"
             memoryStoreEvictionPolicy="LFU"
             transactionalMode="off">
             	<persistence strategy="localTempSwap"/>
             
      </cache>

/ timeToIdleSeconds: time between accesses (creation is ook access) 
/ timeToLiveSeconds: time vanaf creation	,

    	{
	    	Employee employee=new Employee(3, "baz", "Baz");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}
    	
    	try{Thread.currentThread().sleep(A);}catch(Exception e){}
    	{
    	Element element=cache.get(1);
    	Employee employee=(Employee)element.getObjectValue();
    	System.out.println(employee);
    	}
    	{
    	try{Thread.currentThread().sleep(B);}catch(Exception e){}
    	Element element=cache.get(1);
    	Employee employee=(Employee)element.getObjectValue();
    	System.out.println(employee);
    	}
 
/ A=2, B=4 , dan access=2,6	,
/ A=4, B=2 , dan access=4,6	,

idle 	live 	access 		access
		2		6
3	10	empl		null
		4		6
3 	10	null 		null		/ *
		2		4
3	10	empl	 	empl	

/ * : de 2de access is niet na 2sec want de 1ste access was er niet	, dus is na 6 sec	,

/ 7	.

/ De zien altijd een ehcache_auto_created...diskstore file in /tmp	,
/ Dit komt door de persistence entry in ehcache.xml	,
     <cache name="employees"
..
->            	<persistence strategy="localTempSwap"/>
             
      </cache>

/ Als we deze rm, dan zien we die files in /tmp niet	,

/ in ehcache.xml staat ook	, 
    <diskStore path="java.io.tmpdir"/>
/ Dit is WH default	, we kunnen deze ook weglaten	,

/ de diskPersistent attr conflicts met  
/ de overflowToDisk attr conflicts met  
	<cache name="employees"
		...>
            		<persistence strategy="localTempSwap"/>
/ TODO

/ 7	.

/ Lees ehcache.xml uit de distributie	, 

[eric@localhost ehcache-2.8.3]$ pwd
/home/eric/Devel/Java/Ehcache/ehcache-2.8.3
[eric@localhost ehcache-2.8.3]$ vi ehcache.xml 
...

/ 7	.

             maxElementsOnDisk="4"
/ begrenst aantal items in cache	,
/ het is alles of niets	, als we 5 elems store	,

/ 7	.

/ EERST	, 

    <cache name="employees"
             maxElementsInMemory="10"
             maxElementsOnDisk="10"
             eternal="false"
             diskSpoolBufferSizeMB="30"
             timeToIdleSeconds="3"
             timeToLiveSeconds="10"
             memoryStoreEvictionPolicy="LFU"
             transactionalMode="off">
             	<persistence strategy="localTempSwap"/>
             
    </cache>

/ NU	,

    <cache name="employees"
      		 maxEntriesLocalHeap="4"
             maxElementsOnDisk="4"
             eternal="false"
             diskSpoolBufferSizeMB="30"
             timeToIdleSeconds="3"
             timeToLiveSeconds="10"
             memoryStoreEvictionPolicy="LFU"
             transactionalMode="off">
             <persistence strategy="localTempSwap"/>
             
      </cache>

/ 7	.

$ vi App4.java

package my.own.test.ehcache;

import java.io.InputStream;

import net.sf.ehcache.CacheManager;
import net.sf.ehcache.Ehcache;
import net.sf.ehcache.Element;


public class App4 
{
	private CacheManager cacheManager;
		
    public static void main( String[] args )
    {
        new App4();

        
        
    }
    public App4() {
    	
    	ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    	InputStream inputStream=classLoader.getResourceAsStream("ehcache.xml");
    	cacheManager=CacheManager.create(inputStream);
    	
    	Ehcache cache=cacheManager.getEhcache("employees");
       	//Ehcache cache=cacheManager.getEhcache("default");// null

    	{
	    	Employee employee=new Employee(1, "foo", "Foo");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(2, "bar", "Bar");
	    	Element element=new Element(2, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(3, "baz", "Baz");
	    	Element element=new Element(3, employee);
	    	cache.put(element);
    	}
       	{
	    	Employee employee=new Employee(4, "gee", "Gee");
	    	Element element=new Element(4, employee);
	    	cache.put(element);
    	}
    	
    	try{Thread.currentThread().sleep(2000);}catch(Exception e){}
    	{
    		try{
    	Element element=cache.get(1);
    	Element element2=cache.get(2);
    	Element element3=cache.get(3);
    	Employee employee=(Employee)element.getObjectValue();
    	Employee employee2=(Employee)element2.getObjectValue();
    	Employee employee3=(Employee)element3.getObjectValue();
    	System.out.println(employee);
    	System.out.println(employee2);
    	System.out.println(employee3);

    		}catch(Exception e){e.printStackTrace();}
    	}
    	{
    	try{Thread.currentThread().sleep(4000);}catch(Exception e){}
    		try{
    	Element element=cache.get(3);
    	Employee employee=(Employee)element.getObjectValue();
    	System.out.println(employee);
    		}catch(Exception e){e.printStackTrace();}
    	}
		
	cacheManager.shutdown();		// anders exits prog niet	,	
		
	}
  
}

$ vi ehcache.xml

<?xml version="1.0" encoding="UTF-8"?>

<ehcache name="EmployeeCache">

    <diskStore path="java.io.tmpdir"/>

      
      <cache name="employees"
             maxEntriesLocalHeap="10"
             maxEntriesLocalDisk="2"
             eternal="false"
             diskSpoolBufferSizeMB="30"
             timeToIdleSeconds="10"
             timeToLiveSeconds="4"
             memoryStoreEvictionPolicy="LFU"
             transactionalMode="off">
             	<persistence strategy="localTempSwap"/>
             
</ehcache>

/ we zien 2 keer NullPointerException	,  
/ we zien 
[eric@localhost Jdbc]$ ls -l /tmp/ehcache_auto_created3805521576027872615diskstore/employees.data 
-rw-rw-r--. 1 eric eric 0 Jul 21 15:26 /tmp/ehcache_auto_created3805521576027872615diskstore/employees.data

/ Wanner ehcache_auto_created... ?
/ TODO

/ 7	.

    <cache name="employees"
             maxEntriesLocalHeap="4"
             maxEntriesLocalDisk="4"
             eternal="false"
             diskSpoolBufferSizeMB="30"
             timeToIdleSeconds="4"
             timeToLiveSeconds="10"
             memoryStoreEvictionPolicy="LFU"
             transactionalMode="off">
             <persistence strategy="localTempSwap"/>
             
      </cache>

   public App4() {
...
    	{
	    	Employee employee=new Employee(1, "foo", "Foo");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(2, "bar", "Bar");
	    	Element element=new Element(2, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(3, "baz", "Baz");
	    	Element element=new Element(3, employee);
	    	cache.put(element);
    	}
       	{
	    	Employee employee=new Employee(4, "gee", "Gee");
	    	Element element=new Element(4, employee);
	    	cache.put(element);
    	}

	// cacheManager.shutdown();

/ Als we App4 2 keer achter elkaar run, verschijnt er in /tmp/ een ehcache_auto_created1329480694101114045diskstore/	,

/ 7	.

    <cache name="employees"
             maxEntriesLocalHeap="4"
             maxEntriesLocalDisk="4"
             eternal="false"
             diskSpoolBufferSizeMB="30"
             timeToIdleSeconds="4"
             timeToLiveSeconds="10"
             memoryStoreEvictionPolicy="LFU"
             transactionalMode="off">
             <persistence strategy="localTempSwap"/>
             
      </cache>

/ we add 8 items	,

App4

    	{
	    	Employee employee=new Employee(1, "foo", "Foo");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(2, "bar", "Bar");
	    	Element element=new Element(2, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(3, "baz", "Baz");
	    	Element element=new Element(3, employee);
	    	cache.put(element);
    	}
       	{
	    	Employee employee=new Employee(4, "gee", "Gee");
	    	Element element=new Element(4, employee);
	    	cache.put(element);
    	}

    	{
	    	Employee employee=new Employee(5, "foo2", "Foo");
	    	Element element=new Element(5, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(6, "ba2r", "Bar");
	    	Element element=new Element(6, employee);
	    	cache.put(element);
    	}
    	{
	    	Employee employee=new Employee(7, "baz2", "Baz");
	    	Element element=new Element(7, employee);
	    	cache.put(element);
    	}
       	{
	    	Employee employee=new Employee(8, "gee2", "Gee");
	    	Element element=new Element(8, employee);
	    	cache.put(element);
    	}
	// cacheManager.shutdown();

/ Na 1 keer App4 is er /tmp/ehcache_auto_created1329480694101114045diskstore	,

/ als we WEL
	cacheManager.shutdown();
/ dan is er GEEN /tmp/ehcache_auto_created1329480694101114045diskstore

/////////////////////////////////
/ als we een // set , dan moeten we maven install	, eclipse doet niet van zelf	,

/ HIER HIER






/ Einde EHCACHE

/ EHCACHE HIBERNATE ANNOTATIONS

/ Lees	,
http://www.journaldev.com/2980/hibernate-ehcache-second-level-caching-example-tutorial

/ en 	, want we moeten de tbl's fill 	,
http://www.journaldev.com/2954/hibernate-query-language-hql-example-tutorial	, 


/ 7	.

/ we maken ehcache_hibernate proj	,
File, New, Maven project, 
Use default Workspace location: uncheck
/ browse naar ~/Devel/Java/Ehcache, en create folder	,
ehcache_hibnerate
/ kies quickstart	,
my.test.own
ehcache_hibernate

/ we maken pom	, 
...

/ in eclipse	,
/ right click proj	, new , source folder
src/main/resources
/ OK

/ 7	.

defaultCache: Its a mandatory configuration, it is used when an Object need to be cached and there are no caching regions defined for that.

/ 7	.

/ bij EHCACHE zeiden we in welke region een obj moest	,

    	Ehcache cache=cacheManager.getEhcache("employees");
    	{
	    	Employee employee=new Employee(1, "foo", "Foo");
	    	Element element=new Element(1, employee);
	    	cache.put(element);
    	}

/ Bij Hibernate	,

/ we lezen 	,
http://ehcache.org/documentation/user-guide/hibernate

Because the ehcache.xml file has a defaultCache, caches will always be created when required by Hibernate. However more control can be exerted by specifying a configuration per cache, based on its name. In particular, because Hibernate caches are populated from databases, there is potential for them to get very large. This can be controlled by capping their maxEntriesLocalHeap and specifying whether to swap to disk beyond that. Hibernate uses a specific convention for the naming of caches of Domain Objects, Collections, and Queries.

Domain Objects
Hibernate creates caches named after the fully qualified name of Domain Objects. So, for example to create a cache for com.somecompany.someproject.domain.Country create a cache configuration entry similar to the following in ehcache.xml.

    <?xml version="1.0" encoding="UTF-8"?>
<ehcache>
 <cache
    name="com.somecompany.someproject.domain.Country"
    maxEntriesLocalHeap="10000"
    eternal="false"
    timeToIdleSeconds="300"
    timeToLiveSeconds="600"
    <persistence strategy="localTempSwap"/>
 />
</ehcache>

/ 7	. 

/ Met hibernate-core  dep in pom	, kan eclipse javax.persistence.Entity	, org.hibernate.annotations.Entity	,

/ als we in eclipse in pom.xml	,
 <dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>4.3.6.Final</version>
    </dependency>

/ dan kunnen we @Entity use	,

/ dan zien we in eclipse Maven Dependencies	, en deze zien we in de local Maven repository	,

[eric@localhost ~]$ vi .m2/repository/org/hibernate/hibernate-core/3.6.7.Final/hibernate-core-3.6.7.Final.pom
...
      <dependency>
            <groupId>org.hibernate.javax.persistence</groupId>
            <artifactId>hibernate-jpa-2.0-api</artifactId>
        </dependency>

/ en hierin zit de javax.persistence.Entity annotation	,

[eric@localhost repository]$ jar tvf org/hibernate/javax/persistence/hibernate-jpa-2.1-api/1.0.0.Final/hibernate-jpa-2.1-api-1.0.0.Final.jar | grep "Entity.class"
   491 Thu Jul 25 22:32:40 CEST 2013 javax/persistence/Entity.class

/ 7	.

/ Waar zit org.hibernate.annotations.Parameter in	?
/ TODO

/ 7	.

/ Voor session.load(Employee.class,1l) moet Employee een default ctor hebben	, 
/ we hadden alleen de niet default ctor, en dan ERR 	,

/ 7	.

/ we passen aan	,

	@Entity
	@Table(name = "ADDRESS")
	@Cache(usage=CacheConcurrencyStrategy.READ_ONLY, region="employee")
	public class Address {
... 
	    @OneToOne
	    //@PrimaryKeyJoinColumn
	    @JoinColumn
	    private Employee employee;

/ we veranderen @PrimaryKeyJoinColumn door @JoinColumn

/ Anders in emp.address=null in	,
	        Employee emp = (Employee) session.load(Employee.class, 1l);
	        String s=emp.getName();
/ TODO

/ 7	.

/ ehcache_hibernate


/ Main	,

	protected void setUp() throws Exception {
             
        	Configuration configuration=new Configuration().configure();
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);
    		
    		stats = sessionFactory.getStatistics();
            	System.out.println("Stats enabled="+stats.isStatisticsEnabled());
            	stats.setStatisticsEnabled(true);
            	System.out.println("Stats enabled="+stats.isStatisticsEnabled());
        }

	public void testBasicUsage() {

		session = sessionFactory.openSession();
		session.beginTransaction();

	  	printStats(stats, 0);
	         
	        Employee emp = (Employee) session.get(Employee.class, 1l);
	        printData(emp, stats, 1);
	        String s=emp.getName();
	        printData(emp, stats, 1);

	         
	        emp = (Employee) session.get(Employee.class, 1l);
	        printData(emp, stats, 2);
	         
	        //clear first level cache, so that second level cache is used
	        session.evict(emp);
	        emp = (Employee) session.get(Employee.class, 1l);
	        printData(emp, stats, 3);
	         
	        emp = (Employee) session.get(Employee.class, 3l);
	        printData(emp, stats, 4);
	         
	       // emp = (Employee) session2.load(Employee.class, 1L);
	        emp = (Employee) session.get(Employee.class, 1l);
	        printData(emp, stats, 5);

		session.getTransaction().commit();
		session.close();
	}

/ Address	,

    	    @Id
	    @GeneratedValue
	    private long id;
	 
	    @Column(name = "address_line1")
	    private String addressLine1;
	 
	    @Column(name = "zipcode")
	    private String zipcode;
	 
	    @Column(name = "city")
	    private String city;
	 
	    @OneToOne
	    //@PrimaryKeyJoinColumn
	    @JoinColumn
	    private Employee employee;

/ Employee	,

    @Id
    @GeneratedValue
    //@GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "emp_id")
    private long id;
 
    @Column(name = "emp_name")
    private String name;
 
    @Column(name = "emp_salary")
    private double salary;
 
    @OneToOne(mappedBy = "employee")
    @Cascade(value = org.hibernate.annotations.CascadeType.ALL)
    private Address address;

    <cache name="employees"
             maxEntriesLocalHeap="4"
             maxEntriesLocalDisk="4"
             eternal="false"
             diskSpoolBufferSizeMB="30"
             timeToIdleSeconds="4"
             timeToLiveSeconds="10"
             memoryStoreEvictionPolicy="LFU"
             transactionalMode="off">
             <persistence strategy="localTempSwap"/>
             
      </cache>

/ Hoe zit een Statistics eruit?

this	Main  (id=40)	
	stats	ConcurrentStatisticsImpl  (id=2961)	
		closeStatementCount	AtomicLong  (id=2962)	
		collectionFetchCount	AtomicLong  (id=2963)	
		collectionLoadCount	AtomicLong  (id=2964)	
		collectionRecreateCount	AtomicLong  (id=2965)	
		collectionRemoveCount	AtomicLong  (id=2966)	
		collectionStatistics	ConcurrentHashMap<K,V>  (id=2969)	
		collectionUpdateCount	AtomicLong  (id=2971)	
		committedTransactionCount	AtomicLong  (id=2973)	
		connectCount	AtomicLong  (id=2975)	
		entityDeleteCount	AtomicLong  (id=2977)	
		entityFetchCount	AtomicLong  (id=2979)	
		entityInsertCount	AtomicLong  (id=2981)	
		entityLoadCount	AtomicLong  (id=2983)	
		entityStatistics	ConcurrentHashMap<K,V>  (id=2985)	
		entityUpdateCount	AtomicLong  (id=2990)	
		flushCount	AtomicLong  (id=2992)	
		isStatisticsEnabled	true	
		naturalIdCacheHitCount	AtomicLong  (id=3000)	
		naturalIdCacheMissCount	AtomicLong  (id=3002)	
		naturalIdCachePutCount	AtomicLong  (id=3020)	
		naturalIdCacheStatistics	ConcurrentHashMap<K,V>  (id=3022)	
		naturalIdQueryExecutionCount	AtomicLong  (id=3024)	
		naturalIdQueryExecutionMaxTime	AtomicLong  (id=3030)	
		naturalIdQueryExecutionMaxTimeRegion	null	
		optimisticFailureCount	AtomicLong  (id=3031)	
		prepareStatementCount	AtomicLong  (id=3032)	
		queryCacheHitCount	AtomicLong  (id=3033)	
		queryCacheMissCount	AtomicLong  (id=3034)	
		queryCachePutCount	AtomicLong  (id=3035)	
		queryExecutionCount	AtomicLong  (id=3036)	
		queryExecutionMaxTime	AtomicLong  (id=3037)	
		queryExecutionMaxTimeQueryString	null	
		queryStatistics	ConcurrentHashMap<K,V>  (id=3041)	
		secondLevelCacheHitCount	AtomicLong  (id=3043)	
		secondLevelCacheMissCount	AtomicLong  (id=3045)	
		secondLevelCachePutCount	AtomicLong  (id=3047)	
		secondLevelCacheStatistics	ConcurrentHashMap<K,V>  (id=3049)	
		sessionCloseCount	AtomicLong  (id=3051)	
		sessionFactory	SessionFactoryImpl  (id=3010)	
		sessionOpenCount	AtomicLong  (id=3054)	
		startTime	1406277994734	
		transactionCount	AtomicLong  (id=3057)	
		updateTimestampsCacheHitCount	AtomicLong  (id=3059)	
		updateTimestampsCacheMissCount	AtomicLong  (id=3061)	
		updateTimestampsCachePutCount	AtomicLong  (id=3063)	

/ TODO

/ 7	. 

/ In Main	,

			Session session = sessionFactory.openSession();
			org.hibernate.engine.spi.PersistenceContext context=((SessionImpl)session).getPersistenceContext();
/ OK
			session.beginTransaction();
			
	//		Session session2=sessionFactory.getCurrentSession();
	//		org.hibernate.engine.spi.PersistenceContext context2=((SessionImplementor)session2).getPersistenceContext();
// ERR

/ 7	.

	public void testBasicUsage() {

		

			Session session = sessionFactory.openSession();
			session.beginTransaction();
			
			Session session4=sessionFactory.getCurrentSession();
			Transaction tx4=session4.beginTransaction();
	        Employee emp4 = (Employee) session4.get(Employee.class, 1l);
	        String s4=emp4.getName();
	        tx4.commit();

	        session4.close();
/ ERR: session4 is al closed	,
/ TODO



/ Einde EHCACHE HIBERNATE (ANNOTATIONS)


/ EHCACHE HIBERNATE XML

/ we copy een proj	,
/ doe gewoon copy/paste, maar hij copies de content van het proj, niet de dir mee, dus moet je zelf een dir maken waar het inkomt, 	

$ vi org/hibernate/cfg/AvailableSettings.java

cache.provider_class 
/ is er NIET	,

       String CACHE_REGION_FACTORY = "hibernate.cache.region.factory_class";
       String USE_SECOND_LEVEL_CACHE = "hibernate.cache.use_second_level_cache";

/ used in 	,
org/hibernate/cache/internal/RegionFactoryInitiator.java	,
        public RegionFactory initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
                if ( ( useSecondLevelCache || useQueryCache ) && setting != null ) {
/ JA	, 

/ 7	.

/ bidir many-to-one ehcache	,

/ In file:///home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace/ehcache_hibernate_xml4	,

Employee:Address=N:1	, meerdere employees werken op 1 adres	,

/ In employee is de fk, is owner relation	,

/ als we	,
			Employee employee=new Employee("Foo",1.00);
			Employee employee11=new Employee("Foo11",11.00);
			Address address=new Address("foostreet", "12 foo", "FooCity");
			
			employee.setAddress(address);
			address.getEmployees().add(employee);
			employee11.setAddress(address);
			address.getEmployees().add(employee11);
			
			session.save(employee);
			session.save(employee11);
			session.save(address);
 
/ dan ERR	,
HibernateLog --> 08:40:53 WARN  org.hibernate.action.internal.UnresolvedEntityInsertActions - HHH000437: Attempting to save one or more entities that have a non-nullable association with an unsaved transient entity. The unsaved transient entity must be saved in an operation prior to saving these dependent entities.
	Unsaved transient entity: ([my.test.own.ehcache_hibernate_xml4.Address#0])
	Dependent entities: ([[my.test.own.ehcache_hibernate_xml4.Employee#3]])
	Non-nullable association(s): ([my.test.own.ehcache_hibernate_xml4.Employee.address])

/ we moeten eerst address save	,

 /of we moeten cascade in de owner	,employee
/ TODO

/ 13	.

/ als we	,
			session = sessionFactory.openSession();
			session.beginTransaction();
	        Address address=(Address)session.get(Address.class, 1l);
/ dan is de set employees in address leeg	, 
ddress	Address  (id=164)	
	employees	PersistentSet  (id=165)	
		dirty	false	
		set	HashSet<E>  (id=179)	

/ we zien	,
HibernateLog --> 09:11:27 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.ehcache_hibernate_xml4.Address.employees#1]

/ hits OK

/ 7	.

/ bidir 1-1

/ in file:///home/eric/Devel/Java/Ehcache/ehcache_hibernate_xml3 	, 

/ we doen geen cascade bij owner, fk kant, employee	, 

/we moeten eerst de address save, dan de employee	,anders ERR hierboven: als we employee eerst save, dan heeft hij ref naar transient address 	,
			Employee employee=new Employee("Foo",1.00);
			Address address=new Address("foostreet", "12 foo", "FooCity");
			employee.setAddress(address);
			address.setEmployee(employee);
			session.save(address);
			session.save(employee);

/ 7	 

/ we debug bidir 1-1 
/ in file:///home/eric/Devel/Java/Ehcache/ehcache_hibernate_xml3 	, 

/ 13	,

			Employee employee=new Employee("Foo",1.00);
			Address address=new Address("foostreet", "12 foo", "FooCity");
			employee.setAddress(address);
			address.setEmployee(employee);
/ In address is employee, die id 0 heeft, want employee is transient	,
			session.save(address);
/ Maar deze is OK, terwijl toch ook een transient heeft	, 
/ TODO
			session.save(employee);

/ als we 
			session.save(address);
/ dan zien we in de pc address, met de employee, die id=0 heeft	,

/als we
			session.save(employee);
/ dan zien we de employee met id=1 ook in de pc	, naast de address	, terwijl hij ook nog in address zit (en id=1 heeft nu)	,

/ 13	. 



/ ONTHOUD	,

DefaultSaveEventListener(AbstractSaveEventListener).performSave(Object, Serializable, EntityPersister, boolean, Object, EventSource, boolean) line: 184	

	protected Serializable performSave(
			Object entity,
			Serializable id,
			EntityPersister persister,
			boolean useIdentityColumn,
			Object anything,
			EventSource source,
			boolean requiresImmediateIdAccess) {

		final EntityKey key;
		if ( !useIdentityColumn ) {
			key = source.generateEntityKey( id, persister );
			Object old = source.getPersistenceContext().getEntity( key );

/ 13	.

/ we komen in	,

ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 176	

	private void addInsertAction(AbstractEntityInsertAction insert) {
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();

/ 13	. 

/ we komen in	,

EntityInsertAction(AbstractEntityInsertAction).makeEntityManaged() line: 141	
	public final void makeEntityManaged() {
		nullifyTransientReferencesIfNotAlready();
...
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object, Type) line: 101	
		private Object nullifyTransientReferences(final Object value, final Type type) {
			else if ( type.isEntityType() ) {
				final EntityType entityType = (EntityType) type;
				if ( entityType.isOneToOne() ) {
/ TODO
					return value;

/ Bij de laatste value, de employee in de address is dat zo	,

/ Employee mapping	,

	<many-to-one 
		name="address"
		column="address_"
		unique="true"
		not-null="true"	
	></many-to-one>

/ Address' mapping	,

	<one-to-one 
		name="employee"
		property-ref="address"
	></one-to-one>

/ we kunnen <one-to-one GEEN not-null="true" geven	,

/ hij checks  of er not-nullable transient obj zijn	, de employee heeft er een: address	,
/ transient heet in code nullifiable TODO
/ daarom ERR als we eerst employee save
/ als we eerst address save, dan OK	, maar de <one-to-one heeft geen not-null="true" attr, want dat kan een one-to-one niet, dus WH is niet not-nullable, dus die test komt door, maar daarna komt de !one-to-one test	, en die is false, dus daarom is de transient employee niet als zodanig gezien	,
/ TODO

/ 13	.

/ we rm de not-null="true" uit de many-to-one in employee's mapping	,
/ dan komt hij hierboven door, maar dan een nieuwe ERR	,

HibernateLog --> 13:03:18 WARN  org.hibernate.action.internal.UnresolvedEntityInsertActions - HHH000437: Attempting to save one or more entities that have a non-nullable association with an unsaved transient entity. The unsaved transient entity must be saved in an operation prior to saving these dependent entities.
	Unsaved transient entity: ([my.test.own.ehcache_hibernate_xml3.Address#0])
	Dependent entities: ([[my.test.own.ehcache_hibernate_xml3.Employee#1]])
	Non-nullable association(s): ([my.test.own.ehcache_hibernate_xml3.Employee.address])
org.hibernate.TransientPropertyValueException: Not-null property references a transient value - transient instance must be saved before current operation : my.test.own.ehcache_hibernate_xml3.Employee.address -> my.test.own.ehcache_hibernate_xml3.Address
	at org.hibernate.action.internal.UnresolvedEntityInsertActions.checkNoUnresolvedActionsAfterOperation(UnresolvedEntityInsertActions.java:137)
	at org.hibernate.engine.spi.ActionQueue.checkNoUnresolvedActionsAfterOperation(ActionQueue.java:318)
	at org.hibernate.internal.SessionImpl.checkNoUnresolvedActionsAfterOperation(SessionImpl.java:658)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:717)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.ehcache_hibernate_xml3.Main.testBasicUsage(Main.java:114)
	at my.test.own.ehcache_hibernate_xml3.Main.<init>(Main.java:59)
	at my.test.own.ehcache_hibernate_xml3.Main.main(Main.java:53)


/ Dat is dus HIER	,
	private Serializable fireSave(SaveOrUpdateEvent event) {
		errorIfClosed();
		checkTransactionSynchStatus();
		checkNoUnresolvedActionsBeforeOperation();
		for ( SaveOrUpdateEventListener listener : listeners( EventType.SAVE ) ) {
			listener.onSaveOrUpdate( event );
		}
->		checkNoUnresolvedActionsAfterOperation();

/ 13	.


java.lang.UnsupportedOperationException: Can't write to a readonly object
	at org.hibernate.cache.ehcache.internal.strategy.ReadOnlyEhcacheEntityRegionAccessStrategy.update(ReadOnlyEhcacheEntityRegionAccessStrategy.java:115)
	at org.hibernate.cache.ehcache.internal.nonstop.NonstopAwareEntityRegionAccessStrategy.update(NonstopAwareEntityRegionAccessStrategy.java:216)
	at org.hibernate.action.internal.EntityUpdateAction.cacheUpdate(EntityUpdateAction.java:235)
	at org.hibernate.action.internal.EntityUpdateAction.execute(EntityUpdateAction.java:210)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:463)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:349)
	at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:350)
	at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:56)
	at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:1222)
	at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:425)
	at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.beforeTransactionCommit(JdbcTransaction.java:101)
	at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.commit(AbstractTransactionImpl.java:177)
	at my.test.own.ehcache_hibernate_xml3.Main.testBasicUsage(Main.java:128)
	at my.test.own.ehcache_hibernate_xml3.Main.<init>(Main.java:59)
	at my.test.own.ehcache_hibernate_xml3.Main.main(Main.java:53)

/ TODO (Waarom een update ineens, dat doet hij WH niet als we	,
			session.save(address);
			session.save(employee);

/ 13	.

/ we kunnen daarom de cache read-write maken	,
/ we laten de fk not-null="false"
/ de set de volgorde van save	,
			session.save(employee);
			session.save(address);

/ Dit gaat OK	,

/ 7	. 

/ we debug flush	,

/ In Main	,
	tx.commit()

/ we komen in	,

	public void onFlushEntity(FlushEntityEvent event) throws HibernateException {

		if ( isUpdateNecessary( event, mightBeDirty ) ) {
			substitute = scheduleUpdate( event ) || substitute;
		}

/ hierin	,
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/s
			dirtyCheck( event );
			if ( isUpdateNecessary( event ) ) {
/ NEE	, want	,
				return true;

/ hierin	,
			dirtyCheck( event );
/s
					dirtyProperties = persister.findDirty( values, loadedState, entity, session );
/s
		int[] props = TypeHelper.findDirty(
				entityMetamodel.getProperties(),
				currentState,
				previousState,
				propertyColumnUpdateable,
				hasUninitializedLazyProperties( entity ),
				session
			);
/s
		for ( int i = 0; i < span; i++ ) {
			final boolean dirty = currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY
					&& properties[i].isDirtyCheckable( anyUninitializedProperties )
					&& properties[i].getType().isDirty( previousState[i], currentState[i], includeColumns[i], session );

/s
	public final boolean isDirty(Object old, Object current, boolean[] checkable, SessionImplementor session) {
		return checkable[0] && isDirty( old, current );
	}

	protected final boolean isDirty(Object old, Object current) {
		return !isSame( old, current );
	}

/ 13	.

/ we zijn in	,
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	

			session.getActionQueue().executeActions();

/ SAMENVATTING

/ Naar db en naar cache	,

Thread [main] (Suspended (breakpoint at line 104 in EntityInsertAction))	
	EntityInsertAction.execute() line: 104	
	ActionQueue.executeActions(ExecutableList<E>) line: 463	
	ActionQueue.executeActions() line: 349	
	DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
	DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
	SessionImpl.flush() line: 1222	
	SessionImpl.managedFlush() line: 425	
	JdbcTransaction.beforeTransactionCommit() line: 101	
	JdbcTransaction(AbstractTransactionImpl).commit() line: 177	
	Main.testBasicUsage() line: 128	
	Main.<init>() line: 59	
	Main.main(String[]) line: 53	

/ In 	,
EntityInsertAction.execute() line: 104	

			persister.insert( id, getState(), instance, session );

		if ( isCachePutEnabled( persister, session ) ) {
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
			cacheEntry = persister.getCacheEntryStructure().structure( ce );
			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );

			final boolean put = cacheInsert( persister, ck );

/ 7	. 

/ we rm b	,
package org.hibernate.service.internal;
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 199	


/ Einde SAMENVATTING
/s
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
/ Er is maar 1 entry in executableLists	, deze heeft de 4 inserts,	
/s
			for ( E e : list ) {
				try {
					e.execute();
/ e is steeds een insert	,
/s
EntityInsertAction.execute() line: 127	

			persister.insert( id, getState(), instance, session );
//////////////
/ to db	,
/s
		else {
			// For the case of dynamic-insert="false", use the static SQL
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/s
		try {
			// Render the SQL query
			final PreparedStatement insert;
			if ( useBatch ) {
				insert = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
/s
			statement = buildBatchStatement( sql, callable );
/s
	private PreparedStatement buildBatchStatement(String sql, boolean callable) {
		return jdbcCoordinator.getStatementPreparer().prepareStatement( sql, callable );
/s
		return buildPreparedStatementPreparationTemplate( sql, isCallable ).prepareStatement();

			}
/t
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3124	
				insert = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getStatementPreparer()
						.prepareStatement( sql, callable );
			}
/ D
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
				if ( useBatch ) {
					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();
//////////////////
/ to db	,
/s
NonBatchingBatch.addToBatch() line: 58	
				final PreparedStatement statement = entry.getValue();
/ zojuist create	,
				final int rowCount = jdbcCoordinator.getResultSetReturn().executeUpdate( statement );
/ s
ResultSetReturnImpl.executeUpdate(PreparedStatement) line: 207	
			return statement.executeUpdate();
/t

////////////////////////
/ Eerst in db , dan in 2 cache	,

		if ( isCachePutEnabled( persister, session ) ) {
/ JA
/ want	,
/s
		return persister.hasCache()
				&& !persister.isCacheInvalidationRequired()
				&& session.getCacheMode().isPutEnabled();
/s
SingleTableEntityPersister(AbstractEntityPersister).hasCache() line: 4317	
		return cacheAccessStrategy != null;
this	SingleTableEntityPersister  (id=159)	
	cacheAccessStrategy	NonstopAwareEntityRegionAccessStrategy  (id=775)	
		actualStrategy	ReadWriteEhcacheEntityRegionAccessStrategy  (id=777)	
		hibernateNonstopExceptionHandler	HibernateNonstopCacheExceptionHandler  (id=607)	

/t
		if ( isCachePutEnabled( persister, session ) ) {
/ JA
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);

/ Intermezzo

/ 7	. De persister is per type, Address of Employee	, en kent de properties en hun types	, dat is nodig voor disassemble	,


/ 7	.

/ persister.getPropertyTypes() via persister.entityMetamodel	,

this	SingleTableEntityPersister  (id=133)	
	affectingFetchProfileNames	HashSet<E>  (id=304)	
	attributeDefinitions	Collections$UnmodifiableRandomAccessList<E>  (id=307)	
	batchSize	1	
	cacheAccessStrategy	NonstopAwareEntityRegionAccessStrategy  (id=136)	
	cachedPkByNonNullableNaturalIdQuery	null	
	cacheEntryHelper	AbstractEntityPersister$StandardCacheEntryHelper  (id=390)	
	cascadeDeleteEnabled	(id=417)	
	constraintOrderedKeyColumnNames	String[1][]  (id=418)	
	constraintOrderedTableNames	String[1]  (id=419)	
	customSQLDelete	String[1]  (id=420)	
	customSQLInsert	String[1]  (id=421)	
	customSQLUpdate	String[1]  (id=422)	
	deleteBatchKey	null	
	deleteCallable	(id=423)	
	deleteResultCheckStyles	ExecuteUpdateResultCheckStyle[1]  (id=424)	
	discriminatorAlias	null	
	discriminatorColumnName	null	
	discriminatorColumnReaders	null	
	discriminatorColumnReaderTemplate	null	
	discriminatorFormula	null	
	discriminatorFormulaTemplate	null	
	discriminatorInsertable	false	
	discriminatorMetadata	null	
	discriminatorSQLValue	null	
	discriminatorType	null	
	discriminatorValue	null	
	embeddedCompositeIdentifierAttributes	null	
	entityIdentifierDefinition	EntityIdentifierDefinitionHelper$1  (id=425)	
	entityMetamodel	EntityMetamodel  (id=429)	
		cascadeStyles	CascadeStyle[4]  (id=541)	
		dynamicInsert	false	
		dynamicUpdate	false	
		entityMode	EntityMode  (id=542)	
		entityNameByInheritenceClassMap	HashMap<K,V>  (id=544)	
		entityTuplizer	PojoEntityTuplizer  (id=431)	
		entityType	ManyToOneType  (id=545)	
		explicitPolymorphism	false	
		hasCacheableNaturalId	false	
		hasCascades	false	
		hasCollections	false	
		hasImmutableNaturalId	false	
		hasInsertGeneratedValues	false	
		hasLazyProperties	false	
		hasMutableProperties	false	
		hasNonIdentifierPropertyNamedId	false	
		hasPreInsertGeneratedValues	false	
		hasPreUpdateGeneratedValues	false	
		hasSubclasses	false	
		hasUpdateGeneratedValues	false	
		identifierAttribute	IdentifierProperty  (id=550)	
		inDatabaseValueGenerationStrategies	InDatabaseValueGenerationStrategy[4]  (id=556)	
		inherited	false	
		inMemoryValueGenerationStrategies	InMemoryValueGenerationStrategy[4]  (id=559)	
		instrumentationMetadata	BytecodeProviderImpl$EntityInstrumentationMetadataImpl  (id=562)	
		isAbstract	false	
		lazy	true	
		mutable	true	
		name	"my.test.own.ehcache_hibernate_xml3.Address" (id=150)	
		naturalIdPropertyNumbers	null	
		nonlazyPropertyUpdateability	(id=565)	
		optimisticLockStyle	OptimisticLockStyle  (id=566)	
		persister	SingleTableEntityPersister  (id=133)	
		polymorphic	false	
		properties	NonIdentifierAttribute[4]  (id=568)	
		propertyCheckability	(id=571)	
		propertyIndexes	HashMap<K,V>  (id=572)	
		propertyInsertability	(id=370)	
		propertyLaziness	(id=573)	
		propertyNames	String[4]  (id=574)	
		propertyNullability	(id=575)	
		propertySpan	4	
		propertyTypes	Type[4]  (id=576)	
			[0]	StringType  (id=579)	
			[1]	StringType  (id=579)	
			[2]	StringType  (id=579)	
			[3]	OneToOneType  (id=580)	
		propertyUpdateability	(id=577)	
		propertyVersionability	(id=578)	
		rootName	"my.test.own.ehcache_hibernate_xml3.Address" (id=150)	
		selectBeforeUpdate	false	
		sessionFactory	SessionFactoryImpl  (id=59)	
		subclassEntityNames	HashSet<E>  (id=639)	
		superclass	null	
		versioned	false	
		versionPropertyIndex	-66	
	entityTuplizer	PojoEntityTuplizer  (id=431)	
	factory	SessionFactoryImpl  (id=59)	
	filterHelper	FilterHelper  (id=436)	
	forceDiscriminator	false	
	fullDiscriminatorValues	null	
	hasFormulaProperties	false	
	hasSequentialSelects	false	
	hasSubselectLoadableCollections	false	
	identifierAliases	String[1]  (id=438)	
	identifierColumnSpan	1	
	identityDelegate	null	
	inserBatchKey	BasicBatchKey  (id=439)	
	insertCallable	(id=442)	
	insertResultCheckStyles	ExecuteUpdateResultCheckStyle[1]  (id=443)	
	isClassOrSuperclassTable	(id=444)	
	isInverseSubclassTable	(id=445)	
	isInverseTable	(id=446)	
	isLazyPropertiesCacheable	true	
	isNullableSubclassTable	(id=447)	
	isNullableTable	(id=448)	
	joinSpan	1	
	keyColumnNames	String[1][]  (id=449)	
	lazyProperties	HashSet<E>  (id=450)	
	lazyPropertyColumnAliases	String[0][]  (id=451)	
	lazyPropertyNames	String[0]  (id=452)	
	lazyPropertyNumbers	(id=453)	
	lazyPropertyTypes	Type[0]  (id=454)	
	loaderName	null	
	loaders	HashMap<K,V>  (id=455)	
	lobProperties	ArrayList<E>  (id=456)	
	lockers	HashMap<K,V>  (id=458)	
	naturalIdIsNonNullable	null	
	naturalIdRegionAccessStrategy	null	
	propertyColumnAliases	String[4][]  (id=459)	
	propertyColumnFormulaTemplates	String[4][]  (id=460)	
	propertyColumnInsertable	(id=461)	
	propertyColumnNames	String[4][]  (id=462)	
	propertyColumnReaderTemplates	String[4][]  (id=463)	
	propertyColumnSpans	(id=464)	
	propertyColumnUpdateable	(id=465)	
	propertyColumnWriters	String[4][]  (id=466)	
	propertyDefinedOnSubclass	(id=467)	
	propertyMapping	BasicEntityPropertyMapping  (id=468)	
	propertySelectable	(id=471)	
	propertySubclassNames	String[4]  (id=472)	
	propertyTableNumbers	(id=473)	
	propertyTableNumbersByNameAndSubclass	HashMap<K,V>  (id=474)	
	propertyUniqueness	(id=475)	
	qualifiedTableNames	String[1]  (id=476)	
	queryLoader	null	
	rootTableKeyColumnNames	String[1]  (id=479)	
	rootTableKeyColumnReaders	String[1]  (id=480)	
	rootTableKeyColumnReaderTemplates	String[1]  (id=481)	
	rowIdName	null	
	sequentialSelectStringsByEntityName	HashMap<K,V>  (id=482)	
	spaces	String[1]  (id=483)	
	sqlDeleteStrings	String[1]  (id=484)	
	sqlIdentityInsertString	null	
	sqlInsertGeneratedValuesSelectString	null	
	sqlInsertStrings	String[1]  (id=485)	
	sqlLazySelectString	null	
	sqlLazyUpdateByRowIdString	null	
	sqlLazyUpdateStrings	String[1]  (id=486)	
	sqlSnapshotSelectString	"select address_.id_, address_.address_line1_ as address_2_0_, address_.zipcoce_ as zipcoce_3_0_, address_.city_ as city_4_0_ from address address_ where address_.id_=?" (id=488)	
	sqlUpdateByRowIdString	null	
	sqlUpdateGeneratedValuesSelectString	null	
	sqlUpdateStrings	String[1]  (id=490)	
	sqlVersionSelectString	"select id_ from address where id_ =?" (id=491)	
	sqlWhereString	null	
	sqlWhereStringTemplate	null	
	subclassClosure	String[1]  (id=492)	
	subclassColumnAliasClosure	String[3]  (id=493)	
	subclassColumnClosure	String[3]  (id=494)	
	subclassColumnLazyClosure	(id=495)	
	subclassColumnReaderTemplateClosure	String[3]  (id=496)	
	subclassColumnSelectableClosure	(id=497)	
	subclassColumnTableNumberClosure	(id=498)	
	subclassesByDiscriminatorValue	HashMap<K,V>  (id=499)	
	subclassFormulaAliasClosure	String[0]  (id=500)	
	subclassFormulaClosure	String[0]  (id=501)	
	subclassFormulaLazyClosure	(id=502)	
	subclassFormulaTableNumberClosure	(id=503)	
	subclassFormulaTemplateClosure	String[0]  (id=504)	
	subclassPropertyAliases	HashMap<K,V>  (id=505)	
	subclassPropertyCascadeStyleClosure	CascadeStyle[4]  (id=506)	
	subclassPropertyColumnNameClosure	String[4][]  (id=507)	
	subclassPropertyColumnNames	HashMap<K,V>  (id=508)	
	subclassPropertyColumnNumberClosure	(id=509)	
	subclassPropertyColumnReaderClosure	String[4][]  (id=510)	
	subclassPropertyColumnReaderTemplateClosure	String[4][]  (id=511)	
	subclassPropertyFetchModeClosure	FetchMode[4]  (id=512)	
	subclassPropertyFormulaNumberClosure	(id=513)	
	subclassPropertyFormulaTemplateClosure	String[4][]  (id=514)	
	subclassPropertyNameClosure	String[4]  (id=515)	
	subclassPropertyNullabilityClosure	(id=516)	
	subclassPropertySubclassNameClosure	String[4]  (id=517)	
	subclassPropertyTableNumberClosure	(id=518)	
	subclassPropertyTypeClosure	Type[4]  (id=519)	
	subclassTableIsLazyClosure	(id=520)	
	subclassTableKeyColumnClosure	String[1][]  (id=521)	
	subclassTableNameClosure	String[1]  (id=522)	
	subclassTableSequentialSelect	(id=523)	
	tableHasColumns	(id=524)	
	temporaryIdTableDDL	"create temporary table HT_address (id_ int8 not null) on commit drop" (id=525)	
	temporaryIdTableName	"HT_address" (id=526)	
	uniqueKeyLoaders	HashMap<K,V>  (id=527)	
	updateBatchKey	null	
	updateCallable	(id=528)	
	updateResultCheckStyles	ExecuteUpdateResultCheckStyle[1]  (id=529)	
	versionColumnName	null	



/ Einde Intermezzo
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 81	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/ s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 138	
/=
	public static Serializable[] disassemble(
			final Object[] row,
			final Type[] types,
			final boolean[] nonCacheable,
			final SessionImplementor session,
			final Object owner) {
row	Object[3]  (id=874)	
	[0]	"Bar" (id=103)	
	[1]	Double  (id=908)	
	[2]	Address  (id=101)	
types	Type[3]  (id=781)	
	[0]	StringType  (id=344)	
	[1]	DoubleType  (id=838)	
	[2]	ManyToOneType  (id=843)	
/ Dit is voor een employee	, een address heeft een OneToOneType	,


this	SingleTableEntityPersister  (id=159)	
	cacheAccessStrategy	NonstopAwareEntityRegionAccessStrategy  (id=775)	
		actualStrategy	ReadWriteEhcacheEntityRegionAccessStrategy  (id=777)	
		hibernateNonstopExceptionHandler	HibernateNonstopCacheExceptionHandler  (id=607)	


		for ( int i = 0; i < row.length; i++ ) {
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );

/  String	,

/s
StringType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	
this	StringType  (id=344)	
	dictatedSize	Size  (id=799)	
	javaTypeDescriptor	StringTypeDescriptor  (id=788)	
	sqlTypeDescriptor	VarcharTypeDescriptor  (id=800)	
	sqlTypes	(id=802)	

		return getMutabilityPlan().disassemble( (T) value );
/s
		return javaTypeDescriptor.getMutabilityPlan();
/s
ImmutableMutabilityPlan<T>.disassemble(T) line: 48	
		return (Serializable) value;

/ OneToOne	, 

ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 249	
		else {
			// cache the actual id of the object, not the value of the
			// property-ref, which might not be initialized
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
					getAssociatedEntityName(),
					value,
					session
			);
Long 1
			return getIdentifierType( session ).disassemble( id, session, owner );
/s
ManyToOneType(EntityType).getIdentifierType(SessionImplementor) line: 650	
		final Type type = associatedIdentifierType;
		else {
			return type;
LongType

/t
/s
LongType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	
		return getMutabilityPlan().disassemble( (T) value );
/s
ImmutableMutabilityPlan<T>.disassemble(T) line: 48	
		return (Serializable) value;

/ Na de for loops van de rows	,
		return disassembled;
disassembled	Serializable[3]  (id=837)	
	[0]	"Foo" (id=205)	
	[1]	Double  (id=228)	
	[2]	Long  (id=183)	
		value	1	





state	Object[4]  (id=186)	
	[0]	"foostreet" (id=198)	
	[1]	"12 foo" (id=199)	
	[2]	"FooCity" (id=201)	
	[3]	Employee  (id=160)	

this	StandardCacheEntryImpl  (id=406)	
	disassembledState	Serializable[4]  (id=413)	
		[0]	"foostreet" (id=198)	
		[1]	"12 foo" (id=199)	
		[2]	"FooCity" (id=201)	

/t
EntityInsertAction.execute() line: 134	
			cacheEntry = persister.getCacheEntryStructure().structure( ce );
/ D
this	EntityInsertAction  (id=300)	
	cacheEntry	StandardCacheEntryImpl  (id=406)	
		disassembledState	Serializable[4]  (id=413)	
			[0]	"foostreet" (id=198)	
			[1]	"12 foo" (id=199)	
			[2]	"FooCity" (id=201)	
		lazyPropertiesAreUnfetched	false	
		subclass	"my.test.own.ehcache_hibernate_xml3.Address" (id=393)	
		version	null	

			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
ck	CacheKey  (id=562)	
	entityOrRoleName	"my.test.own.ehcache_hibernate_xml3.Address" (id=393)	
	hashCode	31	
	key	Long  (id=183)	
	tenantId	null	
	type	LongType  (id=533)	

			final boolean put = cacheInsert( persister, ck );
//////////////////////
/ Gebeurt niet hier	, 
/ gebeurt na doCommit	, in afterTransactionCommit	,
/ De cacheEntry is prop van de EntityInsertAction	, en zo wordt hij dus later weer gevonden	,

/ Intermezzo

/ onetoone type : gaat null in ehcache
/ manytoone type : gaat id in ehcache

/ Einde Intermezzo

/s
			return persister.getCacheAccessStrategy().insert( ck, cacheEntry, version );

/ t
/ volgende,	
/ en employee	,

/ we hebben in db	, nu in cache	,

EntityInsertAction.execute() line: 127	
			
			persister.insert( id, getState(), instance, session );
/ D
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 137	
row	Object[3]  (id=874)	
	[0]	"Bar" (id=103)	
	[1]	Double  (id=908)	
	[2]	Address  (id=101)	
types	Type[3]  (id=781)	
	[0]	StringType  (id=344)	
	[1]	DoubleType  (id=838)	
	[2]	ManyToOneType  (id=843)	

		for ( int i = 0; i < row.length; i++ ) {
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );

/ string, double doen niets	,
ImmutableMutabilityPlan<T>.disassemble(T) line: 48	
		return (Serializable) value;

/s
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 239	
			// cache the actual id of the object, not the value of the
			// property-ref, which might not be initialized
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
					getAssociatedEntityName(),
					value,
					session
			);
/ we cache een employee	, de fk is naar een address	,
/ 2	, de id van de address	,
/s
	public static Serializable getEntityIdentifierIfNotUnsaved(
			final String entityName,
			final Object object,
			final SessionImplementor session) throws TransientObjectException {
entityName	"my.test.own.ehcache_hibernate_xml3.Address" (id=393)	
object	Address  (id=101)	

/t
			return getIdentifierType( session ).disassemble( id, session, owner );

/t
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 148	
disassembled	Serializable[3]  (id=1031)	
	[0]	"Bar" (id=103)	
	[1]	Double  (id=908)	
	[2]	Long  (id=867)	

/////////////////////////////////////////////
/ Dus aan de ManyToOne kant (fk) en aan de OneToOne kant (entity-ref) wordt het obj vervangen door de id	, die gaat de cache in	,

/t
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 81	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/ D
		subclass = persister.getEntityName();
subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=1129)	

/t
EntityInsertAction.execute() line: 133	
			persister.insert( id, getState(), instance, session );
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/ D
instance	Employee  (id=99)	
	address	Address  (id=101)	
	id	2	
	name	"Bar" (id=103)	
	salary	2.0	
ce	StandardCacheEntryImpl  (id=1028)	
	disassembledState	Serializable[3]  (id=1031)	
		[0]	"Bar" (id=103)	
		[1]	Double  (id=908)	
		[2]	Long  (id=867)	
	lazyPropertiesAreUnfetched	false	
	subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=1129)	
	version	null	

			cacheEntry = persister.getCacheEntryStructure().structure( ce );
/ this.cacheEntry==ce

			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
/s
	public CacheKey generateCacheKey(Serializable id, Type type, String entityOrRoleName) {
type	LongType  (id=533)	
entityOrRoleName	"my.test.own.ehcache_hibernate_xml3.Employee" (id=1129)	

		return new CacheKey( id, type, entityOrRoleName, getTenantIdentifier(), getFactory() );
/s
factory	SessionFactoryImpl  (id=52)	
		this.key = id;
		this.type = type;
		this.entityOrRoleName = entityOrRoleName;
		this.tenantId = tenantId;
		this.hashCode = calculateHashCode( type, factory );

/t
			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
ck	CacheKey  (id=1233)	
	entityOrRoleName	"my.test.own.ehcache_hibernate_xml3.Employee" (id=1129)	
	hashCode	62	
	key	Long  (id=867)	
	tenantId	null	
	type	LongType  (id=533)	

			final boolean put = cacheInsert( persister, ck );
///////////////
/ this	EntityInsertAction  (id=290)	, heeft prop cacheEntry (=ce hierboven), en zo wordt deze insert (is geen arg)	, 
/ Maar deze meth doet niets, we zien de insert pas later na commit in 
			afterTransactionCompletion( Status.STATUS_COMMITTED );

/s
			return persister.getCacheAccessStrategy().insert( ck, cacheEntry, version );
/s
	public boolean insert(Object key, Object value, Object version) throws CacheException {
		try {
			return actualStrategy.insert( key, value, version );
/s
ReadWriteEhcacheEntityRegionAccessStrategy.insert(Object, Object, Object) line: 65	
	 * A no-op since this is an asynchronous cache access strategy.
	 */
	@Override
	public boolean insert(Object key, Object value, Object version) throws CacheException {
		return false;

/t
EntityInsertAction.execute() line: 138	
			final boolean put = cacheInsert( persister, ck );
false

			if ( put && factory.getStatistics().isStatisticsEnabled() ) {
/ NEE
				factory.getStatisticsImplementor().secondLevelCachePut( getPersister().getCacheAccessStrategy().getRegion().getName() );
/ NIET
		if ( factory.getStatistics().isStatisticsEnabled() && !veto ) {
/ JA
			factory.getStatisticsImplementor().insertEntity( getPersister().getEntityName() );
/s
		return serviceRegistry.getService( StatisticsImplementor.class );
/ t
/s
ConcurrentStatisticsImpl.insertEntity(String) line: 249	
/ TODO

/t
JdbcTransaction(AbstractTransactionImpl).commit() line: 182	
		beforeTransactionCommit();
/D

//////////////////////////////////////////
/ De dml is naar de db sent	, nog niet committed	,
/ de obj zijn dissambled voor naar ehcache	,


		try {
			doCommit();
/ nu de tx.commit	, 
	-> db commit	,
///////////////////////////////////////////////////////////////////////
	@Override
	protected void doCommit() throws TransactionException {
		try {
			managedConnection.commit();
			releaseManagedConnection();


/t
			localStatus = LocalStatus.COMMITTED;
			afterTransactionCompletion( Status.STATUS_COMMITTED );
...
/s
TransactionCoordinatorImpl.afterTransaction(TransactionImplementor, int) line: 150	
		getTransactionContext().afterTransactionCompletion( hibernateTransaction, success );
/s
SessionImpl.afterTransactionCompletion(TransactionImplementor, boolean) line: 529	
		actionQueue.afterTransactionCompletion( successful );

/////////////////////////////////
/ Nu wordt alles in de ehcache set	,

/ s
ActionQueue$AfterTransactionCompletionProcessQueue.afterTransactionCompletion(boolean) line: 744	
			while ( !processes.isEmpty() ) {
				try {
					processes.poll().doAfterTransactionCompletion( success, session );
this	ActionQueue$AfterTransactionCompletionProcessQueue  (id=288)	
	processes	ConcurrentLinkedQueue<E>  (id=290)	
[EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Address#1], EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Employee#1], EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Address#2], EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Employee#2]]

/s
EntityInsertAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 226	
this	EntityInsertAction  (id=176)	
	cacheEntry	StandardCacheEntryImpl  (id=212)	
		disassembledState	Serializable[4]  (id=218)	
			[0]	"foostreet" (id=185)	
			[1]	"12 foo" (id=223)	
			[2]	"FooCity" (id=186)	
		subclass	"my.test.own.ehcache_hibernate_xml3.Address" (id=143)	

/ Herinner: in de entityinsertaction was de cacheEntry als prop	saved	,

			final CacheKey ck = getSession().generateCacheKey( getId(), persister.getIdentifierType(), persister.getRootEntityName() );
			final boolean put = cacheAfterInsert( persister, ck );
true
/ Deze cacheEntry gaat precies zo ehcache in	,








/ stack trace, dus verkeerd om	,

	SelectableConcurrentHashMap$Segment.put(Object, int, Element, long, boolean, boolean, boolean) line: 813	
	SelectableConcurrentHashMap.put(Object, Element, long) line: 435	
	MemoryStore.put(Element) line: 260	
	MemoryStore.fill(Element) line: 237	
	DiskBackedMemoryStore(FrontEndCacheTier<T,U>).put(Element) line: 269	
	Cache.putInternal(Element, boolean, boolean) line: 1455	
	Cache.put(Element, boolean) line: 1383	
	Cache.put(Element) line: 1348	
	EhcacheEntityRegion(EhcacheTransactionalDataRegion).put(Object, Object) line: 143	
	ReadWriteEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 79	
	NonstopAwareEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 65	
	EntityInsertAction.cacheAfterInsert(EntityPersister, CacheKey) line: 241	
	EntityInsertAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 228	

	ActionQueue$AfterTransactionCompletionProcessQueue.afterTransactionCompletion(boolean) line: 744	
processes	ConcurrentLinkedQueue<E>  (id=3015)	
	head	ConcurrentLinkedQueue$Node<E>  (id=3017)	
		item	EntityInsertAction  (id=2968)	
			areTransientReferencesNullified	true	
			cacheEntry	StandardCacheEntryImpl  (id=3066)	
				disassembledState	Serializable[3]  (id=3072)	
					[0]	"Foo" (id=3074)	
					[1]	Double  (id=3075)	
					[2]	Long  (id=2991)	
		next	ConcurrentLinkedQueue$Node<E>  (id=3021)	
			item	EntityInsertAction  (id=2970)	
			next	ConcurrentLinkedQueue$Node<E>  (id=3018)	
				item	EntityInsertAction  (id=2972)	
				next	null	

			while ( !processes.isEmpty() ) {
				try {
					processes.poll().doAfterTransactionCompletion( success, session );

	ActionQueue.afterTransactionCompletion(boolean) line: 379	
			afterTransactionProcesses.afterTransactionCompletion( success );

	SessionImpl.afterTransactionCompletion(TransactionImplementor, boolean) line: 529	
	TransactionCoordinatorImpl.afterTransaction(TransactionImplementor, int) line: 150	
-> 	JdbcTransaction.afterTransactionCompletion(int) line: 138	
	JdbcTransaction(AbstractTransactionImpl).commit() line: 182	
	Main.testBasicUsage() line: 128	
	Main.<init>() line: 59	
	Main.main(String[]) line: 53	




/ 7	. 

/ .get employee	, de owner of the rel	, has many-to-one to address	,

/ In nieuwe sessie	,

	        Employee emp = (Employee) session.get(Employee.class, 1l);







...
/s
SessionImpl$IdentifierLoadAccessImpl.load(Serializable) line: 2551	

				fireLoad( event, LoadEventListener.GET );

/ Hier in is	,
	public static final LoadType GET = new LoadType( "GET" )
			.setAllowNulls( true )
			.setAllowProxyCreation( false )
			.setCheckDeleted( true )
			.setNakedEntityReturned( false );

/ Een session.get geeft altijd (TODO) een entity, geen proxy, vandaar: .setAllowProxyCreation( false )	,
/ we zien deze later terug als options	,
...
/s
DefaultLoadEventListener.onLoad(LoadEvent, LoadEventListener$LoadType) line: 151	

					event.setResult( proxyOrLoad( event, persister, keyToLoad, loadType ) );
/ loadType=LoadEventListener.GET : allow proxy =false

/s
DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 275	
		if ( !persister.hasProxy() ) {
/ NEE, 	
/ want persister.hasProxy()==persister.isLazy=true	, employee's zijn in principe lazy	, 

/ maar in dit gevel niet, want we doen .get,	 dus allow proxy=false	,
		if ( options.isAllowProxyCreation() ) {
/ NEE 

		return load( event, persister, keyToLoad, options );
...
/s
///////////////////////////////////////////////////////////////////////////////////
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
/ want,	
/ hij kijkt op key	,
		final Object result = persistenceContext.getEntity(key);

		entity = loadFromSecondLevelCache( event, persister, options );

/ options = LoadEventListener.GET hierboven	,

/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 586	
		final boolean useCache = persister.hasCache()
				&& source.getCacheMode().isGetEnabled()
				&& event.getLockMode().lessThan( LockMode.READ );
NONE<READ
true

		final CacheKey ck = source.generateCacheKey(
				event.getEntityId(),
				persister.getIdentifierType(),
				persister.getRootEntityName()
		);
/s
	public CacheKey generateCacheKey(Serializable id, Type type, String entityOrRoleName) {
this	SessionImpl  (id=2989)	
id	Long  (id=2963)	
	value	1	
type	LongType  (id=3039)	
	dictatedSize	Size  (id=3041)	
	javaTypeDescriptor	LongTypeDescriptor  (id=3042)	
	sqlTypeDescriptor	BigIntTypeDescriptor  (id=3043)	
	sqlTypes	(id=3044)	
entityOrRoleName	"my.test.own.ehcache_hibernate_xml3.Employee" (id=2995)	

		return new CacheKey( id, type, entityOrRoleName, getTenantIdentifier(), getFactory() );

/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 598	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/s
		return fromSharedCache( session, (Object) cacheKey, cacheAccessStrategy );
cacheAccessStrategy	NonstopAwareEntityRegionAccessStrategy  (id=3026)	
	actualStrategy	ReadWriteEhcacheEntityRegionAccessStrategy  (id=3082)	
...
/s
CacheHelper.fromSharedCache(SessionImplementor, Object, RegionAccessStrategy) line: 52	
			cachedValue = (Serializable) cacheAccessStrategy.get( cacheKey, session.getTimestamp() );
/s
			return actualStrategy.get( key, txTimestamp );
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 77	
			final Lockable item = (Lockable) region().get( key );
/s
/ Hibernate's
EhcacheEntityRegion(EhcacheTransactionalDataRegion).get(Object) line: 112	
/s
/ EhCache's
Cache.get(Object) line: 1576	
       if (isStatisticsEnabled()) {
false
/ TODO
            return searchInStoreWithoutStats(key, false, true);
/s
Cache.searchInStoreWithoutStats(Object, boolean, boolean) line: 2066	
            element = compoundStore.get(key);
/s
/ EhCache's 	,
DiskBackedMemoryStore(FrontEndCacheTier<T,U>).get(Object) line: 185	
            Element e = cache.get(key);
/s
/ EhCache's 	,
MemoryStore.get(Object) line: 300	
            final Element e = map.get(key);
/s
/ EhCache's 	,
SelectableConcurrentHashMap.get(Object) line: 375	
        int hash = hash(key.hashCode());
        return segmentFor(hash).get(key, hash);
/s
.segmentFor
    protected final Segment segmentFor(int hash) {
        return segments[(hash >>> segmentShift) & segmentMask];
/t
/s
SelectableConcurrentHashMap$Segment.get(Object, int) line: 892	
/=
       Element get(final Object key, final int hash) {
/////////////////
/ diepst	,
                if (count != 0) { // read-volatile
1
/ TODO
                    HashEntry e = getFirst(hash);
/s
        protected HashEntry getFirst(int hash) {
            HashEntry[] tab = table;
            return tab[hash & (tab.length - 1)];
/ nu: tab[0]	,
this	SelectableConcurrentHashMap$Segment  (id=3184)	
	count	1	
	table	SelectableConcurrentHashMap$HashEntry[1]  (id=3188)	
		[0]	SelectableConcurrentHashMap$HashEntry  (id=3200)	
			key	CacheKey  (id=3209)	
				entityOrRoleName	"my.test.own.ehcache_hibernate_xml3.Employee" (id=2995)	
				hashCode	31	
				key	Long  (id=2963)	
					value	1	
				tenantId	null	
				type	LongType  (id=3039)	
			value	Element  (id=3218)	
				value	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3229)	
					timestamp	5761905336975360	
					value	StandardCacheEntryImpl  (id=3234)	
						disassembledState	Serializable[3]  (id=3236)	
							[0]	"Foo" (id=3239)	
							[1]	Double  (id=3240)	
							[2]	Long  (id=2963)	
/ Klopt	,

/t
SelectableConcurrentHashMap$Segment.get(Object, int) line: 896	
                    HashEntry e = getFirst(hash);
e	SelectableConcurrentHashMap$HashEntry  (id=3200)	
	key	CacheKey  (id=3209)	
	value	Element  (id=3218)	
		value	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3229)	
			value	StandardCacheEntryImpl  (id=3234)	
				disassembledState	Serializable[3]  (id=3236)	
					[0]	"Foo" (id=3239)	
					[1]	Double  (id=3240)	
					[2]	Long  (id=2963)	
/ we zien Element	,

                   while (e != null) {
                        if (e.hash == hash && key.equals(e.key) && !e.value.equals(DUMMY_PINNED_ELEMENT)) {
true
                            e.accessed = true;
                            return e.value;

/t
MemoryStore.get(Object) line: 304	
            final Element e = map.get(key);
/ D
/t
DiskBackedMemoryStore(FrontEndCacheTier<T,U>).get(Object) line: 213	
            Element e = cache.get(key);
/ D
            } else {
                return copyElementForReadIfNeeded(e);
/= e

/t
Cache.searchInStoreWithoutStats(Object, boolean, boolean) line: 2072	
            element = compoundStore.get(key);
/ D
        return elementStatsHelper(key, quiet, notifyListeners, element);
/s
            } else if (!(quiet || skipUpdateAccessStatistics(element))) {
true
                element.updateAccessStatistics();
        return element;


/ want	,
    private boolean skipUpdateAccessStatistics(Element element) {
      return 	configuration.isFrozen() && 
		element.isEternal() && 
false
		(configuration.getMaxElementsInMemory() == 0) && 
false, =10
		(!configuration.isOverflowToDisk() || 
!true=false
		  configuration.getMaxElementsOnDisk() == 0);
false, =100
    }

/t in Hibernate	,
EhcacheEntityRegion(EhcacheTransactionalDataRegion).get(Object) line: 112	
			final Element element = getCache().get( key );
/ D
elementEvictionData	DefaultElementEvictionData  (id=3221)	
key	CacheKey  (id=3209)	
value	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3229)	
	value	StandardCacheEntryImpl  (id=3234)	
		disassembledState	Serializable[3]  (id=3236)	
			[0]	"Foo" (id=3239)	
			[1]	Double  (id=3240)	
			[2]	Long  (id=2963)	
		subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=2995)	

				return element.getObjectValue();
/= value	,

/t
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 79	
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3229)	
	value	StandardCacheEntryImpl  (id=3234)	
		disassembledState	Serializable[3]  (id=3236)	

				return item.getValue();
/t
CacheHelper.fromSharedCache(SessionImplementor, Object, RegionAccessStrategy) line: 58	
			cachedValue = (Serializable) cacheAccessStrategy.get( cacheKey, session.getTimestamp() );
		return cachedValue;
/ D
cachedValue	StandardCacheEntryImpl  (id=3234)	
	disassembledState	Serializable[3]  (id=3236)	
	subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=2995)	

/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 598	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
///////////////////////////////////////
/ hij heeft een query op de 2nd cache gedaan en is gelukt	,
/D
ce	StandardCacheEntryImpl  (id=3234)	
	disassembledState	Serializable[3]  (id=3236)	
	subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=2995)	

...

		if ( factory.getStatistics().isStatisticsEnabled() ) {
true
			}
			else {
				factory.getStatisticsImplementor().secondLevelCacheHit(
						persister.getCacheAccessStrategy().getRegion().getName());

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
/ entry==ce
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
//////////////////////////////////////////////
/ entry is ehcache disassembled Serializable[]	,
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 637	
		if ( entry.isReferenceEntry() ) {
/s
StandardCacheEntryImpl.isReferenceEntry() line: 97	
		return false;
/t
		else {
			subclassPersister = factory.getEntityPersister( entry.getSubclass() );
entry	StandardCacheEntryImpl  (id=3234)	
	subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=2995)	

			final Object optionalObject = event.getInstanceToLoad();
null
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
////////////
/ obj met alles 0, behalve id	,
/s
SessionImpl.instantiate(EntityPersister, Serializable) line: 1391	
			result = persister.instantiate( id, this );
...
/s
PojoInstantiator.instantiate() line: 124	
				return constructor.newInstance( (Object[]) null );
/t
	public final Object instantiate(Serializable id, SessionImplementor session) {
		Object result = getInstantiator().instantiate( id );
/ D
		if ( id != null ) {
			setIdentifier( result, id, session );
/t
SessionImpl.instantiate(EntityPersister, Serializable) line: 1393	
			result = persister.instantiate( id, this );
/ D
result	Employee  (id=3721)	
	address	null	
	id	1	
	name	null	
	salary	0.0	

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 684	
/=
	private Object convertCacheEntryToEntity(
			CacheEntry entry,
			Serializable entityId,
			EntityPersister persister,
			LoadEvent event) {

entry	StandardCacheEntryImpl  (id=3135)	
	disassembledState	Serializable[3]  (id=3140)	
		[0]	"Foo" (id=3141)	
		[1]	Double  (id=3142)	
		[2]	Long  (id=3123)	
	subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=132)	

/ entry komt uit ehcache	, 
/ nu gaat we een obj create	, entity	, waar alle props 0 zijn, behalve de id	, en in de pc set	,

			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
/ D
		// make it circular-reference safe
		final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );
		TwoPhaseLoad.addUninitializedCachedEntity(
				entityKey,
				entity,
				subclassPersister,
				LockMode.NONE,
				entry.areLazyPropertiesUnfetched(),
				entry.getVersion(),
				session
		);
/s
TwoPhaseLoad.addUninitializedCachedEntity(EntityKey, Object, EntityPersister, LockMode, boolean, Object, SessionImplementor) line: 393	

		session.getPersistenceContext().addEntity(
				object,
				Status.LOADING,
				null,
				key,
				version,
				lockMode,
				true,
				persister,
				false,
				lazyPropertiesAreUnFetched
			);

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 705	
		if ( entry.isReferenceEntry() ) {
false
		else {
			final Type[] types = subclassPersister.getPropertyTypes();
types	Type[3]  (id=3819)	
	[0]	StringType  (id=3820)	
	[1]	DoubleType  (id=3821)	
	[2]	ManyToOneType  (id=3822)	

			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);

/ entry is ehcache disassembled Serializable[]	,

/s
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 158	
this	StandardCacheEntryImpl  (id=3234)	
	disassembledState	Serializable[3]  (id=3236)	
	subclass	"my.test.own.ehcache_hibernate_xml3.Employee" (id=2995)	

		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 107	
		Object[] assembled = new Object[row.length];

/ Uit ehcache komt een Serializable[], nu gaat Object[] create	,

		for ( int i = 0; i < types.length; i++ ) {
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
...
/s
/ Bij string, double	,
ImmutableMutabilityPlan<T>.assemble(Serializable) line: 54	
	public T assemble(Serializable cached) {
		return (T) cached;
	}

/ bij many-to-one (fk, die employee heeft naar address)	,
ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 272	
		Serializable id = assembleId( oid, session );
/s
		//the owner of the association is not the owner of the id
/ TODO
		return ( Serializable ) getIdentifierType( session ).assemble( oid, session, null );
/s
LongType(AbstractStandardBasicType<T>).assemble(Serializable, SessionImplementor, Object) line: 330	
/s
ImmutableMutabilityPlan<T>.assemble(Serializable) line: 54	
		return (T) cached;

/t
ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 282	

///////////////////////////////
/ een employee heeft een many-to-one naar een address	, deze address moeten we nu resolve,	 we zien dus een andere persister , die van address's	,

		Serializable id = assembleId( oid, session );
/ D
			return resolveIdentifier( id, session );
/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 716	
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);

/ De ManyToOne type is eager=false	,

/s
SessionImpl.internalLoad(String, Serializable, boolean, boolean) line: 983	
		LoadEventListener.LoadType type = ...
						: LoadEventListener.INTERNAL_LOAD_LAZY;

		LoadEvent event = new LoadEvent(id, entityName, true, this);
		fireLoad( event, type );

/ type is 	,

	public static final LoadType INTERNAL_LOAD_LAZY = new LoadType( "INTERNAL_LOAD_LAZY" )
			.setAllowNulls( false )
			.setAllowProxyCreation( true )
			.setCheckDeleted( false )
			.setNakedEntityReturned( false );
/ Maar dit kan ook	,

	public static final LoadType INTERNAL_LOAD_EAGER = new LoadType( "INTERNAL_LOAD_EAGER" )
			.setAllowNulls( false )
			.setAllowProxyCreation( false )
			.setCheckDeleted( false )
			.setNakedEntityReturned( false );

/s
DefaultLoadEventListener.onLoad(LoadEvent, LoadEventListener$LoadType) line: 151	
					event.setResult( proxyOrLoad( event, persister, keyToLoad, loadType ) );

/ loadType is lazy	, dus allow proxy create=true	,
/s
DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 271	
		if ( options.isAllowProxyCreation() ) {
/ JA	, zie boven	, many-to-one is niet eager	,
			return createProxyIfNecessary( event, persister, keyToLoad, options, persistenceContext );
/ Dus NIET	,
		return load( event, persister, keyToLoad, options );
/ TODO (-> db?)

/ Intermezzo

/ Maar we zijn hier al	, dus recursive	,

/ options = .GET	, dus proxy allow=false	,

/ daar is het .get de employee	, en waar we nu zijn is het de many-to-one rel load, en dat is lazy load	,


DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 275	
		if ( options.isAllowProxyCreation() ) {
/ NEE
			return createProxyIfNecessary( event, persister, keyToLoad, options, persistenceContext );
/ NIET	,
		// return a newly loaded object
		return load( event, persister, keyToLoad, options );


/ Einde Intermezzo


/s
DefaultLoadEventListener.createProxyIfNecessary(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType, PersistenceContext) line: 336	
		Object existing = persistenceContext.getEntity( keyToLoad );
null
key	EntityKey  (id=3858)	
	hashCode	630	
	identifier	Long  (id=2963)	
	persister	SingleTableEntityPersister  (id=2958)	

/ persister is die van addresses	, van de many-to-one	,

/ de persister zit erin, want dan zit hij om welk type het gaat, alleen id=1l is niet voldoende	,

/ Klopt, address zit in de 2nd level cache	, en nog niet in de 1ste cache	, 

		if ( existing != null ) {
/ NEE

		Object proxy = persister.createProxy( event.getEntityId(), event.getSession() );
/ persister is die van addresses	, dus waar employee naar refs	,
...
		persistenceContext.addProxy( keyToLoad, proxy );
		return proxy;

/ hij maakt een proxy, en gaat niet opnieuw naar de ehcache voor de properties van de address	,
/ TODO

/ rol persister: de persister heeft de props van de address type	, via entityMetamodel	, dus kan de proxy create	,

/ t
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 723	

		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/ D
/ proxy naar address	, 
/ herhaling: we load een employee uit 2nd cache, we maken een employee inst, we gaan deze assemble met props uit 2nd cache, maar voor address stond alleen de id in 2nd cache,
/ omdat address niet in 1ste cache, maakt hij proxy met de id	,

...
/t
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 113	
		for ( int i = 0; i < types.length; i++ ) {
				assembled[i] = types[i].assemble( row[i], session, owner );
/ D
assembled	Object[3]  (id=3170)	
	[0]	"Foo" (id=3141)	
	[1]	Double  (id=3142)	
	[2]	Address_$$_jvst54f_0  (id=3227)	



/ ASSEMBLE

/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
D
assembledProps	Object[3]  (id=3251)	
	[0]	"Foo" (id=3254)	
	[1]	Double  (id=3255)	
	[2]	Address_$$_jvstc83_0  (id=3240)	

//////////////////////////////////////
		persister.setPropertyValues( instance, assembledProps );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 713	
		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
			if ( setAll || ... 
true
				setters[j].set( entity, values[j], getFactory() );
/s
BasicPropertyAccessor$BasicSetter.set(Object, Object, SessionFactoryImplementor) line: 68	
				method.invoke( target, value );
this	BasicPropertyAccessor$BasicSetter  (id=402)	
	method	Method  (id=405)	
public void my.test.own.ehcache_hibernate_xml3.Employee.setName(java.lang.String)

/ H calls setters via relection	,
/////////////////////////////////
/ Zo set H de properties uit ehcache in 


instance	Employee  (id=3197)	
	address	null	
	id	1	
	name	null	
	salary	0.0	
/ VOOR 

instance	Employee  (id=3197)	
	address	Address_$$_jvstc83_0  (id=3240)	
	id	1	
	name	"Foo" (id=3254)	
	salary	1.0	
/ NA

		return assembledProps;

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 711	
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ D
/ entity is set	, en is in de pc	,
values	Object[3]  (id=229)	
	[0]	"Foo" (id=180)	
	[1]	Double  (id=181)	
	[2]	Address_$$_jvst79e_0  (id=281)	
entity	Employee  (id=193)	
	address	Address_$$_jvst79e_0  (id=281)	
	id	1	
	name	"Foo" (id=180)	
	salary	1.0	
persistenceContext	StatefulPersistenceContext  (id=145)	


			final Object proxy = persistenceContext.getProxy( entityKey );
			if ( proxy != null ) {
/ NEE	, employee is in pc, 	niet een proxy ernaar	, wel de proxy naar de address is in de pc	,

			else {
				isReadOnly = session.isDefaultReadOnly();
false
		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
/ In de pc stond employee met alles 0 behalve id, nu overwrite met assembled obj	,

/ values gaat mee, want dat wordt de loadedState in de pc van dit obj, de initial values als Hibernate later kijkt of dirty is	, de entity in de pc veranert wel (evt.)	,

		persistenceContext.initializeNonLazyCollections();
/ TODO (Later)	,

/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 620	
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/ D
	return entity;

/t
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	
		entity = loadFromSecondLevelCache( event, persister, options );
/ D

...
/t
DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 275	

		if ( options.isAllowProxyCreation() ) {
/ NEE
			return createProxyIfNecessary( event, persister, keyToLoad, options, persistenceContext );
/ NIET

/ Hierboven juist andersom (JA bij allow proxy create), toen hij de many-to-one naar address create  )	, hier create hij employee met .get	, dus allow proxy create=false	,

		// return a newly loaded object
		return load( event, persister, keyToLoad, options );
/ D
...
/t
Main.testBasicUsage() line: 140	
	        Employee emp = (Employee) session.get(Employee.class, 1l);
/ D


 

/ 7	. 

model	RootClass  (id=207)	
	batchSize	-1	
	cacheConcurrencyStrategy	"read-write" (id=218)	
	cacheRegionName	null	
	className	"my.test.own.ehcache_hibernate_xml3.Address" (id=222)	
	customDeleteCallable	false	
	customInsertCallable	false	
	customSQLDelete	null	
	customSQLInsert	null	
	customSQLUpdate	null	
	customUpdateCallable	false	
	declaredIdentifierMapper	null	
	declaredIdentifierProperty	Property  (id=249)	
	declaredProperties	ArrayList<E>  (id=252)	
		elementData	Object[10]  (id=334)	
			[0]	Property  (id=336)	
				cascade	"none" (id=332)	
				insertable	true	
				lazy	false	
				lob	false	
				metaAttributes	HashMap<K,V>  (id=368)	
				name	"addressLine1" (id=373)	
				naturalIdentifier	false	
				nodeName	"addressLine1" (id=373)	
				optimisticLocked	true	
				optional	false	
				persistentClass	RootClass  (id=207)	
				propertyAccessorName	"property" (id=394)	
				selectable	true	
				updateable	true	
				value	SimpleValue  (id=407)	
				valueGenerationStrategy	null	
			[1]	Property  (id=337)	
				cascade	"none" (id=332)	
				insertable	true	
				lazy	false	
				lob	false	
				metaAttributes	HashMap<K,V>  (id=446)	
				name	"zipcode" (id=451)	
				naturalIdentifier	false	
				nodeName	"zipcode" (id=451)	
				optimisticLocked	true	
				optional	false	
				persistentClass	RootClass  (id=207)	
				propertyAccessorName	"property" (id=394)	
				selectable	true	
				updateable	true	
				value	SimpleValue  (id=488)	
				valueGenerationStrategy	null	
			[2]	Property  (id=416)	
				cascade	"none" (id=332)	
				insertable	true	
				lazy	false	
				lob	false	
				metaAttributes	HashMap<K,V>  (id=509)	
				name	"city" (id=514)	
				naturalIdentifier	false	
				nodeName	"city" (id=514)	
				optimisticLocked	true	
				optional	false	
				persistentClass	RootClass  (id=207)	
				propertyAccessorName	"property" (id=394)	
				selectable	true	
				updateable	true	
				value	SimpleValue  (id=551)	
				valueGenerationStrategy	null	
			[3]	Property  (id=421)	
				cascade	"none" (id=332)	
				insertable	true	
				lazy	false	
				lob	false	
				metaAttributes	HashMap<K,V>  (id=568)	
				name	"employee" (id=573)	
				naturalIdentifier	false	
				nodeName	"employee" (id=573)	
				optimisticLocked	true	
				optional	false	
				persistentClass	RootClass  (id=207)	
				propertyAccessorName	"property" (id=394)	
				selectable	true	
				updateable	true	
				value	OneToOne  (id=610)	
				valueGenerationStrategy	null	
		modCount	4	
		size	4	
	declaredVersion	null	
	deleteCheckStyle	null	
	discriminator	null	
	discriminatorInsertable	true	
	discriminatorValue	"my.test.own.ehcache_hibernate_xml3.Address" (id=222)	
	dynamicInsert	false	
	dynamicUpdate	false	
	embeddedIdentifier	false	
	entityName	"my.test.own.ehcache_hibernate_xml3.Address" (id=222)	
	entityPersisterClass	null	
	explicitPolymorphism	false	
	filters	ArrayList<E>  (id=269)	
	forceDiscriminator	false	
	hasSubselectLoadableCollections	false	
	identifier	SimpleValue  (id=273)	
	identifierMapper	null	
	identifierProperty	Property  (id=249)	
		cascade	"none" (id=332)	
		insertable	true	
		lazy	false	
		lob	false	
		metaAttributes	HashMap<K,V>  (id=633)	
		name	"id" (id=634)	
		naturalIdentifier	false	
		nodeName	"id" (id=636)	
		optimisticLocked	true	
		optional	false	
		persistentClass	RootClass  (id=207)	
		propertyAccessorName	"property" (id=394)	
		selectable	true	
		updateable	true	
		value	SimpleValue  (id=273)	
		valueGenerationStrategy	null	
	insertCheckStyle	null	
	isAbstract	null	
	joins	ArrayList<E>  (id=282)	
	jpaEntityName	"Address" (id=284)	
	lazy	true	
	lazyPropertiesCacheable	true	
	loaderName	null	
	mappedClass	null	
	metaAttributes	HashMap<K,V>  (id=289)	
	mutable	true	
	naturalIdCacheRegionName	null	
	nextSubclassId	0	
	nodeName	"Address" (id=294)	
	optimisticLockStyle	OptimisticLockStyle  (id=296)	
	polymorphic	false	
	properties	ArrayList<E>  (id=301)	
	proxyInterface	null	
	proxyInterfaceName	"my.test.own.ehcache_hibernate_xml3.Address" (id=304)	
	selectBeforeUpdate	false	
	subclasses	ArrayList<E>  (id=307)	
	subclassJoins	ArrayList<E>  (id=309)	
	subclassProperties	ArrayList<E>  (id=311)	
	subclassTables	ArrayList<E>  (id=313)	
	superMappedSuperclass	null	
	synchronizedTables	HashSet<E>  (id=316)	
	table	Table  (id=318)	
	temporaryIdTableDDL	"create temporary table HT_address (id_ int8 not null) on commit drop" (id=321)	
	temporaryIdTableName	"HT_address" (id=323)	
	tuplizerImpls	null	
	updateCheckStyle	null	
	version	null	
	where	null	

/ dit is Address, met al z'n properties	,
/ Hetzelfde voor Employee	,


/ 7	. 

/ .get address	,

DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 265	
		// look for a proxy
		Object proxy = persistenceContext.getProxy( keyToLoad );

/ deze is er omdat we eerder een employee hebben load uit de ehcache	, die een many-to-one heeft	, en dus een proxy krijgt naar deze address	,

		if ( proxy != null ) {
			return returnNarrowedProxy( event, persister, keyToLoad, options, persistenceContext, proxy );
/s
DefaultLoadEventListener.returnNarrowedProxy(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType, PersistenceContext, Object) line: 305	

		if ( li.isUnwrap() ) {
/ NEE
/ TODO
			return li.getImplementation();
/ NEE
		}
		Object impl = null;
		if ( !options.isAllowProxyCreation() ) {
/ JA
/ want we doen .get	,
			impl = load( event, persister, keyToLoad, options );
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
/////////////////////////
/ Dit is de method die eerst 1st cache, dan 2nd cache	,

		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
/ want	,
/s
DefaultLoadEventListener.loadFromSessionCache(LoadEvent, EntityKey, LoadEventListener$LoadType) line: 542	
		Object old = session.getEntityUsingInterceptor( keyToLoad );
/s
SessionImpl.getEntityUsingInterceptor(EntityKey) line: 637	
		final Object result = persistenceContext.getEntity(key);
null
/ want er is alleen een proxy naar de address, id=1	,

		if ( result == null ) {
/JA
			final Object newObject = interceptor.getEntity( key.getEntityName(), key.getIdentifier() );
null
			return newObject;

/t
DefaultLoadEventListener.loadFromSessionCache(LoadEvent, EntityKey, LoadEventListener$LoadType) line: 544	
		Object old = session.getEntityUsingInterceptor( keyToLoad );
/ D
null

/t
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 432	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
/ D

		entity = loadFromSecondLevelCache( event, persister, options );
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 598	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=231)	
	disassembledState	Serializable[4]  (id=234)	
		[0]	"foostreet" (id=236)	
		[1]	"12 foo" (id=237)	
		[2]	"FooCity" (id=238)	
	subclass	"my.test.own.ehcache_hibernate_xml3.Address" (id=180)	

		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 684	

			final Object optionalObject = event.getInstanceToLoad();
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
entity	Address  (id=272)	
	addressLine1	null	
	city	null	
	employee	null	
	id	1	
	zipcode	null	

		else {
			final Type[] types = subclassPersister.getPropertyTypes();
types	Type[4]  (id=293)	
	[0]	StringType  (id=296)	
	[1]	StringType  (id=296)	
	[2]	StringType  (id=296)	
	[3]	OneToOneType  (id=308)	
			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/s
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 163	
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/ s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 108	

		Object[] assembled = new Object[row.length];
		for ( int i = 0; i < types.length; i++ ) {
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/s
OneToOneType.assemble(Serializable, SessionImplementor, Object) line: 198	
		return resolve( session.getContextEntityIdentifier(owner), session, owner );
owner	Address  (id=272)	
	addressLine1	null	
	city	null	
	employee	null	
	id	1	
	zipcode	null	
/s
OneToOneType(EntityType).resolve(Object, SessionImplementor, Object) line: 501	
		if ( value != null && !isNull( owner, session ) ) {
			if ( isReferenceToPrimaryKey() ) {
/=		return referenceToPrimaryKey;
false
/ TODO (true als ok fk is: constrained=true?, nu: property-ref)

			else if ( uniqueKeyPropertyName != null ) {
/ JA
/ TODO
"address"
				return loadByUniqueKey( getAssociatedEntityName(), uniqueKeyPropertyName, value, session );
/ getAssociatedEntityName()="Employee"	,
/value=Long 1

/ Intermezzo

/ In de mapping van Employee	,

	<many-to-one 
		name="address"
		column="address_"
		unique="true"
		not-null="true"
	></many-to-one>

/ In de mapping van Address	,
	<one-to-one 
		name="employee"
		property-ref="address"
	></one-to-one>


	/**
	 * Constructs the requested entity type mapping.
	 *
	 * @param scope The type scope
	 * @param entityName The name of the associated entity.
	 * @param uniqueKeyPropertyName The property-ref name, or null if we
	 * reference the PK of the associated entity.
	 * @param eager Is eager fetching enabled.
	 * @param isEmbeddedInXML Should values of this mapping be embedded in XML modes?
	 * @param unwrapProxy Is unwrapping of proxies allowed for this association; unwrapping
	 * says to return the "implementation target" of lazy prooxies; typically only possible
	 * with lazy="no-proxy".
	 *
	 * @deprecated Use {@link #EntityType(org.hibernate.type.TypeFactory.TypeScope, String, boolean, String, boolean, boolean)} instead.
	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
	 */
	@Deprecated
	protected EntityType(

/ dus uniqueKeyMapping = property-ref="address", en deze is inderdaad unique in Employee	,
/ TODO

/ Einde Intermezzo

/s
OneToOneType(EntityType).loadByUniqueKey(String, String, Object, SessionImplementor) line: 750	

/ one-to-one prop van Address, de andere kant van de fk	,

this	OneToOneType  (id=308)	
	associatedEntityName	"my.test.own.ehcache_hibernate_xml3.Employee" (id=183)	
	associatedEntityPersister	SingleTableEntityPersister  (id=184)	
/ van Employee
	associatedIdentifierType	null	
	eager	true	
	entityName	"my.test.own.ehcache_hibernate_xml3.Address" (id=180)	
	foreignKeyType	ForeignKeyDirection$1  (id=342)	
	isEmbeddedInXML	true	
	propertyName	"employee" (id=345)	
	referenceToPrimaryKey	false	
	returnedClass	null	
	scope	TypeFactory$TypeScopeImpl  (id=346)	
	uniqueKeyPropertyName	"address" (id=349)	
	unwrapProxy	false	


		UniqueKeyLoadable persister = ( UniqueKeyLoadable ) factory.getEntityPersister( entityName );
/ die van Employee	,
/ herinner, we deden .get van een Address	,

		EntityUniqueKey euk = new EntityUniqueKey(
				entityName, 
Employee
				uniqueKeyPropertyName, 
address
				key, 
				getIdentifierOrUniqueKeyType( factory ),
				persister.getEntityMode(),
Employee's persister
				session.getFactory()
		);

/s
	/**
	 * Determine the type of either (1) the identifier if we reference the
	 * associated entity's PK or (2) the unique key to which we refer (i.e.
	 * the property-ref).
	 *
	 * @param factory The mappings...
	 * @return The appropriate type.
	 * @throws MappingException Generally, if unable to resolve the associated entity name
	 * or unique key property name.
	 */
	public final Type getIdentifierOrUniqueKeyType(Mapping factory) throws MappingException {

this	OneToOneType  (id=308)	


/ Employee heeft de many-to-one , fk, en hier lookup we een Address, met one-to-one , property-ref	,
/ de prop Address.employee heeft property-ref="address" en Employee.address is een ManyToOne	, dat willen we weten hier	,

		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
/ NEE

/ isReferenceToPrimaryKey()=false
/ uniqueKeyPropertyName="address

		else {
			Type type = factory.getReferencedPropertyType( getAssociatedEntityName(), uniqueKeyPropertyName );

/s
	public Type getReferencedPropertyType(String className, String propertyName)
		throws MappingException {
		return getEntityPersister( className ).getPropertyType( propertyName );
className	"my.test.own.ehcache_hibernate_xml3.Employee" (id=183)	
propertyName	"address" (id=349)	

/ de persister van Employee heeft de prop types	,

this	BasicEntityPropertyMapping  (id=425)	
	columnsByPropertyPath	HashMap<K,V>  (id=431)	
		table	HashMap$Entry<K,V>[16]  (id=674)	
			[0]	HashMap$Entry<K,V>  (id=675)	
				hash	3536	
				key	"id" (id=598)	
				next	null	
				value	String[1]  (id=611)	
					[0]	"id_" (id=612)	
			[5]	HashMap$Entry<K,V>  (id=676)	
				hash	-1319971851	
				key	"address" (id=349)	
				next	null	
				value	String[1]  (id=680)	
					[0]	"address_" (id=683)	
			[7]	HashMap$Entry<K,V>  (id=677)	
				hash	3156183	
				key	"name" (id=592)	
				next	null	
				value	String[1]  (id=681)	
					[0]	"name_" (id=685)	
			[11]	HashMap$Entry<K,V>  (id=678)	
				hash	1267444699	
				key	"address.id" (id=589)	
				next	HashMap$Entry<K,V>  (id=679)	
				value	String[1]  (id=680)	
					[0]	"address_" (id=683)	
	typesByPropertyPath	HashMap<K,V>  (id=582)	
		table	HashMap$Entry<K,V>[16]  (id=584)	
			[0]	HashMap$Entry<K,V>  (id=585)	
				hash	3536	
				key	"id" (id=598)	
				next	null	
				value	LongType  (id=359)	
			[5]	HashMap$Entry<K,V>  (id=586)	
				hash	-1319971851	
				key	"address" (id=349)	
				next	null	
				value	ManyToOneType  (id=596)	
			[7]	HashMap$Entry<K,V>  (id=587)	
				hash	3156183	
				key	"name" (id=592)	
				next	null	
				value	StringType  (id=296)	
			[11]	HashMap$Entry<K,V>  (id=588)	
				hash	1267444699	
				key	"address.id" (id=589)	
				next	HashMap$Entry<K,V>  (id=590)	
				value	LongType  (id=359)	


/ In Employee's mapping is ook salary	, die zien we niet	, 
/ we zien address_id"
/ TODO

/ Dus de type van de associated prop Employee.address is ManyToOne , en dat klopt	,

/t
OneToOneType(EntityType).getIdentifierOrUniqueKeyType(Mapping) line: 676	
		else {
			Type type = factory.getReferencedPropertyType( getAssociatedEntityName(), uniqueKeyPropertyName );
/ D
/ Employee.address heeft type ManyToOne	,

			if ( type.isEntityType() ) {
true
				type = ( ( EntityType ) type).getIdentifierOrUniqueKeyType( factory );
/ recursive call	,
/s
	public final Type getIdentifierOrUniqueKeyType(Mapping factory) throws MappingException {

this	ManyToOneType  (id=596)	
	associatedEntityName	"my.test.own.ehcache_hibernate_xml3.Address" (id=180)	
	associatedEntityPersister	null	
	associatedIdentifierType	LongType  (id=359)	
	eager	false	
	ignoreNotFound	false	
	isEmbeddedInXML	true	
	isLogicalOneToOne	true	
	referenceToPrimaryKey	true	
	returnedClass	null	
	scope	TypeFactory$TypeScopeImpl  (id=346)	
	uniqueKeyPropertyName	null	
	unwrapProxy	false	

		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
/ JA
			return getIdentifierType(factory);
/= associatedIdentifierType	,

/t
OneToOneType(EntityType).getIdentifierOrUniqueKeyType(Mapping) line: 679	
				type = ( ( EntityType ) type).getIdentifierOrUniqueKeyType( factory );
			}
			return type;

/ LongType	, dus we zijn in Address.employee, 1-to-1 prop en hij vraagt type van Address' id	, via Employee.address	, de fk
/ TODO

/t
OneToOneType(EntityType).loadByUniqueKey(String, String, Object, SessionImplementor) line: 755	

		EntityUniqueKey euk = new EntityUniqueKey(
				entityName, 
				uniqueKeyPropertyName, 
				key, 
				getIdentifierOrUniqueKeyType( factory ),
LongType
				persister.getEntityMode(),
				session.getFactory()
		);

		Object result = persistenceContext.getEntity( euk );
/s
	public Object getEntity(EntityUniqueKey euk) {
		return entitiesByUniqueKey.get( euk );
null

		if ( result == null ) {
			result = persister.loadByUniqueKey( uniqueKeyPropertyName, key, session );
/ uniqueKeyPropertyName="address"
/ key=1l
/ s
SingleTableEntityPersister(AbstractEntityPersister).loadByUniqueKey(String, Object, SessionImplementor) line: 2385	
		return getAppropriateUniqueKeyLoader( propertyName, session ).loadByUniqueKey( session, uniqueKey );
/s
	public Object loadByUniqueKey(SessionImplementor session,Object key) {

this	EntityLoader  (id=898)	
	collectionSuffixes	String[1]  (id=907)	
	persisters	Loadable[1]  (id=919)	
		[0]	SingleTableEntityPersister  (id=184)	
/ van Employee	,

/s
EntityLoader(AbstractEntityLoader).load(SessionImplementor, Object, Object, Serializable, LockOptions) line: 78	

		List list = loadEntity(
				session,
				id,
				uniqueKeyType,
				optionalObject,
				entityName,
				optionalId,
				persister,
				lockOptions
			);
/s
EntityLoader(Loader).loadEntity(SessionImplementor, Object, Type, Object, String, Serializable, EntityPersister, LockOptions) line: 2135	

			result = doQueryAndInitializeNonLazyCollections( session, qp, false );
qp	QueryParameters  (id=1812)	
	autodiscovertypes	false	
	cacheable	false	
	cacheRegion	null	
	callable	false	
	collectionKeys	null	
	comment	null	
	isNaturalKeyLookup	false	
	isReadOnlyInitialized	false	
	lockOptions	LockOptions  (id=1809)	
	namedParameters	null	
	optionalEntityName	"my.test.own.ehcache_hibernate_xml3.Employee" (id=183)	
	optionalId	null	
	optionalObject	null	
	positionalParameterTypes	Type[1]  (id=1814)	
	positionalParameterValues	Object[1]  (id=1815)	
	processedPositionalParameterTypes	null	
	processedPositionalParameterValues	null	
	processedSQL	null	
	queryHints	null	
	queryPlan	null	
	readOnly	false	
	resultTransformer	null	
	rowSelection	null	
	scrollMode	null	

/s
EntityLoader(Loader).doQueryAndInitializeNonLazyCollections(SessionImplementor, QueryParameters, boolean) line: 324	

		return doQueryAndInitializeNonLazyCollections(
				session,
				queryParameters,
				returnProxies,
				null
		);
/s
EntityLoader(Loader).doQueryAndInitializeNonLazyCollections(SessionImplementor, QueryParameters, boolean, ResultTransformer) line: 338	

			queryParameters.setReadOnly( persistenceContext.isDefaultReadOnly() );
/ op false
				result = doQuery( session, queryParameters, returnProxies, forcedResultTransformer );
EntityLoader(Loader).doQuery(SessionImplementor, QueryParameters, boolean, ResultTransformer) line: 902	

		final RowSelection selection = queryParameters.getRowSelection();
null
		final int maxRows = LimitHelper.hasMaxRows( selection ) ?
				selection.getMaxRows() :
				Integer.MAX_VALUE;
/ = Integer.MAX_VALUE

		final SqlStatementWrapper wrapper = executeQueryStatement( queryParameters, false, afterLoadActions, session );
/s
EntityLoader(Loader).executeQueryStatement(QueryParameters, boolean, List<AfterLoadAction>, SessionImplementor) line: 1838	

this	EntityLoader  (id=898)	
	sql	"select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ from employee employee0_ where employee0_.address_=?" (id=921)	

		return executeQueryStatement( getSQLString(), queryParameters, scroll, afterLoadActions, session );
/s
EntityLoader(Loader).executeQueryStatement(String, QueryParameters, boolean, List<AfterLoadAction>, SessionImplementor) line: 1849	
sqlStatement	"select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ from employee employee0_ where employee0_.address_=?" (id=921)	
		final PreparedStatement st = prepareQueryStatement( sql, queryParameters, limitHandler, scroll, session );
/s
EntityLoader(Loader).prepareQueryStatement(String, QueryParameters, LimitHandler, boolean, SessionImplementor) line: 1876	
		PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareQueryStatement(
				sql,
				callable,
				scrollMode
		);
/s
StatementPreparerImpl.prepareQueryStatement(String, boolean, ScrollMode) line: 145	

		else {
			final PreparedStatement ps = new QueryStatementPreparationTemplate( sql ) {
				public PreparedStatement doPrepare() throws SQLException {
						return isCallable
								? connection().prepareCall( sql )
								: connection().prepareStatement( sql );
				}
			}.prepareStatement();
/s
StatementPreparerImpl$5(StatementPreparerImpl$StatementPreparationTemplate).prepareStatement() line: 181	
					preparedStatement = doPrepare();
/s
/ In postgres jdbc	,
Jdbc4Connection(AbstractJdbc2Connection).prepareStatement(String) line: 317	
        return prepareStatement(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY);

/t
EntityLoader(Loader).prepareQueryStatement(String, QueryParameters, LimitHandler, boolean, SessionImplementor) line: 1892	

		PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareQueryStatement(
				sql,
				callable,
				scrollMode
		);
/ D
			col += bindParameterValues( st, queryParameters, col, session );
/ TODO (Afmaken)

/t
EntityLoader(Loader).executeQueryStatement(String, QueryParameters, boolean, List<AfterLoadAction>, SessionImplementor) line: 1862	
		final PreparedStatement st = prepareQueryStatement( sql, queryParameters, limitHandler, scroll, session );
/ D
		return new SqlStatementWrapper( st, getResultSet( st, queryParameters.getRowSelection(), limitHandler, queryParameters.hasAutoDiscoverScalarTypes(), session ) );
/s
EntityLoader(Loader).getResultSet(PreparedStatement, RowSelection, LimitHandler, boolean, SessionImplementor) line: 2065	

			ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( st );
/s
ResultSetReturnImpl.extract(PreparedStatement) line: 70	
				rs = statement.executeQuery();

/t
EntityLoader(AbstractEntityLoader).load(SessionImplementor, Object, Object, Serializable, LockOptions) line: 89	
		List list = loadEntity(
				session,
				id,
				uniqueKeyType,
				optionalObject,
				entityName,
				optionalId,
				persister,
				lockOptions
			);
/ Employee inst met Address proxy
/ TODO

/ 7	.

/ collections

/ my.test.own.ehcache_hibernate_xml4.Main 

/ In Address	,
	    Set<Employee>employees=new HashSet<Employee>();

/ 13	. 

/ .save

/ Een Address inst komt precies zo in 1st cache	,

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 273	

		if ( persister.hasCollections() ) {
/ JA
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
substitude=false
/s
DefaultSaveEventListener(AbstractSaveEventListener).visitCollectionsBeforeSave(Object, Serializable, Object[], Type[], EventSource) line: 370	
		visitor.processEntityPropertyValues( values, types );
/s
	public void processEntityPropertyValues(Object[] values, Type[] types) throws HibernateException {
		for ( int i=0; i<types.length; i++ ) {
				processValue( i, values, types );
/ Alleen interessant voor SetType	,

/s
	final Object processValue(Object value, Type type) throws HibernateException {

		if ( type.isCollectionType() ) {
			//even process null collections
			return processCollection( value, (CollectionType) type );
/s
	Object processCollection(Object collection, CollectionType collectionType)
			throws HibernateException {

		if ( collection != null && ( collection instanceof PersistentCollection ) ) {
/ NEE
		else {
			return processArrayOrNewCollection( collection, collectionType );
/ s
	final Object processArrayOrNewCollection(Object collection, CollectionType collectionType)
			throws HibernateException {
		else {
			CollectionPersister persister = session.getFactory().getCollectionPersister( collectionType.getRole() );
	public CollectionPersister getCollectionPersister(String role) throws MappingException {
role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=2918)	

		CollectionPersister result = collectionPersisters.get(role);
result	OneToManyPersister  (id=2939)	

/ Intermezzo

/ In session factory zijn er collectionPersisters en entityPersisters	,

this	SessionFactoryImpl  (id=2920)	
	collectionPersisters	HashMap<K,V>  (id=2954)	
		table	HashMap$Entry<K,V>[16]  (id=3118)	
			[8]	HashMap$Entry<K,V>  (id=3120)	
				key	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=2918)	
				value	OneToManyPersister  (id=2939)	
			[3]	HashMap$Entry<K,V>  (id=3077)	
				key	"my.test.own.ehcache_hibernate_xml4.Employee" (id=3080)	
				value	SingleTableEntityPersister  (id=2996)	
				key	"my.test.own.ehcache_hibernate_xml4.Address" (id=3001)	
				value	SingleTableEntityPersister  (id=2875)	
/ Einde Intermezzo

/t
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 108	
		else {
			CollectionPersister persister = session.getFactory().getCollectionPersister( collectionType.getRole() );
/ D
			if ( collectionType.hasHolder() ) {
/ NEE
/ TODO
			else {
				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
collection	HashSet<E>  (id=2847)	
[my.test.own.ehcache_hibernate_xml4.Employee@47df68e4, my.test.own.ehcache_hibernate_xml4.Employee@1d7d4a63]
/s
	public PersistentCollection wrap(SessionImplementor session, Object collection) {
		return new PersistentSet( session, (java.util.Set) collection );
/s
	/**
	 * Instantiates a non-lazy set (the underlying set is constructed
	 * from the incoming set reference).
	 */
	public PersistentSet(SessionImplementor session, java.util.Set set) {

/t
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 109	
			else {
				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
/ D
				persistenceContext.addNewCollection( persister, persistentCollection );
/s
	public void addNewCollection(CollectionPersister persister, PersistentCollection collection)
			throws HibernateException {
		addCollection( collection, persister );
/s
	private void addCollection(PersistentCollection collection, CollectionPersister persister) {
collection	PersistentSet  (id=3200)	
persister	OneToManyPersister  (id=2939)	
		final CollectionEntry ce = new CollectionEntry( persister, collection );
		collectionEntries.put( collection, ce );

/t
	protected boolean visitCollectionsBeforeSave(
			Object entity,
			Serializable id,
			Object[] values,
			Type[] types,
			EventSource source) {
		visitor.processEntityPropertyValues( values, types );
/ D
/ collection set in pc	,
		return visitor.isSubstitutionRequired();

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 276	
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
true

		if ( substitute ) {
			persister.setPropertyValues( entity, values );
/ De HashSet wordt vervangen door de PersistentSet	,

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts

/ 13	.

/ .commit	,

	public void flush() throws HibernateException {
		FlushEvent flushEvent = new FlushEvent( this );
		for ( FlushEventListener listener : listeners( EventType.FLUSH ) ) {
			listener.onFlush( flushEvent );
/s
	public void onFlush(FlushEvent event) throws HibernateException {
				flushEverythingToExecutions( event );
/s
	protected void flushEverythingToExecutions(FlushEvent event) throws HibernateException {
			int entityCount = flushEntities( event, persistenceContext );
/s
	private int flushEntities(final FlushEvent event, final PersistenceContext persistenceContext) throws HibernateException {
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {

me	EntityEntryContext$EntityEntryCrossRefImpl  (id=33)	
	entity	Address  (id=60)	
	entityEntry	EntityEntry  (id=62)	

/ address, heeft collection	, 

			EntityEntry entry = me.getValue();
				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );
/s
	public void onFlushEntity(FlushEntityEvent event) throws HibernateException {
...
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/ Dmv getters	,
/s
	private Object[] getValues(Object entity, EntityEntry entry, boolean mightBeDirty, SessionImplementor session) {
////////////////////////////////
/ Met getters	,

			values = persister.getPropertyValues( entity );
/s
		return getEntityTuplizer().getPropertyValues( object );
/s
			return super.getPropertyValues( entity );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValues(Object) line: 608	
				result[j] = getters[j].get( entity );
/s
BasicPropertyAccessor$BasicGetter.get(Object) line: 169	
				return method.invoke( target, (Object[]) null );

/t
/s
	public void onFlushEntity(FlushEntityEvent event) throws HibernateException {

		event.setPropertyValues( values );

			if ( persister.hasCollections() ) {
/ JA
/ we persist een Address	,
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/s
	public void processEntityPropertyValues(Object[] values, Type[] types) throws HibernateException {
		for ( int i=0; i<types.length; i++ ) {
				processValue( i, values, types );
/ alleen interessant voor SetType	,
/s
FlushVisitor.processCollection(Object, CollectionType) line: 46	

/ Intermezzo

/ In pc's entityEntryContext zijn er	,
[12]	Address  (id=3023)	
	employees	PersistentSet  (id=3029)	

[3]	EntityEntryContext$ManagedEntityImpl  (id=3131)	
	entityEntry	EntityEntry  (id=3137)	

/ in de pc's 	,
collectionEntries	IdentityMap<K,V>  (id=3000)	
	entryArray	Map$Entry<K,V>[2]  (id=3066)	
		[0]	IdentityMap$IdentityMapEntry<K,V>  (id=3124)	
			key	PersistentSet  (id=3029)	
			value	CollectionEntry  (id=3127) 				/ ce	

/ we zien dus de collection in de pc in de entities, en in de collections	,	


/ Einde Intermezzo

			Collections.processReachableCollection( coll, type, owner, getSession() );
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 190	
		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );

/ is entry in de pc.collectionEntries	, dus die gaan we update	,

/ in ce is alleen snapshot set,
snapshot	HashMap<K,V>  (id=3237)	
/ 2 Employee's	,

		collection.setOwner( entity );

		ce.setReached( true );
		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
persister	OneToManyPersister  (id=189)	
		ce.setCurrentPersister( persister );
/ nu is in ce ook de collection persister set	,

		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
/ = id uit de EntityEntry	,
Long 12	, die van de Address	,

		prepareCollectionForUpdate( collection, ce, factory );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 229	
		final CollectionPersister loadedPersister = entry.getLoadedPersister();
null
		final CollectionPersister currentPersister = entry.getCurrentPersister();
currentPersister	OneToManyPersister  (id=2939)	

				// do the work
				if ( currentPersister != null ) {
					entry.setDorecreate( true );
				}

/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 221	
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
					listener.onFlushEntity( entityEvent );
/ D

/ volgende	,
/ nu een employee	,
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 176	
			if ( persister.hasCollections() ) {
/ NEE

/ volgende	,
/ een employee	,
/ t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 231	
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
			EntityEntry entry = me.getValue();
entry	EntityEntry  (id=235)	
	id	Long  (id=241)	
		value	2	
	loadedState	Object[3]  (id=242)	
		[0]	"Foo2" (id=245)	
		[1]	Double  (id=246)	
		[2]	Address  (id=60)	
	persister	SingleTableEntityPersister  (id=231)	

				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
/ me.getKey()=employee	,
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );
/ Doet WH niets	,

/t
/ volgende,	
	private int flushEntities(final FlushEvent event, final PersistenceContext persistenceContext) throws HibernateException {

		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
			EntityEntry entry = me.getValue();
me	EntityEntryContext$EntityEntryCrossRefImpl  (id=223)	
	entity	Address  (id=332)					/= .getKey()	
	entityEntry	EntityEntry  (id=299)				/ = .getValue()

				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
/s
		public Object getKey() {
			return getEntity();
/t
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );


/ t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	
			int entityCount = flushEntities( event, persistenceContext );
/ D
			int collectionCount = flushCollections( session, persistenceContext );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 253	
		final Map.Entry<PersistentCollection,CollectionEntry>[] entries = IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries());
entries	Map$Entry<K,V>[2]  (id=3066)	
	[0]	IdentityMap$IdentityMapEntry<K,V>  (id=3124)	
		key	PersistentSet  (id=3029)	
		value	CollectionEntry  (id=3127)	
	[1]	IdentityMap$IdentityMapEntry<K,V>  (id=3125)	
		key	PersistentSet  (id=3105)	
		value	CollectionEntry  (id=3090)	


		for ( Map.Entry<PersistentCollection,CollectionEntry> me : IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries() )) {


			if ( ce.isDorecreate() ) {
/ JA
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
/ OneToManyPersister	,
								ce.getCurrentKey(),	
/ key van Address waar de collectie inzit	,
								session
							)
					);
			}

/t
	public void onFlush(FlushEvent event) throws HibernateException {
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
			session.getActionQueue().executeActions();
/s
	public void executeActions() throws HibernateException {
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
/ Maar 1 list is niet []	, en daar staan alle actions in	,
[EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Address#12]
 EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Employee#1]
 EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Employee#2]
 EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Address#34]
 EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Employee#3]
 EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Employee#4]]
/s
	private <E extends Executable & Comparable<?> & Serializable> void executeActions(ExecutableList<E> list) throws HibernateException {
			for ( E e : list ) {
					e.execute();
/s
EntityInsertAction.execute() line: 90	
this	EntityInsertAction  (id=3498)	
	entityName	"my.test.own.ehcache_hibernate_xml4.Address" (id=3500)	
	instance	Address  (id=3023)	
		addressLine1	"foostreet" (id=3033)	
		city	"FooCity" (id=3035)	
		employees	PersistentSet  (id=3029)	
		id	12	
...

			persister.insert( id, getState(), instance, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3069	
sql	"insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)" (id=3004)	
...
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );

/ propertyColumnInsertable is prop van de persister	, 
this	SingleTableEntityPersister  (id=2995)	
	propertyColumnInsertable	(id=3008)	
[[true], [true], [true], []]
/ TODO


/s
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2840	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...

/ Afmaken TODO


/ 7	. 

/ een Address heeft een coll employees	,
/ bij -> db wordt de field employees gewoon overgeslagen	,
[[true], [true], [true], []]
/ bij -> ehcache wordt de id van de Address inst Long 12 disassemble

/ Als later .get met Address id=Long 12	, dan maakt H. een PersistentSet  die leeg is	,
/ als hij wordt resolved,	 dan wordt deze id=12 used in 	,  om de Employee's te resolve	,
select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?

/ als we een Address (met een set Employee's) -> db, dan wordt de set overgeslagen	,
/ als we een Address (met een set Employee's) -> ehcache, dan wordt ipv set de id van de Address zelf saved	, 
/ Is dit laatste voor de query op de Employee's als we de set willen resolve	, en hoe werkt het zonder ehcache?
/  HIER HIER 

/s
EntityInsertAction.execute() line: 126	
/ in deze method: -> db, -> ehcache	,

/ we -> db, -> ehcache een Address inst, die een coll employees heeft	,

/ de sql is	,
sql	"insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)" (id=3173)	

/ de property types zijn	,
propertyTypes	Type[4]  (id=3181)	
	[0]	StringType  (id=3010)	
	[1]	StringType  (id=3010)	
	[2]	StringType  (id=3010)	
	[3]	SetType  (id=3151)	

/ bij -> db	,
SetType(CollectionType).nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 183	
	public final void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable,
			SessionImplementor session) throws HibernateException, SQLException {
		//NOOP
	}

/ bij -> ehcache	,

/s
SetType(CollectionType).disassemble(Object, SessionImplementor, Object) line: 280	
		final Serializable key = getKeyOfOwner(owner, session);
owner	Address  (id=98)	
12
			return getPersister(session)
					.getKeyType()
					.disassemble( key, session, owner );
/s
SetType(CollectionType).getPersister(SessionImplementor) line: 326	
		return session.getFactory().getCollectionPersister( role );
this	SetType  (id=251)	
	role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=341)	
/s
SessionFactoryImpl.getCollectionPersister(String) line: 1112	
		CollectionPersister result = collectionPersisters.get(role);

/t
/s
OneToManyPersister(AbstractCollectionPersister).getKeyType() line: 820	
/=
		return keyType;
LongType

/t
/s
LongType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	
		return getMutabilityPlan().disassemble( (T) value );
value	Long  (id=100)	
12

/ 7	. 

/ Een Employee heeft een fk address	,
/bij ->db wordt impl een Address de fk 12 persist (=id van de Address)	,
/ bij -> ehcache wordt ook deze fk 12 disassemble	,


SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2843	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/ fields[i]=Address inst in de Employee inst	, hieronder is dat value of object	, 


/ een Employee heeft een fk address	,
[true, true, true]

/s
ManyToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 165	
		getIdentifierOrUniqueKeyType( session.getFactory() )
/ LongType	, dit is de type van de primary key van de Address waar Employee een fk naar heef	,
/ TODO
				.nullSafeSet( st, getIdentifier( value, session ), index, settable, session );


ManyToOneType(EntityType).getIdentifier(Object, SessionImplementor) line: 537	
		if ( isReferenceToPrimaryKey() || ...
/ JA, in Employee is address, een fk, 
			return ForeignKeys.getEntityIdentifierIfNotUnsaved( getAssociatedEntityName(), value, session ); //tolerates nulls
/ getAssociatedEntityName()="pkg.Address"

/t
/s
LongType(AbstractStandardBasicType<T>).nullSafeSet(PreparedStatement, Object, int, WrapperOptions) line: 286	
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );

this	LongType  (id=3226)	
	dictatedSize	Size  (id=3228)	
	javaTypeDescriptor	LongTypeDescriptor  (id=3229)	
	sqlTypeDescriptor	BigIntTypeDescriptor  (id=3230)	
	sqlTypes	(id=3231)	

/ remapSqlTypeDescriptor( options )=this.sqlTypeDescriptor	,

/s
BigIntTypeDescriptor$1.doBind(PreparedStatement, X, int, WrapperOptions) line: 64	
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setLong( index, javaTypeDescriptor.unwrap( value, Long.class, options ) );

/ Dus st.setLong	,

/t
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2849	
		if ( !isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );

/t
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3124	
					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();

/s
	public void addToBatch() {
		for ( Map.Entry<String,PreparedStatement> entry : getStatements().entrySet() ) {
			try {
				final PreparedStatement statement = entry.getValue();
				final int rowCount = jdbcCoordinator.getResultSetReturn().executeUpdate( statement );

/ 7	.

/ .get	, Address van ehcache -> apol	,

/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 618	

		final CacheKey ck = source.generateCacheKey(
				event.getEntityId(),
				persister.getIdentifierType(),
				persister.getRootEntityName()
		);
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/ D
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );


/s
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 300	
this	SetType  (id=3120)	
	role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=3122)	

			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
/s
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 163	
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 113	
types	Type[4]  (id=170)	
	[0]	StringType  (id=174)	
	[1]	StringType  (id=174)	
	[2]	StringType  (id=174)	
	[3]	SetType  (id=176)	

		Object[] assembled = new Object[row.length];
		for ( int i = 0; i < types.length; i++ ) {
				assembled[i] = types[i].assemble( row[i], session, owner );
/s
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 296	
		else {
			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
/s
SetType(CollectionType).getPersister(SessionImplementor) line: 326	
		return session.getFactory().getCollectionPersister( role );
this	SetType  (id=176)	
	role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=256)	
/s
SessionFactoryImpl.getCollectionPersister(String) line: 1112	
		CollectionPersister result = collectionPersisters.get(role);
result	OneToManyPersister  (id=3127)	

/ In sessionFactory zijn entityPersisters en collectionPersisters	,

/t
/s
	public Type getKeyType() {
		return keyType;
LongType

/t
/s
LongType(AbstractStandardBasicType<T>).assemble(Serializable, SessionImplementor, Object) line: 330	
		return getMutabilityPlan().assemble( cached );

/t
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 303	
			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
Long 12, id of the Address inst which has the coll of Employee insts	,
/ D

			return resolveKey( key, session, owner );
/s
SetType(CollectionType).resolveKey(Serializable, SessionImplementor, Object) line: 466	
		return key == null ? null : // TODO: can this case really occur??
			getCollection( key, session, owner );
/s
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 748	

 		CollectionPersister persister = getPersister( session );
persister	OneToManyPersister  (id=3127)	
/ want	,
/s
CollectionType.
	private CollectionPersister getPersister(SessionImplementor session) {
		return session.getFactory().getCollectionPersister( role );
this
	role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=3122)	

/t
	public Object getCollection(Serializable key, SessionImplementor session, Object owner) {
		CollectionPersister persister = getPersister( session );
/ D
		final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();
entityMode	EntityMode  (id=3149)	
	name	"POJO" (id=3151)	
	name	"pojo" (id=3150)	
	ordinal	0	
/ want	,
/s
OneToManyPersister(AbstractCollectionPersister).getOwnerEntityPersister() line: 1578	
this	OneToManyPersister  (id=300)	
	ownerPersister	SingleTableEntityPersister  (id=65)	
/ persisten van Address	,

		return ownerPersister;

/ er zijn 2 single table entity peristers	,  1 op Employee, 1 op Address	,

/t
	public Object getCollection(Serializable key, SessionImplementor session, Object owner) {
		final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();
/ D


		// check if collection is currently being loaded
		PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );

/s
LoadContexts.locateLoadingCollection(CollectionPersister, Serializable) line: 187	
/=
	public PersistentCollection locateLoadingCollection(CollectionPersister persister, Serializable ownerKey) {
persister	OneToManyPersister  (id=300)	
/= OneToManyPersister(my.test.own.ehcache_hibernate_xml4.Address.employees)
ownerKey	Long  (id=144)	
12
		final LoadingCollectionEntry lce = locateLoadingCollectionEntry( new CollectionKey( persister, ownerKey ) );
null
		if ( collection == null ) {
			// check if it is already completely loaded, but unowned
			collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );
null
			if ( collection == null ) {
				// create a new collection wrapper, to be initialized later
				collection = instantiate( session, persister, key );
/ key=12, de id van de Address	,
/s
SetType.instantiate(SessionImplementor, CollectionPersister, Serializable) line: 50	
/ =
	public PersistentCollection instantiate(SessionImplementor session, CollectionPersister persister, Serializable key) {
		return new PersistentSet(session);

/t
/ collection=PersistentSet	,
				collection.setOwner(owner);
				persistenceContext.addUninitializedCollection( persister, collection, key );
/ net als entities	,
/s
StatefulPersistenceContext.addUninitializedCollection(CollectionPersister, PersistentCollection, Serializable) line: 788	
		final CollectionEntry ce = new CollectionEntry( collection, persister, id, flushing );
ce	CollectionEntry  (id=424)	
	dorecreate	false	
	loadedKey	Long  (id=144)	
	loadedPersister	OneToManyPersister  (id=300)	
	role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=256)	

		addCollection( collection, ce, id );
/s
StatefulPersistenceContext.addCollection(PersistentCollection, CollectionEntry, Serializable) line: 818	
		collectionEntries.put( coll, entry );
		final CollectionKey collectionKey = new CollectionKey( entry.getLoadedPersister(), key );
		final PersistentCollection old = collectionsByKey.put( collectionKey, coll );

/t
StatefulPersistenceContext.addUninitializedCollection(CollectionPersister, PersistentCollection, Serializable) line: 790	
		addCollection( collection, ce, id );
/ D

/t
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 769	
				persistenceContext.addUninitializedCollection( persister, collection, key );
/ D
/ net als entities	,

HibernateLog --> 08:57:49 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.ehcache_hibernate_xml4.Address.employees#12]

		collection.setOwner(owner);
		return collection.getValue();
/ = return this;
/ de collection dus	,

/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 172	
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/ D
/ De laaste prop	, 'n PersistentSet, is nog niet initialized	, de Employees zitten er nog niet in	,
/ de owner in deze peristent set is de Address, die enployees heeft, dat is dezefde PersistentSet	,

/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 628	
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/ D

/t
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 453	
		entity = loadFromSecondLevelCache( event, persister, options );
/ D
/ H heeft zelf een new PersistentSet create	, met de key van de Address zelf er in	, en de role "pkg.Address.employees	,

/t
Main.testBasicUsage() line: 157	
	        Address address=(Address)session.get(Address.class, 12l);
/ D
/ address heeft een not initialized set of Employees	,

	        Set<Employee>employees=address.getEmployees();
/ de not initialized PersistentSet	,

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
/ TODO








































 




























































/ Einde EHCACHE HIBERNATE XML

/ HIBERNATE COLLECTIONS

/ 7	. 

/ we maken proj hibernate_collections_xml	,

/ als we ehcache.xml rm, en we laten in de mapping van Address, Employee <cache .../> staan, dan caches hij toh, WH defaults	,

/ we rm de <cache .../> in de mappings	,

/ dan zien we in statistics dat inderdaad de cache buitenspel staat	,

/ 	7. 

/ .get

/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 468	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
			entity = loadFromDatasource( event, persister, keyToLoad, options );
...
/s
SingleTableEntityPersister(AbstractEntityPersister).load(Serializable, Object, LockOptions, SessionImplementor) line: 4125	
		final UniqueEntityLoader loader = getAppropriateLoader(lockOptions, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).getAppropriateLoader(LockOptions, SessionImplementor) line: 4181	
			return ( UniqueEntityLoader ) getLoaders().get( lockOptions.getLockMode() );
/ "NONE"
this	SingleTableEntityPersister  (id=35)	
	loaders	HashMap<K,V>  (id=70)	
{PESSIMISTIC_WRITE=org.hibernate.loader.entity.plan.EntityLoader@8227089
 NONE=org.hibernate.loader.entity.plan.EntityLoader@8117683
 OPTIMISTIC_FORCE_INCREMENT=org.hibernate.loader.entity.plan.EntityLoader@d0a368b
 merge=org.hibernate.loader.entity.CascadeEntityLoader(select address0_.id_ as id_1_0_0_ address0_.address_line1_ as address_2_0_0_ address0_.zipcoce_ as zipcoce_3_0_0_ address0_.city_ as city_4_0_0_ from address address0_ where address0_.id_=?)
 PESSIMISTIC_READ=org.hibernate.loader.entity.plan.EntityLoader@1982e65d
 OPTIMISTIC=org.hibernate.loader.entity.plan.EntityLoader@60e1f0c0
 UPGRADE_SKIPLOCKED=org.hibernate.loader.entity.plan.EntityLoader@1184fef1
 FORCE=org.hibernate.loader.entity.plan.EntityLoader@327d8933
 READ=org.hibernate.loader.entity.plan.EntityLoader@4fba8d2a
 UPGRADE_NOWAIT=org.hibernate.loader.entity.plan.EntityLoader@6089e94a
 PESSIMISTIC_FORCE_INCREMENT=org.hibernate.loader.entity.plan.EntityLoader@7e332ac9
 refresh=org.hibernate.loader.entity.CascadeEntityLoader(select address0_.id_ as id_1_0_0_ address0_.address_line1_ as address_2_0_0_ address0_.zipcoce_ as zipcoce_3_0_0_ address0_.city_ as city_4_0_0_ from address address0_ where address0_.id_=?)
 UPGRADE=org.hibernate.loader.entity.plan.EntityLoader@513e32d9} 

/t
		final UniqueEntityLoader loader = getAppropriateLoader(lockOptions, session );
/ D
		return loader.load( id, optionalObject, session, lockOptions );
...
/s
EntityLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 119	


/ 7	. 

/ we zagen dat de sql query met ?'s al in de loader zat	, 
/ we set b	,
/ start opnieuw	,

/ debugger valt in	,
EntityLoader(AbstractLoadPlanBasedEntityLoader).<init>(OuterJoinLoadable, SessionFactoryImplementor, String[], Type, QueryBuildingParameters) line: 77	

/ we zijn in	,
Thread [main] (Suspended (breakpoint at line 77 in AbstractLoadPlanBasedEntityLoader))	
	EntityLoader(AbstractLoadPlanBasedEntityLoader).<init>(OuterJoinLoadable, SessionFactoryImplementor, String[], Type, QueryBuildingParameters) line: 77	
	EntityLoader.<init>(SessionFactoryImplementor, OuterJoinLoadable, String[], Type, QueryBuildingParameters) line: 134	
	EntityLoader.<init>(SessionFactoryImplementor, OuterJoinLoadable, String[], Type, QueryBuildingParameters, EntityLoader$1) line: 55	
	EntityLoader$Builder.byUniqueKey(String[], Type) line: 98	
	EntityLoader$Builder.byPrimaryKey() line: 94	
	LegacyBatchingEntityLoaderBuilder(AbstractBatchingEntityLoaderBuilder).buildNonBatchingLoader(OuterJoinLoadable, LockMode, SessionFactoryImplementor, LoadQueryInfluencers) line: 47	
	LegacyBatchingEntityLoaderBuilder(BatchingEntityLoaderBuilder).buildLoader(OuterJoinLoadable, int, LockMode, SessionFactoryImplementor, LoadQueryInfluencers) line: 76	
	SingleTableEntityPersister(AbstractEntityPersister).createEntityLoader(LockMode, LoadQueryInfluencers) line: 2506	
	SingleTableEntityPersister(AbstractEntityPersister).createEntityLoader(LockMode) line: 2528	
	SingleTableEntityPersister(AbstractEntityPersister).createLoaders() line: 4035	
	SingleTableEntityPersister(AbstractEntityPersister).postInstantiate() line: 4017	
	SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 481	
	Configuration.buildSessionFactory(ServiceRegistry) line: 1857	
	Main.setUp() line: 71	
	Main.<init>() line: 59	
	Main.main(String[]) line: 54	

...
/s
EntityLoadQueryDetails.<init>(LoadPlan, String[], AliasResolutionContextImpl, EntityReturn, QueryBuildingParameters, SessionFactoryImplementor) line: 106	
		generate();
/s
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 129	

/ TODO

/ SAMENVATTING

/ 7	.

/ In hibernate_collections_xml is employee:address=n:1	, en is employee owner rel	.

/ Employee.address	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	></many-to-one>

/ Address.employees	,
 	<list 
 		name="employees"
 		inverse="true">
 		<key
 			column="address_"
 		></key>
 		<list-index></list-index>
 		<one-to-many class="Employee"/>
 	</list>

/ Inderdaad	, Employee.address is not-null	,

/ als we	,
			session.save(employee);
			session.save(employee11);
			session.save(address);
/ dan ERR op 
			session.save(employee);
/ want in employee is address not-null en transient	, 

/ we moeten eerst de address save	,
			session.save(address);
			session.save(employee);
			session.save(employee11);
/ address heeft een list van employees, deze zijn transient, maar dat is niet erg, wnat employee is niet de owner	,
/ TODO


/ als Employee.address NIET not-null	, dan is OK	,
			session.save(employee);
			session.save(employee11);
			session.save(address);


/ Einde SAMENVATTING

/ 7. 	

/ In hibernate_collections_xml is employee:address=n:1	, en is employee owner rel	.

/ Employee.address' mepping	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	></many-to-one>

 

/ Debug	,
			session.save(employee);
			session.save(employee11);
			session.save(address);

/ ERR op 
			session.save(employee);

/s
	private Serializable fireSave(SaveOrUpdateEvent event) {
		for ( SaveOrUpdateEventListener listener : listeners( EventType.SAVE ) ) {
			listener.onSaveOrUpdate( event );
...
/s
DefaultSaveEventListener(AbstractSaveEventListener).addInsertAction(Object[], Serializable, Object, EntityPersister, boolean, EventSource, boolean) line: 328	
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
			source.getActionQueue().addAction( insert );
values	Object[3]  (id=44)	
	[0]	"Foo1" (id=39)	
	[1]	Double  (id=69)	
	[2]	Address  (id=37)	

...
/s
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 170	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
/s
ForeignKeys.findNonNullableTransientEntities(String, Object, Object[], boolean, SessionImplementor) 
/=
	private static void collectNonNullableTransientEntities(
			Nullifier nullifier,
			Object value,
			String propertyName,
			Type type,
			boolean isNullable,
			SessionImplementor session,
			NonNullableTransientDependencies nonNullableTransientEntities) {

		final Type[] types = persister.getPropertyTypes();
types	Type[3]  (id=142)	
	[0]	StringType  (id=149)	
	[1]	DoubleType  (id=150)	
	[2]	ManyToOneType  (id=151)	

	for ( int i = 0; i < types.length; i++ ) {
			collectNonNullableTransientEntities(
					nullifier,
					values[i],
					propertyNames[i],
					types[i],
					nullability[i],
					session,
					nonNullableTransientEntities
			);
/s
ForeignKeys.collectNonNullableTransientEntities(ForeignKeys$Nullifier, Object, String, Type, boolean, SessionImplementor, NonNullableTransientDependencies) line: 361	

		if ( type.isEntityType() ) {
/ JA, 
/ 
/ fk	,
			final EntityType entityType = (EntityType) type;
			if ( !isNullable
					&& !entityType.isOneToOne()
					&& nullifier.isNullifiable( entityType.getAssociatedEntityName(), value ) ) {
/s
ForeignKeys$Nullifier.isNullifiable(String, Object) line: 148	
			final EntityEntry entityEntry = session.getPersistenceContext().getEntry( object );
			if ( entityEntry == null ) {
				return isTransient( entityName, object, null, session );
/s
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 229	
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
/ persister van Address	,
		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
		isUnsaved = persister.isTransient( entity, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).isTransient(Object, SessionImplementor) line: 4489	

/ CHECKS EERST DE EHCACHE

		// check to see if it is in the second-level cache
		if ( session.getCacheMode().isGetEnabled() && hasCache() ) {
/ NEE
	return null;

/t
		isUnsaved = persister.isTransient( entity, session );
/ D
		if ( isUnsaved != null ) {
/NEE

		// hit the database, after checking the session cache for a snapshot
		final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(
				persister.getIdentifier( entity, session ),
				persister
		);
/s
StatefulPersistenceContext.getDatabaseSnapshot(Serializable, EntityPersister) line: 310	
/=
	public Object[] getDatabaseSnapshot(Serializable id, EntityPersister persister) throws HibernateException {
/ id is Employee.address's id=12	,

		final EntityKey key = session.generateEntityKey( id, persister );
		final Object cached = entitySnapshotsByKey.get( key );
		if ( cached != null ) {
/ NEE
		else {
			final Object[] snapshot = persister.getDatabaseSnapshot( id, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).getDatabaseSnapshot(Serializable, SessionImplementor) line: 1521	
			PreparedStatement ps = session.getTransactionCoordinator()
					.getJdbcCoordinator()
					.getStatementPreparer()
					.prepareStatement( getSQLSnapshotSelectString() );
			try {
				getIdentifierType().nullSafeSet( ps, id, 1, session );
/ bind
				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
				try {
					//if there is no resulting row, return null
					if ( !rs.next() ) {
/ JA
						return null;

/t
StatefulPersistenceContext.getDatabaseSnapshot(Serializable, EntityPersister) line: 317	
			final Object[] snapshot = persister.getDatabaseSnapshot( id, session );
/ D
			entitySnapshotsByKey.put( key, snapshot == null ? NO_ROW : snapshot );
			return snapshot;
null

/t
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 259	
		final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(
				persister.getIdentifier( entity, session ),
				persister
		);
null
		return snapshot == null;
true

/t
ForeignKeys.collectNonNullableTransientEntities(ForeignKeys$Nullifier, Object, String, Type, boolean, SessionImplementor, NonNullableTransientDependencies) line: 364	
			if ( !isNullable
					&& !entityType.isOneToOne()
					&& nullifier.isNullifiable( entityType.getAssociatedEntityName(), value ) ) {
/ JA
				nonNullableTransientEntities.add( propertyName, value );

/t
ForeignKeys.findNonNullableTransientEntities(String, Object, Object[], boolean, SessionImplementor) line: 344	
			collectNonNullableTransientEntities(
					nullifier,
					values[i],
					propertyNames[i],
					types[i],
					nullability[i],
					session,
					nonNullableTransientEntities
			);
		}
		return nonNullableTransientEntities.isEmpty() ? null : nonNullableTransientEntities;
/ TWEEDE	,

/s
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 177	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
/ D

///////////////////////////////////////////////////////////////////////////////
		if ( nonNullableTransientDependencies == null ) {
/ NEE
/ H gaat dus NIET de insert action op de queue set, and de entity in de pc set	,
		else {
			unresolvedInsertions.addUnresolvedEntityInsertAction( insert, nonNullableTransientDependencies );

/t
	private Serializable fireSave(SaveOrUpdateEvent event) {
		for ( SaveOrUpdateEventListener listener : listeners( EventType.SAVE ) ) {
			listener.onSaveOrUpdate( event );
		}
/ D
		checkNoUnresolvedActionsAfterOperation();
...
/s
ActionQueue.checkNoUnresolvedActionsAfterOperation() line: 318	
		unresolvedInsertions.checkNoUnresolvedActionsAfterOperation();
/s
UnresolvedEntityInsertActions.checkNoUnresolvedActionsAfterOperation() line: 121	
		else {
			final AbstractEntityInsertAction firstDependentAction =
					dependenciesByAction.keySet().iterator().next();

			logCannotResolveNonNullableTransientDependencies( firstDependentAction.getSession() );
//we zien	,
HibernateLog --> 10:57:28 WARN  org.hibernate.action.internal.UnresolvedEntityInsertActions - HHH000437: Attempting to save one or more entities that have a non-nullable association with an unsaved transient entity. The unsaved transient entity must be saved in an operation prior to saving these dependent entities.
	Unsaved transient entity: ([my.test.own.hibernate_collections_xml.Address#12])
	Dependent entities: ([[my.test.own.hibernate_collections_xml.Employee#1]])
	Non-nullable association(s): ([my.test.own.hibernate_collections_xml.Employee.address])

			throw new TransientPropertyValueException(
					"Not-null property references a transient value - transient instance must be saved before current operation",
					firstDependentAction.getSession().guessEntityName( firstTransientDependency ),
					firstDependentAction.getEntityName(),
					firstPropertyPath
			);

/ 7	.

/ Employee.address' mepping	,
	<many-to-one 
		name="address"
		column="address_"
	></many-to-one>
<!--
		not-null="true"
-->

/ we hebben nu de voorwaarde laten varen dat de fk not-null	,

/ we doen .save(employee)	,
/ ipv de ERR UnresolvedEntityInsertActions, maakt hij nu de fk null ! in de EntityEntry's loadedState	, want de Address is transient	,
/ WH omdat H niet weet of later .save(address) wordt gedaan	,
/ Wat als we cascade doen in de Employee's mapping, maakt hij dan ook in loadedState de 3de property null?
/ TODO 
/ Later bij .commit komt dit toch goed	, omdat de Address inst dirty is dan	, omdat de Address in loadedState er niet is, en dan wel	,
 

/ Debug	,
			session.save(employee);
			session.save(employee11);
			session.save(address);
/ 13	.

/ .save(employee)

/ bij .save(employee) heeft employee een fk naar een transient address	,   
/ H maakt in de loadedState in de entityentry van de employee in de pc address=null	, in de instance, employee , in de pc is address onveranderd	,  gewoon een Address inst	,

/ debug .seve(employee)

/s
EntityInsertAction(AbstractEntityInsertAction).makeEntityManaged() line: 141	
this	EntityInsertAction  (id=2781)	
	state	Object[3]  (id=2774)	
		[0]	"Foo1" (id=2775)	
		[1]	Double  (id=2776)	
		[2]	Address  (id=2777)	
instance	Employee  (id=2768)	
	address	Address  (id=2777)	
	id	1	
	name	"Foo1" (id=2775)	
	salary	1.0	

		nullifyTransientReferencesIfNotAlready();
/s
EntityInsertAction(AbstractEntityInsertAction).nullifyTransientReferencesIfNotAlready() line: 130	
		if ( ! areTransientReferencesNullified ) {
			new ForeignKeys.Nullifier( getInstance(), false, isEarlyInsert(), getSession() )
					.nullifyTransientReferences( getState(), getPersister().getPropertyTypes() );
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object[], Type[]) line: 80	
			for ( int i = 0; i < types.length; i++ ) {
				values[i] = nullifyTransientReferences( values[i], types[i] );
types	Type[3]  (id=2778)	
	[0]	StringType  (id=2822)	
	[1]	DoubleType  (id=2823)	
	[2]	ManyToOneType  (id=2824)	
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object, Type) line: 95	
/=
		private Object nullifyTransientReferences(final Object value, final Type type) {
value	Address  (id=2777)	
	addressLine1	"foostreet" (id=2845)	
	city	"FooCity" (id=2846)	
	employees	ArrayList<E>  (id=2847)	
	id	12	

			else if ( type.isEntityType() ) {
				final EntityType entityType = (EntityType) type;
ManyToOne
				if ( entityType.isOneToOne() ) {
/ NEE
					return value;
/ TODO
				}
				else {
					final String entityName = entityType.getAssociatedEntityName();
entityName	"my.test.own.hibernate_collections_xml.Address" (id=2855)	
					return isNullifiable( entityName, value ) ? null : value;
/s
ForeignKeys$Nullifier.isNullifiable(String, Object) line: 143	

			final EntityEntry entityEntry = session.getPersistenceContext().getEntry( object );
			if ( entityEntry == null ) {
				return isTransient( entityName, object, null, session );
/s
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 229	

		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
/ persister van de Address	(herinner: we zijn .save(employee)
		isUnsaved = persister.isTransient( entity, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).isTransient(Object, SessionImplementor) line: 4464	

		// check to see if it is in the second-level cache
		if ( session.getCacheMode().isGetEnabled() && hasCache() ) {
/ NEE
/ TODO

		return null;

/t
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 255	

		isUnsaved = persister.isTransient( entity, session );
/D
null
		// hit the database, after checking the session cache for a snapshot
		final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(
				persister.getIdentifier( entity, session ),
				persister
		);
/s
StatefulPersistenceContext.getDatabaseSnapshot(Serializable, EntityPersister) line: 310	

		else {
			final Object[] snapshot = persister.getDatabaseSnapshot( id, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).getDatabaseSnapshot(Serializable, SessionImplementor) line: 1521	

			PreparedStatement ps = session.getTransactionCoordinator()
					.getJdbcCoordinator()
					.getStatementPreparer()
					.prepareStatement( getSQLSnapshotSelectString() );
			try {
				getIdentifierType().nullSafeSet( ps, id, 1, session );
/s
StatefulPersistenceContext.getDatabaseSnapshot(Serializable, EntityPersister) line: 310	

		else {
			final Object[] snapshot = persister.getDatabaseSnapshot( id, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).getDatabaseSnapshot(Serializable, SessionImplementor) line: 1521	

			PreparedStatement ps = session.getTransactionCoordinator()
					.getJdbcCoordinator()
					.getStatementPreparer()
					.prepareStatement( getSQLSnapshotSelectString() );
			try {
				getIdentifierType().nullSafeSet( ps, id, 1, session );
/bind	,
				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
					//if there is no resulting row, return null
					if ( !rs.next() ) {
/ JA
						return null;

/ H doet een query	, maar er is niets	,

HibernateLog --> 15:11:56 DEBUG org.hibernate.SQL - select address_.id_, address_.address_line1_ as address_2_0_, address_.zipcoce_ as zipcoce_3_0_, address_.city_ as city_4_0_ from address address_ where address_.id_=?
Hibernate: select address_.id_, address_.address_line1_ as address_2_0_, address_.zipcoce_ as zipcoce_3_0_, address_.city_ as city_4_0_ from address address_ where address_.id_=?
HibernateLog --> 15:12:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]


/t
StatefulPersistenceContext.getDatabaseSnapshot(Serializable, EntityPersister) line: 317	
			final Object[] snapshot = persister.getDatabaseSnapshot( id, session );
/ D
			entitySnapshotsByKey.put( key, snapshot == null ? NO_ROW : snapshot );
			return snapshot;
null

/t
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 259	
		final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(
				persister.getIdentifier( entity, session ),
				persister
		);
/ D
		return snapshot == null;
true

/t
ForeignKeys$Nullifier.isNullifiable(String, Object) line: 143	
				return isTransient( entityName, object, null, session );
true

/t
ForeignKeys$Nullifier.nullifyTransientReferences(Object, Type) line: 105	

					return isNullifiable( entityName, value ) ? null : value;
null
/ ipv value=Address inst	,

/t
ForeignKeys$Nullifier.nullifyTransientReferences(Object[], Type[]) line: 81	
			for ( int i = 0; i < types.length; i++ ) {
				values[i] = nullifyTransientReferences( values[i], types[i] );
values	Object[3]  (id=2774)	
	[0]	"Foo1" (id=2775)	
	[1]	Double  (id=2776)	
	[2]	Address  (id=2777)	
/ D
values	Object[3]  (id=2774)	
	[0]	"Foo1" (id=2775)	
	[1]	Double  (id=2776)	

 
/ we hebben de state in de entityinsertaction veranderd	, in de pc is nog niets van deze Employee	,

/t
EntityInsertAction(AbstractEntityInsertAction).nullifyTransientReferencesIfNotAlready() line: 132	
			new ForeignKeys.Nullifier( getInstance(), false, isEarlyInsert(), getSession() )
					.nullifyTransientReferences( getState(), getPersister().getPropertyTypes() );
/ D
			new Nullability( getSession() ).checkNullability( getState(), getPersister(), false );
/ doet NIETS	,

			areTransientReferencesNullified = true;
/t
EntityInsertAction(AbstractEntityInsertAction).makeEntityManaged() line: 142	
		nullifyTransientReferencesIfNotAlready();
this	EntityInsertAction  (id=2781)	
	instance	Employee  (id=2768)	
		address	Address  (id=2777)	
		id	1	
		name	"Foo1" (id=2775)	
		salary	1.0	
	state	Object[3]  (id=2774)	
		[0]	"Foo1" (id=2775)	
		[1]	Double  (id=2776)	

/ In de instance is er wel address	, in de state is het 3de prop null	,

		getSession().getPersistenceContext().addEntity(
				getInstance(),
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),
				getState(),
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);
/ de state in de entityinsertaction wordt de loaded state in de entityentry in de pc	,
/ de instance in de entityinsertaction wordt de entity in de pc	,


/s
	public EntityEntry addEntity(
			final Object entity,
			final Status status,
			final Object[] loadedState,
			final EntityKey entityKey,
			final Object version,
			final LockMode lockMode,
			final boolean existsInDatabase,
			final EntityPersister persister,
			final boolean disableVersionIncrement,
			boolean lazyPropertiesAreUnfetched) {
		addEntity( entityKey, entity );
		return addEntry(
				entity,
				status,
				loadedState,
				null,
				entityKey.getIdentifier(),
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched
		);
	}
/s
	public EntityEntry addEntry(
			final Object entity,
			final Status status,
			final Object[] loadedState,
			final Object rowId,
			final Serializable id,
			final Object version,
			final LockMode lockMode,
			final boolean existsInDatabase,
			final EntityPersister persister,
			final boolean disableVersionIncrement,
			boolean lazyPropertiesAreUnfetched) {

		final EntityEntry e = new EntityEntry(
				status,
				loadedState,
				rowId,
				id,
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched,
				this
		);

		entityEntryContext.addEntityEntry( entity, e );
/ sets dirty=true	,

/ we zien	,
"session.getPers...stenceContext()"	 (pending)	
	entityEntryContext	EntityEntryContext  (id=2765)	
		nonEnhancedEntityXref	IdentityHashMap<K,V>  (id=2986)	
			table	Object[64]  (id=2988)	
				[44]	Employee  (id=2768)	
					address	Address  (id=2777)	
					id	1	
					name	"Foo1" (id=2775)	
					salary	1.0	
				[45]	EntityEntryContext$ManagedEntityImpl  (id=2981)	
					entityEntry	EntityEntry  (id=2979)	
						loadedState	Object[3]  (id=2774)	
							[0]	"Foo1" (id=2775)	
							[1]	Double  (id=2776)	

/ we zien in de loadedState geen address	, maar in de instance wel	,
/ TODO

...
/t
SessionImpl.fireSave(SaveOrUpdateEvent) line: 717	
			listener.onSaveOrUpdate( event );
/ D
		checkNoUnresolvedActionsAfterOperation();
/ deze zijn er nu niet	,


/ 13	.

/ .save(address)

/ Employee.address' mepping	,

	<many-to-one 
		name="address"
		column="address_"
	></many-to-one>
<!--
		not-null="true"
-->

/ Address.employees' mapping	,

	<list 
 		name="employees"
 		inverse="true">
 		<key
 			column="address_"
 		></key>
 		<list-index></list-index>
 		<one-to-many class="Employee"/>
 	</list>



			session.save(employee);
			session.save(employee11);
/ Debug	,
			session.save(address);

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 277	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
values	Object[4]  (id=3250)	
	[0]	"foostreet" (id=2845)	
	[1]	"12 foo" (id=3251)	
	[2]	"FooCity" (id=2846)	
	[3]	ArrayList<E>  (id=2847)	

		Type[] types = persister.getPropertyTypes();
values	Object[4]  (id=3250)	
types	Type[4]  (id=3288)	
	[0]	StringType  (id=2822)	
	[1]	StringType  (id=2822)	
	[2]	StringType  (id=2822)	
	[3]	ListType  (id=3295)	

		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/s
WrapVisitor(AbstractVisitor).processEntityPropertyValues(Object[], Type[]) line: 76	
		for ( int i=0; i<types.length; i++ ) {
			if ( includeEntityProperty(values, i) ) {
				processValue( i, values, types );
/ Voor de ListType	,
/s
WrapVisitor.processValue(int, Object[], Type[]) line: 125	
		Object result = processValue( values[i], types[i] );
/s
WrapVisitor(AbstractVisitor).processValue(Object, Type) line: 119	
		if ( type.isCollectionType() ) {
			//even process null collections
			return processCollection( value, (CollectionType) type );
/s
WrapVisitor.processCollection(Object, CollectionType) line: 62	
collection	ArrayList<E>  (id=2847)	
	elementData	Object[10]  (id=3348)	
		[0]	Employee  (id=2768)	
		[1]	Employee  (id=3252)	

		if ( collection != null && ( collection instanceof PersistentCollection ) ) {
/ NEE
		else {
			return processArrayOrNewCollection( collection, collectionType );
/s
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 81	
		else {
			CollectionPersister persister = session.getFactory().getCollectionPersister( collectionType.getRole() );
collectionType	ListType  (id=3295)	
	role	"my.test.own.hibernate_collections_xml.Address.employees" (id=3367)	
persister	OneToManyPersister  (id=3373)	

			else {

				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
persister	OneToManyPersister  (id=3373)	

				persistenceContext.addNewCollection( persister, persistentCollection );
/s
	private void addCollection(PersistentCollection collection, CollectionPersister persister) {
		final CollectionEntry ce = new CollectionEntry( persister, collection );
		collectionEntries.put( collection, ce );

/t
				return persistentCollection; //Force a substitution!

/t
WrapVisitor.processValue(int, Object[], Type[]) line: 128	
		Object result = processValue( values[i], types[i] );
/ D
result	PersistentList  (id=3381)	
		if ( result != null ) {
			substitute = true;
			values[i] = result;
values	Object[4]  (id=3250)	
	[0]	"foostreet" (id=2845)	
	[1]	"12 foo" (id=3251)	
	[2]	"FooCity" (id=2846)	
	[3]	ArrayList<E>  (id=2847)	
/ WORDT	,
values	Object[4]  (id=3250)	
	[0]	"foostreet" (id=2845)	
	[1]	"12 foo" (id=3251)	
	[2]	"FooCity" (id=2846)	
	[3]	PersistentList  (id=3381)	

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 276	
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/ D
		if ( substitute ) {
			persister.setPropertyValues( entity, values );
entity	Address  (id=2777)	
	addressLine1	"foostreet" (id=2845)	
	city	"FooCity" (id=2846)	
	employees	PersistentList  (id=3381)	 	/ ! veranderd	,
	id	12	
	zipcode	"12 foo" (id=3251)	

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/s
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
			source.getActionQueue().addAction( insert );
...
/s
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 176	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
...
/s
ForeignKeys.findNonNullableTransientEntities(String, Object, Object[], boolean, SessionImplementor) line: 334	
		for ( int i = 0; i < types.length; i++ ) {
			collectNonNullableTransientEntities(
					nullifier,
					values[i],
					propertyNames[i],
					types[i],
					nullability[i],
					session,
					nonNullableTransientEntities
			);
		}

/ Maar in Address hebben we geen fk	,

/s
ForeignKeys.collectNonNullableTransientEntities(ForeignKeys$Nullifier, Object, String, Type, boolean, SessionImplementor, NonNullableTransientDependencies) line: 355	
		if ( type.isEntityType() ) {
/ NEE
		else if ( type.isAnyType() ) {
/ NEE
		else if ( type.isComponentType() ) {
/ NEE

/t
		return nonNullableTransientEntities.isEmpty() ? null : nonNullableTransientEntities;
/ EERSTE	,

/ t
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 177	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
null
		if ( nonNullableTransientDependencies == null ) {
/ JA
			addResolvedEntityInsertAction( insert );
/s
			insertions.add( insert );
		insert.makeEntityManaged();
/s
EntityInsertAction(AbstractEntityInsertAction).makeEntityManaged() line: 141	
		nullifyTransientReferencesIfNotAlready();
/s
		if ( ! areTransientReferencesNullified ) {
			new ForeignKeys.Nullifier( getInstance(), false, isEarlyInsert(), getSession() )
					.nullifyTransientReferences( getState(), getPersister().getPropertyTypes() );
this	EntityInsertAction  (id=3441)	
	state	Object[4]  (id=3250)	
		[0]	"foostreet" (id=2845)	
		[1]	"12 foo" (id=3251)	
		[2]	"FooCity" (id=2846)	
		[3]	PersistentList  (id=3381)	
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object[], Type[]) line: 80	
			for ( int i = 0; i < types.length; i++ ) {
				values[i] = nullifyTransientReferences( values[i], types[i] );
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object, Type) line: 98	
			else if ( type.isEntityType() ) {
/ NEE
			else if ( type.isAnyType() ) {
/ NEE
			else if ( type.isComponentType() ) {
/ NEE

/t
EntityInsertAction(AbstractEntityInsertAction).makeEntityManaged() line: 143	
		final Object version = Versioning.getVersion( getState(), getPersister() );
/ D
		getSession().getPersistenceContext().addEntity(
				getInstance(),
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),
				getState(),
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);
/ De entityentry is dirty	,


/ 7.

/ .commit	,

/ Employee.address' mepping	,
	<many-to-one 
		name="address"
		column="address_"
	></many-to-one>
<!--
		not-null="true"
-->

/ we hebben al	,
			session.save(employee);
			session.save(employee11);
			session.save(address);

/ we debug	,
			tx.commit();



	public void commit() throws HibernateException {
		beforeTransactionCommit();
...
/s
SessionImpl.flush() line: 1215	
		FlushEvent flushEvent = new FlushEvent( this );
		for ( FlushEventListener listener : listeners( EventType.FLUSH ) ) {
			listener.onFlush( flushEvent );

/s
DefaultFlushEventListener.onFlush(FlushEvent) line: 55	
	public void onFlush(FlushEvent event) throws HibernateException {
				flushEverythingToExecutions( event );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 102	
			int entityCount = flushEntities( event, persistenceContext );
/s
	private int flushEntities(final FlushEvent event, final PersistenceContext persistenceContext) throws HibernateException {

		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {

entityEntries	EntityEntryContext$EntityEntryCrossRefImpl[3]  (id=43)	
	[0]	EntityEntryContext$EntityEntryCrossRefImpl  (id=39)	
		entity	Employee  (id=104)	
			address	Address  (id=160)	
			id	1	
			name	"Foo1" (id=75)	
			salary	1.0	
		entityEntry	EntityEntry  (id=35)	
			id	Long  (id=48)	
				value	1	
			loadedState	Object[3]  (id=51)	
				[0]	"Foo1" (id=75)	
				[1]	Double  (id=76)	
	[1]	EntityEntryContext$EntityEntryCrossRefImpl  (id=2818)	
		entity	Employee  (id=2799)	
		entityEntry	EntityEntry  (id=2840)	
	[2]	EntityEntryContext$EntityEntryCrossRefImpl  (id=103)	
		entity	Address  (id=160)	
			addressLine1	"foostreet" (id=205)	
			city	"FooCity" (id=207)	
			employees	PersistentList  (id=208)	
			id	12	
			zipcode	"12 foo" (id=206)	
		entityEntry	EntityEntry  (id=202)	
			id	Long  (id=203)	
				value	12	
			loadedState	Object[4]  (id=204)	
				[0]	"foostreet" (id=205)	
				[1]	"12 foo" (id=206)	
				[2]	"FooCity" (id=207)	
				[3]	PersistentList  (id=208)	

	[2]	EntityEntryContext$EntityEntryCrossRefImpl  (id=2819)	
		entity	Address  (id=2785)	
		entityEntry	EntityEntry  (id=2851)	

/ we zien dat de loadedState van een Employee fk=null heeft	,
/ we zien dat de loadedState van een Address volledig is	, 

/ Eerst 1ste Employee	,

				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 143	

		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/ Uit entity	(NIET loadedState)	,

		event.setPropertyValues( values );

		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/s
DefaultFlushEntityEventListener.isUpdateNecessary(FlushEntityEvent, boolean) line: 232	
			dirtyCheck( event );
/s
DefaultFlushEntityEventListener.dirtyCheck(FlushEntityEvent) line: 492	

		final Object[] values = event.getPropertyValues();
/ uit entity
		final Object[] loadedState = entry.getLoadedState();

					dirtyProperties = persister.findDirty( values, loadedState, entity, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).findDirty(Object[], Object[], Object, SessionImplementor) line: 4243	
		int[] props = TypeHelper.findDirty(
				entityMetamodel.getProperties(),
				currentState,
				previousState,
				propertyColumnUpdateable,
				hasUninitializedLazyProperties( entity ),
				session
			);
/s
TypeHelper.findDirty(NonIdentifierAttribute[], Object[], Object[], boolean[][], boolean, SessionImplementor) line: 289	
		for ( int i = 0; i < span; i++ ) {
3
			final boolean dirty = currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY
					&& properties[i].isDirtyCheckable( anyUninitializedProperties )
					&& properties[i].getType().isDirty( previousState[i], currentState[i], includeColumns[i], session );
/ i=2	,
/s
ManyToOneType.isDirty(Object, Object, boolean[], SessionImplementor) line: 320	
/=
	public boolean isDirty(
			Object old,
/ loadedState
			Object current,
/ entity values
			boolean[] checkable,
			SessionImplementor session) throws HibernateException {

		if ( isAlwaysDirtyChecked() ) {
			return isDirty( old, current, session );
/s
ManyToOneType.isDirty(Object, Object, SessionImplementor) line: 307	
		if ( isSame( old, current ) ) {
/s
		return x == y;
/ NEE
old	null	
current	Address  (id=160)	
	addressLine1	"foostreet" (id=205)	
	city	"FooCity" (id=207)	
	employees	PersistentList  (id=208)	
	id	12	
	zipcode	"12 foo" (id=206)	
/t
		Object oldid = getIdentifier( old, session );
null
		Object newid = getIdentifier( current, session );
Long 12	, van Address	,
		return getIdentifierType( session ).isDirty( oldid, newid, session );
/s
LongType(AbstractStandardBasicType<T>).isDirty(Object, Object, SessionImplementor) line: 229	
		return isDirty( old, current );
/s
	public final boolean isSame(Object x, Object y) {
		return isEqual( x, y );
/s
	public final boolean isEqual(Object one, Object another) {
		return javaTypeDescriptor.areEqual( (T) one, (T) another );
/s
LongTypeDescriptor(AbstractTypeDescriptor<T>).areEqual(T, T) line: 89	
		return EqualsHelper.equals( one, another );
/s
EqualsHelper.equals(Object, Object) line: 34	
		return x == y || ( x != null && y != null && x.equals( y ) );
false
/ want x==null

/t
TypeHelper.findDirty(NonIdentifierAttribute[], Object[], Object[], boolean[][], boolean, SessionImplementor) line: 299	
		for ( int i = 0; i < span; i++ ) {
			final boolean dirty = currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY
					&& properties[i].isDirtyCheckable( anyUninitializedProperties )
					&& properties[i].getType().isDirty( previousState[i], currentState[i], includeColumns[i], session );
/ D
			if ( dirty ) {
/ JA
				if ( results == null ) {
					results = new int[span];
				}
				results[count++] = i;
/ results[0]=2
/ count was 0, 2 is index dirty property	,

		else {
			int[] trimmed = new int[count];
			System.arraycopy( results, 0, trimmed, 0, count );
			return trimmed;
		}
/ trimmed[0]=2

/t
DefaultFlushEntityEventListener.dirtyCheck(FlushEntityEvent) line: 588	
					dirtyProperties = persister.findDirty( values, loadedState, entity, session );
/ D
[0]=2

		event.setDirtyProperties( dirtyProperties );

/t
DefaultFlushEntityEventListener.isUpdateNecessary(FlushEntityEvent, boolean) line: 234	
			dirtyCheck( event );
/ D
			if ( isUpdateNecessary( event ) ) {
				return true;

/t
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 160	
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/ JA
			substitute = scheduleUpdate( event ) || substitute;
/s
DefaultFlushEntityEventListener.scheduleUpdate(FlushEntityEvent) line: 300	
		int[] dirtyProperties = event.getDirtyProperties();
dirtyProperties	(id=420)	
	[0]	2	

		// note that we intentionally do _not_ pass in currentPersistentState!
		session.getActionQueue().addAction(
				new EntityUpdateAction(
						entry.getId(),
						values,
/ entity's state
						dirtyProperties,
[0]=2
						event.hasDirtyCollection(),
false
						( status == Status.DELETED && !entry.isModifiableEntity() ?
								persister.getPropertyValues( entity ) :
								entry.getLoadedState() ),
/ loadedState	, met fk=null
						entry.getVersion(),
						nextVersion,
						entity,
						entry.getRowId(),
						persister,
						session
				)
		);

/t
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 163	
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
			substitute = scheduleUpdate( event ) || substitute;
/ D

			if ( persister.hasCollections() ) {
/ NEE

/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 225	
/ Dan 2de Employee	,
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
			EntityEntry entry = me.getValue();
			Status status = entry.getStatus();
...

/ Dan Address	,
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
			EntityEntry entry = me.getValue();
entry	EntityEntry  (id=202)	
	id	Long  (id=203)	
		value	12	
	loadedState	Object[4]  (id=204)	
		[0]	"foostreet" (id=205)	
		[1]	"12 foo" (id=206)	
		[2]	"FooCity" (id=207)	
		[3]	PersistentList  (id=208)	

				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 163	
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/ NEE
/ GEEN schedule update	,

			if ( persister.hasCollections() ) {
/ JA
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/s
FlushVisitor(AbstractVisitor).processEntityPropertyValues(Object[], Type[]) line: 75	
types	Type[4]  (id=581)	
	[0]	StringType  (id=582)	
	[1]	StringType  (id=582)	
	[2]	StringType  (id=582)	
	[3]	ListType  (id=586)	
		role	"my.test.own.hibernate_collections_xml.Address.employees" (id=628)	


/s
FlushVisitor(AbstractVisitor).processValue(Object, Type) line: 119	
		if ( type.isCollectionType() ) {
/ JA
			//even process null collections
			return processCollection( value, (CollectionType) type );
		}
		else if ( type.isEntityType() ) {
			return processEntity( value, (EntityType) type );
		}
		else if ( type.isComponentType() ) {
			return processComponent( value, (CompositeType) type );
		}
/s
FlushVisitor.processCollection(Object, CollectionType) line: 59	
			Collections.processReachableCollection( coll, type, owner, getSession() );
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 192	
		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
persister	OneToManyPersister  (id=637)	
		ce.setCurrentPersister( persister );
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
Long 12
		prepareCollectionForUpdate( collection, ce, factory );
/s
				if ( currentPersister != null ) {
					entry.setDorecreate( true );

/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	
			int entityCount = flushEntities( event, persistenceContext );
/ D
			int collectionCount = flushCollections( session, persistenceContext );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 255	
		final Map.Entry<PersistentCollection,CollectionEntry>[] entries = IdentityMap.concurrentEntries(
				(Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries()
		);
/ CONCURRENCY

		final int count = entries.length;
1
		for ( Map.Entry<PersistentCollection,CollectionEntry> me :
			IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries() )) {
/ CONCURRENCY

/ in de pc in entityEntryContext is de EntityEntry van de Address	, in de Address is de coll	, maar niet de CollectionEntry (met bijv de persister)	, 
/ De CollectionEntry is in de pc in de collectionEntries
/ ce hieronder is zo'n collection entry	,

			if ( ce.isDorecreate() ) {
/ JA
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
OneToManyPersister	,
								ce.getCurrentKey(),
Long 12	,
								session
							)
					);
			}

/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 105	
			int collectionCount = flushCollections( session, persistenceContext );
/ D

/t
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
/s
ActionQueue.executeActions() line: 349	
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
		}
executableLists	Collections$UnmodifiableRandomAccessList<E>  (id=841)	
	list	ArrayList<E>  (id=842)	
		elementData	Object[10]  (id=843)	
			[1]	ExecutableList<E>  (id=824)	
				executables	ArrayList<E>  (id=825)	
[EntityInsertAction[my.test.own.hibernate_collections_xml.Employee#1], EntityInsertAction[my.test.own.hibernate_collections_xml.Employee#2], EntityInsertAction[my.test.own.hibernate_collections_xml.Address#12]]

			[2]	ExecutableList<E>  (id=509)	
				executables	ArrayList<E>  (id=511)	
[EntityUpdateAction[my.test.own.hibernate_collections_xml.Employee#1], EntityUpdateAction[my.test.own.hibernate_collections_xml.Employee#2]]

			[6]	ExecutableList<E>  (id=836)	
				executables	ArrayList<E>  (id=855)	
[CollectionRecreateAction[my.test.own.hibernate_collections_xml.Address.employees#12], null, null, null, null]

/s
EntityInsertAction.execute() line: 90	
this	EntityInsertAction  (id=1021)	
	entityName	"my.test.own.hibernate_collections_xml.Employee" (id=1026)	
	id	Long  (id=48)	
		value	1	
	instance	Employee  (id=104)	
		address	Address  (id=160)	
		id	1	
		name	"Foo1" (id=75)	
		salary	1.0	
	state	Object[3]  (id=51)	
		[0]	"Foo1" (id=75)	
		[1]	Double  (id=76)	

		nullifyTransientReferencesIfNotAlready();
/s
EntityInsertAction(AbstractEntityInsertAction).nullifyTransientReferencesIfNotAlready() line: 129	
		if ( ! areTransientReferencesNullified ) {
/ NEE

/t
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );
persister	SingleTableEntityPersister  (id=56)	
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
		final int span = getTableSpan();
1
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/s
		return entityMetamodel.getPropertyInsertability();
[true,true,true]
/t
/s
		return sqlInsertStrings;
[insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)]

/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3096	
			inserBatchKey = new BasicBatchKey(
					getEntityName() + "#INSERT",
					expectation
			);
this	SingleTableEntityPersister  (id=56)	
	inserBatchKey	BasicBatchKey  (id=1113)	
		comparison	"my.test.own.hibernate_collections_xml.Employee#INSERT" (id=1119)	

			if ( useBatch ) {
				insert = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
			}
insert	Jdbc4PreparedStatement  (id=1255)	

				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/s
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2843	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i )) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );

this	SingleTableEntityPersister  (id=56)	
	entityMetamodel	EntityMetamodel  (id=333)	
			[0]	StringType  (id=582)	
			[1]	DoubleType  (id=1300)	
			[2]	ManyToOneType  (id=355)	
/ de laatste	, i=2
/ fields[i]=null	,
/s
ManyToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 165	
		getIdentifierOrUniqueKeyType( session.getFactory() )
				.nullSafeSet( st, getIdentifier( value, session ), index, settable, session );
value=null
/s
	public final Type getIdentifierOrUniqueKeyType(Mapping factory) throws MappingException {
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
/ JA
			return getIdentifierType(factory);
/s
ManyToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 165	
		final Type type = associatedIdentifierType;
LongType
/t
/s
ManyToOneType(EntityType).getIdentifier(Object, SessionImplementor) line: 537	
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
/ JA
			return ForeignKeys.getEntityIdentifierIfNotUnsaved( getAssociatedEntityName(), value, session ); //tolerates nulls
/ getAssociatedEntityName()="pgk.Address"
/s
ForeignKeys.getEntityIdentifierIfNotUnsaved(String, Object, SessionImplementor) line: 284	
		if ( object == null ) {
			return null;
		}

/t
/s
LongType(AbstractSingleColumnStandardBasicType<T>).nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 55	
this	LongType  (id=381)	
	javaTypeDescriptor	LongTypeDescriptor  (id=398)	
	sqlTypeDescriptor	BigIntTypeDescriptor  (id=402)	

			nullSafeSet( st, value, index, session );
value=null
/s
	protected final void nullSafeSet(PreparedStatement st, Object value, int index, WrapperOptions options) throws SQLException {
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
sqlTypeDescriptor	BigIntTypeDescriptor  (id=402)	

/s
public class BigIntTypeDescriptor implements SqlTypeDescriptor {
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setLong( index, javaTypeDescriptor.unwrap( value, Long.class, options ) );
			}
		};
	}

/s
BigIntTypeDescriptor$1(BasicBinder<J>).bind(PreparedStatement, J, int, WrapperOptions) line: 77	
       if ( value == null ) {
/JA
            st.setNull( index, sqlDescriptor.getSqlType() );
       }
/ NIET	,
            doBind( st, value, index, options );


/t
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2849	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i )) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...

/ D
		if ( !isUpdate ) {
/ JA
			index += dehydrateId( id, rowId, ps, session, index );
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 10:11:38 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 10:11:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 10:26:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [null]
HibernateLog --> 10:50:12 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

/t
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3123	
					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();

/t
EntityInsertAction.execute() line: 143	
			persister.insert( id, getState(), instance, session );
/ D
		if ( isCachePutEnabled( persister, session ) ) {
/ NEE

/ t
/ Address persist	,

/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3069	
fields	Object[4]  (id=204)	
	[0]	"foostreet" (id=205)	
	[1]	"12 foo" (id=206)	
	[2]	"FooCity" (id=207)	
	[3]	PersistentList  (id=208)	
notNull	(id=1531)	
	[0]	true	
	[1]	true	
	[2]	true	
	[3]	true	
sql	"insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)" (id=1534)	

/ De list komt gewoon niet in de sql voor	, de mapping is many-to-one, bidir, dus Employee is owner	,

/ propertyTypes=[StringType, StringType, StringType, ListType]

/ een van de strings	,

/s
	protected final void nullSafeSet(PreparedStatement st, Object value, int index, WrapperOptions options) throws SQLException {
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
/s
VarcharTypeDescriptor.
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setString( index, javaTypeDescriptor.unwrap( value, String.class, options ) );
			}
		};
	}
/t
/s
VarcharTypeDescriptor$1(BasicBinder<J>).bind(PreparedStatement, J, int, WrapperOptions) line: 90	
            doBind( st, value, index, options );
/s
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setString( index, javaTypeDescriptor.unwrap( value, String.class, options ) );

/t
/ de laatste	, de list	,
/s
ListType(CollectionType).nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 183	
	public final void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable,
			SessionImplementor session) throws HibernateException, SQLException {
		//NOOP
	}


/ Dan de entityupdateactions	,
/s
EntityUpdateAction.execute() line: 129	

/ employee update	, nl fk naar Address	,

		if ( persister.hasCache() ) {
/ NEE
			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
this	EntityUpdateAction  (id=495)	
	dirtyFields	(id=420)	
		[0]	2	
	id	Long  (id=48)	
		value	1	
	previousState	Object[3]  (id=51)	
		[0]	"Foo1" (id=75)	
		[1]	Double  (id=76)	
	state	Object[3]  (id=326)	
		[0]	"Foo1" (id=75)	
		[1]	Double  (id=327)	
		[2]	Address  (id=160)	
/s
SingleTableEntityPersister(AbstractEntityPersister).update(Serializable, Object[], int[], boolean, Object[], Object, Object, Object, SessionImplementor) line: 3456	

		else {
			// For the case of dynamic-update="false", or no snapshot, we use the static SQL
			updateStrings = getUpdateStrings(
					rowId != null,
					hasUninitializedLazyProperties( object )
			);
[update employee set name_=?, salary_=?, address_=? where id_=?]
/ want,	
hasUninitializedLazyProperties( object )=false
TODO
/s
			return lazy ? getSQLLazyUpdateStrings() : getSQLUpdateStrings();
/ lazy=false

/t
			if ( tableUpdateNeeded[j] ) {
				updateOrInsert(
						id,
						fields,
						oldFields,
						j == 0 ? rowId : null,
						propsToUpdate,
						j,
						oldVersion,
						object,
						updateStrings[j],
						session
					);
			}
/s
SingleTableEntityPersister(AbstractEntityPersister).updateOrInsert(Serializable, Object[], Object[], Object, boolean[], int, Object, Object, String, SessionImplementor) line: 3183	
				isRowToUpdate = update( id, fields, oldFields, rowId, includeProperty, j, oldVersion, object, sql, session );
fields	Object[3]  (id=326)	
	[0]	"Foo1" (id=75)	
	[1]	Double  (id=327)	
	[2]	Address  (id=160)	

			if ( useBatch ) {
				update = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( updateBatchKey )
						.getBatchStatement( sql, callable );
			}
update	Jdbc4PreparedStatement  (id=1725)	
update employee set name_=?, salary_=?, address_=? where id_=?

				//Now write the values of fields onto the prepared statement
				index = dehydrate( id, fields, rowId, includeProperty, propertyColumnUpdateable, j, update, session, index, true );
/s
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2841	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i )) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/ De laatste	,
ManyToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 165	
		getIdentifierOrUniqueKeyType( session.getFactory() )
				.nullSafeSet( st, getIdentifier( value, session ), index, settable, session );

////////////////////
/ Hier zien we dat als we een fk persist, hij de id van de target pakt , en die persist		,
getIdentifierOrUniqueKeyType( session.getFactory()=LongType	,

...
/s
BigIntTypeDescriptor.getBinder(JavaTypeDescriptor<X>) line: 61	
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setLong( index, javaTypeDescriptor.unwrap( value, Long.class, options ) );
			}
		};
/t
/s
BigIntTypeDescriptor$1(BasicBinder<J>).bind(PreparedStatement, J, int, WrapperOptions) line: 66	
       if ( value == null ) {
/ NEE
            doBind( st, value, index, options );
/s
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
->				st.setLong( index, javaTypeDescriptor.unwrap( value, Long.class, options ) );
			}

/t
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2863	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/ D

		if ( isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );

/t
SingleTableEntityPersister(AbstractEntityPersister).update(Serializable, Object[], Object[], Object, boolean[], int, Object, Object, String, SessionImplementor) line: 3281	

				index = dehydrate( id, fields, rowId, includeProperty, propertyColumnUpdateable, j, update, session, index, true );
/ D
Hibernate: update employee set name_=?, salary_=?, address_=? where id_=?
HibernateLog --> 11:45:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 11:47:08 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 11:56:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 11:59:54 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( updateBatchKey ).addToBatch();
/ exec	,

/t
EntityUpdateAction.execute() line: 201	
			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
/ D
		final EntityEntry entry = getSession().getPersistenceContext().getEntry( instance );

			entry.postUpdate( instance, state, nextVersion );
this	EntityUpdateAction  (id=2889)	
	state	Object[3]  (id=2893)	
		[0]	"Foo1" (id=2894)	
		[1]	Double  (id=2895)	
		[2]	Address  (id=2896)	
/s
EntityEntry.postUpdate(Object, Object[], Object) line: 285	
		this.loadedState = updatedState;
/////////////////////////
/ Hier staat het	,

/t

		if ( persister.hasCache() ) {
/ NEE

/ 7	.

/ we hebben zojuist	,

/ Employee.address' mapping	,
	<many-to-one 
		name="address"
		column="address_"

	></many-to-one>
<!--
	not-null="true"
-->

/ Address.employees' mapping	,
 	<list 
 		name="employees"
 		inverse="true">
 		<key
 			column="address_"
 		></key>
 		<list-index></list-index>
 		<one-to-many class="Employee"/>
 	</list>

/ Main	,
			session.save(employee);
			session.save(employee11);
			session.save(address);
			tx.commit();

/ omdat de fk null mag zijn	, is het OK om eerst de employee te .save	,
/ in de enttyentry loadedState is fk=null	,
/ later bij .commit wordt deze loadedState update	, 


/ we gaan nu eerst een address save	, en we set de fk in de employee op not-null	,


/ Employee.address' mapping	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	></many-to-one>
<!--
-->

/ Address.employees' mapping	,
 	<list 
 		name="employees"
 		inverse="true">
 		<key
 			column="address_"
 		></key>
 		<list-index></list-index>
 		<one-to-many class="Employee"/>
 	</list>

/ Main	,
			session.save(address);
			session.save(employee);
			session.save(employee11);
			tx.commit();

/ .save(address)

/////////////////////////////////////////////////////
/ in de set in address staan 2 transient employees. Nu is dit niet erg: ze worden toch niet mapped naar de db	, alleen fk's in de employees

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 268	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
		Type[] types = persister.getPropertyTypes();
values	Object[4]  (id=70)	
	[0]	"foostreet" (id=72)	
	[1]	"12 foo" (id=75)	
	[2]	"FooCity" (id=76)	
	[3]	ArrayList<E>  (id=77)	
types	Type[4]  (id=99)	
	[0]	StringType  (id=108)	
	[1]	StringType  (id=108)	
	[2]	StringType  (id=108)	
	[3]	ListType  (id=123)	

		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/ calls processValue op elke property	,
/ en updates values met PersistentList ipv ArrayList	,

/ inserts CollectionEntry in  pc	,	in collectionEntries	,
/s
WrapVisitor(AbstractVisitor).processValue(Object, Type) line: 119	
/=
	final Object processValue(Object value, Type type) throws HibernateException {

		if ( type.isCollectionType() ) {
			//even process null collections
			return processCollection( value, (CollectionType) type );
		}
		else if ( type.isEntityType() ) {
			return processEntity( value, (EntityType) type );
		}
		else if ( type.isComponentType() ) {
			return processComponent( value, (CompositeType) type );
		}
		else {
			return null;
		}
	}
/s
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 88	
		else {
			CollectionPersister persister = session.getFactory().getCollectionPersister( collectionType.getRole() );
collectionType.getRole() =my.test.own.hibernate_collections_xml.Address.employees
persister	OneToManyPersister  (id=184)	

			else {

				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
				persistenceContext.addNewCollection( persister, persistentCollection );
/ inserts CollectionEntry in  pc	,	in collectionEntries	,
				return persistentCollection; //Force a substitution!

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 276	
		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/ calls processValue op elke property	,
/ en updates values met PersistentList ipv ArrayList	,
/ D
	if ( substitute ) {
			persister.setPropertyValues( entity, values );
/ Ook in de entity wordt ArrayList -> PersistentList	,

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
...
/s
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 176	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
...
/s
ForeignKeys.findNonNullableTransientEntities(String, Object, Object[], boolean, SessionImplementor) line: 334	
		for ( int i = 0; i < types.length; i++ ) {
			collectNonNullableTransientEntities(
					nullifier,
					values[i],
					propertyNames[i],
					types[i],
					nullability[i],
					session,
					nonNullableTransientEntities
			);
		}
/s
ForeignKeys.collectNonNullableTransientEntities(ForeignKeys$Nullifier, Object, String, Type, boolean, SessionImplementor, NonNullableTransientDependencies) line: 355	
		if ( value == null ) {
			return;
		}

		if ( type.isEntityType() ) {
/ NEE
		else if ( type.isAnyType() ) {
/ NEE
		else if ( type.isComponentType() ) {
/ NEE

/t
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 177	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
null

/////////////////////////////////////////////////////
/ Als we eerst .save(employee) 	, en in de mapping is fk nullable	, dan is nonNullableTransientDependencies!=null	, en dan komt hij niet in de code hieronder, waar een entityinsertaction op de insert action queue wordt set	, 
/  Waarom komt hij er er door heen? Want de Employee's zijn transient. We zien het hierboven: het is geen entity type, any type of component type	,
 
/ D
		if ( nonNullableTransientDependencies == null ) {
			addResolvedEntityInsertAction( insert );
/s
			insertions.add( insert );
		insert.makeEntityManaged();
/s
		getSession().getPersistenceContext().addEntity(
				getInstance(),
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),
				getState(),
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);
/s
	public EntityEntry addEntity(
			final Object entity,
			final Status status,
			final Object[] loadedState,
			final EntityKey entityKey,
			final Object version,
			final LockMode lockMode,
			final boolean existsInDatabase,
			final EntityPersister persister,
			final boolean disableVersionIncrement,
			boolean lazyPropertiesAreUnfetched) {
entity	Address  (id=34)	
	addressLine1	"foostreet" (id=72)	
	employees	PersistentList  (id=202)	
	id	12	
	zipcode	"12 foo" (id=75)	
loadedState	Object[4]  (id=70)	
	[0]	"foostreet" (id=72)	
	[1]	"12 foo" (id=75)	
	[2]	"FooCity" (id=76)	
	[3]	PersistentList  (id=202)	

		addEntity( entityKey, entity );
		return addEntry(
				entity,
				status,
				loadedState,
				null,
				entityKey.getIdentifier(),
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched
		);
	}


/ 7	. 

/ we verwisselen de owner , nu Address de owner, dus 1-N bidir	,

/ Address list's mapping	,

	<list 
 		name="employees"
 		inverse="false">
 		<key
			not-null="true" 
 			column="address_"
 		></key>
 		<list-index
 			column="index_"></list-index>
 		<one-to-many 
 			class="Employee"/>
 	</list>
 

 Employee fk's mapping	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		update="false"
		insert="false"
	></many-to-one>

/ we zien in beide 
		not-null="true"

/ we zien hieronder dat de fk in employee blijft	, 

foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
 index_   | integer                |           | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id_)
Has OIDs: no

foo=> \d+ address
                                   Table "public.address"
     Column     |          Type          | Modifiers | Storage  | Stats target | Description 
----------------+------------------------+-----------+----------+--------------+-------------
 id_            | bigint                 | not null  | plain    |              | 
 address_line1_ | character varying(255) |           | extended |              | 
 zipcoce_       | character varying(255) |           | extended |              | 
 city_          | character varying(255) |           | extended |              | 
Indexes:
    "address_pkey" PRIMARY KEY, btree (id_)
Referenced by:
    TABLE "employee" CONSTRAINT "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id_)
Has OIDs: no


HibernateLog --> 14:49:13 DEBUG org.hibernate.SQL - insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 14:49:13 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, index_, id_) values (?, ?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, index_, id_) values (?, ?, ?, ?, ?)
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [INTEGER] - [0]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [BIGINT] - [1]
HibernateLog --> 14:49:13 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, index_, id_) values (?, ?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, index_, id_) values (?, ?, ?, ?, ?)
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [11.0]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [INTEGER] - [1]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [BIGINT] - [2]
HibernateLog --> 14:49:13 DEBUG org.hibernate.SQL - update employee set address_=?, index_=? where id_=?
Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [0]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]
HibernateLog --> 14:49:13 DEBUG org.hibernate.SQL - update employee set address_=?, index_=? where id_=?
Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [1]
HibernateLog --> 14:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]


/ als we in Address' list's <key NIET not-null="true" en in Employee's fk WEL not-null="true"	, dan ERR,	

/ dezelfde \d+'s	,


ibernateLog --> 14:37:15 DEBUG org.hibernate.SQL - insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)
HibernateLog --> 14:37:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 14:37:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 14:37:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity]
HibernateLog --> 14:37:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 14:37:15 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, id_) values (?, ?, ?)
Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 14:37:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 14:37:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 14:37:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]
HibernateLog --> 14:37:15 WARN  org.hibernate.engine.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: 23502
HibernateLog --> 14:37:15 ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - ERROR: null value in column "address_" violates not-null constraint
  Detail: Failing row contains (1, Foo1, 1, null, null).
HibernateLog --> 14:37:15 INFO  org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl - HHH000010: On release of batch it still contained JDBC statements
org.hibernate.exception.ConstraintViolationException: could not execute statement
	at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:129)
	at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:49)
	at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:126)
	at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:112)
	at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(ResultSetReturnImpl.java:211)
	at org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch.addToBatch(NonBatchingBatch.java:62)
	at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:3124)
	at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:3581)
	at org.hibernate.action.internal.EntityInsertAction.execute(EntityInsertAction.java:104)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:463)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:349)
	at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:350)
	at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:56)
	at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:1222)
	at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:425)
	at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.beforeTransactionCommit(JdbcTransaction.java:101)
	at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.commit(AbstractTransactionImpl.java:177)
	at my.test.own.hibernate_collections_xml_1_N.Main.testBasicUsage(Main.java:142)
	at my.test.own.hibernate_collections_xml_1_N.Main.<init>(Main.java:60)
	at my.test.own.hibernate_collections_xml_1_N.Main.main(Main.java:54)
Caused by: org.postgresql.util.PSQLException: ERROR: null value in column "address_" violates not-null constraint
  Detail: Failing row contains (1, Foo1, 1, null, null).
	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2198)
	at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1927)
	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:255)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:561)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:419)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeUpdate(AbstractJdbc2Statement.java:365)
	
/ we debug .commit	, als de <key in Address' employees <list NIET not-null="true" is	,

/ het gaat mis bij de employee, bij de fk dus	, 
/ bij de address gaat OK	,

/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	
			int entityCount = flushEntities( event, persistenceContext );
/ creates collection entry ce in de 1c	, and sets ce.doRecreate=true	,
/ TODO
			int collectionCount = flushCollections( session, persistenceContext );
/ creates an collection recreate action	,
			if ( ce.isDorecreate() ) {
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
								ce.getCurrentKey(),
								session
							)
					);
/s
ActionQueue.addAction(CollectionRecreateAction) line: 250	
		collectionCreations.add( action );

/t
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
/s
			session.getActionQueue().executeActions();
/s
ActionQueue.executeActions() line: 344	
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
this	ActionQueue  (id=2903)	
	executableLists	Collections$UnmodifiableRandomAccessList<E>  (id=2925)	
		list	ArrayList<E>  (id=2936)	
			elementData	Object[10]  (id=2938)	
				[1]	ExecutableList<E>  (id=2927)	
					executables	ArrayList<E>  (id=2950)	
[EntityInsertAction[my.test.own.hibernate_collections_xml_1_N.Address#12], EntityInsertAction[my.test.own.hibernate_collections_xml_1_N.Employee#1], EntityInsertAction[my.test.own.hibernate_collections_xml_1_N.Employee#2]]

				[6]	ExecutableList<E>  (id=2908)	
					executables	ArrayList<E>  (id=2916)	
[CollectionRecreateAction[my.test.own.hibernate_collections_xml_1_N.Address.employees#12]]

/s
ActionQueue.executeActions(ExecutableList<E>) line: 463	
			for ( E e : list ) {
				try {
					e.execute();

/ 1ste is een Address	,

/s
EntityInsertAction.execute() line: 90	
			persister.insert( id, getState(), instance, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	

			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3069	

fields	Object[4]  (id=2865)	
	[0]	"foostreet" (id=2877)	
	[1]	"12 foo" (id=2878)	
	[2]	"FooCity" (id=2879)	
	[3]	PersistentList  (id=2880)	
notNull	(id=3039)	
	[0]	true	
	[1]	true	
	[2]	true	
	[3]	true	
sql	"insert into address (address_line1_, zipcoce_, city_, id_) values (?, ?, ?, ?)" (id=3036)	
object	Address  (id=2873)	
	addressLine1	"foostreet" (id=2877)	
	city	"FooCity" (id=2879)	
	employees	PersistentList  (id=2880)	
	id	12	
	zipcode	"12 foo" (id=2878)	

/t 
/ volgende	
ActionQueue.executeActions(ExecutableList<E>) line: 463	
			for ( E e : list ) {
				try {
					e.execute();

/ 2de is een Employee	, 
/s
EntityInsertAction.execute() line: 104	
			
			persister.insert( id, getState(), instance, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3069	
fields	Object[3]  (id=3408)	
	[0]	"Foo1" (id=3415)	
	[1]	Double  (id=3416)	
	[2]	Address  (id=2873)	
notNull	(id=3410)	
	[0]	true	
	[1]	true	
	[2]	false	

/s
SingleTableEntityPersister(AbstractEntityPersister).dehydrate
			final Serializable id,
			final Object[] fields,
			final Object rowId,
			final boolean[] includeProperty,
[true,true,false]

/ de sql is	,
insert into employee (name_, salary_, id_) values (?, ?, ?)

/ en ook in de binding zien we dat address prop niet wordt bind	,

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
/ NEE bij i=2	, bij address	, 
					&& !lobProperties.contains( i )) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...
			}
		}
		
		if ( !isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );
		}


Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 16:46:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 16:47:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 16:47:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

/ Dit is op zich goed,	 maar in de db is mapped de table , en daar staat in employee table een constraint not-null op de address_ column	,  dus gaat het hieronder fout,	 bij de exec	,
				if ( useBatch ) {
					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();
/s
NonBatchingBatch.addToBatch() line: 71	
	public void addToBatch() {
		notifyObserversImplicitExecution();
		for ( Map.Entry<String,PreparedStatement> entry : getStatements().entrySet() ) {
			try {
				final PreparedStatement statement = entry.getValue();
				final int rowCount = jdbcCoordinator.getResultSetReturn().executeUpdate( statement );
			catch (JDBCException e) {
e	ConstraintViolationException  (id=3471)	
org.hibernate.exception.ConstraintViolationException: could not execute statement

/ In de log zien we 	, ( Waar ? TODO)
HibernateLog --> 16:55:33 WARN  org.hibernate.engine.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: 23502
HibernateLog --> 16:55:33 ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - ERROR: null value in column "address_" violates not-null constraint
  Detail: Failing row contains (1, Foo1, 1, null, null).


/  13	.

/ we doen not-null="true" in de Employee employees list <key	,
...
/s
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
...
/s
ActionQueue.executeActions(ExecutableList<E>) line: 463	
			for ( E e : list ) {
				try {
					e.execute();
e	EntityInsertAction  (id=36)	
	entityName	"my.test.own.hibernate_collections_xml_1_N.Employee" (id=55)	
	state	Object[5]  (id=88)	
		[0]	"Foo1" (id=90)	
		[1]	Double  (id=91)	
		[2]	Address  (id=92)	
		[3]	Long  (id=95)	
		[4]	Integer  (id=96)	

/ de Address OK, 
/ we kijken nu naar een Employee	,
...
/s
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/s
propertyInsertability	(id=175)	
	[0]	true	
	[1]	true	
	[2]	false	
	[3]	true	
	[4]	true	








































/ Einde HIBERNATE COLLECTIONS

/ OPEN BASH 

[eric@localhost conf]$ pwd
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/dsvfms/conf
[eric@localhost conf]$ rm -rf tms.war tms.jar mpo-management.sar 
[eric@localhost conf]$ cat firebird-ds.xml 
[eric@localhost conf]$ grep build application.properties 

[eric@localhost deploy]$ pwd
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/dsvfms/deploy
[eric@localhost deploy]$ sudo yum install pgadmin3

[eric@localhost DB]$ pwd
/home/eric/Devel/Java/DB
[eric@localhost DB]$ ./squirrel-sql-3.5.3/squirrel-sql.sh 
[eric@localhost DB]$ java -jar ~/Downloads/squirrel-sql-3.5.3-standard.jar 
[eric@localhost DB]$ isql-fb 
[eric@localhost DB]$ sudo -u firebird gbak -rep -n -user sysdba -password masterkey dsvfms.fdb_20140615-220001.fbk dsvfms.fdb
[eric@localhost DB]$ sudo -u firebird gzip -d dsvfms.fdb_20140615-220001.fbk.gz 
[eric@localhost Dsvfms]$  pwd
/home/eric/Devel/Dsvfms
[eric@localhost Dsvfms]$ gzip -d dsvfms.fdb_20140615-220001.fbk.gz 
[eric@localhost Dsvfms]$ cp dsvfms.fdb_20140615-220001.fbk.gz dsvfms.fdb_20140615-220001.fbk.gz.cp
[eric@localhost Dsvfms]$ sudo -u firebird cp dsvfms.fdb_20140615-220001.fbk.gz /tmp

[eric@localhost forticlientsslvpn]$ pwd
/home/eric/Devel/Intermax/forticlientsslvpn
[eric@localhost forticlientsslvpn]$ sudo ./forticlientsslvpn_cli --server 80.95.170.62:443 --vpnuser vanderveldene 
Password for VPN:
h^Zgcyr&Q
STATUS::Setting up the tunnel
STATUS::Connecting...
...

/ 23 dec 2014

/ Lees	,
username	wachtwoord	token	activatiecode
vanderveldene	HA65Fs8LTTCK	VES0309767	36344214563535869646

/ de token en activatiecode hebben we op de telefoon gegeven, in digipass	,
/ dat form zien we daarna niet meer	,

/ op de telefoon hebben we one-time password	, geef die achter het wachtwoord	,
[eric@localhost forticlientsslvpn]$ sudo ./forticlientsslvpn_cli --server 80.95.170.62:443 --vpnuser vanderveldene
Password for VPN: HA65Fs8LTTCK211804
Y

/ install keypass


/ Einde 23 dec 2014 

[eric@localhost forticlientsslvpn]$ pwd
/home/eric/Devel/Intermax/forticlientsslvpn
[eric@localhost forticlientsslvpn]$ ssh vanderveldene@192.168.171.1
h^Zgcyr&Q

mpopostgres@mpo

[eric@localhost test_divers-EHCACHE]$ pwd
/home/eric/Devel/Java/Ehcache/test_divers-EHCACHE
[eric@localhost test_divers-EHCACHE]$ vi ./src/com/ho/ehcache/test1/uses/UseCaseClass.java

[eric@localhost simple-webapp]$ pwd
/home/eric/Devel/Java/Maven/Book/mvnexbook-examples-1.0/ch-multi-spring/simple-parent/simple-webapp
[eric@localhost simple-webapp]$ mvn hibernate3:hbm2ddl
[eric@localhost simple-webapp]$ vi ../simple-persist/target/classes/hibernate.cfg.xml 

[eric@localhost threadlocal]$ pwd
/home/eric/Devel/Java/Maven/threadlocal

[eric@localhost hsqldb]$ pwd
/home/eric/Devel/Java/Hibernate/hibernate-book/hsqldb
[eric@localhost hsqldb]$ jdb -classpath target/merge-1.0-SNAPSHOT-jar-with-dependencies.jar org.hibernate.book.hbm.Main2a

[eric@localhost hibernate-book]$   pwd
/home/eric/Devel/Java/Hibernate/hibernate-book

[eric@localhost Postgres]$ pwd
/home/eric/Devel/Postgres
[eric@localhost Postgres]$ psql -U mpopostgres -f firstmpo.dump -d mpo
[eric@localhost Postgres]$ pg_dump -U mpopostgres -f rmsampo.dump mpo

[eric@localhost 2014.01]$  pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/2014.01

[eric@localhost Manual]$ pwd
/home/eric/Devel/Java/Ant/Manual
[eric@localhost Manual]$ ant clean init
[eric@localhost Manual]$ ant clean use
[eric@localhost Manual]$ vi build.xml 
[eric@localhost Manual]$ java -jar build/helloWorld.jar 

[eric@localhost Chapter02]$ pwd
/home/eric/Devel/Java/Ant/Book/code/Chapter02
[eric@localhost Chapter02]$ ant -v clean jarfile

[eric@localhost Ch01]$ pwd
/home/eric/Devel/Java/Ant/Book/Ch01
[eric@localhost Ch01]$ vi build.xml 

[eric@localhost mvnexbook-examples-1.0]$ pwd
/home/eric/Devel/Java/Maven/Book/mvnexbook-examples-1.0
[eric@localhost mvnexbook-examples-1.0]$ $(awk '{print "ls -l",$0}' <(locate mpo.dump) )
[eric@localhost mvnexbook-examples-1.0]$ awk '{print "ls -l",$0}' <(locate mpo.dump) 

[eric@localhost Test]$ pwd
/home/eric/Devel/Java/Test
[eric@localhost Test]$ java date 1399649075000

[eric@localhost apache-tomcat-7.0.53]$ pwd
/home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.53
[eric@localhost apache-tomcat-7.0.53]$ vi bin/catalina.sh 

/In smb, Home, Devel, Dsvfms
...
/In smb, scratch on mpofs1, issue-data, DSVSOL-xxx
dsvfms_fdb_20140615-2200001.fbk


 





/ einde OPEN BASH

/ APPLICATION

select this_.SYSTEM_ID as SYSTEM1_41_0_, this_.DESCRIPTION as DESCRIPT2_41_0_, this_.CMINUTE as CMINUTE41_0_, this_.CHOUR as CHOUR41_0_, this_.CDAY_OF_WEEK as CDAY5_41_0_, this_.CDAY_OF_MONTH as CDAY6_41_0_, this_.CMONTH as CMONTH41_0_, this_.TASK_CLASS as TASK8_41_0_, this_.PARAMETERS as PARAMETERS41_0_, this_.EMAIL as EMAIL41_0_, this_.EMAIL_ERROR as EMAIL11_41_0_, this_.ENABLED as ENABLED41_0_, this_.STATUS as STATUS41_0_, this_.LAST_RUN_RESULT as LAST14_41_0_, this_.LAST_RUN_SECS as LAST15_41_0_, this_.LAST_RUN_DATE as LAST16_41_0_, this_.FAILURE_COUNT as FAILURE17_41_0_, this_.FAILURE_THRESHOLD as FAILURE18_41_0_ 
from CRONJOBLINES this_ 
where this_.ENABLED=? and this_.STATUS=?

select this_.SYSTEM_ID as SYSTEM1_143_0_, this_.INTERFACE_ID as INTERFACE2_143_0_, this_.STATUS as STATUS143_0_, this_.EVENT_DATE as EVENT4_143_0_, this_.OBJECT_REFERENCE1 as OBJECT5_143_0_, this_.OBJECT_REFERENCE2 as OBJECT6_143_0_, this_.OBJECT_REFERENCE3 as OBJECT7_143_0_, this_.OBJECT_REFERENCE4 as OBJECT8_143_0_, this_.OBJECT_REFERENCE5 as OBJECT9_143_0_, this_.START_DTM as START10_143_0_, this_.END_DTM as END11_143_0_, this_.ERROR_STRING as ERROR12_143_0_ 
from INTERFACE_TRIGGER_EVENT this_ 
where this_.INTERFACE_ID=? 
and this_.STATUS=? 
and this_.EVENT_DATE between ? and ? order by this_.EVENT_DATE asc limit ?

2014-07-29 16:32:53,229 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - CARCON_SERVICE
2014-07-29 16:32:53,232 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - PLAN_SERVICE_ACTION
2014-07-29 16:32:53,239 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - RATE_CALC_RECALCULATE
2014-07-29 16:32:53,243 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - CUSTOMER_INVOICE_MSG
2014-07-29 16:32:53,293 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - SMS_MSG
2014-07-29 16:32:53,297 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - INVOICE_MSG
2014-07-29 16:32:53,302 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - SERVICE_ORDER_REPAIR
2014-07-29 16:32:53,306 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - PATH_ASSIGNMENT
2014-07-29 16:32:53,310 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - REPORT_BY_EMAIL
2014-07-29 16:32:53,315 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - PRENOTIFY
2014-07-29 16:32:53,321 DEBUG [org.hibernate.type.descriptor.sql.BasicBinder] (interfaceTriggerEventTimerFactory:) binding parameter [1] as [VARCHAR] - DEFERRED_EVENT

select sum(this_.OPEN_ALERT_COUNT) as y0_ 
from EVENT_CACHE this_ 
where this_.ORGANIZATION_SYSTEMID in (?, ?, ?)

/ Zoek op scheduledtimertask in alle *sb*xml files	,

6000000
300000
7200000


/ 13	,

/t
	public void onFlush(FlushEvent event) throws HibernateException {
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
/s
	public void executeActions() throws HibernateException {
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
/ er zijn multiple lists	, 
/ er is maar 1 list die niet [] is	,
[EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Address#1], EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Employee#1], EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Address#2], EntityInsertAction[my.test.own.ehcache_hibernate_xml3.Employee#2]]

/s
	 */
	private <E extends Executable & Comparable<?> & Serializable> void executeActions(ExecutableList<E> list) throws HibernateException {
			for ( E e : list ) {
					e.execute();
/s
	public void execute() throws HibernateException {
		nullifyTransientReferencesIfNotAlready();
/ NIET 	,

/ we set de values op de pstmt	, 
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2843	

/ s	, bij string type	,
StringType(AbstractStandardBasicType<T>).nullSafeSet(PreparedStatement, Object, int, WrapperOptions) line: 286	
       protected final void nullSafeSet(PreparedStatement st, Object value, int index, WrapperOptions options) throws SQLException {
                remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
        }
/s
VarcharTypeDescriptor$1(BasicBinder<J>).bind(PreparedStatement, J, int, WrapperOptions) line: 90	

            doBind( st, value, index, options );
/s
VarcharTypeDescriptor$1.doBind(PreparedStatement, X, int, WrapperOptions) line: 65	
/=
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {

		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setString( index, javaTypeDescriptor.unwrap( value, String.class, options ) );
			}
		};

/ en later,	

/ s , bij 1-1 type	,
OneToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 144	
/ NIETS	,





/ 13	,

/ KLAD

DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 422   
                Object entity = loadFromSessionCache( event, keyToLoad, options );











/ Einde APPLICATION

/ HIBERNATE

/ 7	. 

/ getold


/ Item's mapping	,
...
  <set
		name="bids"
	>
		<key
			not-null="true"
			column="item_"
		/>
		<one-to-many
			class="Bid"/>
        </set>
</class>

/ Bid's mapping	,

	<many-to-one 
		name="item" 
		column="item_"
		not-null="true"
		update="false"
		insert="false"
	/>

/ Main	,

		Item item=new Item(1l,"first","Vlaardingen");
		Item item2=new Item(2l,"second","Rijswijk");

		Bid bid=new Bid(1l);
		//bid.setItem(item2);
		item2.getBids().add(bid);

		Bid bid2=new Bid(2l);
		//bid2.setItem(item);
		item.getBids().add(bid2);

		Bid bid3=new Bid(3l);
		//bid3.setItem(item2);
		item2.getBids().add(bid3);

		Bid bid4=new Bid(4l);
		//bid4.setItem(item);
		item.getBids().add(bid4);

		session.save(item); 
		session.save(item2); 

		session.save(bid); 
		session.save(bid2); 
		session.save(bid3); 
		session.save(bid4); 

/ Onderscheid: we moeten WEL alle Bid's save	,
/ Als we NIET alle Bid's save, krijgen we een StaleStateException	,
/ TODO

/ Als we dat niet willen doen 	, moeten we cascade="all" in Item.bids mapping	,

/ Item's mapping,

  	 <set
		name="bids"
		cascade="all"	
	>
		<key
			not-null="true"
			column="item_"
		/>
		<one-to-many
			class="Bid"/>
	</set>

/ Main	,

		Item item=new Item(1l,"first","Vlaardingen");
		Item item2=new Item(2l,"second","Rijswijk");

		Bid bid=new Bid(1l);
		//bid.setItem(item2);
		item2.getBids().add(bid);

		Bid bid2=new Bid(2l);
		//bid2.setItem(item);
		item.getBids().add(bid2);

		Bid bid3=new Bid(3l);
		//bid3.setItem(item2);
		item2.getBids().add(bid3);

		Bid bid4=new Bid(4l);
		//bid4.setItem(item);
		item.getBids().add(bid4);

		session.save(item); 
		session.save(item2); 

/ 7	.

/ In een mapping file is	,  
	name attr de prop in de Java class	,
	column attr de column name in de tbl	,
/ Inderdaad de mapping,	


/ Einde HIBERNATE

/ HIBERNATE BINDING

/ 7	.

/ manual_one_to_one	,

/ de XML <one-to-many bestaat alleen in <set  

/ 13	.

/ we maken eerst unidir person:address=N:1

/ Address	,

public class Address{
	private Long id;
	
	public Long getId() {
		return id;
	}

	public void setId(Long id){
		this.id= id;
	}
}

/ Person	,


public class Person{

	private Long id;
	private Address address;
	
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Address getAddress() {
		return address;
	}

	public void setAddress(Address address) {
		this.address = address;
	}

/ Main
		Address address=new Address();
		
		Person person=new Person();
		person.setAddress(address);
		Person person2=new Person();
		person2.setAddress(address);
		
		
		session.save(address);
		
		session.save(person);
		session.save(person2);

/ Address mapping	,

<class 
	name="Address" 
	table="address"
>
	<id 
		name="id"
		column="id__"
	>	

		<generator 
			class="increment"/>

	</id>


</class>

/ Person mapping	,


<class 
	name="Person" 
	table="person"
>
	<id 	
		name="id"
		column="id_"
	>	
		<generator 
			class="increment"/>

	</id>
	
	<many-to-one
		name="address"
		column="address_"
		not-null="true"
	/>

</class>




/ Voor logging, 
/ in hibernate.cfg	,
<property name="show_sql">true</property>
/ en we moeten file	,
$ vi log4j.properties	
log4j.logger.org.hibernate.SQL=DEBUG
log4j.logger.org.hibernate.type=TRACE

/ we zien de queries pas ontstaan bij .commit, 	niet bij .save	,

/ we zagen eerder de queries ontstaan bij een hql query	,

/ we zien	,

foo=> select*from person\g
 id_ | address_ 
-----+----------
   1 |        1
   2 |        1
(2 rows)

foo=> select*from address\g
 id__ 
------
    1
(1 row)

/ we zien dat de fk niet unique is	, want hij komt 2 keer voor	,

/ 13	.

/ In person, we owner van de N:1 rel, de fk kant, set we cascade	,

<class 
	name="Person" 
	table="person"
>
	<id 	
		name="id"
		column="id_"
	>	
		<generator 
			class="increment"/>

	</id>
	
	<many-to-one
		name="address"
		column="address_"
		not-null="true"
		cascade="all"
	/>

</class>

/ In Main	,

	Address address=new Address();

        Person person=new Person();
        person.setAddress(address);
        Person person2=new Person();
        person2.setAddress(address);

     	// session.save(address);
        session.save(person);
        session.save(person2);

/ OK	, we zien maar 1 keer de insert address dml	, niet 2 keer, dus OK	,

/ 13	. 

/ unidir one-to-one: we hoeven alleen te zeggen dat de mapping van person naar een unique fk is 

/ Person's mapping	,

<class 
	name="Person" 
	table="person"
>
	<id 	
		name="id"
		column="id_"
	>	
		<generator 
			class="increment"/>

	</id>
	
	<many-to-one
		name="address"
		column="address_"
		not-null="true"
		unique="true"
	/>

</class>

/ Main	,

	// undir person:address=n:1 
	Address address=new Address();

        Person person=new Person();
        person.setAddress(address);
        Person person2=new Person();
        person2.setAddress(address);


        session.save(address);

        session.save(person);
        session.save(person2);


/ we zien een ConstraintViolationException	,

/ 13	. 

/ unidir one-to-one on a primary key	,

/ we draaien het alleen niet om zoals in de manual	,

/ Address mapping

<class 
	name="Address" 
	table="address"
>
	<id 
		name="id"
		column="id__"
	>	

		<generator 
			class="increment"/>

	</id>

</class>

/ Person mapping	,

<class 
	name="Person" 
	table="person"
>
	<id 	
		name="id"
		column="id_"
	>	
		<generator 
			class="foreign">
			<param name="property">address</param>
			
		</generator>

	</id>
	
	<one-to-one
		name="address"
		constrained="true"
	/>

</class>

/ Main	,

		Session session = sessionFactory.openSession();
		session.beginTransaction();

	
		
		Address address=new Address();
		Person person=new Person();
		person.setAddress(address);

		Address address2=new Address();
		Person person2=new Person();
		person2.setAddress(address2);
		
		
		session.save(address);
		session.save(person);
		
		session.save(address2);
		session.save(person2);

		session.getTransaction().commit();
		session.close();

/ we zien	,

foo=> select*from address\g
 id__ 
------
    1
    2
(2 rows)

foo=> select*from person\g
 id_ 
-----
   1
   2
(2 rows)

/ we cp hibernate.cfg.xml naar  hibernate.cfg.xml.bak
/ De hibernate cfg is nu hibernate.cfg.xml.bak	,

/ 13	.

/ we gaan nu met annot	,

/ unidir N:1	, 

/ we copy manual_one_to_one naar manual_one_to_one_annot	,

/ Bij een @ManyToOne kan GEEN @Column	, alleen een @JoinColumn	,

/ we kunnen @ManyToOne of @OneToOne	,

/ hibernate.cfg.xml	,

 <mapping class="org.hibernate.book.hbm.Person"/>
 <mapping class="org.hibernate.book.hbm.Address"/>

/ Address	,

@Entity
public class Address{
	
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id_")
	private Long id;

...

/ Person	,

public class Person{

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id__")
	private Long id;
	
	@ManyToOne
	@JoinColumn(name="address_")
	private Address address;

...

/ Main	,	
	// undir person:address=N:1 
	Address address=new Address();

        Person person=new Person();
        person.setAddress(address);
        Person person2=new Person();
        person2.setAddress(address);


        session.save(address);

        session.save(person);
        session.save(person2);	

/ we zien	,

foo=> select*from address\g
 id_ 
-----
   1
(1 row)

foo=> select*from person\g
 id__ | address_ 
------+----------
    1 |        1
    2 |        1
(2 rows)


/ 13	,

/ unidir N:1 on primary key	, 

/ we zien de @PrimaryKeyJoinColumn annot niet in de Hibernate API docs, maar in de JavaEE API docs	,
http://docs.oracle.com/javaee/7/api/

/ we moeten @OneToOne	, anders zien we dezelfde person table als hierboven (ook als je daar @OneToOne neemt)	,

/ Person	,


@Entity
public class Person{

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id__")
	private Long id;
	
	@OneToOne
	@PrimaryKeyJoinColumn(name="address_")
	/*@JoinColumn(name="address_")*/
	private Address address;

/ Main	,

		// undir person:address=N:1 on  a primary key
		Address address=new Address();
		Person person=new Person();
		person.setAddress(address);
		
		Address address2=new Address();
		Person person2=new Person();
		person2.setAddress(address2);
		
		
		session.save(address);
		session.save(person);
		
		session.save(address2);
		session.save(person2);

/ we zien	,


foo=> select*from person\g
 id__ 
------
    1
    2
(2 rows)

foo=> select*from address\g
 id_ 
-----
   1
   2
(2 rows)

/ 7	. 

/ Lees	,
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch08.html#assoc-unidirectional-121

/ bidir 1-1, 

/ manual_one_to_one

/ 13	. 

/ on primary key	,

/ Person's mapping,	 onveranderd vlg. unidir 1-1

<class
        name="Person"
        table="person"
>
        <id
                name="id"
                column="id_"
        >
                <generator
                        class="foreign">
                        <param name="property">address</param>
                </generator>

        </id>

        <one-to-one
                name="address"
                constrained="true"
        />

</class>
 
/ Address's mapping	, voor bidir is <one-to-one erbij gekomen	,

<class 
	name="Address" 
	table="address"
>
	<id 
		name="id"
		column="id__"
	>	

		<generator 
			class="increment"/>

	</id>

	<one-to-one name="person"></one-to-one>

</class>

/ Main	,

		Address address=new Address();
		Person person=new Person();
		person.setAddress(address);
		//address.setPerson(person);
		
		session.save(address);
		session.save(person);
		
		Query q=session.createQuery("select a.person from Address a");
		List<Person>result=q.list();
		for(Person p:result){
			System.out.println(p.getId());
		}

/  WH is Person de owner van de rel	, want we MOETEN	,  
		person.setAddress(address);
/ Anders TOOD

/ WH voor de query moeten we in de mapping van Address	,
	<one-to-one name="person"></one-to-one>
/ dat address.person=null, staat los van de query	,
/ als we deze <one-to-one NIET doen	, dan 	,
org.hibernate.id.IdentifierGenerationException: attempted to assign id from null one-to-one property [org.hibernate.book.hbm.Person.address]
	at org.hibernate.id.ForeignGenerator.generate(ForeignGenerator.java:98)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:117)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:209)
	at org.hibernate.event.internal.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:55)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:194)
	at org.hibernate.event.internal.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:49)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:90)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:715)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at org.hibernate.book.hbm.Main.testBasicUsage(Main.java:110)
	at org.hibernate.book.hbm.Main.<init>(Main.java:52)
	at org.hibernate.book.hbm.Main.main(Main.java:46)

/ 13	. 

/  bidir 1-1, annot 	,on primary key	,

/ Person's mapping,	 onveranderd vlg. unidir 1-1

/ Person's mapping,	 owner mapping	, onveranderd tov unidir	,

Entity
public class Person{

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id__")
	private Long id;
	
	// bidir, on primary
	@OneToOne
	@PrimaryKeyJoinColumn
	private Address address;

/ Address's mapping, person erbij	,	

oEntity
public class Address{
	
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id_")
	private Long id;
	
	@OneToOne(mappedBy="address")
	private Person person;

/ Person's mapping	, 

/ Main	,

		Address address=new Address();
        Person person=new Person();
        person.setAddress(address);
        
        session.save(address);
        session.save(person);
        
        Address address2=new Address();
        Person person2=new Person();
        person2.setAddress(address);
        
        session.save(address2);        
        session.save(person2);
        
        Query q=session.createQuery("select a.person from Address a");
        List<Person>result=q.list();
        for(Person p:result){
        	System.out.println(p.getId());
        }

        Query q2=session.createQuery("select p.address from Person p");
        List<Address>result2=q2.list();
        for(Address a:result2){
        	System.out.println(a.getId());
        	System.out.println(a.getPerson());
        }


/ we zien	,

foo=> select*from person\g
 id__ 
------
    1
    2
(2 rows)

foo=> select*from address\g
 id_ 
-----
   1
   2
(2 rows)


/ de outcome van Main	,

Hibernate: select person1_.id__ as id__1_1_ from Address address0_ inner join Person person1_ on address0_.id_=person1_.id__
HibernateLog --> 14:22:51 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_1_] : [BIGINT]) - [1]
HibernateLog --> 14:22:51 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_1_] : [BIGINT]) - [2]
1
2

/ In Java is  in 1ste query	,
p	Person  (id=53)	
	address	Address  (id=46)	
		id	Long  (id=74)	
		person	null	
	id	Long  (id=74)	

///////////////////////////////////////////////////////
/ In de tbl is er alleen id_ field	, maar deze moet je zien als PK EN FK	, dus er is geen apart FK field	,
/ In Java is Person.address een fk	,









/ Einde HIBERNATE BINDING

/ JAVA 

/ laad een file in fs, of in classpath	,

[eric@localhost Test]$ pwd
/home/eric/Devel/Java/Test
[eric@localhost Test]$ ls
dir  my.xml

[eric@localhost dir]$ cat sub/fis.java 
package sub;
import java.io.*;
class fis{
	public static void main(String[]args)throws Exception{
		InputStream is=new FileInputStream("my.xml");
		System.out.println(is);
	}
}

$ javac dir/sub/fis.java
$ java -cp dir sub.fis
/ OK

/ De file my.xml wordt gevonden vanaf de dir waar de JVM wordt start, java wordt start	, 

[eric@localhost ehcache]$ pwd
/home/eric/Devel/Java/Ehcache/ehcache
[eric@localhost ehcache]$ vi src/main/java/my/own/test/ehcache/SimpleEhCache.java 
        try{my=new FileInputStream("target/classes/ehcache.xml");}catch(Exception e){e.printStackTrace();}

[eric@localhost ehcache]$ mvn clean assembly:assembly
[eric@localhost ehcache]$ java -classpath target/ehcache-0.0.1-SNAPSHOT-jar-with-dependencies.jar my.own.test.ehcache.App
[eric@localhost ehcache]$ jar tvf target/ehcache-0.0.1-SNAPSHOT.jar 
...
   741 Mon Jul 21 08:08:00 CEST 2014 ehcache.xml
  2159 Mon Jul 21 08:08:00 CEST 2014 my/own/test/ehcache/SimpleEhCache.class
...

/ Dus toevallig omdat er target/classes/ehcache.xml is	, wordt hij gevonden	, 

/ beter is via classpath	, want daar zit ehcache.xml in de top	,

[eric@localhost ehcache]$ jar tvf target/ehcache-0.0.1-SNAPSHOT.jar 
...
   741 Mon Jul 21 08:54:56 CEST 2014 ehcache.xml
  2159 Mon Jul 21 08:54:56 CEST 2014 my/own/test/ehcache/SimpleEhCache.class
...

/ we kunnen ook via fs	,
        cacheManager=CacheManager.create("target/classes/ehcache.xml");



/ we kunnen ook via classpath load	,

       	ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        InputStream resourceAsStream = contextClassLoader.getResourceAsStream("ehcache.xml");
        cacheManager = CacheManager.create(resourceAsStream);

/ Dat is makkelijker dan via fs	,
        try{my=new FileInputStream("target/classes/ehcache.xml");}catch(Exception e){e.printStackTrace();}


/ Einde JAVA

/ HIBERNATE

/ 7	.

/ we maken in Main6	,

		session = sessionFactory.openSession();
		session.beginTransaction();
		
		item.setName("bar");
		session.update(item); 
		
		session.getTransaction().commit(); 
		session.close();
		
		session = sessionFactory.openSession();
		session.beginTransaction();
		
		Query q=session.createQuery("update Item set name=:name");
		q.setString("name", "Baz");
		int updateItems=q.executeUpdate();
		
		session.getTransaction().commit(); 
		session.close();

/ In de 1ste session wordt item in de pc set	, 
/ in de 2de session blijft de pc leeg	,

/ 7	.

/ (566)

/ Lees	,
/home/eric/Devel/Java/Hibernate/caveatemptor-native-061211

/ User (seller=verkoper) heeft  een bag van Item's 	, maar initially een bag van proxies naar Item's	, 
/ Item heeft een ref naar User, is dit ook een proxy? WH wel	,

/ In de db zijn er alleen: item tbl zijn er foreign keys naar de user tbl	,







/ Einde HIBERNATE

