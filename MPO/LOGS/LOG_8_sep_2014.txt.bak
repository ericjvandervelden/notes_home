
/ HPV

[eric@localhost workspace]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace
 [eric@localhost workspace]$ svn co https://system.mp-objects.com/svn/tms/branches/2014.02.hvp

[eric@localhost workspace]$ cp 2014.01/.project 2014.02.hvp/
[eric@localhost workspace]$ cp 2014.01/.classpath 2014.02.hvp/
[eric@localhost workspace]$ cp 2014.01/application.properties 2014.02.hvp/

/ right click explorer in eclipse, 	
/ Import, general, existing eclipse project
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/2014.02.hvp

/ Verander de name van de instance	,
[eric@localhost 2014.02.hvp]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/2014.02.hvp
[eric@localhost 2014.02.hvp]$ vi application.properties 
base.product = mposcs
...

/ ant window, 
/ add build files	,
base-framework, buildscripts, build.xml
/right click buildbase , run as , external tools configuration,

ant build. New
/ we zien 2014.02.hvp.build.xml
Build tab
Build before launch: uncheck

JRE tab
Run time JRE:
Seperate  JRE: ...
Workding dir: ${workspace_loc:2014.02.hvp/base-framework}


[eric@localhost ~]$ cd Devel/Java/JBoss/jboss-4.0.5.GA/server/
[eric@localhost server]$ cp -R mpo mposcs

[eric@localhost deploy]$ pwd
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/mposcs/deploy
/ tms.jar , tms.war worden build	,
/ pas postgres-ds.xml aan	,

/ click clean-prepare-and-dev-deploy
/ hij build 
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/mposcs


$ ssh eric@mposerv13
rtdMpo45
eric@mposerv13:~$ sudo su - jboss
jboss@mposerv13:~$ cd mposcs/deploy/
jboss@mposerv13:~/mposcs/deploy$ ls
bsh-deployer.xml                hsqldb-ds.xml            jboss-local-jdbc.rar     jsr88-service.xml           mposcs-schedule-service.xml
cache-invalidation-service.xml  http-invoker.sar         jbossweb-tomcat55.sar    mail-ra.rar                 postgres-ds.xml
client-deployer-service.xml     jboss-aop.deployer       jbossws14.sar            mail-service.xml            properties-service.xml
ear-deployer.xml                jboss-bean.deployer      jboss-xa-jdbc.rar        management                  sqlexception-service.xml
ejb-deployer.xml                jboss-ha-local-jdbc.rar  jms                      monitoring-service.xml      uuid-key-generator.sar
hpscs.jar                       jboss-ha-xa-jdbc.rar     jmx-console.war          mpo-management.sar
hpscs.war                       jbossjca-service.xml     jmx-invoker-service.xml  mposcs-activemq-jms-ds.xml
jboss@mposerv13:~/mposcs/deploy$ vim postgres-ds.xml 
                <xa-datasource-property name="ServerName">localhost</xa-datasource-property>
                <xa-datasource-property name="PortNumber">5432</xa-datasource-property>
                <xa-datasource-property name="DatabaseName">mposcs</xa-datasource-property>
                <xa-datasource-property name="User">mposcs</xa-datasource-property>
                <xa-datasource-property name="Password">Huewabe6iwaithai</xa-datasource-property>
/ Hiermee kunnen we een dump maken van de database	,
/ op mijn laptop
$ pg_dump <remote ds>

/ HPV

/ POSTNL

[eric@localhost workspace]$ svn co https://system.mp-objects.com/svn/tms/trunk

[eric@localhost server]$ pwd
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server
[eric@localhost server]$ cp -a mpo pnloms
[eric@localhost deploy]$ pwd
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/pnloms/deploy
/ pnloms ipv mpo

[eric@localhost trunk]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/trunk
[eric@localhost trunk]$ cp ../2014.02.hvp/application.properties .
$ vi application.properties
base.product = pnloms

[eric@localhost trunk]$ cp ../2014.02.hvp/.project .
[eric@localhost trunk]$ cp ../2014.02.hvp/.classpath .
[eric@localhost trunk]$ vi .project 
<projectDescription>
        <name>trunk</name>
$ vi .classpath
        <classpathentry kind="con" path="org.dbpowder.plugins.LIB_CONTAINER/recurse~project/trunk/base-framework/core/lib/jar"/>
        <classpathentry kind="con" path="org.dbpowder.plugins.LIB_CONTAINER/recurse~project/trunk/base-framework/buildscripts/build-lib"/>
        <classpathentry kind="con" path="org.dbpowder.plugins.LIB_CONTAINER/recurse~project/trunk/module/interfacing/lib"/>

[eric@localhost Backup]$ pwd
/home/eric/Devel/Postgres/Backup
[eric@localhost Backup]$  pg_dump -U eric -Fc -h mposerv8 pnloms -f  pnloms.dump 

mpo=> \c mpo mpopostgres
You are now connected to database "mpo" as user "mpopostgres".
mpo=# create database pnloms\g
CREATE DATABASE

[eric@localhost Backup]$ pg_restore -U mpopostgres -d pnloms pnloms.dump 
mpopostgres@mpo

/ eclipse
/ Import...
General, Existing project
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/trunk

/ server config maken	,
/ copy die van mpo onder Server tab, rechts muis click: open	,
Server name: pnloms
Server configuration: pnloms	, dit slaat op /home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/pnloms	,


/ Einde POSTNL

/ MPO-33 MPO 2014.04 VERSION 123 

/ CREATE INSTANCE

/ 7	. 

/ install branch , build mpo instance

[eric@localhost workspace]$ svn co https://system.mp-objects.com/svn/tms/patches/2014.01/mpo
$ mv mpo 2014.01_mpo
[eric@localhost workspace]$ cp trunk/application.properties 2014.01_mpo/
$ pwd
workspace/2014.01_mpo
$ vi application.properties
base.product = mpo
build.war.dir = /home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/2014.01_${base.product}/deploy/tms.war/
jboss.configuration = 2014.01_${base.product}

[eric@localhost workspace]$ ls 2014.01_mpo/
application.properties  carcon     cevaoms  dsvoms  isbscs    mpo       pnloms   rollsroyce     terex
base-framework          carconmpo  dsvcts   els     jnjedobe  mposcs    pom.xml  rollsroyceoms  tntwillebroek
bin                     cevabgb    dsvfms   geodis  module    naccomfg  rfsdms   src            wartsila
/ we zien dat we allerlei instances kunnen maken: pnloms, mpo, ... 
/ we geven aan welke in application.properties	, see hierboven	, we gaan alleen instance mpo maken, en komt in 2014.01_mpo/ in jboss's server/	,

[eric@localhost server]$ pwd
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server

[eric@localhost server]$ cp -a mpo 2014.01_mpo 
[eric@localhost server]$ ls
2014.01_mpo  all  default  dsvfms  minimal  mpo  mposcs  pnloms
/ instances
/ 2014.01_mpo wordt toch bijna helemaal overwrite, we hebben de config files nodig, daarom doen we dit	,

[eric@localhost server]$ vi 2014.01_mpo/deploy/postgres-ds.xml 

                <xa-datasource-property name="DatabaseName">mpo_2014_01</xa-datasource-property>
 ...
               <connection-url>jdbc:postgresql://127.0.0.1:5432/mpo_2014_01</connection-url>

[eric@localhost workspace]$ cp 2014.01/.project 2014.01_mpo/
[eric@localhost workspace]$ cp 2014.01/.classpath 2014.01_mpo/

[eric@localhost workspace]$ cp ../2014.02.hvp/.project .
[eric@localhost trunk]$ cp ../2014.02.hvp/.classpath .
[eric@localhost trunk]$ vi .project 
<projectDescription>
        <name>2014.01_mpo</name>
...
$ vi .classpath
...
        <classpathentry kind="con" path="org.dbpowder.plugins.LIB_CONTAINER/recurse~project/2014.01_mpo/base-framework/core/lib/jar"/>
        <classpathentry kind="con" path="org.dbpowder.plugins.LIB_CONTAINER/recurse~project/2014.01_mpo/base-framework/buildscripts/build-lib"/>
        <classpathentry kind="con" path="org.dbpowder.plugins.LIB_CONTAINER/recurse~project/2014.01_mpo/module/interfacing/lib"/>

[eric@localhost Backup]$ pwd
/home/eric/Devel/Postgres/Backup
[eric@localhost Backup]$ pg_dump -U eric -Fc -h mposerv8 mpo -f mpo_2014_01.dump 

mpo=> \c mpo mpopostgres
You are now connected to database "mpo" as user "mpopostgres".
mpo=# create database mpo_2014_01\g
CREATE DATABASE

[eric@localhost Backup]$ pg_restore -U mpopostgres -d mpo_2014_01 mpo_2014_01.dump 
mpopostgres@mpo
/ OK	, werkt met -Fc	,

/ eclipse
/ Import...
General, Existing project
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/trunk

/ server config maken	,
/ copy die van mpo onder Server tab, rechts muis click: open	,
Server name: pnloms
Server configuration: pnloms	, dit slaat op /home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/pnloms	,

/ 7	.

/ voor vpn, lees	,
LOG_18_jul_2014.txt
LOG_2_jun_2014.txt	/ 

[eric@localhost Backup]$ cd ../../Intermax/forticlientsslvpn/
[eric@localhost forticlientsslvpn]$  sudo ./forticlientsslvpn_cli --server 80.95.170.62:443 --vpnuser vanderveldene
Password for VPN:h^Zgcyr&Q
...


[eric@localhost Wicket]$  ssh vanderveldene@192.168.171.1
vanderveldene@192.168.171.1's password: 
[vanderveldene@scs-application-p ~]$ pg_dump -U mpopostgres -W -v -f mpo.dump --no-acl --no-owner -h 127.0.0.1 mpo
/ Dit doen we op de intermax server,	
[vanderveldene@scs-application-p ~]$  ls
mpo.dump

[eric@localhost Wicket]$ scp vanderveldene@192.168.171.1:mpo.dump /tmp

/ text file, dus	,
[eric@localhost Java]$ psql -d mpo_2014_01 -U mpopostgres -f /tmp/mpo.dump 
/ see pg_restore hierboven	, 

[vanderveldene@scs-application-p ~]$ rm mpo.dump 
[vanderveldene@scs-application-p ~]$ exit 

[eric@localhost forticlientsslvpn]$ ^c

 
/ See	,
https://acceptance.scs.mp-objects.com/mpo/core/index_frameset





/ Einde MPO-33 MPO 2014.04 VERSION 123 

/ TRUNK 

/ svn

/ Ga naar team view	,
links: synchronize button	,
/ kijk of er conflicts zijn (rode pijltes)	, 
/ als deze er zijn, los op	,
/ pas daarna check out: button ernaast	(= HEAD)	,

/ ga naar java view	,
clean-prepare-and-dev-deploy	,



/ Einde TRUNK 



/ POSTGRESQL

/ role foo maakt database db en table x ,

/ 7     .

$ sudo -u postgres pg_dump -C -f /tmp/db.dump db
/ role foo drops database db    ,
$ sudo -u postgres psql -f /tmp/db.dump
/ OK

$ pg_dump -U foo -C -f /tmp/db.dump db
Password: ...
pg_dump: [archiver] could not open output file "/tmp/db.dump": Permission denied

/ 7     .

[eric@localhost Backup]$ sudo -u postgres pg_dump -c -f db.dump db
/ role foo creates database db2 ,
[eric@localhost Backup]$ sudo -u postgres psql -f db.dump -d db2
/ OK
[eric@localhost Backup]$ sudo -u postgres psql -f db.dump -d db2
/ OK
/ Zo vaak je wilt, doordat we -c deden  ,

[eric@localhost Backup]$ psql -U foo -f db.dump
Password for user foo:
/ ERR   ,

/ 7     .

[eric@localhost Backup]$ pg_dump -U eric -Fc -h mposerv13 mposcs -f mposcs.dump
/ eric is superuser in db op mposerv13  ,
[eric@localhost Backup]$ pg_restore -d mposcs mposcs.dump
mpopostgres@mpo

/ 7     .

foo=> \c foo mpopostgres
Password for user mpopostgres: mpopostgres@mpo
You are now connected to database "foo" as user "mpopostgres".
foo=# create database mposcs;
CREATE DATABASE

[eric@localhost Backup]$ pg_restore -U mpopostgres -d mposcs mposcs.dump


/ Einde POSTGRESQL

/ APPL

[eric@localhost mposcs]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/2014.02.hvp/mposcs
[eric@localhost mposcs]$ vi mposcs.properties 

hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
type.mapping=Firebird
/ TODO




/ Einde APPL

/ TICKETS

[eric@localhost workspace]$ svn co https://system.mp-objects.com/svn/tms/branches/2013.04.01
...
[eric@localhost 2013.04.01]$ svn revert --depth=infinity .
...
[eric@localhost 2013.04.01]$ svn commit -m "CEVA-14030 hide recharge, recharge summary, recharge overall reports"

/ EHCACHE MONITOR

[eric@localhost Ehcache_Monitor]$ tar xvzf ~/Downloads/ehcache-monitor-kit-1.0.3-distribution.tar.gz 
ehcache-monitor-kit-1.0.3/README.txt
ehcache-monitor-kit-1.0.3/LICENSE.txt
ehcache-monitor-kit-1.0.3/THIRD-PARTY-LICENSES.txt
ehcache-monitor-kit-1.0.3/bin/startup.bat
ehcache-monitor-kit-1.0.3/bin/startup.sh
ehcache-monitor-kit-1.0.3/bin/shutdown.sh
ehcache-monitor-kit-1.0.3/bin/shutdown.bat
ehcache-monitor-kit-1.0.3/etc/ehcache-monitor.conf
ehcache-monitor-kit-1.0.3/etc/jetty.xml
ehcache-monitor-kit-1.0.3/lib/ehcache-monitor-1.0.3.jar
ehcache-monitor-kit-1.0.3/lib/common-1.0.3.jar
ehcache-monitor-kit-1.0.3/lib/jetty-patched-1.0.3.jar
ehcache-monitor-kit-1.0.3/lib/terracotta-license-1.0.2.jar
ehcache-monitor-kit-1.0.3/lib/slf4j-api-1.6.1.jar
ehcache-monitor-kit-1.0.3/lib/jetty-patched-extra-1.0.3.jar
ehcache-monitor-kit-1.0.3/lib/slf4j-jdk14-1.6.1.jar
ehcache-monitor-kit-1.0.3/lib/ehcache-probe-1.0.3.jar

[eric@localhost ehcache-monitor-kit-1.0.3]$ mvn install:install-file -Dfile=lib/ehcache-probe-1.0.3.jar -Dpackaging=jar -DgroupId=org.terracotta -DartifactId=ehcache-probe -Dversion=1.0.3
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Stub Project (No POM) 1
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---
[INFO] Installing /home/eric/Devel/Java/Ehcache_Monitor/ehcache-monitor-kit-1.0.3/lib/ehcache-probe-1.0.3.jar to /home/eric/.m2/repository/org/terracotta/ehcache-probe/1.0.3/ehcache-probe-1.0.3.jar
[INFO] Installing /tmp/mvninstall7674510619837122782.pom to /home/eric/.m2/repository/org/terracotta/ehcache-probe/1.0.3/ehcache-probe-1.0.3.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.465s
[INFO] Finished at: Mon Sep 29 13:55:26 CEST 2014
[INFO] Final Memory: 6M/150M
[INFO] ------------------------------------------------------------------------

[eric@localhost repository]$ ls org/terracotta/ehcache-probe/1.0.3/
ehcache-probe-1.0.3.jar  ehcache-probe-1.0.3.pom  _remote.repositories     

[eric@localhost ehcache-monitor-kit-1.0.3]$ vi etc/jetty.xml 
...
<!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN" "http://eclipse.org/jetty/configure.dtd">

[eric@localhost ehcache-monitor-kit-1.0.3]$ bin/startup.sh
Sep 29, 2014 2:13:33 PM org.terracotta.ehcachedx.monitor.Monitor loadPropertiesFromConfigurationAndCommandLine
INFO: Loading properties from config file /home/eric/Devel/Java/Ehcache_Monitor/ehcache-monitor-kit-1.0.3/etc/ehcache-monitor.conf
Sep 29, 2014 2:13:33 PM org.terracotta.ehcachedx.monitor.Monitor$Configuration determineSamplingHistory
INFO: History will hold 8640 observations.
Sep 29, 2014 2:13:33 PM org.terracotta.ehcachedx.monitor.Monitor$Configuration determineSamplingSeconds
INFO: Sampling will be done every 10 seconds.
Sep 29, 2014 2:13:33 PM org.terracotta.ehcachedx.license.LicenseResolver resolveLicense
WARNING: No  license key found. This monitoring probe software is not licensed for production usage, and is only licensed for development usage. See LICENSE.txt for details. A temporary key will be generated for development usage. When the temporary key expires, the ing probe capability will be suspended but your ability to continue to use Ehcache will not be affected. Please contact sales@terracottatech.com to request a license.
Sep 29, 2014 2:13:33 PM org.terracotta.ehcachedx.license.LicenseResolver logLicense
INFO: 
---------------  license key ---------------
Capabilities: ehcache monitor
Date of Issue: 2014-09-29
Edition: DX
Expiration Date: 2014-10-02
License Number: 0000
License Type: DevOnly
Licensee: DevOnly
Product: Ehcache
-----------------------------------------------
Sep 29, 2014 2:13:34 PM org.terracotta.ehcachedx.monitor.monitor.MonitorDxService start
INFO: Applying jettyConfig from 'bin/../etc/jetty.xml'
Sep 29, 2014 2:13:34 PM org.terracotta.ehcachedx.monitor.monitor.MonitorDxService startHTTPListener
INFO: Started monitor at http://127.0.0.1:9889/monitor

http://localhost:9889/monitor

/ Sent e-mail to pm@terracotta.org

Hello,

I have installed your Ehcache Monitor. 

I have two questions.  The first concerns the tab Contents:

When I select an item in a cache, then always the message appears:

"The element couldn't be found in the cache anymore".

The second iquestion concerns the tab Statistics:

Always a window comes up which says that statistics is not configured. But I did it in ehcache.cml.

Thanks.


/ Einde EHCACHE MONITOR

/ TERRACOTTA

/ ehcache-hibernate forum: eric.vandervelden@mp-objects.com
Eric
Van der Velden
eric.vandervelden@mp-objects.com
ericj
vlWalnoot27



/ register for forum	,


/ Einde TERRACOTTA

/ EHCACHE POM

/ in hibernate_xml_1_N_join_ehcache	,

/ WAS	,

<dependency>
    <groupId>net.sf.ehcache</groupId>
    <artifactId>ehcache-core</artifactId>
    <version>2.6.9</version>
</dependency>

/ NU	,

<dependency>
    <groupId>net.sf.ehcache.internal</groupId>
    <artifactId>ehcache-core</artifactId>
    <version>2.9.0</version>
</dependency>

/ Einde EHCACHE POM

/ SKYPE

/ Einde SKYPE

/ SELF MONITOR

/ we kunnen	,
persister.getCacheAccessStrategy().getRegion()	,
/ getCache() is protected	, maar er is public get(<key>)	,

		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
		final CacheKey cacheKey = session.generateCacheKey( lce.getKey(), persister.getKeyType(), persister.getRole() );
org.hibernate.cache.ehcache.internal.regions.EhcacheCollectionRegion@780a03a2
lce.getKey()=34L	,
/ er is ook 
org.hibernate.cache.ehcache.internal.regions.EhcacheEntityRegion@780a03a2


				final boolean put = persister.getCacheAccessStrategy().putFromLoad(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						session.getTimestamp(),
						version,
						factory.getSettings().isMinimalPutsEnabled() && session.getCacheMode()!= CacheMode.REFRESH
				);


performExections, prepareActions	, [CollectionUpdateAction[my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees#34]] -> 
			final SoftLock lock = persister.getCacheAccessStrategy().lockItem( ck, null ); -> rm [1l,2l] uit coll cache	,

executeActions: [EntityInsertAction[my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee#4]]
[CollectionUpdateAction[my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees#34]]: schedules CollectionAction$CacheCleanupProcess
afterTransaction: EntityInsertAction: e4 -> 2c	, CollectionAction$CacheCleanupProcess-> unlockItem


[EntityDeleteAction[my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee#4]]
/s
EntityDeleteAction.execute() line: 107	
			lock = persister.getCacheAccessStrategy().lockItem( ck, version );
/ e4 2c item=["foostreet",4.0,34l] -> lockItem	,

			persister.delete( id, version, instance, session );

/ afterTx:[EntityDeleteAction[my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee#4]]: unlockItem	,

/ Einde SELF MONITOR

/ HIBERNATE & EHCACHE

/ .hibernate_xml_N_1_bidir_ehcache

/ 7	.

		  	address3=(Address)session.get(Address.class, 34l);
		  	address3.getEmployees().clear();
/s
PersistentSet.clear() line: 302	
	public void clear() {
		if ( isClearQueueEnabled() ) {
/s
		return !initialized
				&& isConnectedToSession()
				&& isInverseCollectionNoOrphanDelete();
/ JA
/t

			queueOperation( new Clear() );
/s
PersistentSet(AbstractPersistentCollection).queueOperation(AbstractPersistentCollection$DelayedOperation) line: 482	
		if ( operationQueue == null ) {
			operationQueue = new ArrayList<DelayedOperation>( 10 );
		}
		operationQueue.add( operation );
		//needed so that we remove this collection from the second-level cache
		dirty = true;

/t
	        tx.commit();
/s
/ flushEntities, FlushVisitor, .setDoupdate(true)
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 307	
			if ( ce.isDoupdate() ) {
				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionUpdateAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
								ce.isSnapshotEmpty(coll),
								session
							)
					);
			}
			if ( !coll.wasInitialized() && coll.hasQueuedOperations() ) {
				actionQueue.addAction(
						new QueuedOperationCollectionAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
								session
							)
					);
			}
/ t
/s 
ActionQueue.prepareActions() line: 359	
		prepareActions( collectionUpdates );
/ lockItem op coll employees#34
		prepareActions( collectionQueuedOps );
/ lockItem op coll employees#34

/t
ActionQueue.executeActions() line: 349	
[QueuedOperationCollectionAction[my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees#34]]
/s
QueuedOperationCollectionAction.execute() line: 60	
		getPersister().processQueuedOps( getCollection(), getKey(), getSession() );
/s
OneToManyPersister(AbstractCollectionPersister).processQueuedOps(PersistentCollection, Serializable, SessionImplementor) line: 1707	
		if ( collection.hasQueuedOperations() ) {
			int nextIndex = getSize( key, session );
2
/ want	,
Hibernate: select count(id_) from employee where address_ =?
HibernateLog --> 15:17:38 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]

			doProcessQueuedOps( collection, key, nextIndex, session );
/s
	protected void doProcessQueuedOps(PersistentCollection collection, Serializable id, SessionImplementor session)
			throws HibernateException {
		writeIndex( collection, collection.queuedAdditionIterator(), id, getSize( id, session ), session );
/s
		if ( isInverse && hasIndex && !indexContainsFormula ) {
/ NEE	,
this	OneToManyPersister  (id=3539)	
this.isInverse=true
this.hasIndex=false

/t

[CollectionUpdateAction[my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees#34].execute
/ TODO

/ 7	. 

/ als we eerst de coll init, ,dan doet PersistentSet.clear iets anders	,

		  	address3=(Address)session.get(Address.class, 34l);
		  	address3.getEmployees().size();					// inits coll	,
		  	address3.getEmployees().clear();
/s
PersistentSet.clear() line: 305	
	public void clear() {
		if ( isClearQueueEnabled() ) {
/ NEE
		else {
			initialize( true );
/ NIETS, want is al	,
			if ( !set.isEmpty() ) {
				set.clear();
				dirty();


/ 7	.

		  	address3=(Address)session.get(Address.class, 34l);
		  	address3.setEmployees(null);
	        tx.commit();    
/s
/ via flushEverythingToExecutions	, 
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 258	

		for ( Map.Entry<PersistentCollection,CollectionEntry> me : entries ) {
			CollectionEntry ce = me.getValue();
			if ( !ce.isReached() && !ce.isIgnore() ) {
/ TODO
				Collections.processUnreachableCollection( me.getKey(), session );
/s
		else {
			processDereferencedCollection( coll, session );
/s
		// do the work
		entry.setCurrentPersister( null );
		entry.setCurrentKey( null );
		prepareCollectionForUpdate( coll, entry, session.getFactory() );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 225	

/ hier komen we weer altijd ook	,

			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );
/ Nu is currentPersister==null	, en loadPersister!=null	,
/ In de 1ste session's commit is currentPersister!=null en loadedPersister==null	,
/ Normaal is in volgende sessions  currentPersister!=null en loadedPersister!=null beide	,

				// do the work
				if ( currentPersister != null ) {
/ NEE
					entry.setDorecreate( true );
				}
				if ( loadedPersister != null ) {
/ JA
					// we will need to remove ye olde entries
					entry.setDoremove( true );
					if ( entry.isDorecreate() ) {
/ NEE

/ dan in	,
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 272	
			if ( ce.isDoremove() ) {
				session.getInterceptor().onCollectionRemove( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionRemoveAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
								ce.isSnapshotEmpty(coll),
								session
							)
					);
			}


/ ce.isReached()==false	, 
/ WH is dit de default,	 want normaal komen we in	, via FlushVisitor.proccessEntityPropertyValues	,
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 184	
		ce.setReached( true );

/ we zien in de db GEEN verandering	, 
/ Ook met 
	address3.getEmployees().clear();
/ zien we geen verandering in de db	,
/ TODO

/ 7	. 

/ In hibernate_xml_N_1_bidir_ehcache	,

/ we komen in	,
	ActionQueue.executeActions() line: 349	
	DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
	DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/ schedules CollectionUpdateAction	,
/ D
				performExecutions( source );

	SessionImpl.flush() line: 1222	
	SessionImpl.managedFlush() line: 425	
	JdbcTransaction.beforeTransactionCommit() line: 101	
	JdbcTransaction(AbstractTransactionImpl).commit() line: 177	
	Main.testBasicUsage() line: 295	
	Main.<init>() line: 62	
	Main.main(String[]) line: 56	

/s
CollectionUpdateAction.execute() line: 100	
		else {
			persister.deleteRows( collection, id, session );
			persister.updateRows( collection, id, session );
			persister.insertRows( collection, id, session );
		}

		getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
		evict();
		postUpdate();

/ Deze zijn WH alleen interessant bij 1_N	, 

/ 7	.

/ 1-N bidir

/ hibernate_xml_1_N_bdir_ehcache

/ performExecutions, session.getActionQueue().executeActions()	, 

/ EntityInsertAction.execute 

/ van een Employee	,
/s
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2840	
	protected int dehydrate(
			final Serializable id,
			final Object[] fields,
			final Object rowId,
			final boolean[] includeProperty,
[true, true, false, true]
			final boolean[][] includeColumns,
[[true], [true], [true], [true]]
			final int j,
			final PreparedStatement ps,
			final SessionImplementor session,
			int index,
			boolean isUpdate ) throws SQLException, HibernateException {

	for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
/ NEE voor i=2
					&& !lobProperties.contains( i )) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
				index += ArrayHelper.countTrue( includeColumns[i] ); //TODO:  this is kinda slow...

/ SAMENVATTING

/ bij .save(employee) gaat H terug naar de address.employees en kijkt of employee er in zit: zo ja, dan Backref.getter geeft owner coll=address.employees	, 

/ Address	,

/ address's entry.state=(...,...,...,pset)

/ includeProperty
/ TODO
/ includeColumns
/ TODO

/ p.insert calls type.dehydate,	SetType.dehydrate={}
/ p.insert(state)=(...,...,...)
/ p.buildCacheEntry calls type.disassemble,	 SetType.disassemble=getKeyOfOwner
/ p.disassemble(state)=(...,...,...,34l)

/ Employee,

/ address's entry.state=(...,...,null,34l)

/ includeProperty
/ [true,true,false,true] 
/ includeColumns
/ [[true],[true],[true],[true]] 

/ p.insert calls type.dehydate,	ManyToOne.dehydrate wordt overgeslagen	, LongType.dehydrate gewoon	, hij set dus de keyOfOwner op address_	,
/ p.insert(state)=(...,...,34l)
/ p.buildCacheEntry calls type.disassemble,	 ManyToOne.disassemble(null)=null	,  
/ p.disassemble(state)=(...,...,null,34l)

/ Einde SAMENVATTING

/ Later	, via performExecutions, session.getActionQueue().executeActions()	,
/s
CollectionRecreateAction.execute() line: 67	

		getPersister().recreate( collection, getKey(), getSession() );
/s
		if ( !isInverse && isRowInsertEnabled() ) {
/ JA	,
				// create all the new entries
				Iterator entries = collection.entries( this );
/ JA (bij address#34)	,
					while ( entries.hasNext() ) {

							String sql = getSQLInsertRowString();
/ we zien 	,
Hibernate: update employee set address_=? where id_=?
								// TODO: copy/paste from insertRows()
								int loc = writeKey( st, id, offset, session );
HibernateLog --> 12:33:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
								loc = writeElement( st, collection.getElement( entry ), loc, session );
HibernateLog --> 12:34:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ en volgende 	,
								int loc = writeKey( st, id, offset, session );
HibernateLog --> 12:33:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
								loc = writeElement( st, collection.getElement( entry ), loc, session );
HibernateLog --> 12:34:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]






/t
		getPersister().recreate( collection, getKey(), getSession() );
/ D
		getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
/ sets loadedKey, loadedPersister	,

/ 7	.

/ Intermezzo

/ we zien !isInverse	,

$ vi org/hibernate/persister/collection/AbstractCollectionPersister.java

	public void remove(Serializable id, SessionImplementor session) throws HibernateException {
		if ( !isInverse && isRowDeleteEnabled() ) {
...

	public void recreate(PersistentCollection collection, Serializable id, SessionImplementor session)
			throws HibernateException {

		if ( !isInverse && isRowInsertEnabled() ) {
...

	public void deleteRows(PersistentCollection collection, Serializable id, SessionImplementor session)
			throws HibernateException {

		if ( !isInverse && isRowDeleteEnabled() ) {
...

	public void insertRows(PersistentCollection collection, Serializable id, SessionImplementor session)
			throws HibernateException {

		if ( !isInverse && isRowInsertEnabled() ) {
...

	public void updateRows(PersistentCollection collection, Serializable id, SessionImplementor session)
			throws HibernateException {

		if ( !isInverse && collection.isRowUpdatePossible() ) {
...

$ vi Collection.java

	public void createAllKeys() throws MappingException {
		createForeignKeys();
		if ( !isInverse() ) createPrimaryKey();



/ Einde Intermezzo


/ 7	. 

/ ehcache version comparator	,

Thread [main] (Suspended)	
	ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).<init>(T, Settings) line: 56	
		super( region, settings );
		this.versionComparator = region.getCacheDataDescription().getVersionComparator();

	ReadWriteEhcacheEntityRegionAccessStrategy.<init>(EhcacheEntityRegion, Settings) line: 50	
		super( region, settings );

	EhcacheAccessStrategyFactoryImpl.createEntityRegionAccessStrategy(EhcacheEntityRegion, AccessType) line: 61	
			case READ_WRITE:
				return new ReadWriteEhcacheEntityRegionAccessStrategy( entityRegion, entityRegion.getSettings() );

	NonstopAccessStrategyFactory.createEntityRegionAccessStrategy(EhcacheEntityRegion, AccessType) line: 59	
		return new NonstopAwareEntityRegionAccessStrategy(
				actualFactory.createEntityRegionAccessStrategy( entityRegion, accessType ),
				HibernateNonstopCacheExceptionHandler.getInstance()
		);

	EhcacheEntityRegion.buildAccessStrategy(AccessType) line: 69	
		return getAccessStrategyFactory().createEntityRegionAccessStrategy( this, accessType );

	SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 365	
					EntityRegion entityRegion = regionFactory.buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
					accessStrategy = entityRegion.buildAccessStrategy( accessType );

	Configuration.buildSessionFactory(ServiceRegistry) line: 1857	
	Main.setUp() line: 75	
	Main.<init>() line: 63	
	Main.main(String[]) line: 58	


  
 

/ Einde HIBERNATE & EHCACHE

/ HIBERNATE 

https://lists.jboss.org/mailman/listinfo/hibernate-dev

/ geabonneerd	,

/ Einde HIBERNATE 

/ SPRING

/ we add in jboss tools  een achetype catalog	,

windows, preferences, maven, archetypes
http://repo1.maven.org/maven2/archetype-catalog.xml
name: repo1
/ Nu zien we dezelfde als op de command line	, 

/ Einde SPRING

/ HIBERNATE & EHCACHE NONSTRICT-READ-WRITE

/ 7	.

////////////////////////////////////////////////
/ we hebben nonstrict-read-write 	,

/ 13	. 

/////////////////////////////////////////////////////////////
/ In de 1ste session wordt 2c NIET write	,

DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
			session.getActionQueue().prepareActions();
/ .lockItem is nu return null	,
			session.getActionQueue().executeActions();
/s
CollectionRecreateAction.execute() line: 67	

////////////////////
/ sets fk (impl van een coll)
/ een EntityInsertAction doet persist.insert	, deze doet deze persist, via batch (TODO)	,
/s
OneToManyPersister(AbstractCollectionPersister).recreate(PersistentCollection, Serializable, SessionImplementor) line: 1255	
		if ( !isInverse && isRowInsertEnabled() ) {
/s
		return keyIsUpdateable;
/true
/ Dit geeft 'die' queries	,
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:30:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 13:30:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:31:21 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 13:31:27 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ Dit is dus geen 2c	, maar EntityInsertAction doet ook persist.insert , en daarna pas 2c	,

/t
CollectionRecreateAction.execute() line: 69	
		evict();
/ Dit is 2c	,
/s
		if ( persister.hasCache() ) {
			final CacheKey ck = session.generateCacheKey(
					key, 
					persister.getKeyType(), 
					persister.getRole()
			);
			persister.getCacheAccessStrategy().remove( ck );
/ Deze execs nu	,
/ TODO

/t
JdbcTransaction(AbstractTransactionImpl).commit() line: 182	
			doCommit();
/d
			afterTransactionCompletion( Status.STATUS_COMMITTED );
/s
		getTransactionContext().afterTransactionCompletion( hibernateTransaction, success );
/s
		actionQueue.afterTransactionCompletion( successful );
/s
			while ( !processes.isEmpty() ) {
				try {
					processes.poll().doAfterTransactionCompletion( success, session );
/s
EntityInsertAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 228	
			final CacheKey ck = getSession().generateCacheKey( getId(), persister.getIdentifierType(), persister.getRootEntityName() );
12/34	, Address	,
1/2	, Employee	,
			final boolean put = cacheAfterInsert( persister, ck );
/s
			return persister.getCacheAccessStrategy().afterInsert( ck, cacheEntry, version );
/s
			return actualStrategy.afterInsert( key, value, version );
/s
NonStrictReadWriteEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 112	
		return false;

/ Intermezzo

/ Maar	, 
ReadWriteEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 112	
                        final Lockable item = (Lockable) region().get( key );
                        if ( item == null ) {
                                region().put( key, new Item( value, version, region().nextTimestamp() ) );
                                return true;
                        }
                        else {
                                return false;


/ Einde Intermezzo

/ dan	,
EntityUpdateAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 328	

/ we zien dat in 1ste session NIET naar 2c	, 

/ 13	.

/ hibernate_xml_1_N_bidir_ehcache	,
/ nonstrict-read-write

/ 2de session	,

/ Een .get van Address#34 -> write naar 2c	, (doet new Address, new PersistenSet)	,

/ 2de session	,
Main.testBasicUsage() line: 183	
	        address=(Address)session.get(Address.class, 34l);

/ hydrates db row to H props , met self creates MarkerObject=coll id (TODO)	, en creates PersistentSet, met deze id	, en -> entity-2c
/ TODO

/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 468	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
null
			entity = loadFromDatasource( event, persister, keyToLoad, options );
/s
EntityLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 138	
				wrapper = executeQueryStatement( sql, queryParameters, false, afterLoadActions, session );
				results = loadQueryDetails.getResultSetProcessor().extractResults(
						wrapper.getResultSet(),
						session,
						queryParameters,
						new NamedParameterContext() {
							@Override
							public int[] getNamedParameterLocations(String name) {
								return AbstractLoadPlanBasedLoader.this.getNamedParameterLocs( name );
							}
						},
						returnProxies,
						queryParameters.isReadOnly(),
						forcedResultTransformer,
						afterLoadActions
				);
/s
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 129	

/ dit is ook de mth waar we ook altijd in komen bij .iterator()	,
/ TODO

		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
		}
		rowReader.finishUp( context, afterLoadActionList );

/ Eerst 
			Object logicalRow = rowReader.readRow( resultSet, context );
/s
EntityLoadQueryDetails$EntityLoaderRowReader.readRow(ResultSet, ResultSetProcessingContextImpl) line: 232	
...
			return super.readRow( resultSet, context );
/s
EntityLoadQueryDetails$EntityLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 84	

/ Met .iterator komen we direct in deze mth	,
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 125

/ we zagen	,
HibernateLog --> 14:25:19 DEBUG org.hibernate.SQL - select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 14:25:19 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]

			// 2) allow entity references to resolve their non-identifier hydrated state and entity instance
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateEntityState( resultSet, context );

HibernateLog --> 14:45:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 14:45:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [34 foo]
HibernateLog --> 14:45:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city_4_0_0_] : [VARCHAR]) - [FooCity34A]

/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
		rowReader.finishUp( context, afterLoadActionList );
/s
		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 166	
		final Serializable id = entityEntry.getId();
34
		final Object[] hydratedState = entityEntry.getLoadedState();
hydratedState	Object[4]  (id=3525)	
	[0]	"foostreet" (id=3526)	
	[1]	"34 foo" (id=3527)	
	[2]	"FooCity34A" (id=3528)	
	[3]	MarkerObject  (id=3529)	
/ TODO
types	Type[4]  (id=3595)	
	[0]	StringType  (id=3602)	
	[1]	StringType  (id=3602)	
	[2]	StringType  (id=3602)	
	[3]	SetType  (id=3607)	

		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
				hydratedState[i] = types[i].resolve( value, session, entity );
/s
SetType(CollectionType).resolve(Object, SessionImplementor, Object) line: 460	
		return resolveKey( getKeyOfOwner( owner, session ), session, owner );
/s
			getCollection( key, session, owner );
/s
				collection = instantiate( session, persister, key );
				collection.setOwner(owner);
				persistenceContext.addUninitializedCollection( persister, collection, key );

/t
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 191	
		final Type[] types = persister.getPropertyTypes();
		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
				hydratedState[i] = types[i].resolve( value, session, entity );
			}
		}
/d
		persister.setPropertyValues( entity, hydratedState );
/d
		if ( persister.hasCache() && session.getCacheMode().isPutEnabled() ) {
			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
entry	StandardCacheEntryImpl  (id=3649)	
	disassembledState	Serializable[4]  (id=3651)	
		[0]	"foostreet" (id=3526)	
		[1]	"34 foo" (id=3527)	
		[2]	"FooCity34A" (id=3528)	
		[3]	Long  (id=3472)	

			final CacheKey cacheKey = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
							cacheKey,
							persister.getCacheEntryStructure().structure( entry ),
							session.getTimestamp(),
							version,
							useMinimalPuts( session, entityEntry )
					);
/s
NonStrictReadWriteEhcacheEntityRegionAccessStrategy.putFromLoad(Object, Object, long, Object, boolean) line: 66	

		if ( minimalPutOverride && region().contains( key ) ) {
/ NEE
		else {
			region().put( key, value );

/ Intermezzo

/ ReadWriteEhcacheEntityRegionAccessStrategy heeft zelf geen .putFromLoad	, maar inherit van	,
./org/hibernate/cache/ehcache/internal/strategy/AbstractReadWriteEhcacheAccessStrategy.java

        public final boolean putFromLoad( Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride) throws CacheException {
                region().writeLock( key );
                try {
                        final Lockable item = (Lockable) region().get( key );
                        final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
                        if ( writeable ) {
                                region().put( key, new Item( value, version, region().nextTimestamp() ) );
                                return true;
                        }
                        else {
                                return false; 

/ Einde Intermezzo

/ Dat is die method met die lock, 

/ Nu wordt Address#34 in 2c set	,

/t
EntityLoadQueryDetails$EntityLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 218	
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/d
		// now we can finalize loading collections
		finishLoadingCollections( context );
/ Nu NIETS	,
/ We hebben niet de coll query gedaan	, maar de entity query	,

/ 13	.

/t
Main.testBasicUsage() line: 186	
	        address=(Address)session.get(Address.class, 34l);
/d

/ db row ->(hydrate) H props (met MarkerObject(34l))	, address=new Address, sets H prop er in	,  address-> 2c (WH met Long 34 als laatste (TODO))	,

	        Set<Employee>employees=address.getEmployees();
	        Iterator<Employee>iterator=employees.iterator();
/s
PersistentSet(AbstractPersistentCollection).initialize(boolean) line: 554	
/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 83	
			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
false
.getLoadedPersister().initialize( ce.getLoadedKey(), source );
s
CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 138	
				wrapper = executeQueryStatement( sql, queryParameters, false, afterLoadActions, session );

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 10:24:24 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]

				results = loadQueryDetails.getResultSetProcessor().extractResults(
						wrapper.getResultSet(),
						session,
						queryParameters,
						new NamedParameterContext() {
							@Override
							public int[] getNamedParameterLocations(String name) {
								return AbstractLoadPlanBasedLoader.this.getNamedParameterLocs( name );
							}
						},
						returnProxies,
						queryParameters.isReadOnly(),
						forcedResultTransformer,
						afterLoadActions
				);

/ zojuist, bij Entities	, dezelfde mth	,
EntityLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 138	

/s
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
/ Leest H props	in	,
		rowReader.finishUp( context, afterLoadActionList );
/s
		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );

/ handles entities uit de coll query	,
/ resolves H props	,sets H props in e=new Employee van boven (TODO)	en entity->2c	,
/ straks finishLoadingCollections	, die coll -> 2c

/s
		for ( HydratedEntityRegistration registration : hydratedEntityRegistrations ) {
			TwoPhaseLoad.initializeEntity(
					registration.getInstance(),
					context.isReadOnly(),
					context.getSession(),
					preLoadEvent
			);
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 167	
		final Type[] types = persister.getPropertyTypes();
		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
/ Laat <unknown> onveranderd	,
				hydratedState[i] = types[i].resolve( value, session, entity );

		persister.setPropertyValues( entity, hydratedState );



			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
entry	StandardCacheEntryImpl  (id=3903)	
	disassembledState	Serializable[4]  (id=3904)	
		[0]	"Foo1A" (id=3882)	
		[1]	Double  (id=3883)	
		[2]	Long  (id=3472)	
		[3]	BackrefPropertyAccessor$1  (id=3884)	

/ <unknown> gaat ook de 2c in	,

			final CacheKey cacheKey = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );

					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
							cacheKey,
							persister.getCacheEntryStructure().structure( entry ),
							session.getTimestamp(),
							version,
							useMinimalPuts( session, entityEntry )
					);
/s
NonStrictReadWriteEhcacheEntityRegionAccessStrategy.putFromLoad(Object, Object, long, Object, boolean) line: 66	
		if ( minimalPutOverride && region().contains( key ) ) {
			return false;
		}
		else {
			region().put( key, value );

/ NU WEL	, NIET bij readwrite	,
////////////////////////////////////////////////////////////////////
/ We zijn in de 2de session	, 

/t
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/d
/ Dit waren de entities	,

/ Nu de colls	,
		finishLoadingCollections( context );

/ Nu WEL, want we doen de coll query, NIET de entity query	,
/s
CollectionLoadContext.endLoadingCollection(LoadingCollectionEntry, CollectionPersister) line: 251	
		final boolean hasNoQueuedAdds = lce.getCollection().endRead();
/ coll tempList->set
			addCollectionToCache( lce, persister );
/s
		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
entry	CollectionCacheEntry  (id=3985)	
	state	Serializable[2]  (id=3988)	
		[0]	Long  (id=3880)	
		[1]	Long  (id=3989)	
				final boolean put = persister.getCacheAccessStrategy().putFromLoad(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						session.getTimestamp(),
						version,
						factory.getSettings().isMinimalPutsEnabled() && session.getCacheMode()!= CacheMode.REFRESH
				);

////////////////////////////////////////
/ .putFromLoad	: 2c <- 1c/2c/db
/ .putFromInsert: onze obj -> 2c	, bij ons in 1ste session	,

/ 13	.

/ 3de session	, 

	        address=(Address)session.get(Address.class, 34l);

/ haalt address <-2c	, er wordt new PersistenSet , met ownerId	, maar niet filled	, ondanks dat coll in 2c	, en de bijbehorende entities (Employee's)	, want hij doet de coll query	,
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
/s
NonStrictReadWriteEhcacheEntityRegionAccessStrategy.get(Object, long) line: 60	
		return region().get( key );

/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 618	
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
entry	StandardCacheEntryImpl  (id=3649)	
	disassembledState	Serializable[4]  (id=3651)	
		[0]	"foostreet" (id=3526)	
		[1]	"34 foo" (id=3527)	
		[2]	"FooCity34A" (id=3528)	
		[3]	Long  (id=3472)	
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 707	
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )

			final Type[] types = subclassPersister.getPropertyTypes();
			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ sets H props ook in entity	,
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 109	
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ NEE
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/s
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 296	
			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
			return resolveKey( key, session, owner );
/ creates lege PersistenSet, met ownerId er in	,
/s

/ WH calls .get in 2de session, die db query deed, ook getCollection	, 
/ TODO
			getCollection( key, session, owner );
/s
			if ( collection == null ) {
				// create a new collection wrapper, to be initialized later
				collection = instantiate( session, persister, key );
				collection.setOwner(owner);
				persistenceContext.addUninitializedCollection( persister, collection, key );
/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/d
		persister.setPropertyValues( instance, assembledProps );
/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 719	
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
/t
	        address=(Address)session.get(Address.class, 34l);
	        employees=address.getEmployees();
	        iterator=employees.iterator();
/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 63	
		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry( collection );
/ .get(Address.class,34l) sets 'm	,
		if ( !collection.wasInitialized() ) {
/ JA
			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
/s
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 139	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );

/////////////////////
/ In de persister, 'n OneToManyPersister	, zit de actualStrategy, met region	,
persister	OneToManyPersister  (id=3799)	
	cacheAccessStrategy	NonstopAwareCollectionRegionAccessStrategy  (id=4066)	
		actualStrategy	NonStrictReadWriteEhcacheCollectionRegionAccessStrategy  (id=4074)	
			region	EhcacheCollectionRegion  (id=4075)	
				cache	Cache  (id=4081)	
					configuration	CacheConfiguration  (id=5066)	
						name	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employees" (id=5121)	

key	CacheKey  (id=5036)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employees" (id=4973)	
	hashCode	1054	
	key	Long  (id=3472)		34
	tenantId	null	
	type	LongType  (id=3849)	

/t
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 139	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	CollectionCacheEntry  (id=3985)	
	state	Serializable[2]  (id=3988)	
		[0]	Long  (id=3880)	
		[1]	Long  (id=3989)	

		cacheEntry.assemble( collection, persister, persistenceContext.getCollectionOwner( id, persister ) );
/s
		collection.initializeFromCache( persister, state, owner );
/s
		for ( Serializable arrayElement : array ) {
			final Object assembledArrayElement = persister.getElementType().assemble( arrayElement, getSession(), owner );
/ persister.getElementType()=ManyToOneType	,
/s
			return resolveIdentifier( id, session );
/ id=1l
/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 716	
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
/s
		final CacheKey ck = source.generateCacheKey(
				event.getEntityId(),
				persister.getIdentifierType(),
				persister.getRootEntityName()
		);
ck	CacheKey  (id=5226)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Employee" (id=3858)	
	hashCode	31	
	key	Long  (id=3880)		1
	tenantId	null	
	type	LongType  (id=3849)	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=3903)	
	disassembledState	Serializable[4]  (id=3904)	
		[0]	"Foo1A" (id=3882)	
		[1]	Double  (id=3883)	
		[2]	Long  (id=3472)	
		[3]	BackrefPropertyAccessor$1  (id=3884)	

		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
/s
			final Type[] types = subclassPersister.getPropertyTypes();
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
types	Type[4]  (id=3887)	
	[0]	StringType  (id=3602)	
	[1]	DoubleType  (id=5295)	
	[2]	ManyToOneType  (id=5296)	
	[3]	LongType  (id=3849)	
/s
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/s
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ JA	, 3de	, neemt over,	
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
			}
		}
/t
		persister.setPropertyValues( instance, assembledProps );
/ slaat <unknown> over	,
		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);

/t
PersistentSet.initializeFromCache(CollectionPersister, Serializable, Object) line: 147	
		for ( Serializable arrayElement : array ) {
			final Object assembledArrayElement = persister.getElementType().assemble( arrayElement, getSession(), owner );
/d
				set.add( assembledArrayElement );










 




























/ Einde HIBERNATE & EHCACHE NONSTRICT-READ-WRITE


/ LOG4J


/ we hebben proj mylog4j create	,

/ 7	. 

/ log4j-1.2

/ Lees	,
http://logging.apache.org/log4j/1.2/manual.html

TRACE< DEBUG< INFO< WARN< ERROR <FATAL	, dus WARN is sterker dan INFO	,

/ als level=INFO, dan zal log.warn print, omdat INFO<WARN	,   

/ we lezen	,

  // get a logger instance named "com.foo"
   Logger  logger = Logger.getLogger("com.foo");

   // Now set its level. Normally you do not need to set the
   // level of a logger programmatically. This is usually done
   // in configuration files.
   logger.setLevel(Level.INFO);

   Logger barlogger = Logger.getLogger("com.foo.Bar");

   // This request is enabled, because WARN >= INFO.
   logger.warn("Low fuel level.");

   // This request is disabled, because DEBUG < INFO.
   logger.debug("Starting search for nearest gas station.");

//////////////////////////////////////////////////////////////////////
   // The logger instance barlogger, named "com.foo.Bar",
   // will inherit its level from the logger named
   // "com.foo" Thus, the following request is enabled
   // because INFO >= INFO.
   barlogger.info("Located nearest gas station.");

////////////////////////////////////
/ Dus daarom .getLogger("...")	, 

/ 7	.

/ we maken	,

$ vi com/foo/MyApp.java

package com.foo;

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Logger;

import com.bar.Bar;

public class MyApp {
	// Define a static logger variable so that it references the
	   // Logger instance named "MyApp".
	   static Logger logger = Logger.getLogger("com.foo");
	   public static void main(String[] args) {

	     // Set up a simple configuration that logs on the console.
	     BasicConfigurator.configure();

	     logger.info("Entering application.");
	     Bar bar = new Bar();
	     bar.doIt();
	     logger.info("Exiting application.");
	   }
}

$ vi com/bar/Bar.java

package com.bar;

import org.apache.log4j.Logger;

public class Bar {
	Logger logger=Logger.getLogger("com.bar");
	public void doIt() {
		logger.debug("Bar.doIt()");

	}

}

$ vi pom.xml

    	<dependency>
	    <groupId>log4j</groupId>
	    <artifactId>log4j</artifactId>
	    <version>1.2.17</version>
	</dependency>
 

$ mvn clean compile

/ run as appl	,

0 [main] INFO you.and.me  - Entering application.
1 [main] DEBUG com.bar  - Bar.doIt()
1 [main] INFO you.and.me  - Exiting application.


/ 7	. 

/ Nu met config file	,

/ noem config file log4j.properties	,

/ of noem hem zoals je wilt, my.txt	, maar dan moet je wel in MyApp2.java	,
   	InputStream inputStream=MyApp2.class.getResourceAsStream("/my.txt");
     	PropertyConfigurator.configure(inputStream);


/ In src/main/resources	,
$ vi my.txt

# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

/ In src/main/java	,
$ vi com/foo/MyApp2.java
...
   	static Logger logger = Logger.getLogger("com.foo");

	  Logger tmp= Logger.getRootLogger();
	  logger.info(tmp);

	  logger.info(tmp==logger);

	     logger.info("Entering application.");
	     Bar bar = new Bar();
	     bar.doIt();
	     logger.info("Exiting application.");

$ vi com/bar/Bar.java

	Logger logger=Logger.getLogger("com.bar");
	public void doIt() {
	logger.debug("Bar.doIt()");

$ vi log4j.properties

# Set root logger level to DEBUG and its only appender to MY.
log4j.rootLogger=WARN, MY


# MY is set to be a ConsoleAppender.
log4j.appender.MY=org.apache.log4j.ConsoleAppender

# MY uses PatternLayout.
log4j.appender.MY.layout=org.apache.log4j.PatternLayout
log4j.appender.MY.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

log4j.logger.com.foo=DEBUG
log4j.logger.com.bar=DEBUG

/ we geven de root logger WARN	,
/ alle loggers, ook die in MyApp2, Bar staan, hebben deze dan ook, maar daarom doen we	,
log4j.logger.com.foo=DEBUG

/ we kunnen ook 	,
	     tmp.info("Entering application.");

/ maar we zullen dan niets zien	, omdat root logger WARN is	,

/ run appl	,

0    [main] INFO  com.foo  - org.apache.log4j.spi.RootLogger@65b6903f
1    [main] INFO  com.foo  - false
1    [main] INFO  com.foo  - Entering application.
2    [main] DEBUG com.bar  - Bar.doIt()
2    [main] INFO  com.foo  - Exiting application.


/ 7	.

/ Lees	,
///////////////////////////////////////////////////////////////
http://happygiraffe.net/blog/2008/09/03/logging-in-java/

/ die was ref in	,
http://stackoverflow.com/questions/23869207/what-is-the-significance-of-log4j-rootlogger-property-in-log4j-properties-file

/ 7	.

/ Lees	over de conversionpattern	,
https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html

/ 13
log4j.appender.MY.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n
/ ->
1    [main] INFO  com.foo  - Entering application.

/ TODO (%x) 

/ 13	. 
log4j.appender.MY.layout.ConversionPattern=%d [%t] %-5p (%F:%L) - %m%n
/->
2015-01-07 17:02:44,717 [main] INFO  (MyApp2.java:29) - Entering application.




/ Einde LOG4J

/ HIBERNATE & EHCACHE

/ 

/ Einde HIBERNATE & EHCACHE

/ SLF4J 

/ Lees	,
http://www.slf4j.org/manual.html

/ we hebben proj myslf4j create	, 

/ 7	.

/ Lees	,
http://www.slf4j.org/manual.html

$ vi MyApp3.java

package com.foo;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyApp3 {
	public static void main(String[] args) {
		Logger logger=LoggerFactory.getLogger("com.foo");
		logger.info("com.foo");
	}
}

$ vi pom.xml

 	<dependency>
	      <groupId>org.slf4j</groupId>
	      <artifactId>slf4j-api</artifactId>
	      <version>1.7.10</version>
	</dependency>

/ we zien	,
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.

/ Dan 	,
$ vi pom.xml

	<dependency>
	      <groupId>org.slf4j</groupId>
	      <artifactId>slf4j-api</artifactId>
	      <version>1.7.10</version>
	</dependency>
	<dependency>
	    <groupId>org.slf4j</groupId>
	    <artifactId>slf4j-simple</artifactId>
	    <version>1.7.10</version>
	</dependency>

/ we zien	,
[main] INFO com.foo - com.foo

/ 7	.

/ nu niet slf4j-simple, maar slf4j-log4j12	,

$ vi pom.xml

	<dependency>
	    <groupId>org.slf4j</groupId>
	    <artifactId>slf4j-log4j12</artifactId>
	    <version>1.7.10</version>
	</dependency>

/ we hoeven geen dep op log4j12 of slf4j-api	, want die deps staan al in de pom van slf4j-log4j12	,

[eric@localhost repository]$ pwd
/home/eric/.m2/repository
[eric@localhost repository]$ vi org/slf4j/slf4j-log4j12/1.7.10/slf4j-log4j12-1.7.10.pom

  <parent>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-parent</artifactId>
    <version>1.7.10</version>
  </parent>

  <dependencies>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
    </dependency>

    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
    </dependency>
  </dependencies>

[eric@localhost repository]$ vi org/slf4j/slf4j-parent/1.7.10/slf4j-parent-1.7.10.pom

  <version>1.7.10</version>

  <dependencyManagement>
    <dependencies>

      <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>${project.version}</version>
      </dependency>

     <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>${log4j.version}</version>
      </dependency>

/ we zien	,

0    [main] INFO  com.foo  - com.foo

/ 7	.

/ Omdat slf4j-log4j12 een dep heeft op log4j, gaan de MyApp2 en Bar uit mylog4j project OK	, 
/ We kunnen dus org.apache.log4j.Logger laten staan	, 
/ Maar we gaan het toch op de slf4j manier doen	,
/ we houden log4j.properties	,

$ vi MyApp2.java

package com.foo;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.bar.Bar;

public class MyApp2 {
	
	   static Logger logger = LoggerFactory.getLogger("com.foo");
	   public static void main(String[] args) {
	     
	  	Logger tmp= LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
	  	tmp.warn("root logger");

		  logger.info("Entering application.");
	     Bar bar = new Bar();
	     bar.doIt();
	     logger.info("Exiting application.");
	   }
}

$ vi Bar.java

package com.bar;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Bar {
	Logger logger=LoggerFactory.getLogger("com.bar");
	public void doIt() {
		logger.debug("Bar.doIt()");
	}
}

/ 7	. 

/ we use nu commons-logging	,

$ vi pom.xml

 	<dependency>
	    <groupId>commons-logging</groupId>
	    <artifactId>commons-logging</artifactId>
	    <version>1.2</version>
	</dependency>

/ we zien	,
[eric@localhost repository]$ pwd
/home/eric/.m2/repository
[eric@localhost repository]$ vi commons-logging/commons-logging/1.2/commons-logging-1.2.pom
  <dependencies>
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.17</version>
      <optional>true</optional>
    </dependency>

/ Dus log4j dep hoeven we niet op te nemen in onze pom.xml	,

/ Met commons-logging we use Log, LogFactory, ipv Logger, LoggerFactory uit slf4j	,

$ vi MyApp3a.java

package com.foo;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class MyApp3a {
	public static void main(String[] args) {
		Log log=LogFactory.getLog("com.foo");
		log.info("com.foo");
	}
	
}

/ we zien	,
0    [main] INFO  com.foo  - com.foo

/ we maken ook MyApp2a.java en Bar2.java	,

$ vi MyApp2a.java

package com.foo;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.bar.Bar2;

public class MyApp2a {
	
	   static Log log = LogFactory.getLog("com.foo");
	   public static void main(String[] args) {
		  
//		  Log tmp=LogFactory.getLog(Log
//		  tmp.warn("root logger");

		log.info("Entering application.");
	     Bar2 bar2 = new Bar2();
	     bar2.doIt();
	     log.info("Exiting application.");
	   }
}

/ Hoe root logger met commons-logging	?
/ TODO

$ vi Bar2a.java

package com.bar;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class Bar2 {
	Log log=LogFactory.getLog("com.bar");
	public void doIt() {
		log.debug("Bar.doIt()");

	}
}

/ we zien	,
0    [main] INFO  com.foo  - Entering application.
1    [main] DEBUG com.bar  - Bar.doIt()
1    [main] INFO  com.foo  - Exiting application.








/ Einde SLF4J

/ MONTOR HIBERNATE

/ 7	. 

/ Lees	,
http://hibernate-jcons.sourceforge.net/

/ Lees	,
http://stackoverflow.com/questions/1839299/tool-for-monitoring-hibernate-cache-usage
->
 Publishing statistics through JMX
https://developer.jboss.org/wiki/PublishingStatisticsThroughJMX

/ Lees	,
http://www.kjkoster.org/zapcat/Hibernate_How_To.html


/ Einde MONTOR HIBERNATE

/ MONITOR EHCACHE 

/ 7	. 

/ we kunnen de 2c clear	,

/ in proj hibernate_xml_1_N_bidir_ehcache	,

		  	CacheManager.getInstance().clearAll();

/ 7	.

/ geef in eclipse 
monitor ehcache
N

https://cwiki.apache.org/confluence/display/SHINDIG/Monitoring+EhCache+with+JMX
->
http://ehcache.org/generated/2.9.0/html/ehc-all/#page/Ehcache_Documentation_Set/_ehcache_all.1.153.html
->
Monitoring and Management Using JMX
http://ehcache.org/generated/2.9.0/html/ehc-all/#page/Ehcache_Documentation_Set%2Fto-jmx_management_and_monitoring.html%23wwconnect_header

/ we zien	,
[eric@localhost repository]$ jar tvf net/sf/ehcache/ehcache-core/2.6.9/ehcache-core-2.6.9.jar  | grep MBean
   559 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/CacheMBean.class
   894 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/CacheStatisticsMBean.class
  1037 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/provider/MBeanRegistrationProviderImpl$1.class
   493 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/management/provider/MBeanRegistrationProvider.class
   326 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/management/provider/MBeanRegistrationProviderFactory.class
  1074 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/provider/NullMBeanRegistrationProvider.class
  3327 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/provider/MBeanRegistrationProviderImpl.class
  1020 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/provider/MBeanRegistrationProviderFactoryImpl.class
   638 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/management/provider/MBeanRegistrationProviderException.class
  8893 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/sampled/SampledMBeanRegistrationProvider.class
   905 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/sampled/SampledCacheMBean.class
   602 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/sampled/SampledCacheManagerMBean.class
  2677 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/sampled/SampledEhcacheMBeans.class
  1471 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/CacheConfigurationMBean.class
   593 Wed Apr 23 12:48:20 CEST 2014 net/sf/ehcache/management/CacheManagerMBean.class
  4939 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/hibernate/management/impl/EhcacheHibernateMBeanRegistrationImpl.class
  5110 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/hibernate/management/impl/ProviderMBeanRegistrationHelper$RegisterMBeansTask.class
   411 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/hibernate/management/impl/EhcacheHibernateMBeanRegistration.class
  3089 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/hibernate/management/impl/ProviderMBeanRegistrationHelper.class
   332 Wed Apr 23 12:48:18 CEST 2014 net/sf/ehcache/hibernate/management/api/EhcacheHibernateMBean.class

/ er is ook	,
http://ehcache.org/documentation/2.7/operations/jmx

/ er is ook	,
http://khushroomistry.wordpress.com/2013/09/24/monitoring-ehcache-spring/

/ Einde MONITOR EHCACHE 

/ CACHE STRATEGIES

abstract class AbstractEhcacheAccessStrategy<T extends EhcacheTransactionalDataRegion> {

abstract class AbstractReadWriteEhcacheAccessStrategy<T extends EhcacheTransactionalDataRegion> extends AbstractEhcacheAccessStrategy<T> {

/ 13	.

public class ReadOnlyEhcacheEntityRegionAccessStrategy extends AbstractEhcacheAccessStrategy<EhcacheEntityRegion> implements EntityRegionAccessStrategy {


        public Object get(Object key, long txTimestamp) throws CacheException {
                return region().get( key );
        }

       public boolean putFromLoad(Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)throws CacheException {
                if ( minimalPutOverride && region().contains( key ) ) {
                        return false;
                }
                else {
                        region().put( key, value );
                        return true;

        public SoftLock lockItem(Object key, Object version) throws UnsupportedOperationException {
                return null;

         * A no-op since this cache is read-only
         */
        public void unlockItem(Object key, SoftLock lock) throws CacheException {
                evict( key );

      public boolean afterInsert(Object key, Object value, Object version) throws CacheException {
                region().put( key, value );
                return true;
        }

        public boolean afterUpdate(Object key, Object value, Object currentVersion, Object previousVersion, SoftLock lock)
                        throws UnsupportedOperationException {
                throw new UnsupportedOperationException( "Can't write to a readonly object" );

/ 13	.

public class ReadOnlyEhcacheCollectionRegionAccessStrategy extends AbstractEhcacheAccessStrategy<EhcacheCollectionRegion> implements CollectionRegionAccessStrategy {

/ See read only entity	, maar geen afterInsert, afterUpdate	, 

/ 13	.

org/hibernate/cache/ehcache/internal/strategy/NonStrictReadWriteEhcacheEntityRegionAccessStrategy extends AbstractEhcacheAccessStrategy<EhcacheEntityRegion>

       public Object get(Object key, long txTimestamp) throws CacheException {
                return region().get( key );
       }

       public boolean putFromLoad(Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride) throws CacheException {
                if ( minimalPutOverride && region().contains( key ) ) {
                        return false;
                }
                else {
                        region().put( key, value );
                        return true;
                }
        }
       public SoftLock lockItem(Object key, Object version) throws CacheException {
                return null;
        }

       public void unlockItem(Object key, SoftLock lock) throws CacheException {
                region().remove( key );
        }
       public boolean afterInsert(Object key, Object value, Object version) throws CacheException {
                return false;
	}

          public boolean update(Object key, Object value, Object currentVersion, Object previousVersion)
                        throws CacheException {
                remove( key );
                return false;
        }
        public boolean afterUpdate(Object key, Object value, Object currentVersion, Object previousVersion, SoftLock lock)
                        throws CacheException {
                unlockItem( key, lock );
                return false;
        }

        public void remove(Object key) throws CacheException {
                region().remove( key );
        }

/ 13	.

public class ReadWriteEhcacheEntityRegionAccessStrategy extends AbstractReadWriteEhcacheAccessStrategy<EhcacheEntityRegion> implements EntityRegionAccessStrategy {

         * Inserts will only succeed if there is no existing value mapped to this key.
         */
        public boolean afterInsert(Object key, Object value, Object version) throws CacheException {
                        final Lockable item = (Lockable) region().get( key );
                        if ( item == null ) {
                                region().put( key, new Item( value, version, region().nextTimestamp() ) );
                                return true;
                        }
                        else {
                                return false;
                        }

         * Updates will only succeed if this entry was locked by this transaction and exclusively this transaction for the
         * duration of this transaction.  It is important to also note that updates will fail if the soft-lock expired during
         * the course of this transaction.
         */
//////////////////////////
this entry was locked by this transaction: dat was bij ons nooit, want wij wilden een disassembled state uit een obj (uit 1ste session) overwrite in de 2de session met disassembled state uit de db	, en die update was in de 2de tx , een andere als de 1ste	,  

        public boolean afterUpdate(Object key, Object value, Object currentVersion, Object previousVersion, SoftLock lock) throws CacheException {
                        final Lockable item = (Lockable) region().get( key );

                        if ( item != null && item.isUnlockable( lock ) ) {
                                final Lock lockItem = (Lock) item;
                                if ( lockItem.wasLockedConcurrently() ) {
                                        decrementLock( key, lockItem );
                                        return false;
                                }
                                else {
                                        region().put( key, new Item( value, currentVersion, region().nextTimestamp() ) );
                                        return true;
                                }
  
$ vi ./org/hibernate/cache/ehcache/internal/strategy/AbstractReadWriteEhcacheAccessStrategy.java

         * Returns <code>null</code> if the item is not readable.  Locked items are not readable, nor are items created
         * after the start of this transaction.
         */
        public final Object get(Object key, long txTimestamp) throws CacheException {
                        final Lockable item = (Lockable) region().get( key );

                        final boolean readable = item != null && item.isReadable( txTimestamp );
                        if ( readable ) {
                                return item.getValue();
                        }
                        else {
                                return null;

        * Returns <code>false</code> and fails to put the value if there is an existing un-writeable item mapped to this
         * key.
         public final boolean putFromLoad( Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride) throws CacheException {
                        final Lockable item = (Lockable) region().get( key );
                        final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
                        if ( writeable ) {
                                region().put( key, new Item( value, version, region().nextTimestamp() ) );
                                return true;
                        }
                        else {
                                return false;

       /**
         * Soft-lock a cache item.
         */
        public final SoftLock lockItem(Object key, Object version) throws CacheException {
                        final Lockable item = (Lockable) region().get( key );
                        final long timeout = region().nextTimestamp() + region().getTimeout();
                        final Lock lock = (item == null) ? new Lock( timeout, uuid, nextLockId(), version ) : item.lock(
                                        timeout,
                                        uuid,
                                        nextLockId()
                        );
                        region().put( key, lock );
                        return lock;

      public final void unlockItem(Object key, SoftLock lock) throws CacheException {
                        final Lockable item = (Lockable) region().get( key );

                        if ( (item != null) && item.isUnlockable( lock ) ) {
                                decrementLock( key, (Lock) item );
                        }
                        else {
                                handleLockExpiry( key, item );
                        }

public class ReadWriteEhcacheCollectionRegionAccessStrategy extends AbstractReadWriteEhcacheAccessStrategy<EhcacheCollectionRegion>

/ Einde CACHE STRATEGIES

/ HIBERNATE MAPPINGS

/ 7	.

/ 1-N bidir	,

/ 13	,

/ Address	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 		/></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="false"
		update="false"
	>
	</many-to-one>

/ 13	,

/ of	,

/ Address	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
	>
	</many-to-one>

/ Als we in Address <key not-null="true"> 	, dan moeten we in Employee <many-to-one insert="false" update="false"> 
/ Als we in Address NIET <key not-null="true"> 	, dan moeten we in Employee NIET <many-to-one insert="false" update="false"> 
/ TODO

/ Intermezzo

/ WHICH SIDE PERSIST ASSOCIATION FK

/ 13	.

/ als <set inverse="false" ...>	, dan wordt de employee aan de coll add, doordat 
	update employee set address_=? where id=?
/ en op de 1ste ? komt coll.keyOfOwner() 	,

/ dus 
<set inverse="false" ...>
/ betekent dat de coll met de fk aan moet komen	, dus moeten we	,
	a12.getEmployees().add(e1)
/ want dan kan hij .keyOfOwner() doen	,

/ als <set inverse="true" ...>	, dan moet Employee met de fk aankomen	, dus moeten we	,
	e1.setAddress(a12)

/ 13	. 

/ als
<set inverse="false" ...>
	<key not-null="true">
/ dan moet er een fk komen: hij weet niet of de andere kant het al dan niet doet	, dus we kunnen dan met update="false" de update query cancel	,
	<key not-null="true" update="false">
/ TODO
	 

/ 13	.

/ Welke kant persist de fk	, dus welke kant bepaalt in welke coll een Employee zit?

/ als de fk van employee 12 is, zit na .get(a12) en .iterator e1 in de coll van a12	, omdat de fk van e1 zo staat: dat is de coll query	,

OneToManyPersister(AbstractCollectionPersister).recreate(PersistentCollection, Serializable, SessionImplementor) line: 1253	
		if ( !isInverse && isRowInsertEnabled() ) {
/s
    protected boolean isRowInsertEnabled() {
		return keyIsUpdateable;

/ Address 
	<set ...>
 		<key
 			column="address_"
 			not-null="false"
 			update="false"
 		/>
/ als we update="false", dan is in de coll persister keyIsUpdateable=false	, 

/ als we doen	,
	e1.a=a34
	a12.add(e1)
/ en de key is updatable,	 dan wordt 
	update employee set address_=12 where id_=1
/ en daardoor zal in volgende sessie e1 in de coll van a12	,  omdat de fk van employee, id_=1  12 is	, dus daarom heet persister.keyIsUpdateable isRowInsertEnabled()	,

/ Einde Intermezzo

/ Intermezzo

/ WHICH SIDE PERSIST ASSOCIATION FK

/ 13	.

<set ...>
	<key not-null="true">

/ Als we not-null="true", dan moet deze een key maken	, dat staat er , dus verschint er een extra prop in Employee	, de Long 	, met wat de fk moet worden	,

/ 13	.

/ Als we 
/ Address
<set inverse="false">
	<key not-null="true">

/ dan komt er dus een extra prop in Employee	, en moeten we dus de Employee.address overslaan	,  dus moet daar staan: insert="false"	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="false"
		update="true"

/ Einde Intermezzo

/ 13	.

///////////////////////////////

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false/true"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="false"
		update="false"			/ Moet voor <set ...><key not-null="true">	, see hieronder voor betekenis 

	/>

/ Main	,
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address3);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);

			session.save(address); 
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			
			tx.commit();

/ dan krijgen we bij <set inverse="false><key not-null="false"> een op .commit een PSQL ERR, omdat we een null insert , omdat we <many-to-one insert="false" ....> en daardoor slaat persist.insert deze over	, ook al is hij er wel	, 	
/ maar als we <key not-null="true" , dan is er een extra prop en omdat <many-to-one insert="false" ...> slaat persist.insert hem over	, en pakt hij de extra prop van Employee	,  

/ 13	. 

/ <many-to-one update="false"> 

/ dan wordt een update van de fk niet gedaan	,
<set inverse="false"><key not-null="true"> eist <many-to-one update="false"> , WH omdat de <many-to-one ...> daarna geen update mag doen van de fk, die de coll side zojuist heeft insert	, want er wordt alleen een insert gedaan en daarom <many-to-one insert="false">	, dus de <many-to-one ...>-fk wordt overgeslagen	, 

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 	>
 		<key
 			column="address_"
 			not-null="true"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="true"
		update="false"

	/>

/ Main	,
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address3);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);

			session.save(address); 
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			
			employee.setAddress(address);		/ update fk	, maar het gebeurt niet	, want <many-to-one update="false">
			
		  	printStats(stats);
			tx.commit();

/ als <many-to-one update="false"> gaat de update van de fk niet door	, er volgt dus NIET	,
update employee set ... address_=? where id_=? 

/ want	,
SingleTableEntityPersister(AbstractEntityPersister).update(Serializable, Object[], int[], boolean, Object[], Object, Object, Object, SessionImplementor) line: 3470	
		final boolean[] tableUpdateNeeded = getTableUpdateNeeded( dirtyFields, hasDirtyCollection );
/ [false]
/ want	,
/s
SingleTableEntityPersister(AbstractEntityPersister).getTableUpdateNeeded(int[], boolean) line: 484	
			boolean[] updateability = getPropertyUpdateability();
[true,trrue,false]
			int[] propertyTableNumbers = getPropertyTableNumbers();
[0,0,0]
			boolean[] tableUpdateNeeded = new boolean[ getTableSpan() ];
/ init met [false]
			for ( int i = 0; i < dirtyProperties.length; i++ ) {
/ dirtyProperties=[2]
				int property = dirtyProperties[i];
				int table = propertyTableNumbers[property];
				tableUpdateNeeded[table] = tableUpdateNeeded[table] ||
						( getPropertyColumnSpan(property) > 0 && updateability[property] );
/ blijft false	,
			}

/t
SingleTableEntityPersister(AbstractEntityPersister).update(Serializable, Object[], int[], boolean, Object[], Object, Object, Object, SessionImplementor) line: 3524	


		for ( int j = 0; j < span; j++ ) {
			// Now update only the tables with dirty properties (and the table with the version number)
			if ( tableUpdateNeeded[j] ) {
/ NEE
				updateOrInsert(
						id,
						fields,
						oldFields,
						j == 0 ? rowId : null,
						propsToUpdate,
						j,
						oldVersion,
						object,
						updateStrings[j],
						session
					);
/ NIET

/ 13	. 

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true/false"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="true"
		update="true"
	/>

/ Main	,		  
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
//			employee.setAddress(address3);
//			employee2.setAddress(address3);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);

			session.save(address); 
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			
			tx.commit();

/ we hebben <many-to-one insert="true"> dus persist.insert zal de entityinsertactions geven fk=null	, 

/ 13	. 

/ Address
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="false"
		update="false"

	/>

/ the employee tbl column address_ has NO constrained not-null	,

/ 13	.

/ we zien dat in feite alleen appl data -> 2c, NIET 2c <- db	,

/ in hibernate_xml_1_N_bidir_ehcache	,

/ in 1st session	,

/ afterInsert, afterUpdate 
/ insertentityaction.execute schedules 2c-entry	,
/ updateentityaction.execute writes lock in 2c	, and schedules 2c-entry	,
/ collrecreateaction doets niets met 2c	,
/ na tx: insertentityaction , als lock is set door updateentityaction.execute	, dan doet afterInsert niets	, alleen als current item==null, dan put
/ na tx: updateentityaction	, de lock is set door updateentityaction.execute	in deze tx, dus OK, dus afterUpdate  puts	,
/ na tx: cleanupaction, lock wordt unlocked	,

/ in 2de session	,

/ coll query	, 
/ putFromLoad op entities: doet NIETS, want alleen als current item==null, of isWritable	, dan put	,
/ putFromLoad op coll: doet OK, want alleen als current item==null, of isWritable	, dan put	, en er nu een lock, van vorige tx, maar hij was unlocked	, 
/ maar als de entities dirty zijn	, dan net als in 1ste session	, updateentityaction.execute sets lock (in deze tx)	, dus RM de vorige entity 	,  
 
/ Maar met nonstrict-read-write gaat het OK	, we hoven employees niet dirty te maken	,

/ Maar dit is de oplossing niet	,

  	<set
 		name="employees"
 		inverse="false"
 		>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="false"
		update="false"
	></many-to-one>

/ 1ste session	,
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");

			address3.getEmployees().add(employee);
			address3.getEmployees().add(employee2);
			
			session.save(address);
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			
			tx.commit();

/ 2de session	,

	        address=(Address)session.get(Address.class, 34l);
	        Set<Employee>employees=address.getEmployees();
	        Iterator<Employee>iterator=employees.iterator();
	        while(iterator.hasNext()){
	        	Employee e=iterator.next();
	        	e.setName(e.getName()+"A");
	        	String s=e.getName();
	        	boolean b=false;
	        }

/ 3de session	,

	        address=(Address)session.get(Address.class, 34l);
	        printStats( stats); 
	        employees=address.getEmployees();
	        iterator=employees.iterator();
	        while(iterator.hasNext()){
	        	Employee e=iterator.next();
/ e.address!=34	,
/ als we NIET	, 
	        	e.setName(e.getName()+"A");
/ dan is 
/ e.address==null	,
 
/ 13	.

/ in M_N_bidir_ehcache	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="true"
		update="true"

	/>

/ Main	,
		  	Employee employee4=new Employee(4l, "foostreet", 4.0);
		  	session.save(employee4);
		  	address3=(Address)session.get(Address.class, 34l);
		  	//employee4.setAddress(address3);
		  	address3.getEmployees().add(employee4); 
/ .add calls .dirty()	, dus de coll is dirty	,
		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address3.getEmployees().remove(employee2);
/ ook calls .dirty()
					  	
/ Als deze coll updates leiden tot 1 CollectionUpdateAction	, na .doSetUpdate
/ Daarom zien we straks	,
			persister.deleteRows( collection, id, session );
			persister.updateRows( collection, id, session );
			persister.insertRows( collection, id, session );


/ na commit	,
foo=> select*from employee;
 id_ | name_ | salary_ | address_ 
-----+-------+---------+----------
   1 | Foo1  |       1 |       34
   2 | Foo2  |       2 |         
   4 | Foo4  |       4 |       34
(3 rows)

	        	tx.commit();    
/s
flushEntities
/s
	DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 172	
/ address3 is niet dirty	,
/ FlushVisitor.processEntityPropertyValues 
/s
		Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 264	
			else if ( collection.isDirty() ) {
				// the collection's elements have changed
				entry.setDoupdate( true );
/t
flushCollections	,
			if ( ce.isDoupdate() ) {
				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionUpdateAction(
/t
performExecutions	,
	prepare 
		prepareActions( collectionRemovals );
		prepareActions( collectionUpdates );
		prepareActions( collectionCreations );
		prepareActions( collectionQueuedOps );

CollectionUpdateAction.beforeExecutions	, coll-region:coll-cache key={role: employees, key=34l} new Lock	, RM de coll {1l,2l} die er zat	,
//////////////////////////////////////////////////////////////////////
/ Als we 2 keer .iterator	, is er geen CollectionUpdateAction	, dat is alleen als de role of key verandert	, 
/ Ook als we een coll create	, (TODO)	,
/ MORGEN
               this.versionComparator = region.getCacheDataDescription().getVersionComparator();
 / MORGEN

	execute
CollectionUpdateAction.execute
			persister.deleteRows( collection, id, session );
/s
		if ( !isInverse && isRowDeleteEnabled() ) {
/s
    protected boolean isRowDeleteEnabled() {
		return keyIsUpdateable && keyIsNullable;
true 
/ want <set inverse="false"><key not-null="false" update="true">
/ keyIsUpdateable=true
/ keyIsNullable=false/true
/ persister=OneToManyPersister	,

/ Als de key nullable is , kun je de entity rm van de coll	, dat is logisch	,

/t
/s
OneToManyPersister(AbstractCollectionPersister).deleteRows(PersistentCollection, Serializable, SessionImplementor) line: 1378	
				// delete all the deleted entries
				Iterator deletes = collection.getDeletes( this, !deleteByIndex );
/s
PersistentSet.getDeletes(CollectionPersister, boolean) line: 380	
		final java.util.Map sn = (java.util.Map) getSnapshot();
		final ArrayList deletes = new ArrayList( sn.size() );
		Iterator itr = sn.keySet().iterator();
		while ( itr.hasNext() ) {
			final Object test = itr.next();
			if ( !set.contains( test ) ) {
				// the element has been removed from the set
				deletes.add( test );
/ test=e2 bij ons	,

		final Type elementType = persister.getElementType();
		itr = set.iterator();
		while ( itr.hasNext() ) {
			final Object test = itr.next();
			final Object oldValue = sn.get( test );
			if ( oldValue!=null && elementType.isDirty( test, oldValue, getSession() ) ) {
				// the element has changed
				deletes.add( oldValue );
/ TODO

/t
OneToManyPersister(AbstractCollectionPersister).deleteRows(PersistentCollection, Serializable, SessionImplementor) line: 1381	
				// delete all the deleted entries
				Iterator deletes = collection.getDeletes( this, !deleteByIndex );
/d
					while ( deletes.hasNext() ) {
...
/ we zien	,
Hibernate: update employee set address_=null where address_=? and id_=?
HibernateLog --> 11:30:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:30:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/t
			persister.updateRows( collection, id, session );
/s
		if ( !isInverse && collection.isRowUpdatePossible() ) {
/s
	public boolean isRowUpdatePossible() {
		return false;

/t
			persister.insertRows( collection, id, session );
/s
		if ( !isInverse && isRowInsertEnabled() ) {
/s
    protected boolean isRowInsertEnabled() {
		return keyIsUpdateable;
/ keyIsUpdateable=true

				Iterator entries = collection.entries( this );
				String sql = getSQLInsertRowString();
				while ( entries.hasNext() ) {
					if ( collection.needsInserting( entry, i, elementType ) ) {
/ JA voor entty=employee(4)	,
/ kijkt in collection.snapShot	,
		final Object oldValue = ( (java.util.Map) getSnapshot() ).get( entry );
		return oldValue == null || elemType.isDirty( oldValue, entry, getSession() );
oldValue=null	,
/t
/ we zien	,
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 16:48:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 16:51:30 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [4]

/ we zijn nu in Doupdate -> CollectionUpdateAction.execute	, maar Dorecreate -> CollectionInsertAction doet deze laatste ook	,

/ Intermezzo

/ EXECUTABLELISTS

/ ActionQueue.class	,

		// Important: these lists are in execution order
		List<ExecutableList<?>> tmp = new ArrayList<ExecutableList<?>>( 7 );
		tmp.add( orphanRemovals );
		tmp.add( insertions );
		tmp.add( updates );
		// do before actions are handled in the other collection queues
		tmp.add( collectionQueuedOps );
		tmp.add( collectionRemovals );
		tmp.add( collectionUpdates );
		tmp.add( collectionCreations );
		tmp.add( deletions );

		executableLists = Collections.unmodifiableList( tmp );


/ Einde Intermezzo


/ 13	.
/ DEMO

/ We doen hetzelfde als hierboven	, maar  nu met .clear erachter	,

/ in M_N_bidir_ehcache	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="true"
		update="true"

	/>

/ Main	,
		  	Employee employee4=new Employee(4l, "foostreet", 4.0);
		  	session.save(employee4);
		  	address3=(Address)session.get(Address.class, 34l);
		  	//employee4.setAddress(address3);
		  	address3.getEmployees().add(employee4); 
/ .add calls .dirty()	, dus de coll is dirty	,
		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address3.getEmployees().remove(employee2);
/ ook calls .dirty()
		  	
		  	address3.getEmployees().clear();
/ calls set.clear(); dirty()

/ Als deze coll updates leiden tot 1 CollectionUpdateAction	, na .doSetUpdate



/ we zien	,
foo=> select*from employee;
 id_ | name_ | salary_ | address_ 
-----+-------+---------+----------
   4 | Foo4  |       4 |         
   2 | Foo2  |       2 |         
   1 | Foo1  |       1 |         
(3 rows)

/ De insertions komen eerst (rij 1)	, en daarna de collectionUpdates (5)	,


	        tx.commit();    
/s
FlushVisitor(AbstractVisitor).processValue(Object, Type) line: 121	
			return processCollection( value, (CollectionType) type );
/s
			Collections.processReachableCollection( coll, type, owner, getSession() );
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 209	

		// The CollectionEntry.isReached() stuff is just to detect any silly users
		// who set up circular or shared references between/to collections.
		if ( ce.isReached() ) {
/ NEE
			// We've been here before
			throw new HibernateException(
					"Found shared references to a collection: " + type.getRole()
			);
/ NIET
		}
		ce.setReached( true );

		ce.setCurrentPersister( persister );
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );

		prepareCollectionForUpdate( collection, ce, factory );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 264	
		if ( loadedPersister != null || currentPersister != null ) {
/ NEE
			else if ( collection.isDirty() ) {
/ JA
				// the collection's elements have changed
				entry.setDoupdate( true );

/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 296	

		for ( Map.Entry<PersistentCollection,CollectionEntry> me : entries ) {
			CollectionEntry ce = me.getValue();
			if ( !ce.isReached() && !ce.isIgnore() ) {
/ NEE

			if ( ce.isDoupdate() ) {
				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionUpdateAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
								ce.isSnapshotEmpty(coll),
								session
							)
					);
			}


/s
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
/s
CollectionUpdateAction.execute() line: 84	

		else if ( !affectedByFilters && collection.empty() ) {
/////////////////////////
/ Door coll.clear()
			if ( !emptySnapshot ) {
				persister.remove( id, session );

/ CollectionRemoveAction.execute doet dit ook	, 
/ TODO	

OneToManyPersister(AbstractCollectionPersister).remove(Serializable, SessionImplementor) line: 1171	
		else {
/ NIET
			persister.deleteRows( collection, id, session );
			persister.updateRows( collection, id, session );
			persister.insertRows( collection, id, session );
		}


/ Hierboven waren we in persister.deleteRows	, die is er naast prog	, dat is als je een of meerdere items uit de list hebt .remove	,

/s
OneToManyPersister(AbstractCollectionPersister).remove(Serializable, SessionImplementor) line: 1211	

		if ( !isInverse && isRowDeleteEnabled() ) {
/=
		return keyIsUpdateable && keyIsNullable;
true
...
/ we zien	,
Hibernate: update employee set address_=null where address_=?
HibernateLog --> 12:16:12 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]


/ Bij .remove(e2) zagen	 we	,
Hibernate: update employee set address_=null where address_=? and id_=?
HibernateLog --> 11:30:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:30:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/ 13	.

/ We doen hetzelfde als hierboven	, maar  nu met coll=null	, 

/ in M_N_bidir_ehcache	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="true"
		update="true"

	/>

/ Main	,
		  	Employee employee4=new Employee(4l, "foostreet", 4.0);
		  	session.save(employee4);
		  	address3=(Address)session.get(Address.class, 34l);
		  	//employee4.setAddress(address3);
		  	address3.getEmployees().add(employee4); 
/ .add calls .dirty()	, dus de coll is dirty	,
		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address3.getEmployees().remove(employee2);
/ ook calls .dirty()
		  	
		  	address3.getEmployees().clear();
		  	address3.setEmployees(null);
	        	tx.commit();       

/s
FlushVisitor(AbstractVisitor).processValue(Object, Type) line: 121	
		if ( type.isCollectionType() ) {
			//even process null collections
			return processCollection( value, (CollectionType) type );
/ Doet NIETS	,
/s
		if (collection!=null) {
/ NEE
			Collections.processReachableCollection( coll, type, owner, getSession() );
/ NIET
/ We zien hieronder dat .setDoremove wel wordt set	, maar onder flushCollections	, ook wordt deze meteen process	, zoals altijd daar	,

 
/s
FlushVisitor.processCollection(Object, CollectionType) line: 62	

		if (collection!=null) {
/ NEE
				coll = (PersistentCollection) collection;
			}

			Collections.processReachableCollection( coll, type, owner, getSession() );
/ NIET
/ Dus Geen CollectionUpdateAction	, zoals bij .clear()	,

/ In de coll entry is reached==false	, WH de default	, want hierboven bij .clear() en eig. altijd wordt .setReached(true) 	,
/ Omdat reached==false, komt er een CollectionRemoveAction, en geen CollectionUpdateAction	,
/////////////////////////////////////////////////
	
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	
			int entityCount = flushEntities( event, persistenceContext );
/d

/ we zien in 1c dat de coll entry en entity entry een PersistentSet met een lege set (HashSet)	, omdat .clear() dat doet	,  en dat in de entity de coll==null	,

			int collectionCount = flushCollections( session, persistenceContext );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 258	

	for ( Map.Entry<PersistentCollection,CollectionEntry> me : entries ) {
			CollectionEntry ce = me.getValue();
			if ( !ce.isReached() && !ce.isIgnore() ) {
/ JA

/ Hier komen we normaal nooit	, ook bij coll.clear() niet	,

				Collections.processUnreachableCollection( me.getKey(), session );
/s
	public static void processUnreachableCollection(PersistentCollection coll, SessionImplementor session) {
		if ( coll.getOwner()==null ) {
/ NEE
		else {
			processDereferencedCollection( coll, session );
/s
Collections.processDereferencedCollection(PersistentCollection, SessionImplementor) line: 72	
		// do the work
		entry.setCurrentPersister( null );
		entry.setCurrentKey( null );
		prepareCollectionForUpdate( coll, entry, session.getFactory() );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 222	
		final CollectionPersister loadedPersister = entry.getLoadedPersister();
		final CollectionPersister currentPersister = entry.getCurrentPersister();
null
/ ANDERSOM ALS BIJ COLLECTION RECREATE	,
/ Het is nu dus andersom als bij coll recreate	,
//////////////////////////////////////////

		if ( loadedPersister != null || currentPersister != null ) {
/ JA
				// do the work
				if ( currentPersister != null ) {
/ NEE
					entry.setDorecreate( true );
				}

				if ( loadedPersister != null ) {
/ JA
					// we will need to remove ye olde entries
					entry.setDoremove( true );
					if ( entry.isDorecreate() ) {
/ NEE
						LOG.trace( "Forcing collection initialization" );
						collection.forceInitialization();
					}
				} 
/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 270	

/ coll entry.setDoremove wordt meteen processed	, zoals altijd hier	; alleen coll entry.setDoremove was set op een andere plaats als normaal	,  
			if ( ce.isDoremove() ) {
				session.getInterceptor().onCollectionRemove( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionRemoveAction(
...

/t
/s
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 338	
/s
	public void prepareActions() throws HibernateException {
		prepareActions( collectionRemovals );
/t
/s
CollectionRemoveAction.execute() line: 106	

		if ( !emptySnapshot ) {
			// an existing collection that was either non-empty or uninitialized
			// is replaced by null or a different collection
			// (if the collection is uninitialized, hibernate has no way of
			// knowing if the collection is actually empty without querying the db)
			getPersister().remove( getKey(), getSession() );
/s
OneToManyPersister(AbstractCollectionPersister).remove(Serializable, SessionImplementor) line: 1171	

/ we kwamen hier ook in CollectionUpdateAction.execute naar coll.clear()

/ we zien	,
Hibernate: update employee set address_=null where address_=?
HibernateLog --> 13:59:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]

		if ( collection != null ) {
			getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
/s
CollectionEntry.afterAction(PersistentCollection) line: 243	

		loadedKey = getCurrentKey();
/ was 34, nu null
		setLoadedPersister( getCurrentPersister() );
/ was OneToManyPersister, nu null

			snapshot = loadedPersister==null || !loadedPersister.isMutable() ?
					null :
/ Was 2 employees	, nu null	,

		collection.postAction();
/s
	clearDirty()

















/ 13	.

/ Add an employee to a set: sets the fk in the table	, maar niet via CollectionRecreateAction	,

/ We doen hetzelfde als hierboven	, maar  nu zonder .clear() of set null	, 

/ in M_N_bidir_ehcache	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="true"
		update="true"

	/>

/ Main	,
		  	Employee employee4=new Employee(4l, "foostreet", 4.0);
		  	session.save(employee4);
		  	address3=(Address)session.get(Address.class, 34l);
		  	//employee4.setAddress(address3);
		  	address3.getEmployees().add(employee4); 
/ .add calls .dirty()	, dus de coll is dirty	,
		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address3.getEmployees().remove(employee2);
/ ook calls .dirty()
		  	
	        	tx.commit();       
/ Er is een EntityInsertAction	, en een CollectionUpdateAction	,

/ EntityInsertAction	, we zien dat address_=null wordt	,
//////////////////////////////////////////////////////////////////////
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo4]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [4.0]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [null]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [4]
/t
/s
CollectionUpdateAction.execute() line: 100	
		else {
			persister.deleteRows( collection, id, session );
Hibernate: update employee set address_=null where address_=? and id_=?
HibernateLog --> 15:15:07 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 15:15:07 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

			persister.updateRows( collection, id, session );
			persister.insertRows( collection, id, session );
/s
							offset = writeKey( st, id, offset, session );
							if ( hasIdentifier ) {
								offset = writeIdentifier( st, collection.getIdentifier( entry, i ), offset, session );
							}
							writeElement( st, collection.getElement( entry ), offset, session );
/ TODO
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 15:15:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 15:16:47 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [4]
/ Dus de fk van e4 wordt update	, van null tot 34	,
////////////////////////////////////////////////////////////////

/ 13	.

/ we doen	,
		  	address3.setEmployees(new HashSet<Employee>());
		  	address3.getEmployees().add(employee4);

/ employee4 wordt add aan een hash set	, NIET aan een PersistentSet	, dus de overloaded .add (met initialize) wordt NIET called	,
/ uiteindelijk heeft address3 wel een PersistentSet	,
/ TODO


/ 13	.

/ DEMO
/ Switch sets 	, 

/ in M_N_bidir_ehcache	, 

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"      
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="true"
		update="true"

	/>

/ Main2	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Employee employee3=new Employee(3l,"Foo3",3.00);
			Employee employee4=new Employee(4l,"Foo4",4.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");

/ de colls in address en address3 hebben dezelfde persister (role)	, role="<pkg>.Address.employees"	,
			
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			address3.getEmployees().add(employee3);
			address3.getEmployees().add(employee4);

			session.save(address); 
/ In coll-1c is in de entry reached=false
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			session.save(employee3);
			session.save(employee4);
			
			tx.commit();
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 178	

		// The CollectionEntry.isReached() stuff is just to detect any silly users
		// who set up circular or shared references between/to collections.
		if ( ce.isReached() ) {
/ NEE
			// We've been here before
			throw new HibernateException(
					"Found shared references to a collection: " + type.getRole()
			);
/ NIET
		}
		ce.setReached( true );

		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
		ce.setCurrentPersister( persister );
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
/ TODO(role)	, 12l

		prepareCollectionForUpdate( collection, ce, factory );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 233	

		final CollectionPersister currentPersister = entry.getCurrentPersister();
		final CollectionPersister loadedPersister = entry.getLoadedPersister();

/ De loadedKey en loadedPersister zijn null	,
/ Deze worden set in CollectionRecreate/Update/Action,  in .afterAction	,

		if ( loadedPersister != null || currentPersister != null ) {
			if ( ownerChanged ) {
			// do the work
				if ( currentPersister != null ) {
/ JA
					entry.setDorecreate( true );

				if ( loadedPersister != null ) {
/ NEE
					// we will need to remove ye olde entries
					entry.setDoremove( true );
/ NIET
					if ( entry.isDorecreate() ) {
/ NIET
						LOG.trace( "Forcing collection initialization" );
						collection.forceInitialization();

/t
/ volgende, entity#34	,
...
/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 273	
		for ( Map.Entry<PersistentCollection,CollectionEntry> me :
			IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries() )) {
			PersistentCollection coll = me.getKey();
			CollectionEntry ce = me.getValue();

			if ( ce.isDorecreate() ) {
/ JA
				actionQueue.addAction(
						new CollectionRecreateAction(
...
/ voor #12, #34	,

/t
				performExecutions( source );

HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [null]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [null]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo3]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [3.0]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [null]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [3]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo4]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [4.0]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [null]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [4]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [3]
HibernateLog --> 16:55:36 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 16:55:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [4]

/t
/ new session
		  	address=(Address)session.get(Address.class, 12l);
/ in coll-1c is in de entry reached=false
		  	address3=(Address)session.get(Address.class, 34l);
		  	Set<Employee>employees=address.getEmployees();
		  	Set<Employee>employees3=address3.getEmployees();
		  	address.setEmployees(employees3);
		  	address3.setEmployees(employees);
	        	tx.commit();       

/ Let op: de coll's in address, address3 zijn leeg, alleen de keyOfOwner zit er in	, en de role (Address.employees)	,

/ we doen 1 voor 1	,
		  	address=(Address)session.get(Address.class, 12l);
/s
EntityLoadQueryDetails$EntityLoaderRowReader(AbstractRowReader).performTwoPhaseLoad(PreLoadEvent, ResultSetProcessingContextImpl, List<HydratedEntityRegistration>) line: 244	
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 170	
		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
				hydratedState[i] = types[i].resolve( value, session, entity );
/ i==3	,
value	MarkerObject  (id=3439)	
	name	"NOT NULL COLLECTION" (id=3443)	
/s
SetType:
	public Object resolve(Object value, SessionImplementor session, Object owner)
			throws HibernateException {
		
		return resolveKey( getKeyOfOwner( owner, session ), session, owner );
/ De value doet er helemaal niet toe	,
///////////////////////////////////////
/ TODO
/s
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 748	
/ key=12l	,
/ coll-1c is leeg	,
				// create a new collection wrapper, to be initialized later
				collection = instantiate( session, persister, key );
				persistenceContext.addUninitializedCollection( persister, collection, key );
/s
		final CollectionEntry ce = new CollectionEntry( collection, persister, id, flushing );
/s
		this.loadedKey = loadedKey;
		setLoadedPersister(loadedPersister);
/ employees-persister	,


/t
PhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 188	
		persister.setPropertyValues( entity, hydratedState );



/ dan	,
	        	tx.commit();       
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 231	
	for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
			EntityEntry entry = me.getValue();
					listener.onFlushEntity( entityEvent );
/ address#12
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 145	
		final Object entity = event.getEntity();
entity.employees=PersistentSet(3425)#34
		final EntityEntry entry = event.getEntityEntry();
loadedState[3]=PersistentSet(3413)#12
/s
FlushVisitor.processCollection(Object, CollectionType) line: 46	
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 165	
/ coll.key=34l
		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );
/ coll entry bij coll#34	,
ce.loadedKey=34l

		// The CollectionEntry.isReached() stuff is just to detect any silly users
		// who set up circular or shared references between/to collections.
		if ( ce.isReached() ) {
/ NEE
			// We've been here before
			throw new HibernateException(
					"Found shared references to a collection: " + type.getRole()
			);
		}
		ce.setReached( true );

		ce.setCurrentPersister( persister );
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
12l
/ ce is de coll entry bij coll#34	, want dat is de coll op entity#12	, ce.loadedKey=34l	, en ce.currentKey=12l	,
/ ce.loadedKey=34l: de set zat in address#34 toen hij werd loaded	,
/ ce.currentKey=12l: de set zit nu in address#12	,

		prepareCollectionForUpdate( collection, ce, factory );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 238	
			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );
true
/ de key is veranderd	,

				// do the work
				if ( currentPersister != null ) {
/ JA
					entry.setDorecreate( true );
				if ( loadedPersister != null ) {
/ JA
					// we will need to remove ye olde entries
					entry.setDoremove( true );
					if ( entry.isDorecreate() ) {
/ JA
						collection.forceInitialization();
/s
			session.initializeCollection( this, false );
/s
/ we komen waar we altijd komen	,
SessionImpl.initializeCollection(PersistentCollection, boolean) line: 1893	

		PersistentCollection collection = event.getCollection();
coll#34l
		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry( collection );
ce.loadedKey=34l	, ce.currentKey=12l	,

				ce.getLoadedPersister().initialize( ce.getLoadedKey(), source );
/s
CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 98	

		final Serializable[] ids = new Serializable[]{id};
		try {
			final QueryParameters qp = new QueryParameters();
			qp.setPositionalParameterTypes( new Type[]{ collectionPersister.getKeyType() } );
			qp.setPositionalParameterValues( ids );
			qp.setCollectionKeys( ids );
/s
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 88	
		handlePotentiallyEmptyCollectionRootReturns( loadPlan, queryParameters.getCollectionKeys(), resultSet, session );
/ queryParameters.getCollectionKeys()==[34l]
/ TODO (Hoe bij coll	, WH met 34l key	, )
/ sets coll.set , coll.tempList	,

////////////////////////////////////
/ de 34l wordt ook used in	,
Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 09:48:47 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]

/ Klopt, de coll#34 is weliswaar in address#12	, maar hij moet filled met employees met address=34l	, want we hadden de coll verwisseld dus address#12 moet de coll#34 	,

		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 158	
		final Serializable id = entityEntry.getId();
4
		final Object[] hydratedState = entityEntry.getLoadedState();
["Foo4",4.0,34l]
		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
				hydratedState[i] = types[i].resolve( value, session, entity );
/ we vinden Address#34 in 1c,	
/s
ManyToOneType(EntityType).resolve(Object, SessionImplementor, Object) line: 502	
				return resolveIdentifier( (Serializable) value, session );
/s
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/ eager=false
/ id=34l
/ we gaan de owner load	, address#34
/s
		if ( options.isAllowProxyCreation() ) {
/ JA
			return createProxyIfNecessary( event, persister, keyToLoad, options, persistenceContext );
/s
		Object existing = persistenceContext.getEntity( keyToLoad );
/ Address#34	,

/t
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 188	
		persister.setPropertyValues( entity, hydratedState );
/ entity=Employee#4

/ we zijn nog in	,
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).performTwoPhaseLoad(PreLoadEvent, ResultSetProcessingContextImpl, List<HydratedEntityRegistration>) line: 244	
/ en we hebben de 1ste Employee uit de coll-query resolved,	
/ de andere gaat net zo	,

/ dan	,
		// now we can finalize loading collections
		finishLoadingCollections( context );
/ Is voor 2c	,
/s
CollectionLoadContext.endLoadingCollection(LoadingCollectionEntry, CollectionPersister) line: 257	
		CollectionEntry ce = getLoadContext().getPersistenceContext().getCollectionEntry( lce.getCollection() );
/ ce.loadedKey=34l, ce.currentKey=12l	,

/t
						collection.forceInitialization();
/d
/t
/ FlushVisitor.processCollection klaar	,
/d
/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 226	

/ volgende	,
/ address#34	,
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
...
					listener.onFlushEntity( entityEvent );
/s
/ Weer een FlushVisitor.processCollection	,
			Collections.processReachableCollection( coll, type, owner, getSession() );
/ coll#12
/s
		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );
/ ce.loadedKey=12l	, ce.currentKey=null nog	,

		if ( ce.isReached() ) {
/ NEE
		ce.setReached( true );

		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
		ce.setCurrentPersister( persister );
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
/ ce.loadedKey=12l	, ce.currentKey=34l	,
/ address#34l heeft coll#12l	, 

		prepareCollectionForUpdate( collection, ce, factory );
/s
				// do the work
				if ( currentPersister != null ) {
/ JA
					entry.setDorecreate( true );
				}

				if ( loadedPersister != null ) {
/ JA
					// we will need to remove ye olde entries
					entry.setDoremove( true );
					if ( entry.isDorecreate() ) {
/ JA
						collection.forceInitialization();

/ coll-query	, de Employee's zijn nog NIET in 1c	, deze worden in 1c set tijdens resolve	, 
/s
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 126	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
/ Hier wordt Employee in 1c set	,
/s
EntityReferenceInitializerImpl.hydrateEntityState(ResultSet, ResultSetProcessingContextImpl) line: 239	
		final Object entityInstance = optionalEntityInstance != null
				? optionalEntityInstance
/ new Employee
		loadFromResultSet(
				resultSet,
				context,
				entityInstance,
				concreteEntityTypeName,
				entityKey,
				lockModeToAcquire
		);
/ Deze sets new Employee(1) in 1c	,

/t
			int entityCount = flushEntities( event, persistenceContext );
/d
			int collectionCount = flushCollections( session, persistenceContext );
/s
ce	CollectionEntry  (id=3413)	
	currentKey	Long  (id=3506)	 				34
	currentPersister	OneToManyPersister  (id=3418)	
	dorecreate	true	
	doremove	true	
	doupdate	false	
	loadedKey	Long  (id=3414)					12	
	loadedPersister	OneToManyPersister  (id=3418)	
	reached	true	
	role	"my.test.own.hibernate_xml_M_N_bidir_ehcache.Address.employees" (id=3534)	

			if ( ce.isDorecreate() ) {
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
								ce.getCurrentKey(),			34l
/ Dat betekent dat we de fk opnieuw gaan set	,
/ DEMO
//////////////////////////////////////////////////////
/ WH coll12 heeft empl#1/2	, coll#12 zit nu op address#34	, dus de fk van empl#1/2 moeten 34l worden	, want de coll's owner is nu address#34	,

			if ( ce.isDoremove() ) {
				actionQueue.addAction(
						new CollectionRemoveAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),			12l
								ce.isSnapshotEmpty(coll),
								session
/ WH rm fk 12 van empl1/2

/ In de list van execute actions komt CollectionRemovals eerst	, dan CollectionCreations	,

/ volgende	,
ce	CollectionEntry  (id=3419)	
	currentKey	Long  (id=3408)					12l
	currentPersister	OneToManyPersister  (id=3402)	
	dorecreate	true	
	doremove	true	
	doupdate	false	
	fromMerge	false	
	ignore	false	
	loadedKey	Long  (id=3401)					34l
	loadedPersister	OneToManyPersister  (id=3402)	
	processed	true	
	reached	true	
	role	"my.test.own.hibernate_xml_M_N_bidir_ehcache.Address.employees" (id=3431)	
	snapshot	HashMap<K,V>  (id=3432)	

/ coll#34 zit nu in address#12	, de empl#3/4 moeten dus fk 12l krijgen	,

			if ( ce.isDorecreate() ) {
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,				34l
								ce.getCurrentPersister(),
								ce.getCurrentKey(),		12l
								session
/ empl#3/4/ krijgen fk 12l

			if ( ce.isDoremove() ) {
				actionQueue.addAction(
						new CollectionRemoveAction(
								coll,				34l
								ce.getLoadedPersister(),	34l
								ce.getLoadedKey(),
								ce.isSnapshotEmpty(coll),
								session
/ rm fk 34l van empl#3/4	,

/t
				performExecutions( source );
/ eerst
[CollectionRemoveAction[my.test.own.hibernate_xml_M_N_bidir_ehcache.Address.employees#12], CollectionRemoveAction[my.test.own.hibernate_xml_M_N_bidir_ehcache.Address.employees#34]]
/s
CollectionRemoveAction.execute() line: 106	
			getPersister().remove( getKey(), getSession() );
/ getKey()=12l
/t
/s
OneToManyPersister(AbstractCollectionPersister).remove(Serializable, SessionImplementor) line: 1171	
		if ( !isInverse && isRowDeleteEnabled() ) {

/////////////////
/ Collection...Action alleen als set inverse="false"	,

   protected boolean isRowDeleteEnabled() {
		return keyIsUpdateable && keyIsNullable;
true & true 
/ want <set inverse="false"><key not-null="false" update="true">

Hibernate: update employee set address_=null where address_=?
HibernateLog --> 12:46:51 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]

/ we zien dus maar 1 query	,
////////////////////////////////////////

/t
			getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
/s
CollectionEntry.afterAction(PersistentCollection) line: 240	
/ coll#12
		loadedKey = getCurrentKey();
34l
/ WAS 12l
		setLoadedPersister( getCurrentPersister() );

/ In de coll verandert niets: key=12l blijft, 	empl#1/2 blijven in de set	,

/ volgende	,
Hibernate: update employee set address_=null where address_=?
HibernateLog --> 12:59:26 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]

/ volgende,	 
CollectionRecreateAction.execute() line: 64	
		getPersister().recreate( collection, getKey(), getSession() );
/ getKey()=34l
/s
	public void recreate(PersistentCollection collection, Serializable id, SessionImplementor session)
			throws HibernateException {
		if ( !isInverse && isRowInsertEnabled() ) {
/=
		return keyIsUpdateable;
true
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:09:38 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 13:09:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:13:12 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 13:13:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/t
		getPersister().recreate( collection, getKey(), getSession() );
/d
		getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
/s
		loadedKey = getCurrentKey();
		setLoadedPersister( getCurrentPersister() );


/ 13	. 

/ 1_N_ehcache	, dus unidir	,

/  we moeten <set inverse="false"><key not-null="true"> anders krijgt Employee geen extra prop van type long	,

/ Address	,
 	<set
 		name="employees"
 		inverse="false"
 		>
 		<key
 			column="address_"
 			not-null="true"
 			update="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/  Main	,
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address2=new Address(21l,"foostreet", "21 foo", "FooCity21");
			
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);

		  	address.setCity("FooCityA");
		  	employee.setName("Foo1A");
			
			tx.commit();
			session.close();
/ OK

/  new session	,
		  	Employee employee4=new Employee(4l, "Foo4", 4.0);
		  	session.save(employee4);
/ ERR

org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_1_N_ehcache.Employee._my.test.own.hibernate_xml_1_N_ehcache.Address.employeesBackref
	at org.hibernate.engine.internal.Nullability.checkNullability(Nullability.java:106)
	at org.hibernate.action.internal.AbstractEntityInsertAction.nullifyTransientReferencesIfNotAlready(AbstractEntityInsertAction.java:132)
	at org.hibernate.action.internal.AbstractEntityInsertAction.makeEntityManaged(AbstractEntityInsertAction.java:141)
	at org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:201)
	at org.hibernate.engine.spi.ActionQueue.addInsertAction(ActionQueue.java:179)
	at org.hibernate.engine.spi.ActionQueue.addAction(ActionQueue.java:166)
	at org.hibernate.event.internal.AbstractSaveEventListener.addInsertAction(AbstractSaveEventListener.java:332)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:288)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:194)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:137)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:209)
	at org.hibernate.event.internal.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:55)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:194)
	at org.hibernate.event.internal.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:49)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:90)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:715)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_1_N_ehcache.Main.testBasicUsage(Main.java:164)
	at my.test.own.hibernate_xml_1_N_ehcache.Main.<init>(Main.java:63)
	at my.test.own.hibernate_xml_1_N_ehcache.Main.main(Main.java:57)

/ we moeten eerst 	,
		  	address.getEmployees().add(employee4);
/ dan	,
			session.save(employee2);
/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	
/s
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 125	
/ als de employee niet in de set	, dan komt hier null uit WH	,

/t
		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/s
Nullability.checkNullability(Object[], EntityPersister, boolean) line: 94	
			final boolean[] nullability = persister.getPropertyNullability();
[true,true,false]
			final boolean[] checkability = isUpdate ?
false
				persister.getPropertyUpdateability() :
				persister.getPropertyInsertability();
[true,true,true]
propertyTypes	Type[3]  (id=3109)	
	[0]	StringType  (id=3115)	
	[1]	DoubleType  (id=3118)	
	[2]	LongType  (id=3121)	

/t
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 296	
			if ( ce.isDoupdate() ) {
				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionUpdateAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
...

/ 13	.

/ N-1 unidir, N_1_ehcache

/ een Employee heeft een ref naar een Address	, deze Address moeten we eerst save	, anders kan .save(employee) de employee niet in 1c set	, want employee heeft een transient prop	, 

/ Employee
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			employee.setAddress(address);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			employee2.setAddress(address);

			session.save(address);
			session.save(employee);
			session.save(employee2);
			tx.commit();

/ we moeten eerst address save	,
/////////////////////////////////////

/ als we 	,

			session.save(employee);
			session.save(address);
/ dan ERR bij 	,
			session.save(employee);
org.hibernate.TransientPropertyValueException: Not-null property references a transient value - transient instance must be saved before current operation : my.test.own.hibernate_xml_N_1_ehcache.Employee.address -> my.test.own.hibernate_xml_N_1_ehcache.Address
	at org.hibernate.action.internal.UnresolvedEntityInsertActions.checkNoUnresolvedActionsAfterOperation(UnresolvedEntityInsertActions.java:137)
	at org.hibernate.engine.spi.ActionQueue.checkNoUnresolvedActionsAfterOperation(ActionQueue.java:318)
	at org.hibernate.internal.SessionImpl.checkNoUnresolvedActionsAfterOperation(SessionImpl.java:658)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:717)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.testBasicUsage(Main.java:128)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.<init>(Main.java:63)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.main(Main.java:57)

/ Namelijk	, 
SessionImpl.fireSave(SaveOrUpdateEvent) line: 717	

		errorIfClosed();
		checkTransactionSynchStatus();
		checkNoUnresolvedActionsBeforeOperation();
		for ( SaveOrUpdateEventListener listener : listeners( EventType.SAVE ) ) {
			listener.onSaveOrUpdate( event );
/ OK	,
Hibernate: select address_.id__, address_.address_line1__ as address_2_0_, address_.zipcode__ as zipcode_3_0_, address_.city__ as city__4_0_ from address address_ where address_.id__=?
HibernateLog --> 07:47:58 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]

		}
		checkNoUnresolvedActionsAfterOperation();
/ ERR	,

/ Waar komt die query vandaan	?
/ In	, nog voor de schedule van de EntityInsertAction	, 

DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 288	
/s
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 177	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();

/ Als we eerst address save	, en dan employee	, dan is deze query er NIET	, 

		if ( nonNullableTransientDependencies == null ) {
/ NORMAAL, als OK
			LOG.tracev( "Adding insert with no non-nullable, transient entities: [{0}]", insert );
			addResolvedEntityInsertAction( insert );
		}
		else {
/ NU	, er volgt dus GEEN schedule	,
			if ( LOG.isTraceEnabled() ) {
				LOG.tracev( "Adding insert with non-nullable, transient entities; insert=[{0}], dependencies=[{1}]", insert,
							nonNullableTransientDependencies.toLoggableString( insert.getSession() ) );
			}
			unresolvedInsertions.addUnresolvedEntityInsertAction( insert, nonNullableTransientDependencies );

/ en dan 	,
/ t
SessionImpl.fireSave(SaveOrUpdateEvent) line: 717	
			listener.onSaveOrUpdate( event );
/d
		checkNoUnresolvedActionsAfterOperation();
/s
			actionQueue.checkNoUnresolvedActionsAfterOperation();
/s
ActionQueue.checkNoUnresolvedActionsAfterOperation() line: 318	
		unresolvedInsertions.checkNoUnresolvedActionsAfterOperation();
/ Dit is ook een queue	,
UnresolvedEntityInsertActions[[insert=EntityInsertAction[my.test.own.hibernate_xml_N_1_ehcache.Employee#1] dependencies=[NonNullableTransientDependencies[transientEntityName=my.test.own.hibernate_xml_N_1_ehcache.Address requiredBy=[address]]]]
/s
UnresolvedEntityInsertActions.checkNoUnresolvedActionsAfterOperation() line: 137	
			throw new TransientPropertyValueException(
...



/ In meer detail	,

ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 176	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
/s
ForeignKeys$Nullifier.isNullifiable(String, Object) line: 177	
			final EntityEntry entityEntry = session.getPersistenceContext().getEntry( object );
			if ( entityEntry == null ) {
/ JA
				return isTransient( entityName, object, null, session );

/ Als object in 1c, komen we NIET hier, dus zal de query niet worden gedaan	, 

/s
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 255	
		// hit the database, after checking the session cache for a snapshot
		final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(
				persister.getIdentifier( entity, session ),
				persister
		);
/ we zien	,

Hibernate: select address_.id__, address_.address_line1__ as address_2_0_, address_.zipcode__ as zipcode_3_0_, address_.city__ as city__4_0_ from address address_ where address_.id__=?
HibernateLog --> 08:18:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]

/ 1313	,

/ Het probleem was de ref naar Address	, we kunnen de <many-to-one cascade="update-save">	, maar dan zien we ook die check transient query	,

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		cascade="save-update"
	>

/ Main	,
			session.save(employee);
			session.save(employee2);
/ we zien	,
Hibernate: select address_.id__, address_.address_line1__ as address_2_0_, address_.zipcode__ as zipcode_3_0_, address_.city__ as city__4_0_ from address address_ where address_.id__=?
HibernateLog --> 08:33:20 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]

/ TODO (Is cascade een goed idee?)

/ 13	.

/ N_1_ehcache	, N-1 unidr	,

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	>

/ Main	,
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			employee.setAddress(address);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			employee2.setAddress(address);
			
			session.save(address);		
			session.save(employee);
			session.save(employee2);

		  	address.setCity("FooCityA");
		  	employee.setName("Foo1A");

			tx.commit();

/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 08:48:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

/ Deze queries zien we ook bij 1-N , <key not-null=true>	, maar daar zijn ook Collection...Action queries	, 

/ next session	,

			Address address2=new Address(34l,"foostreet", "34 foo", "FooCity34");
			session.save(address2);
			employee=(Employee)session.get(Employee.class, 1l);
			employee.setAddress(address2);
			employee2=(Employee)session.get(Employee.class, 2l);
			employee.setAddress(null);
/ we zien	,

Hibernate: select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ from employee employee0_ where employee0_.id_=?
HibernateLog --> 15:46:26 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 15:46:26 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo1]
HibernateLog --> 15:46:26 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [1.0]
HibernateLog --> 15:46:26 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [12]

Hibernate: select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ from employee employee0_ where employee0_.id_=?
HibernateLog --> 15:46:35 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]
HibernateLog --> 15:46:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo2]
HibernateLog --> 15:46:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [2.0]
HibernateLog --> 15:46:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [12]
		  			  	 
	        tx.commit();
/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34]
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]

Hibernate: update employee set name_=?, salary_=?, address_=? where id_=?
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [null]
HibernateLog --> 15:48:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]



/ 13	.

/ N-1 unidir, join table,	

/ we passen 
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	>
/ er in	,

/ Employee	,
		<join 
			table="jointable"		/ MOETEN we geven, H maakt zelf geen name	,
			optional="true"
		>
			<key 
				column="employee_"	/ self	, 
				unique="true"	
			/>
			<many-to-one 
				name="address"	
				column="address_"	/ address_ UIT employee tbl naar koppel tbl	,
				not-null="true"
			/>
		</join>

/ Main	,

			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			employee.setAddress(address);			
			Employee employee2=new Employee(2l,"Foo2",2.00);
//			employee2.setAddress(address);
			
	
			session.save(address);		
			session.save(employee);
			session.save(employee2);

/ we zien 	,

foo=> select*from employee;
 id_ | name_ | salary_ 
-----+-------+---------
   1 | Foo1  |       1
   2 | Foo2  |       2
(2 rows)

foo=> select*from jointable;
 employee_ | address_ 
-----------+----------
         1 |       12
         2 |       12
(2 rows)


/ we zien dus geen null in de address_ column in de employee tbl	, maar we zien dat een row verdwijnt in de join tbl	, en zo moet het	,
////////////////////////////////////////////

HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into jointable (address_, employee_) values (?, ?)
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 14:43:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: insert into jointable (address_, employee_) values (?, ?)
HibernateLog --> 18:02:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 18:02:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]


/ new session	,
			
			Address address2=new Address(34l,"foostreet", "34 foo", "FooCity34");
			session.save(address2);
			employee=(Employee)session.get(Employee.class, 1l);
			employee.setAddress(address2);
			employee2=(Employee)session.get(Employee.class, 2l);
			employee2.setAddress(null);
		  			  	 

/ we zien	,

Hibernate: select employee0_.id_ as id_1_2_0_, employee0_.name_ as name_2_2_0_, employee0_.salary_ as salary_3_2_0_, employee0_1_.address_ as address_2_0_0_ from employee employee0_ left outer join FooBar employee0_1_ on employee0_.id_=employee0_1_.foo_ where employee0_.id_=?
HibernateLog --> 17:57:27 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 17:57:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_2_0_] : [VARCHAR]) - [Foo1]
HibernateLog --> 17:57:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_2_0_] : [DOUBLE]) - [1.0]
HibernateLog --> 17:57:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [BIGINT]) - [12]

Hibernate: select employee0_.id_ as id_1_2_0_, employee0_.name_ as name_2_2_0_, employee0_.salary_ as salary_3_2_0_, employee0_1_.address_ as address_2_0_0_ from employee employee0_ left outer join FooBar employee0_1_ on employee0_.id_=employee0_1_.foo_ where employee0_.id_=?
HibernateLog --> 17:57:35 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]
HibernateLog --> 17:57:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_2_0_] : [VARCHAR]) - [Foo2]
HibernateLog --> 17:57:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_2_0_] : [DOUBLE]) - [2.0]
HibernateLog --> 17:57:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [BIGINT]) - [12]

	        	tx.commit();
/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 18:04:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 18:04:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 18:04:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34]
HibernateLog --> 18:04:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]

Hibernate: update jointable set address_=? where employee_=?
HibernateLog --> 18:04:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 18:04:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: delete from jointable where employee_=?
HibernateLog --> 18:04:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]

/ 13	.

/ 1_N bidir, koppel table	,

/ Address	,

 	<set
 		name="employees"
 		inverse="false"
 	>
 <!-- 		<cache usage="read-write"/>	
 --> 		
 		<key
 			column="address_"		/ owner, normaal in employee table, nu in join table,	
 			not-null="false"
 			update="true"
 		/>
 		
 <!-- 		<one-to-many class="Employee"/>
  -->		
 		<many-to-many 
 			column="employee_"		/ in join table	,
 			unique="true"	
 			class="Employee"
 		/>	
 	</set>

/ Employee	,

		<join					/ new 
			table="jointable"
			optional="true"
			inverse="true"
		>
			<key 				/ new
				column="employee_"	
				unique="true"	
			/>
			<many-to-one 
				name="address"
				column="address_"
				not-null="true"
			/>
		</join>


			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);

			address.getEmployees().add(employee);
			employee.setAddress(address);
			address.getEmployees().add(employee2);
			employee2.setAddress(address);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);
			
			tx.commit();



/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 18:16:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/ we zien	,



foo=> select*from address;
 id__ | address_line1__ | zipcode__ |   city_   
------+-----------------+-----------+-----------
   12 | foostreet       | 12 foo    | FooCity12
(1 row)

foo=> select*from employee;
 id_ | name_ | salary_ 
-----+-------+---------
   1 | Foo1  |       1
   2 | Foo2  |       2
(2 rows)

foo=> select*from address_employees;
 address_ | employee_ 
----------+-----------
       12 |         1
       12 |         2
(2 rows)

/ new session	,

/ 13	.

/ M_N_bidir

/ Address
 	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
	 			column="address_"
	 			not-null="false"
	 			update="true"
 		/>
 		
 		<many-to-many 
 			column="employee__"
 			unique="false"	
 			class="Employee"
 		/>	
 
 	</set>

/ Employee
	 	<set
 		name="addresses"
 		inverse="true"
 	>
 		<key
	 			column="employee__"
	 			not-null="false"
	 			update="true"
 		/>
 		
 		<many-to-many 
 			column="address_"
 			unique="false"	
 			class="Employee"
 		/>	
 
 	</set>




Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, employee__) values (?, ?)
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: insert into address_employees (address_, employee__) values (?, ?)
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 18:05:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]






















/ 13		.

/  1_N_ehcache, 1-N unidir	, 

/ when <set inverse=false><key not-null=true>	, 

/ Address	,
  	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 			update="true"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Main	,
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			address.getEmployees().add(employee);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);
		
			tx.commit();

/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:10:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 09:58:49 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:58:49 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/ Er is altijd een address_ column 	, want we doen <set ...><key ....>	,

/ we zien dat er extra H prop is bij employee	, die wordt meegegeven	, we zien dan ook address_ col in de employee-insert	, dat moet ook wel, want er is de constraint not-null=true	,

/ <key not-null="true"> is WH create voor schema's die al bestaan en not-null constraint hebben op de address_ fk in de employee table, of voor exports waar bij gewenst is dat not-null constraint er op komt 	, want altijd komt de coll recreate er achter aan	, die de fk set	,
/ Dus als <key not-null="true"> dan is de extra prop overbodig, maar kan niet anders	,
/ Maar het is niet goed	, want we kunnen nu nooit een employee uit de coll rm	, want de constraint address_ in employee is not-null: use join table	,
/////////////////////////////////////////////////////////////

/ we zien een not-null constraint op de fk	,

foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id__)
Has OIDs: no

/ volgende session	,
		  	address=(Address)session.get(Address.class, 12l);
		  	
		  	Employee employee4=new Employee(4l, "Foo4", 4.0);
		  	address.getEmployees().add(employee4);
		  	session.save(employee4);

		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address.getEmployees().remove(employee2);

/ we zien	,

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 14:27:07 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 14:27:07 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 14:27:07 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 14:27:07 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city_4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 14:27:08 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_1_N_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 14:27:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]


	        	tx.commit();

/ we zien	,
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 14:28:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo4]
HibernateLog --> 14:28:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [4.0]
HibernateLog --> 14:28:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 14:28:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [4]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 14:28:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:28:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [4]

/ we zien	,
foo=> select*from employee;
 id_ | name_ | salary_ | address_ 
-----+-------+---------+----------
   1 | Foo1  |       1 |       12
   2 | Foo2  |       2 |       12
   4 | Foo4  |       4 |       12
(3 rows)

/ de de remove van employee#2 is NIET gedaan	,
/ TODO (Collection...Action.execute)

/ 13

/  1_N_ehcache, 1-N unidir	, 

/ when <set inverse=false><key not-null=false>	, 

/ Address	,
  	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Main	,
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			address.getEmployees().add(employee);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);
		
			tx.commit();

/ we zien	,
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:35:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]


/ als we <key not-null=false>	, dan is er ook een address_ col in de employee table, maar er is geen extra H prop	, en er wordt dus null insert	, wat kan, want de constraint is er niet	, en de coll recreate action updates dan toch address_	, 

/ we zien	,
foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 |           | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id__)
Has OIDs: no

/ we zien geen not-null constraint	,
/ we zien in de insert ook geen address_ column	, dus in feite null,	 de collection recreate action updates address_	,

/ new session	,
		  	address=(Address)session.get(Address.class, 12l);
		  	
		  	Employee employee4=new Employee(4l, "Foo4", 4.0);
		  	address.getEmployees().add(employee4);
		  	session.save(employee4);

		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address.getEmployees().remove(employee2);

/ we zien	,

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 14:40:14 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 14:40:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 14:40:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 14:40:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city_4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 14:40:14 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_1_N_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 14:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]

			tx.commit();
/ we zien	,

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 14:41:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo4]
HibernateLog --> 14:41:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [4.0]
HibernateLog --> 14:41:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [4]

Hibernate: update employee set address_=null where address_=? and id_=?
HibernateLog --> 14:41:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:41:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 14:41:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:41:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [4]

/ we zien	,
foo=> select*from employee;
 id_ | name_ | salary_ | address_ 
-----+-------+---------+----------
   1 | Foo1  |       1 |       12
   2 | Foo2  |       2 |         
   4 | Foo4  |       4 |       12
(3 rows)



/ 1313	,

/ Als we <key not-null="true"> moet de volgorde moet precies zo zijn als bij N-1 unidir	,  eerst .save(address), dan .seve(employee)	, 
/ Dat is logisch, omdat voor .save employee  geen transient props mag hebben,
 maar als we <key not-null="false"> kunnen we .save(employee) en daarna .save(address),	 omdat Employee geen Address prop heeft,	 
/ Als <key not-null="true"> en we de volgorde verwisselen	,

			session.save(employee);
			session.save(address);
/ ERR

org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_1_N_ehcache.Employee._my.test.own.hibernate_xml_1_N_ehcache.Address.employeesBackref
	at org.hibernate.engine.internal.Nullability.checkNullability(Nullability.java:106)
	at org.hibernate.action.internal.AbstractEntityInsertAction.nullifyTransientReferencesIfNotAlready(AbstractEntityInsertAction.java:132)
	at org.hibernate.action.internal.AbstractEntityInsertAction.makeEntityManaged(AbstractEntityInsertAction.java:141)
	at org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:201)
	at org.hibernate.engine.spi.ActionQueue.addInsertAction(ActionQueue.java:179)
	at org.hibernate.engine.spi.ActionQueue.addAction(ActionQueue.java:166)
	at org.hibernate.event.internal.AbstractSaveEventListener.addInsertAction(AbstractSaveEventListener.java:332)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:288)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:194)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:137)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:209)
	at org.hibernate.event.internal.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:55)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:194)
	at org.hibernate.event.internal.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:49)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:90)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:715)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_1_N_ehcache.Main.testBasicUsage(Main.java:124)
	at my.test.own.hibernate_xml_1_N_ehcache.Main.<init>(Main.java:63)
	at my.test.own.hibernate_xml_1_N_ehcache.Main.main(Main.java:57)

/ we zien dat de ERR is tijdens addInsertAction	,
/ Bij 1_N unidir	,
org.hibernate.TransientPropertyValueException: Not-null property references a transient value - transient instance must be saved before current operation : my.test.own.hibernate_xml_N_1_ehcache.Employee.address -> my.test.own.hibernate_xml_N_1_ehcache.Address
	at org.hibernate.action.internal.UnresolvedEntityInsertActions.checkNoUnresolvedActionsAfterOperation(UnresolvedEntityInsertActions.java:137)
	at org.hibernate.engine.spi.ActionQueue.checkNoUnresolvedActionsAfterOperation(ActionQueue.java:318)
	at org.hibernate.internal.SessionImpl.checkNoUnresolvedActionsAfterOperation(SessionImpl.java:658)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:717)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.testBasicUsage(Main.java:128)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.<init>(Main.java:63)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.main(Main.java:57)
/ TODO

/ 13	.

/ RM

/  1-N unidir	, <set inverse=false><key not-null=false>

/ we zien maar 1 query voor de fk	,
////////////////////////////////////////////////////

/ Address	,
  	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Main	,

			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			address.getEmployees().add(employee);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			address.getEmployees().add(employee2);

			session.save(employee);
			session.save(address);
// .save(employee) voor .save(address) kan	, 
			session.save(employee2);

 			tx.commit();
 
/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ Het klopt	, 
/ Door <key not-null=false> zien we geen not-null constraint in de fk	,
foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 |           | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id__)
Has OIDs: no

/ de employee's worden in de laatste 2 queries add aan de coll	, daar wordt de fk set in de employee's	,

/ we zien dat de employee's entry's geen extra prop krijgen	, vandaar dat er geen value wordt insert	, 

/ WH we zien de fk maar aan een kant insert	, want we zien geen null insert in de employee's

/ 13	.

/ 1-N unidir , koppel tabel	,

/ we moeten, en doen eerst	,
	unique="true"

/ Address	,
 	<set
 		name="employees"
 		inverse="false"
 		>
 		<key
 			column="address_"		/ NIET in employee tbl, maar in koppel tbl address_employees	, 
 			not-null="true/false"
 			update="true"
 		></key>
<!--  		
		<one-to-many class="Employee"/>
 --> 	
 		<many-to-many 				/ koppel tbl	,
 			column="employee_"
 			unique="true"	
 			class="Employee"
 		/>	
 
 		</set>

/ Main	,
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			address.getEmployees().add(employee);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			address.getEmployees().add(employee2);
			
			session.save(employee);
			session.save(address);
			session.save(employee2);

			tx.commit();

/ een many-to-many gaat beide kanten op 	, dus daarom is <many-to-many ...> row in koppel tbl	,

/ we moeten <one-to-many ...> vervangen door <many-to-many unique="true" column="employee_" ...>

/ 1-N:

a - e1
  \ e2
  /	
a2	/ NIET

/ 1-N: In de koppel table : employee_ unique	, (hierboven zou e2 2 keer voorkomen)	,
////////////////////////

/ <key not-null="true/false"> maakt niet uit	,
/ TODO

/ we kunnen nu address .save NA employee .save	,
/ TODO

/ we zien	,

foo=> \d+ employee
                               Table "public.employee"
 Column  |          Type          | Modifiers | Storage  | Stats target | Description 
---------+------------------------+-----------+----------+--------------+-------------
 id_     | bigint                 | not null  | plain    |              | 
 name_   | character varying(255) |           | extended |              | 
 salary_ | double precision       |           | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)

foo=> \d+ address_employees
                   Table "public.address_employees"
  Column   |  Type  | Modifiers | Storage | Stats target | Description 
-----------+--------+-----------+---------+--------------+-------------
 address_  | bigint | not null  | plain   |              | 
 employee_ | bigint | not null  | plain   |              | 
Indexes:
    "address_employees_pkey" PRIMARY KEY, btree (address_, employee_)
  "uk_pfjhypr3roqawxjipeash0vtn" UNIQUE CONSTRAINT, btree (employee_)
Foreign-key constraints:
    "fk_7uqxbshgfhi9okm1yot3bqsbs" FOREIGN KEY (address_) REFERENCES address(id__)
    "fk_pfjhypr3roqawxjipeash0vtn" FOREIGN KEY (employee_) REFERENCES employee(id_)
Has OIDs: no

foo=> select*from address_employees;
 address_ | employee_ 
----------+-----------
       12 |         1
       12 |         2
(2 rows)

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, foo_) values (?, ?)
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, foo_) values (?, ?)
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 10:23:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ In de schema van de employee tbl is geen address_ col, dus er wordt geen null insert	,

/ we zien dat de fk maar 1 keer wordt insert	,

/ 13	.

/ 1-N bidir	, koppel tbl	,

/ new session	,

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 17:15:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]



/ 1313	.

/ Als we unique="false", kunnen we Employee in 2 Address's	,

/ Address	,
 	<set
 		name="employees"
 		inverse="false"
 		>
 		<key
 			column="address_"
 			not-null="true"
 			update="true"
 		></key>
<!--  		
		<one-to-many class="Employee"/>
 --> 	
 		<many-to-many 
 			column="employee_"
 			unique="false"	
 			class="Employee"
 		/>	
 
 	</set>

/ Main	,
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			address.getEmployees().add(employee);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			address.getEmployees().add(employee2);
			
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			address3.getEmployees().add(employee);


			session.save(employee);
			session.save(address);
			session.save(employee2);
			session.save(address3);

/ we zien	,

foo=> \d+ address_employees
                   Table "public.address_employees"
  Column   |  Type  | Modifiers | Storage | Stats target | Description 
-----------+--------+-----------+---------+--------------+-------------
 address_  | bigint | not null  | plain   |              | 
 employee_ | bigint | not null  | plain   |              | 
Indexes:
    "address_employees_pkey" PRIMARY KEY, btree (address_, employee_)
Foreign-key constraints:
    "fk_7uqxbshgfhi9okm1yot3bqsbs" FOREIGN KEY (address_) REFERENCES address(id__)
    "fk_pfjhypr3roqawxjipeash0vtn" FOREIGN KEY (employee_) REFERENCES employee(id_)
Has OIDs: no

foo=> select*from address_employees;
 address_ | employee_ 
----------+-----------
       12 |         2
       12 |         1
       34 |         1
(3 rows)

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 12:45:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ 1313

/ we doen weer unique="true", en we doen een aantal coll ops	,

/ DEMO

/ Address	,
 	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 			update="true"
 		/>
 		
<!-- 		<one-to-many class="Employee"/>
 --> 	
 		<many-to-many 
 			column="employee_"
 			unique="true"	
 			class="Employee"
 		/>	
 
 		</set>


/ Main	,

			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			address.getEmployees().add(employee);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			address.getEmployees().add(employee2);

			session.save(employee);
			session.save(address);
			session.save(employee2);

			tx.commit();

/ nieuwe sessie	,
		  	address=(Address)session.get(Address.class, 12l);
		  	
		  	Employee employee4=new Employee(4l, "Foo4", 4.0);
		  	address.getEmployees().add(employee4);
		  	session.save(employee4);

		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address.getEmployees().remove(employee2);

	        	tx.commit();

/ we zien	,
foo=> select*from address_employees;
 address_ | employee_ 
----------+-----------
       12 |         1
       12 |         4
(2 rows)

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city_4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_1_N_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_1_0_0_, employees0_.employee_ as employee2_1_0_, employee1_.id_ as id_1_2_1_, employee1_.name_ as name_2_2_1_, employee1_.salary_ as salary_3_2_1_ from address_employees employees0_ inner join employee employee1_ on employees0_.employee_=employee1_.id_ where employees0_.address_=?
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_2_1_] : [BIGINT]) - [1]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_2_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_2_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_1_0_0_] : [BIGINT]) - [12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([employee2_1_0_] : [BIGINT]) - [1]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_2_1_] : [BIGINT]) - [2]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_2_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_2_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_1_0_0_] : [BIGINT]) - [12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([employee2_1_0_] : [BIGINT]) - [2]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo4]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [4.0]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [4]

Hibernate: delete from address_employees where address_=? and employee_=?
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [4]



/ 1313

/ Address	,

 	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"			/ gaat koppel table in 	, niet employee tbl
 			not-null="false/true"
 			update="true"
 		/>
  		<many-to-many 					// koppel tbl	,
 			column="employee_"
 			unique="true"	
 			class="Employee"
 		/>	 
 
 		</set>


/ als we een coll.clear() erachter	,
/ Main	,

		  	address=(Address)session.get(Address.class, 12l);
		  	
		  	Employee employee4=new Employee(4l, "Foo4", 4.0);
		  	address.getEmployees().add(employee4);
		  	session.save(employee4);

		  	employee2=(Employee)session.get(Employee.class, 2l);
		  	address.getEmployees().remove(employee2);
		  	address.getEmployees().clear();

/ dan zien we IPV

Hibernate: delete from address_employees where address_=? and employee_=?
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: insert into address_employees (address_, employee_) values (?, ?)
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:11:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [4]

/ deze	,
Hibernate: delete from address_employees where address_=?
HibernateLog --> 13:32:21 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]

/ TODO (Collection...Action's)




/ 1313	.

/ SAMENVATTING	1-N

/ Address	,
 	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true/false"
 			update="true"
 		/>
 		<many-to-many 
 			column="employee_"
 			unique="true"	
 			class="Employee"
 		/>	
 
	</set>

/ is beter dan	, 
 	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"
 		/>
		<one-to-many class="Employee"/> 
	</set>

/ omdat dan de fk NIET constraint not-null heeft	, omdat address field niet wordt insert  maar er toch is in het scheme	,

/ bij <many-to-one ...> is address er niet in het schema	, en omdat address_ in aparte table vindt daar de insert niet plaats als null is	,
/ TODO

/ Wat niet zo goed is, is <key not-null="true">	,  
/ Let wel op de volgorde , eerst .save(address)	, dan .save(employee)	, 

 	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 			update="true"
 		/>
		<one-to-many class="Employee"/> 
	</set>

/ Main	,
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			address.getEmployees().add(employee);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			address.getEmployees().add(employee2);

			session.save(address);
			session.save(employee);
			session.save(employee2);

			tx.commit();

/ want Employee's entry krijgt een extra H prop	, en wordt dus 2 keer insert	,

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:59:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]


/ 13	.


/ N-1 bidir, in N_1_bidir_ehcache	,

/ waarom willen we bidir	, als we N-1 unidir hebben?

/ Omdat we dan kunnen doen	,

		Set<Employee>employees=address.getEmployees();  
/ Kan NIET bij unidir	,
	        Iterator<Employee>iterator=employees.iterator(); 

		query=session.createQuery("select a.employees from Address a where a.zipcode=:z");
/ Kan NIET bij unidir	,
		query.setParameter("z", "12 foo");
		employees4=query.list();
	        iterator=employees4.iterator();

/ Deze query kan WEL bij unidir	,

		  	address=(Address)session.get(Address.class, 12l);
		  	Query query=session.createQuery("select e from Employee e where e.address=:address");
		  	query.setParameter("address", address);
		  	List<Employee>employees4=query.list();
	        	iterator=employees4.iterator();

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 	>
 		<key
 			column="address_"
 			not-null="true/false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"

	/>

/ omdat inverse="true"	, maakt niet uit	,
 			not-null="true/false"

/ Main	,
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			
			employee.setAddress(address);
			address.getEmployees().add(employee);
			employee2.setAddress(address);
			address.getEmployees().add(employee);
			
			session.save(address);
/ Eerst	,
			session.save(employee);
			session.save(employee2);

			tx.commit();

/ new session	,
	        	address=(Address)session.get(Address.class, 12l); 
			Set<Employee>employees=address.getEmployees(); 
// kan niet bij unidir
	        	Iterator<Employee>iterator=employees.iterator(); 

/ new session	,
		  	address=(Address)session.get(Address.class, 12l);
		  	Query query=session.createQuery("select e from Employee e where e.address=:address");
/ Kan wel in unidir	,
		  	query.setParameter("address", address);
		  	List<Employee>employees4=query.list();
	        	iterator=employees4.iterator();

/ new session	,
		  	
		  	query=session.createQuery("select a.employees from Address a where a.zipcode=:z");
// kan niet bij unidir
		  	query.setParameter("z", "12 foo");
		  	employees4=query.list();
	        	iterator=employees4.iterator();

/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

/ Precies hetzelfde als bij unidir	,

/ new session	,

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]

/ new session	,


Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [4]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [foostreet]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [4.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [4]

/ new session	,

Hibernate: select employee0_.id_ as id_1_1_, employee0_.name_ as name_2_1_, employee0_.salary_ as salary_3_1_, employee0_.address_ as address_4_1_ from employee employee0_ where employee0_.address_=?
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [4]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [foostreet]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [4.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]

/ new session	,


Hibernate: select employees1_.id_ as id_1_1_, employees1_.name_ as name_2_1_, employees1_.salary_ as salary_3_1_, employees1_.address_ as address_4_1_ from address address0_ inner join employee employees1_ on address0_.id__=employees1_.address_ where address0_.zipcode__=?
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [12 foo]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [4]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [foostreet]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [4.0]
HibernateLog --> 16:24:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]

/ 13	. 

/ 1-N 	, 1_N_list_bidir_ehcache	,

/ boek (292) als de assoc <set inverse="true"> , dan zijn er geen Collection...Action's	, 


/ 1ste session

/ .commit

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo3]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [3.0]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [3]

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [0]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [1]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [2]
HibernateLog --> 07:59:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [3]

/ 2de session

/ .get(12l)
/ .iterator

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 08:01:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 08:01:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 08:01:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 08:01:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city_4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 08:01:02 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_1_N_list_bidir_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.index_ as index_5_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [0]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [1]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo3]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [3.0]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [3]
HibernateLog --> 08:01:09 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [2]

/ 3de session

/ .remove(0)

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 08:02:49 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 08:02:49 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 08:02:49 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 08:02:49 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city_4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 08:02:49 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_1_N_list_bidir_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.index_ as index_5_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [0]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [1]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo3]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [3.0]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [3]
HibernateLog --> 08:02:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [2]

/ .commit

Hibernate: update employee set address_=null, index_=null where address_=? and id_=?
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: update employee set address_=null, index_=null where address_=? and id_=?
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: update employee set address_=null, index_=null where address_=? and id_=?
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [3]

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [0]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [1]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [3]

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [2]
HibernateLog --> 08:04:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

/ .remove calls .setDirty	,
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 264	
			else if ( collection.isDirty() ) {
				entry.setDoupdate( true );
/t
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 296	
			if ( ce.isDoupdate() ) {
				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionUpdateAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
								ce.isSnapshotEmpty(coll),
/t
/s
CollectionUpdateAction.execute() line: 68	
		else {
			persister.deleteRows( collection, id, session );
			persister.updateRows( collection, id, session );
			persister.insertRows( collection, id, session );
		}
/ In detail	,
		else {
			persister.deleteRows( collection, id, session );
/s
OneToManyPersister(AbstractCollectionPersister).deleteRows(PersistentCollection, Serializable, SessionImplementor) line: 1374	
		if ( !isInverse && isRowDeleteEnabled() ) {
/s
		return keyIsUpdateable && keyIsNullable;
true
/t
			boolean deleteByIndex = !isOneToMany() && hasIndex && !indexContainsFormula;
				// delete all the deleted entries
				Iterator deletes = collection.getDeletes( this, !deleteByIndex );
				if ( deletes.hasNext() ) {
/ NEE

/t
CollectionUpdateAction.execute() line: 101	

			persister.updateRows( collection, id, session );
/s
		if ( !isInverse && collection.isRowUpdatePossible() ) {
/s
PersistentList(AbstractPersistentCollection).isRowUpdatePossible() line: 703	
	return true
/t
			// update all the modified entries
			int count = doUpdateRows( id, collection, session );
/s
OneToManyPersister.doUpdateRows(Serializable, PersistentCollection, SessionImplementor) line: 310	
			if ( isRowDeleteEnabled() ) {

/ Kijkt in snapshot,	 in hoe de list WAS	,
//////////////////////////////////////////////////////////////
/s
		return keyIsUpdateable && keyIsNullable;
true
/t
					Iterator entries = collection.entries( this );
					while ( entries.hasNext() ) {
/ volgende	,
						if ( collection.needsUpdating( entry, i, elementType ) ) {  // will still be issued when it used to be null
true
							int loc = writeKey( st, id, offset, session );
id=12
offset=1	/= par pos in pst	, de 1ste dus	,
/s
		getKeyType().nullSafeSet( st, key, i, session );
/ key=12, i=1
/s
LongType(AbstractStandardBasicType<T>).nullSafeSet(PreparedStatement, Object, int, SessionImplementor) line: 281	
		nullSafeSet( st, value, index, options );
/ value=12, index=1	
/t
		getKeyType().nullSafeSet( st, key, i, session );
/d
		return i + keyColumnAliases.length;
/ 2, volgende index	,
/t
OneToManyPersister.doUpdateRows(Serializable, PersistentCollection, SessionImplementor) line: 343	
							int loc = writeKey( st, id, offset, session );
/d
loc=2	, volgende index in pst	,
							writeElementToWhere( st, collection.getSnapshotElement(entry, i), loc, session );
/ i=0, 1ste elem in coll.snapshot	, dat is e1	,	in coll is dat nu e2	,
/ Klopt	, want we willen delete hoe het was	, en is in de database	,
//////////////////////////////////////////////////////////////////////////////
/s
		getElementType().nullSafeSet( st, elt, i, elementColumnIsInPrimaryKey, session );
/ elt=e1	, i=2 pos in pst	,

...
/ we zien	,
/ Gaat snapshot lijst af: vindt achtereenvolgends id=1,2,3
Hibernate: update employee set address_=null, index_=null where address_=? and id_=?
HibernateLog --> 08:58:16 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:58:36 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: update employee set address_=null, index_=null where address_=? and id_=?
HibernateLog --> 08:59:17 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:59:18 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: update employee set address_=null, index_=null where address_=? and id_=?
HibernateLog --> 08:59:27 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:59:28 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [3]

/t
OneToManyPersister.doUpdateRows(Serializable, PersistentCollection, SessionImplementor) line: 372	
			if ( isRowDeleteEnabled() ) {
/ Keek in snapshot list	, hoe de list WAS	,
/d
			if ( isRowInsertEnabled() ) {

/ kijkt in current list	, hoe de list IS	,
//////////////////////////////////////////////////////////
/s
	return keyIsUpdateable
true
/t
					Iterator entries = collection.entries( this );
					while ( entries.hasNext() ) {
						if ( collection.needsUpdating( entry, i, elementType ) ) {
true
							int loc = writeKey( st, id, offset, session );
/ 12 1ste in pst	, loc=2 volgende index in pst	,
								loc = writeIndexToWhere( st, collection.getIndex( entry, i, this ), loc, session );
/i=0, 1ste elem	,
/ collection.getIndex( entry, i, this )==i
/t
/s
		getIndexType().nullSafeSet( st, incrementIndexByBase( index ), i, session );
/s
		nullSafeSet( st, value, index, options );
/ value=0 , index=2 (plaats par in pst)
	return ...

/t
							writeElementToWhere( st, collection.getElement( entry ), loc, session );

/ we zien	,
/ Gaat huidige lijst af: vindt achtereenvolgends id=2,3,1
/////////////////////////////////////////////////////////////////////////////////
Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 09:05:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12] / writeKey
HibernateLog --> 09:05:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [0]/ writeIndexToWhere
HibernateLog --> 09:05:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2] / writeElementToWhere

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 09:05:14 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:05:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [1]
HibernateLog --> 09:05:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [3]

Hibernate: update employee set address_=?, index_=? where id_=?
HibernateLog --> 09:05:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:05:25 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [INTEGER] - [2]
HibernateLog --> 09:05:25 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]


			persister.insertRows( collection, id, session );
/s
					if ( collection.needsInserting( entry, i, elementType ) ) {
/ NEE



/ 4de session	,

/ .iterator	,

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 08:09:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 08:09:50 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 08:09:50 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 08:09:50 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city_4_0_0_] : [VARCHAR]) - [FooCity12]
HibernateLog --> 08:09:50 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_1_N_list_bidir_ehcache.Address.employees#12]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.index_ as index_5_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [0]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo3]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [3.0]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [3]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [1]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
HibernateLog --> 08:14:47 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([index_5_0_] : [INTEGER]) - [2]

/ 1313.

/ N_1_list_bidir_ehcache

/ 3de session	,

/ .commit
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 264	
			else if ( collection.isDirty() ) {
				entry.setDoupdate( true );
/ Net als bij 1-N	,
/t
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 296	
				actionQueue.addAction(
						new CollectionUpdateAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
								ce.isSnapshotEmpty(coll),
/ Net als bij 1-N
/s
CollectionUpdateAction.execute() line: 68	
		else {
			persister.deleteRows( collection, id, session );
/s
		if ( !isInverse && isRowDeleteEnabled() ) {
/ NEE
			persister.updateRows( collection, id, session );
/s
		if ( !isInverse && collection.isRowUpdatePossible() ) {
/ NEE
			persister.insertRows( collection, id, session );
/s
		super.insertRows( collection, id, session );
/s
		if ( !isInverse && isRowInsertEnabled() ) {
/ NEE
/t
		super.insertRows( collection, id, session );
/d
		writeIndex( collection, collection.entries( this ), id, 0, session );
/s
OneToManyPersister.writeIndex(PersistentCollection, Iterator, Serializable, int, SessionImplementor) line: 204	
		// If one-to-many and inverse, still need to create the index.  See HHH-5732.
		if ( isInverse && hasIndex && !indexContainsFormula ) {
true

/ Kijkt in current list	,
///////////////////////////////////////////////////////////
Hibernate: update employee set index_=? where id_=?

					while ( entries.hasNext() ) {
						final Object entry = entries.next();
								offset = writeIndex( st, collection.getIndex( entry, nextIndex, this ), offset, session );
HibernateLog --> 10:40:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [INTEGER] - [0]
								offset = writeElement( st, collection.getElement( entry ), offset, session );
HibernateLog --> 10:41:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/ volgende,
								offset = writeIndex( st, collection.getIndex( entry, nextIndex, this ), offset, session );
HibernateLog --> 10:40:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [INTEGER] - [1]
								offset = writeElement( st, collection.getElement( entry ), offset, session );
HibernateLog --> 10:41:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [3]

/we zien de CollectionUpdateAction toch actie als inverse=true
////////////////////////////////////////////////////////////////////////////////////////////





HibernateLog --> 08:22:43 DEBUG org.hibernate.SQL - update employee set index_=? where id_=?
Hibernate: update employee set index_=? where id_=?
HibernateLog --> 08:22:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [INTEGER] - [0]
HibernateLog --> 08:22:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
HibernateLog --> 08:22:43 DEBUG org.hibernate.SQL - update employee set index_=? where id_=?
Hibernate: update employee set index_=? where id_=?
HibernateLog --> 08:22:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [INTEGER] - [1]
HibernateLog --> 08:22:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [3]
HibernateLog --> 08:22:43 DEBUG org.hibernate.SQL - update employee set index_=? where id_=?
Hibernate: update employee set index_=? where id_=?
HibernateLog --> 08:22:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [INTEGER] - [2]
HibernateLog --> 08:22:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

foo=> select*from employee;
 id_ | name_ | salary_ | address_ | index_ 
-----+-------+---------+----------+--------
   2 | Foo2  |       2 |       12 |      0
   3 | Foo3  |       3 |       12 |      1
   1 | Foo1  |       1 |       12 |      2
(3 rows)

/ DEMO









/ 13	.

/ 1-N bidir	, 1_N_bidir_ehcache	,

/ SAMENVATTING

/ we hebben	,

/ Address	,
 	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 			update="true"
 		/>
 		<one-to-many 
			class="Employee"
		/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="false"
		update="false"
	/>

/ we kunnen varieren	,

Address						Employee

/ 7	.
<key 						<many-to-one
	not-null="true"					not-null="true"
>							insert="false"	
						>
/ stuurt keyOfOwner mee	,			/ staat geen null toe, slaat Address-ref over,

/ 13
<key 						<many-to-one
	not-null="false"				not-null="false"
>							insert="true"	
/ stuurt niets mee	,			/ staat null toe, inserts Address-ref , only if bidir	,
						>
/ 713
<key 						<many-to-one
	not-null="false"				not-null="false"
>							insert="false"	
/ stuurt niets mee	,			/ staat null toe, inserts Address-ref niet	, coll recreate sets fk	,


/ we zien in de 1ste session	,

/ 13	.



/ 713

/ address_ niet in insert employee	, wel in schema	, dus wordt eerst null insert	,

Hibernate: insert into address (address_line1__, zipcode__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 18:30:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]







	

 














 		












































/ 13	.

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
	/>

this	Main  (id=16)	
	configuration	Configuration  (id=40)	
		classes	HashMap<K,V>  (id=73)	
			size	2	
			table	HashMap$Entry<K,V>[16]  (id=91)	
				[4]	HashMap$Entry<K,V>  (id=96)	
				[5]	HashMap$Entry<K,V>  (id=98)	
					key	"my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee" (id=149)	
					value	RootClass  (id=150)	
						identifierProperty	Property  (id=151)	
						properties	ArrayList<E>  (id=160)	
							elementData	Object[10]  (id=168)	
								[0]	Property  (id=169)	
								[1]	Property  (id=170)	
								[2]	Property  (id=171)	
							modCount	3	
							size	3	

	SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
		if ( entityMetamodel.isDynamicInsert() ) {
/ NEE
		else {
			// For the case of dynamic-insert="false", use the static SQL
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/ getPropertyInsertability()=[true,true,true]
/ Klopt, we hebben nu NIET <many-to-one insert="false" ...>

	EntityInsertAction.execute() line: 104	
	ActionQueue.executeActions(ExecutableList<E>) line: 463	
	ActionQueue.executeActions() line: 349	
	DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
	DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
	SessionImpl.flush() line: 1222	
	SessionImpl.managedFlush() line: 425	
	JdbcTransaction.beforeTransactionCommit() line: 101	
	JdbcTransaction(AbstractTransactionImpl).commit() line: 177	
	Main.testBasicUsage() line: 118	
	Main.<init>() line: 63	
	Main.main(String[]) line: 57	

				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/s
	protected int dehydrate(
...
			final boolean[] includeProperty,
[true,true,true] 	, van hierboven	,
			final boolean[][] includeColumns,
[[true],[true],[true]] 	, van hierboven	,

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i )) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 09:45:52 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 09:45:55 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 09:46:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [34]

/ 13	.

/ insert ERR	, bij .save	,

<many-to-one not-null="true" insert="false"> laat null toe bij .save als we NIET e1.setAddress(a12)	, maar alleen a12.getEmployees().add(e1)	,  maar bij .commit  PSQL-ERR op not-null="true"	,

/ config 137

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
			update="true"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="true"
		update="true"

	/>

/ config 1313

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="false"
		update="true"

	/>


/ Main	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");

//			employee.setAddress(address3);
//			employee2.setAddress(address3);
			address3.getEmployees().add(employee);
			address3.getEmployees().add(employee2);
			
			session.save(address);
			session.save(address3);
			session.save(employee);
			session.save(employee2);

/ Met config 137 ERR	, met 1313 NIET	,

org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee.address

	at org.hibernate.engine.internal.Nullability.checkNullability(Nullability.java:106)

nullability=[true,true,false]	// 137	, <many-to-one not-null="true" ...>
nullability=[true,true,false,false]	// 1313	, <many-to-one not-null="true" ...>, <key not-null="true">

			final boolean[] checkability = isUpdate ?
false
				persister.getPropertyUpdateability() :
				persister.getPropertyInsertability();
[true,true,true]	, want <many-to-one insert="true" ...>
[true,true,false,true]	, want <many-to-one insert="false" ...>	, de extra laatste is wel insertable, 

				if ( checkability[i] && values[i]!= LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
					final Object value = values[i];
					if ( !nullability[i] && value == null ) {
/ JA, 137	,
/ NEE, 1313	, de value is wel null, maar deze prop is niet insertable, 	dus hoeven we ook niet te check	,

						//check basic level one nullablilty
						throw new PropertyValueException(
								"not-null property references a null or transient value",
								persister.getEntityName(),
								persister.getPropertyNames()[i]
							);

	at org.hibernate.action.internal.AbstractEntityInsertAction.nullifyTransientReferencesIfNotAlready(AbstractEntityInsertAction.java:132)
	at org.hibernate.action.internal.AbstractEntityInsertAction.makeEntityManaged(AbstractEntityInsertAction.java:141)
	at org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:201)
	at org.hibernate.engine.spi.ActionQueue.addInsertAction(ActionQueue.java:179)
	at org.hibernate.engine.spi.ActionQueue.addAction(ActionQueue.java:166)
	at org.hibernate.event.internal.AbstractSaveEventListener.addInsertAction(AbstractSaveEventListener.java:332)
values="Foo1",1.0,null				/ 137
types=StringType@,DoubleType@,ManyToOneType@	/ 137
values="Foo1",1.0,null,12l			/ 1313
types=StringType@,DoubleType@,ManyToOneType@,LongType	/ 1313
->	at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:288)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:137)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:209)
	at org.hibernate.event.internal.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:55)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:194)
	at org.hibernate.event.internal.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:49)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:90)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:715)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.testBasicUsage(Main.java:110)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.<init>(Main.java:63)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.main(Main.java:57)

/ 13	.

/ 137 config	,

/ update ERR	, bij .commit	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"	/ er staat geen not-null="true"	, er wordt geen Backref getter def,	 dus het is alsof er GEEN not-null="false" staat	,
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"	/ deze telt	,
		insert="false"			/ de insert van employee gaat OK
		update="true"			/ de update van employee gaat ERR	, 
	/>

/ Main	,
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
//			employee.setAddress(address3);
//			employee2.setAddress(address3);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			session.save(address); 
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			
		
		  	address3.setCity("FooCity34A");
		  	employee.setName("Foo1A");
			
		  	printStats(stats);
			tx.commit();
/ ERR
org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee.address

	at org.hibernate.engine.internal.Nullability.checkNullability(Nullability.java:106)

			final boolean[] nullability = persister.getPropertyNullability();
nullability=[true,true,false]
			final boolean[] checkability = isUpdate ?
/ isUpdate=true	,
				persister.getPropertyUpdateability() :
				persister.getPropertyInsertability();
[true,true,true]							/ klopt, we hebben <many-to-one update="true" ...>

				if ( checkability[i] && values[i]!= LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
					final Object value = values[i];
					if ( !nullability[i] && value == null ) {
/ JA voor config 137	,
						//check basic level one nullablilty
						throw new PropertyValueException(
								"not-null property references a null or transient value",
								persister.getEntityName(),
								persister.getPropertyNames()[i]
							);

					}



	at org.hibernate.event.internal.DefaultFlushEntityEventListener.scheduleUpdate(DefaultFlushEntityEventListener.java:309)
	at org.hibernate.event.internal.DefaultFlushEntityEventListener.onFlushEntity(DefaultFlushEntityEventListener.java:160)
	at org.hibernate.event.internal.AbstractFlushingEventListener.flushEntities(AbstractFlushingEventListener.java:231)
	at org.hibernate.event.internal.AbstractFlushingEventListener.flushEverythingToExecutions(AbstractFlushingEventListener.java:102)
	at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:55)
	at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:1222)
	at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:425)
	at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.beforeTransactionCommit(JdbcTransaction.java:101)
	at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.commit(AbstractTransactionImpl.java:177)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.testBasicUsage(Main.java:118)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.<init>(Main.java:63)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.main(Main.java:57)

/ 13	.

/ 137 config	,

/ we maken <many-to-one update="false" ...>

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="false"
		update="false"
	/>

/ Main	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
//			employee.setAddress(address3);
//			employee2.setAddress(address3);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			session.save(address); 
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			
		
		  	address3.setCity("FooCity34A");
		  	employee.setName("Foo1A");
			
			tx.commit();
/ ERR	,

/ <many-to-one not-null="true" ...> , maar employee.address=null	, dus constraint violation	,
/ oplossing: <set ...><key not-null="true"> , er komt een extra Long prop	, set met Backref getter	, en omdat <many-to-one insert="false" ...> zal hij deze overslaan bij entityinsertaction, wat we hieronder ook doen en fout gaat, en pakt de laatste, die 12l is, en voldoet aan de not-null constraint	,

HibernateLog --> 14:16:46 INFO  org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl - HHH000010: On release of batch it still contained JDBC statements
org.hibernate.exception.ConstraintViolationException: could not execute statement

	at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:129)
	at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:49)
	at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:126)
	at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:112)
	at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(ResultSetReturnImpl.java:211)
	at org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch.addToBatch(NonBatchingBatch.java:62)
	at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:3124)
	at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:3581)
	at org.hibernate.action.internal.EntityInsertAction.execute(EntityInsertAction.java:104)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:463)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:349)
	at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:350)
	at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:56)
	at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:1222)
	at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:425)
	at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.beforeTransactionCommit(JdbcTransaction.java:101)
	at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.commit(AbstractTransactionImpl.java:177)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.testBasicUsage(Main.java:118)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.<init>(Main.java:63)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.main(Main.java:57)
Caused by: org.postgresql.util.PSQLException: ERROR: null value in column "address_" violates not-null constraint
  Detail: Failing row contains (1, Foo1, 1, null).
	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2198)
	at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1927)
	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:255)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:561)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:419)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeUpdate(AbstractJdbc2Statement.java:365)
	at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(ResultSetReturnImpl.java:208)
	... 15 more

SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
			for ( int j = 0; j < span; j++ ) {
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/ getPropertyInsertability()=[true,true,false]
/ klopt, we hebben <many-to-one insert=false ...>

				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/ OK	, want	,
/ fields="Foo1",1.0,null	,
/ notNull=[true,true,false]	, / = property insert	,

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
					&& !lobProperties.contains( i )) {
/ NEE, i==2	, laatste	,
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );

/t
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3124	

				if ( useBatch ) {
					session.getTransactionCoordinator().getJdbcCoordinator().getBatch( inserBatchKey ).addToBatch();
/s
				final int rowCount = jdbcCoordinator.getResultSetReturn().executeUpdate( statement );
/s
insert into employee (name_, salary_, id_) values ('Foo1', 1.0, 1)

/ 13	. 

/ config 137	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,












/ 13	. 

/ Als we persist aan de coll kant,	 waarom moeten we dan <many-to-one ...> in de Employee mapping?

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 	>
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
/ GEEN <many-to-one ...>

/ Het moet, want	, 

/ 137	.

	        address3=(Address)session.get(Address.class, 34l); 
	       	  	
		employees=address3.getEmployees();
	        Iterator<Employee>iterator=employees.iterator(); 
	        while(iterator.hasNext()){
	        	Employee e=iterator.next();
/ e.address=null

//////////////////////////
/ we zien in de db WEL een fk in de employee rows	, maar blijkbaar is er in de H props bij Employee GEEN Address ref	,

/ 137	,

/ En hier gaat het mis	,

		  	Query query=session.createQuery("select e from Employee e where e.address=:address");

ibernateLog --> 08:30:12 DEBUG org.hibernate.hql.internal.ast.tree.FromReferenceNode - Resolved : e -> employee0_.id_
org.hibernate.QueryException: could not resolve property: address of: my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee [select e from my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee e where e.address=:address]
	at org.hibernate.QueryException.generateQueryException(QueryException.java:137)
	at org.hibernate.QueryException.wrapWithQueryString(QueryException.java:120)
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:234)
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:158)
	at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:126)
	at org.hibernate.engine.query.spi.HQLQueryPlan.<init>(HQLQueryPlan.java:88)
	at org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:167)
	at org.hibernate.internal.AbstractSessionImpl.getHQLQueryPlan(AbstractSessionImpl.java:301)
	at org.hibernate.internal.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:236)
	at org.hibernate.internal.SessionImpl.createQuery(SessionImpl.java:1800)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.testBasicUsage(Main.java:683)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.<init>(Main.java:62)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.main(Main.java:56)
Caused by: org.hibernate.QueryException: could not resolve property: address of: my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee
	at org.hibernate.persister.entity.AbstractPropertyMapping.propertyException(AbstractPropertyMapping.java:83)
	at org.hibernate.persister.entity.AbstractPropertyMapping.toType(AbstractPropertyMapping.java:77)
	at org.hibernate.persister.entity.AbstractEntityPersister.toType(AbstractEntityPersister.java:1978)
	at org.hibernate.hql.internal.ast.tree.FromElementType.getPropertyType(FromElementType.java:367)
	at org.hibernate.hql.internal.ast.tree.FromElement.getPropertyType(FromElement.java:500)
	at org.hibernate.hql.internal.ast.tree.DotNode.getDataType(DotNode.java:652)
	at org.hibernate.hql.internal.ast.tree.DotNode.prepareLhs(DotNode.java:275)
	at org.hibernate.hql.internal.ast.tree.DotNode.resolve(DotNode.java:219)
	at org.hibernate.hql.internal.ast.tree.FromReferenceNode.resolve(FromReferenceNode.java:126)
	at org.hibernate.hql.internal.ast.tree.FromReferenceNode.resolve(FromReferenceNode.java:121)
	at org.hibernate.hql.internal.ast.HqlSqlWalker.resolve(HqlSqlWalker.java:946)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.expr(HqlSqlBaseWalker.java:1267)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.exprOrSubquery(HqlSqlBaseWalker.java:4686)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.comparisonExpr(HqlSqlBaseWalker.java:4156)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.logicalExpr(HqlSqlBaseWalker.java:2104)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.whereClause(HqlSqlBaseWalker.java:796)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.query(HqlSqlBaseWalker.java:597)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.selectStatement(HqlSqlBaseWalker.java:301)
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.statement(HqlSqlBaseWalker.java:249)
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.analyze(QueryTranslatorImpl.java:278)
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:206)
	... 10 more

/ 7	.

/ cascade="save-update"	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 		cascade="save-update,delete,delete-orphan"
 	>
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ new session
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			address3.getEmployees().add(employee);
			address3.getEmployees().add(employee2);
			session.save(address);
/ 1c.entities=1	, 1c.colls=1
			session.save(address3);
Hibernate: select employee_.id_, employee_.name_ as name_2_1_, employee_.salary_ as salary_3_1_ from employee employee_ where employee_.id_=?
HibernateLog --> 11:10:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
Hibernate: select employee_.id_, employee_.name_ as name_2_1_, employee_.salary_ as salary_3_1_ from employee employee_ where employee_.id_=?
HibernateLog --> 11:10:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]

/ 1c.entities=4, 1c.colls=2
			
		  	address3.setCity("FooCity34A");
		  	employee.setName("Foo1A");
			tx.commit();

/ EntityInsertActions	,

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [34]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [34]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

/ EntityUpdateActions	,

Hibernate: update address set address_line1__=?, zipcode__=?, city__=? where id__=?
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34A]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]

Hibernate: update employee set name_=?, salary_=? where id_=?
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1A]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

/ CollectionRecreateActions	,

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:12:50 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/ De 1c is onveranderd	, 


/ new session
			session.sessionFactory.openSession();
/ 1c.entities=0, 1c.colls=0
			address=(Address)session.get(Address.class, 34l);

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 11:18:28 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
Address.setId()
HibernateLog --> 11:18:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 11:18:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [34 foo]
HibernateLog --> 11:18:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity34A]
HibernateLog --> 11:18:28 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_M_N_bidir_ehcache.Address.employees#34]

/ 1c.entities=1, 1c.colls=1	(new PersistentSet(34l))	,	 address#12 is niet in deze session	,

			session.delete(address);

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo1A]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [34]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [34]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [34]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [34]
HibernateLog --> 11:20:30 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]

/ WH cascade -> de entities die moeten worden delete, moeten eerst in 1c,

/ 1c.entities=3, 1c.colls=1

			tx.commit();

Hibernate: delete from employee where id_=?
HibernateLog --> 11:21:58 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 11:21:58 DEBUG org.hibernate.SQL - delete from employee where id_=?

Hibernate: delete from employee where id_=?
HibernateLog --> 11:21:58 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]
HibernateLog --> 11:21:58 DEBUG org.hibernate.SQL - delete from address where id__=?

Hibernate: delete from address where id__=?
HibernateLog --> 11:21:58 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]

/ 1c.entities=0, 1c.colls=0

/ in de db is employees tbl leeg, in de address tbl is address#34 rm, address#12 is er nog wel in de db	,

/ 3de session	,
			session = sessionFactory.openSession();
	
			employee=new Employee(1l,"Foo1",1.00);
			employee2=new Employee(2l,"Foo2",2.00);
			address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			address3.getEmployees().add(employee);
			address3.getEmployees().add(employee2);
			
			session.save(address3);

Hibernate: select employee_.id_, employee_.name_ as name_2_1_, employee_.salary_ as salary_3_1_ from employee employee_ where employee_.id_=?
HibernateLog --> 11:33:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]
Hibernate: select employee_.id_, employee_.name_ as name_2_1_, employee_.salary_ as salary_3_1_ from employee employee_ where employee_.id_=?
HibernateLog --> 11:33:31 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

/ 1c.entities=3	, 1c.colls=1				// address#12 is niet in deze session	,
			
	        	tx.commit();

/ EntityInsertActions,

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [34 foo]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity34]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [34]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [34]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [34]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

/ CollectionRecreateActions	,

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ new session	,

			session = sessionFactory.openSession();
			tx=session.beginTransaction();
			
			address=(Address)session.get(Address.class, 34l);

Hibernate: select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 11:43:20 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
Address.setId()
HibernateLog --> 11:43:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 11:43:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [34 foo]
HibernateLog --> 11:43:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity34]

/ 1c.entities=1, 1c.colls=1 (new PersistentSet(34l))	,

			employee=(Employee)session.get(Employee.class, 1l);

Hibernate: select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ from employee employee0_ where employee0_.id_=?
HibernateLog --> 11:46:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 11:46:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo1]
HibernateLog --> 11:46:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [1.0]
HibernateLog --> 11:46:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [34]

/ 1c.entities=2, 1c.colls=1

			employee2=(Employee)session.get(Employee.class, 2l);

/ 1c.entities=3, 1c.colls=1

			address.getEmployees().remove(employee);

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 11:48:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:48:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 11:48:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [34]
HibernateLog --> 11:48:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]
HibernateLog --> 11:48:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 11:48:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [34]
HibernateLog --> 11:48:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]

/ 1c.

			address.getEmployees().remove(employee2);
			
			session.update(address);
			
	        	tx.commit();

HibernateLog --> 11:51:44 DEBUG org.hibernate.SQL - delete from employee where id_=?
Hibernate: delete from employee where id_=?
HibernateLog --> 11:51:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]

HibernateLog --> 11:51:44 DEBUG org.hibernate.SQL - delete from employee where id_=?
Hibernate: delete from employee where id_=?
HibernateLog --> 11:51:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

/ 1c.entities=1	, 1c.colls=1	,


/ 7	. 

/ Er is een verschil of we doen	,
			address=(Address)session.get(Address.class, 34l);
			employee=(Employee)session.get(Employee.class, 1l);
			employee2=(Employee)session.get(Employee.class, 2l);
			address.getEmployees().remove(employee);
/ of	,
			address=(Address)session.get(Address.class, 34l);
			address.getEmployees().remove(employee);

/ In .remove doet hij eerst init de coll	, en daarom doet hij de coll query	,
/ Als we al 
			employee=(Employee)session.get(Employee.class, 1l);
			employee2=(Employee)session.get(Employee.class, 2l);
/ dan staan deze dus in de 1c,	 en worden de H props niet hydrated uit de resultSet 	,




AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 114	
			// 2) allow entity references to resolve their non-identifier hydrated state and entity instance
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateEntityState( resultSet, context );

////////////////////
/ DEMO
/ Als entity in 1c, dan zal hij de queried data NIET hydrate, want dat heeft hij al gedaan	,
/ Maar de query (de coll query in dit geval ) doet hij wel	, WH om te zien welke Employees er in de coll moeten	,
/ Hij checks niet 2c	, want assemble is even veel werk als hydrate	,

EntityReferenceInitializerImpl.hydrateEntityState(ResultSet, ResultSetProcessingContextImpl) line: 214	
	// see if we have an existing entry in the session for this EntityKey
		final Object existing = context.getSession().getEntityUsingInterceptor( entityKey );
		if ( existing != null ) {
/ JA	, als we al eerder session.get(Employee.class,2l) 	, 
/ NEE 	, als niet	,
/s
SessionImpl.getEntityUsingInterceptor(EntityKey) line: 637	
		final Object result = persistenceContext.getEntity(key);
			return result;
/t
			// use the existing association as the hydrated state
			processingState.registerEntityInstance( existing );
/ 7	.

/ we kunnen .seve en .update ook eerder set	,

/ 7	.

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 		cascade="save-update,delete,delete-orphan"
 	>
 		<key
 			column="address_"
 
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Geen <key not-null="true">
/ we hoeven in <many-to-one NIET insert, update="false">

/ Employee

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"

	>
	</many-to-one>

/ Wel <key not-null="true">

			Employee employee=new Employee(1l,"Foo1",1.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
//			employee.setAddress(address3);
//			employee2.setAddress(address3);
			address3.getEmployees().add(employee);
			address3.getEmployees().add(employee2);
			session.save(address3);

org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee.address
	at org.hibernate.engine.internal.Nullability.checkNullability(Nullability.java:106)
	at org.hibernate.action.internal.AbstractEntityInsertAction.nullifyTransientReferencesIfNotAlready(AbstractEntityInsertAction.java:132)
	at org.hibernate.action.internal.AbstractEntityInsertAction.makeEntityManaged(AbstractEntityInsertAction.java:141)
	at org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:201)
	at org.hibernate.engine.spi.ActionQueue.addInsertAction(ActionQueue.java:179)
	at org.hibernate.engine.spi.ActionQueue.addAction(ActionQueue.java:166)
	at org.hibernate.event.internal.AbstractSaveEventListener.addInsertAction(AbstractSaveEventListener.java:332)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:288)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:194)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:137)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:209)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:194)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.performSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:114)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:90)
	at org.hibernate.internal.SessionImpl.fireSaveOrUpdate(SessionImpl.java:684)
	at org.hibernate.internal.SessionImpl.saveOrUpdate(SessionImpl.java:676)
	at org.hibernate.engine.spi.CascadingActions$5.cascade(CascadingActions.java:235)
	at org.hibernate.engine.internal.Cascade.cascadeToOne(Cascade.java:350)
	at org.hibernate.engine.internal.Cascade.cascadeAssociation(Cascade.java:293)
	at org.hibernate.engine.internal.Cascade.cascadeProperty(Cascade.java:161)
	at org.hibernate.engine.internal.Cascade.cascadeCollectionElements(Cascade.java:379)
	at org.hibernate.engine.internal.Cascade.cascadeCollection(Cascade.java:319)
	at org.hibernate.engine.internal.Cascade.cascadeAssociation(Cascade.java:296)
	at org.hibernate.engine.internal.Cascade.cascadeProperty(Cascade.java:161)
	at org.hibernate.engine.internal.Cascade.cascade(Cascade.java:118)
	at org.hibernate.event.internal.AbstractSaveEventListener.cascadeAfterSave(AbstractSaveEventListener.java:460)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:294)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:194)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:137)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:209)
	at org.hibernate.event.internal.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:55)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:194)
	at org.hibernate.event.internal.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:49)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:90)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:715)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.testBasicUsage(Main.java:108)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.<init>(Main.java:62)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.main(Main.java:56)


/ Maar als we WEL ref def in Employee, dan is deze ERR er NIET	,

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 		cascade="save-update,delete,delete-orphan"
 	>
 		<key
 			column="address_"
 
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"

	>
	</many-to-one>

/ Main.java	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address3);
			address3.getEmployees().add(employee);
			address3.getEmployees().add(employee2);
			session.save(address3);
/ OK	,

/ 7	.

/ Address	,
	<set
 		name="employees"
 		inverse="false"
 		cascade="save-update,delete,delete-orphan"
 	>
 		<key
 			column="address_"
			not-null="true" 
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ WEL <key not-null="true">

/ Employee

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"

	>
	</many-to-one>

/ Tijdens factory	,

HibernateLog --> 15:19:26 INFO  org.hibernate.engine.jdbc.internal.LobCreatorBuilder - HHH000424: Disabling contextual LOB creation as createClob() method threw error : java.lang.reflect.InvocationTargetException
org.hibernate.MappingException: Repeated column in mapping for entity: my.test.own.hibernate_xml_M_N_bidir_ehcache.Employee column: address_ (should be mapped with insert="false" update="false")
	at org.hibernate.mapping.PersistentClass.checkColumnDuplication(PersistentClass.java:709)
	at org.hibernate.mapping.PersistentClass.checkPropertyColumnDuplication(PersistentClass.java:731)
	at org.hibernate.mapping.PersistentClass.checkColumnDuplication(PersistentClass.java:753)
	at org.hibernate.mapping.PersistentClass.validate(PersistentClass.java:506)
	at org.hibernate.mapping.RootClass.validate(RootClass.java:270)
	at org.hibernate.cfg.Configuration.validate(Configuration.java:1358)
	at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1849)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.setUp(Main.java:73)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.<init>(Main.java:61)
	at my.test.own.hibernate_xml_M_N_bidir_ehcache.Main.main(Main.java:56)

/ TODO

/ 7	.

/ Hibernate: waar de not-null="true" staat is de kant waar de fk is def	,

/ Als we de fk def aan de <many-to-one> side	, dan hoeven we aan de set kant <key NIET not-null="true"> , want dat hebben we al gedaan	,

/ 13	.

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 		cascade="save-update,delete,delete-orphan"
 	>
 		<key
 			column="address_"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"

	>
	</many-to-one>

/ 13	.

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 		cascade="save-update,delete,delete-orphan"
 	>
 		<key
 			column="address_"
			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		insert="false"
		update="false"
	>
	</many-to-one>

/ 7	. 

/ als de set inverse	, dan is er wel een collectionrecreateaction, maar die doet niets	, 
	public void recreate(PersistentCollection collection, Serializable id, SessionImplementor session) throws HibernateException {
		if ( !isInverse && isRowInsertEnabled() ) {
/ NEE
/ Dus GEEN	, 
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 11:38:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ 13	.

/ ehcache, read-write

/ hibernate_xml_1_N_bidir_ehcache	,

/ in de 2de session doet H bij .iterator de coll query, en omdat de employee's al in de 1ste session ->2c	, worden ze nu niet update in 2c	,  in de 3de session vinden we de employee's uit 2c, uit de 1ste session dus, en deze hebben address=null
/ maar als we een employee in de 2de session update,	 dan wordt hij in 2c wel update, omdat de soft-lock en deze update in dezelfde tx plaatsvinden	, 
/ TODO 
/ HIER HIER

/ Einde HIBERNATE MAPPINGS

/ HIBERNATE PERFORMANCE

/ 7	.

/ <many-to-one lazy="false/proxy/no-proxy"
/ <set lazy="false/true/extra">
/ <class lazy="true/false">

/ we lezen	,

By default, Hibernate3 uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. 

/ bij <many-to-one ...> betekent lazy: proxy of inst	,
/ bij <set ...> betekent lazy: wanneer wordt de set collected: with .get(address) of later bij coll.size() of coll.iterator()



/ no-proxy
/ TODO

/ bij een <property lazy="true/false">

/ 13	. 

/ N_1_ehcache	,

/ <many-to-one lazy="false/proxy"> 

/ In Employee is een ref naar de Address	,
/ als we 'n Employee session.get	, en we willen geen proxy naar de Address, maar de Address zelf, dan kunnen we	, 
	class Address lazy=false
/ of	,
	in Employee <many-to-one class="Address" lazy="false"> 


/ 1313	.

/ Address
<class 
	name="Address" 
	table="address"
	lazy="true"
>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		lazy="proxy"
	/>

/ <many-to-one lazy="proxy"> is de default	,
/ <class lazy="true"> is de default	,

/ 1st session	,

			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			employee.setAddress(address);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			employee2.setAddress(address);

			session.save(employee);
			session.save(employee2);
			session.save(address);

/ 2de session	,
	        employee = (Employee) session.get(Employee.class, 1l);
/ *
	        employee.getAddress().setCity("BarTown");
/**

/ *
select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ 
from employee employee0_ 
where employee0_.id_=?
HibernateLog --> 15:33:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 15:33:23 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo1]
HibernateLog --> 15:33:23 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [1.0]
HibernateLog --> 15:33:23 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [12]

employee	Employee  (id=54)	
	address	Address_$$_jvst135_1  (id=57)	

/ **
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 15:33:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 15:33:43 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 15:33:43 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 15:33:43 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity12]


/ Als we <many-to-one lazy="false"> is employee.address een Address inst	,

/ 1313

<class 
	name="Address" 
	table="address"
	lazy="true"
>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		lazy="false"		/ !
	/>

/ De query naar Address komt er meteen achteraan	,  en employee.address=Address inst	,

/ 2de session	,
	        employee = (Employee) session.get(Employee.class, 1l);
/*
	        employee.getAddress().setCity("BarTown");
/**

/ *
select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ 
from employee employee0_ 
where employee0_.id_=?
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo1]
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [1.0]
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [12]
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
Address.setId()
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 15:45:04 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity12]

/ **
/ NIETS

employee	Employee  (id=54)	
	address	Address  (id=57)	


/ 1313	,

/ Address
<class 
	name="Address" 
	table="address"
	lazy="false" 		/ !
>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		lazy="false/proxy"	/ ! maakt niet uit	, we zien een join	,
	/>


	        employee = (Employee) session.get(Employee.class, 1l);
/ *
	        employee.getAddress().setCity("BarTown");
/**

/ we see a join	, and employee.address is an Adress inst	, not a proxy	,

/*
select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_, 
 address1_.id__ as id__1_0_1_, address1_.address_line1__ as address_2_0_1_, address1_.zipcode__ as zipcode_3_0_1_, address1_.city__ as city__4_0_1_ 
from employee employee0_ 
left outer join address address1_ on employee0_.address_=address1_.id__ 
where employee0_.id_=?
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [12]
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo1]
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [1.0]
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [12]
Address.setId()
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [foostreet]
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [12 foo]
HibernateLog --> 15:52:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [FooCity12]
Address.setAddressLine1()

employee	Employee  (id=54)	
	address	Address  (id=57)	

/ **
/ NOTHING

/ 13	



/ N_1_join_ehcache	,

/ TODO, SKIP FOR NOW

/ lazy	, ref	,

/ Employee
		<join 
			table="employee_address"
			optional="true">
			<key 
				column="employee_"
				unique="true"	
			/>
			<many-to-one 
				name="address"
				column="address_"
				not-null="true"
				lazy="false/proxy/no-proxy"
			/>
		</join>


/ 2de session	,
	        employee = (Employee) session.get(Employee.class, 1l);

select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, 
	employee0_1_.address_ as address_2_2_0_ 
from employee employee0_ 
left outer join employee_address employee0_1_ on employee0_.id_=employee0_1_.employee_ 
where employee0_.id_=?



/ als lazy="proxy", WH de default	, of als we lazy weglaten	, 

employee	Employee  (id=47)	
	address	Address_$$_jvstaad_0  (id=50)	
	id	1	
	name	"Foo1" (id=55)	
	salary	1.0	

/ we zien dus een proxy	,

	        employee.getAddress().getCity();
	        employee.getAddress().setCity("BarTown");
/ employee.address blijft een proxy	,

/ 13	.

/ 1_N_ehcache

/ lazy	, coll	,

/ Address	,
  	<set
 		name="employees"
 		inverse="false"
 		lazy="true/false/extra"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="false"
 			update="true"
 		/>
 		
		<one-to-many 
			class="Employee"
		/>
 	
 
	</set>

/ de default is <set lazy="true">

/ 1313	. 

/ <set lazy="true">

/ lazy="true" => we zien dat er GEEN speciale size query is	,

/ Main	,
/ 2de session	,

	        employee = (Employee) session.get(Employee.class, 1l);
/ uit 2c
	        address=(Address)session.get(Address.class, 12l);
/ uit 2c	, address.employees=lege PersistentSet	,

	        employees=address.getEmployees();
	        employees.size();
/ coll query	,
	        employees.size();
/ reads set.size()
	        iterator=employees.iterator();
/ GEEN coll query	,

/ 3de session
	        employee = (Employee) session.get(Employee.class, 1l);
/ uit 2c
	        address=(Address)session.get(Address.class, 12l);
/ uit 2c	,
	        employees=address.getEmployees();
	        employees.size();
/ GEEN coll query	,
	        employees.size();
/ GEEN coll query	,
	        iterator=employees.iterator();
/ GEEN coll query	,


/ 1313	. 

/ lazy="extra"

/ lazy="extra" => we zien dat er een speciale size query is	,
/ de result van deze query komt niet in 1c, 2c	,  maar =  set.size()	,

/ Main	,
/ 2de session	,

	        employee = (Employee) session.get(Employee.class, 1l);
/ uit 2c
	        address=(Address)session.get(Address.class, 12l);
/ uit 2c	,
	        employees=address.getEmployees();
	        employees.size();
/ size query	,
	        employees.size();
/ reads set.size()
	        iterator=employees.iterator();
/ coll query	,

/ 3de session
	        employee = (Employee) session.get(Employee.class, 1l);
/ uit 2c
	        address=(Address)session.get(Address.class, 12l);
/ uit 2c	,
	        employees=address.getEmployees();
	        employees.size();
/ coll query	,
	        employees.size();
/ reads set.size()
	        iterator=employees.iterator();
/ uit 2c, GEEN coll query	,

/ 1313	. 

/ <set lazy="false">

	        employee = (Employee) session.get(Employee.class, 1l);
/ uit 2c
	        address=(Address)session.get(Address.class, 12l);
/ uit 2c	, maar coll uit coll query	,

	        employees=address.getEmployees();
	        employees.size();
	        employees.size();
	        iterator=employees.iterator();
/ NIETS	, 

/ 3de session
	        employee = (Employee) session.get(Employee.class, 1l);
/ uit 2c
	        address=(Address)session.get(Address.class, 12l);
/ uit 2c	 , de coll ook uit 2c	,

	        employees=address.getEmployees();
	        employees.size();
	        iterator=employees.iterator();
/ NIETS 

/ 1313

/ <set lazy="extra"> more detail	,

/ 2de session	,  meer detail	,

	        Set<Employee>employees=address.getEmployees();
	        employees.size();

Hibernate: select count(id_) from employee where address_ =?
HibernateLog --> 13:25:20 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]

	        employees.size();
	        Iterator<Employee>iterator=employees.iterator();

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ 
from employee employees0_ 
where employees0_.address_=?
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [2]
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]

HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [2]
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]
HibernateLog --> 13:25:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]
/ TODO

	       
/ code	, Meer detail	, 
	        employees.size();
/s
PersistentSet(AbstractPersistentCollection).readSize() line: 155	
		if ( !initialized ) {
			if ( cachedSize != -1 && !hasQueuedOperations() ) {
				return true;
			}
			else {
				final boolean isExtraLazy = withTemporarySessionIfNeeded(
						new LazyInitializationWork<Boolean>() {
							@Override
...							public Boolean doWork() {


	        employees.size();
/s
			return readSize() ? getCachedSize() : set.size();


	        iterator=employees.iterator();
/s
PersistentSet(AbstractPersistentCollection).initialize(boolean) line: 554	
		if ( initialized ) {
			return;
		}
		withTemporarySessionIfNeeded(
				new LazyInitializationWork<Object>() {
					@Override
					public Object doWork() {
...


/ 7	.

/ 1_N__ehcache
/ 1_N_bidir_ehcache

/ volgorder .save	,

/ Address
  	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache 
 			usage="read-write"
 		/>	
 		<key
 			column="address_"
 			not-null="true"				/ !
 			update="true"
 		/>
 		
		<one-to-many 
			class="Employee"
		/>
 	
 
 		</set>

/ we moeten een extra H prop laten gen	, als not-null="true", dan zien we ERR als de volgorder van .save niet OK	,

/ we moeten volgorde	,
			session.save(address);
			session.save(employee);

/ want employee's H props krijgt extra	, en als we eerst .save(employee) is die extra H prop null	, want	,
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 125	
				return session.getPersistenceContext().getOwnerId( entityName, propertyName, target, mergeMap );

/ Dan in	,
ForeignKeys$Nullifier.isNullifiable(String, Object) line: 180	
			final EntityEntry entityEntry = session.getPersistenceContext().getEntry( object );
/ object=Address inst	,
			if ( entityEntry == null ) {
/ JA als we eerst .save(employee)	, 
/ er volgt dan een query op Address#12	,
				return isTransient( entityName, object, null, session );
			}
			else {
/ JA	, als .save(employee) na .save(eddress)	, dan is Address#12 in de 1c	,
				return entityEntry.isNullifiable( isEarlyInsert, session );

/ Ook	, 
/ Eerder	, in 
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 177	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
/ TODO (Wat is dit?)

/ 7	.

/ N_1_ehcache

/ volgorde .save

/ Employee
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"	 		/ !
		lazy="proxy"
	/>

/ als we not-null="true"	,  dan ERR	,

/ we zien nu een latere fout als bij 1_N_ehcache	, 

org.hibernate.TransientPropertyValueException: Not-null property references a transient value - transient instance must be saved before current operation : my.test.own.hibernate_xml_N_1_ehcache.Employee.address -> my.test.own.hibernate_xml_N_1_ehcache.Address
	at org.hibernate.action.internal.UnresolvedEntityInsertActions.checkNoUnresolvedActionsAfterOperation(UnresolvedEntityInsertActions.java:137)
	at org.hibernate.engine.spi.ActionQueue.checkNoUnresolvedActionsAfterOperation(ActionQueue.java:318)
	at org.hibernate.internal.SessionImpl.checkNoUnresolvedActionsAfterOperation(SessionImpl.java:658)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:717)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.testBasicUsage(Main.java:123)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.<init>(Main.java:64)
	at my.test.own.hibernate_xml_N_1_ehcache.Main.main(Main.java:58)

/ Als we not-null="false", dan OK, maar we zien wel weer die extra query	,

select address_.id__, address_.address_line1__ as address_2_0_, address_.zipcode__ as zipcode_3_0_, address_.city__ as city__4_0_ 
from address address_ 
where address_.id__=?
HibernateLog --> 13:11:55 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]

/ 7	.

/ N_1_bidir_fetch_ehcache

/ HIER HIER


/ Book (574) 1+N probleem	,

/ EntBatchApp	,

/ Employee
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"

	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="true"
		lazy="proxy"

	/>

/ Address	,
	
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
 	>
<!--  		<cache usage="read-write"/>	
 --> 		
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Address	,
	Set<Employee>employees=new HashSet<Employee>();

/ Employee	,
   	private Address address;
    	private Address living;

/ we geven een employee ook een woon adres	, living	,  
/ address is werk adres	, deze is bidir	, living is unidir	,

/ Beide zijn not-null, dus we moeten eerst de Address's save	, daarna de Employee	,

foo=> select*from address;
 id__ | address_line1__ | zipcode__ |   city__   
------+-----------------+-----------+------------
   12 | foostreet       | 12 foo    | FooCity12
    1 | livingstreet    | 1 living  | LivingCity
    0 | livingstreet    | 0 living  | LivingCity
    3 | livingstreet    | 3 living  | LivingCity
    4 | livingstreet    | 4 living  | LivingCity
    2 | livingstreet    | 2 living  | LivingCity
(6 rows)

foo=> select*from employee;
 id_ | name_ | salary_ | address_ | living_ 
-----+-------+---------+----------+---------
   1 | Foo1  |       1 |       12 |       1
   0 | Foo0  |       0 |       12 |       0
   3 | Foo3  |       3 |       12 |       3
   4 | Foo4  |       4 |       12 |       4
   2 | Foo2  |       2 |       12 |       2
(5 rows)


/ Main	,

/ 1ste session	,

			Address address=new Address(1l,"FooStreet"+1, 1+"Foo", "FooCity"+1);
			session.save(address);
/ .save(address) voor .save(employee)
			for(int j=1;j<+ENTSIZ;j++){		
				int k=10*1+j;
				Employee employee=new Employee((long)k,"Foo"+k,(double)k);
				address.getEmployees().add(employee);
				employee.setAddress(address);
				employee.setLiving(new Address((long)k,"LivingStreet",k+" living","LivingCity"+k));
				session.save(employee.getLiving());
/ .save(living) voor .save(employee)
				session.save(employee);
			}

/ 2de session	,
			Query query=session.createQuery("from Employee");
			List<Employee>employees6=query.list();
/ *
			ListIterator<Employee>listIterator=employees6.listIterator();
			while(listIterator.hasNext()){
				Employee employee6=listIterator.next();
				String city=employee6.getLiving().getCity();
/ **

/ *
/ de 1 query	,

select employee0_.id_ as id_1_1_, employee0_.name_ as name_2_1_, employee0_.salary_ as salary_3_1_, employee0_.address_ as address_4_1_, employee0_.living_ as living_5_1_ 
from employee employee0_
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [1]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [1]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [0.0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [3]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo3]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [3.0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [3]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [4]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo4]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [4.0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [4]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [2]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 13:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [2]


/ **
/ De N queries	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__=?
HibernateLog --> 13:50:40 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 13:50:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [livingstreet]
HibernateLog --> 13:50:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1 living]
HibernateLog --> 13:50:40 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity]

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__=?
HibernateLog --> 13:51:34 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [0]
Address.setId()
HibernateLog --> 13:51:34 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [livingstreet]
HibernateLog --> 13:51:34 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [0 living]
HibernateLog --> 13:51:34 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity]

...


/ 13	. 

/ N_1_bidir_fetch_ehcache

/ batch-size

/ EntBatchApp	,

/ Address
<class 
	name="Address" 
	table="address"
	batch-size="3"
>


/ 2de session	,
			Query query=session.createQuery("from Employee");
			List<Employee>employees6=query.list();
/*
			ListIterator<Employee>listIterator=employees6.listIterator();
			while(listIterator.hasNext()){
				Employee employee6=listIterator.next();
				String city=employee6.getLiving().getCity();
/ **

/ *
/ onveranderd	,

select employee0_.id_ as id_1_1_, employee0_.name_ as name_2_1_, employee0_.salary_ as salary_3_1_, employee0_.address_ as address_4_1_, employee0_.living_ as living_5_1_ 
from employee employee0_
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [4]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo4]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [4.0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [4]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [3]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo3]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [3.0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [3]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [0.0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [2]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo2]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [2.0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [2]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_] : [VARCHAR]) - [Foo1]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_] : [DOUBLE]) - [1.0]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_] : [BIGINT]) - [12]
HibernateLog --> 07:36:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_] : [BIGINT]) - [1]


/ **

/ In de 1ste while loop	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?, ?)
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [4]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [0]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [3]

HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [4]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [livingstreet]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [4 living]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity]

HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [3]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [livingstreet]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [3 living]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity]

HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [0]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [livingstreet]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [0 living]
HibernateLog --> 07:36:39 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity]

/ Dan in de 4de while loop	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?, ?)
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [12]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [12]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity12]

HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [2]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [livingstreet]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [2 living]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity]

HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [livingstreet]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1 living]
HibernateLog --> 07:49:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity]

/ we zien ook 12	, maar dat is een werk adres	, maar in de while loop gaat het toch goed	, bij iedere  
				String city=employee6.getLiving().getCity();
/ wordt de living proxy in employee  resolved	, en hij pakt alleen de living's in de rs	, niet de working address	,

/ 13	.

/ N_1_bidir_fetch_ehcache

/ CollBatchApp

/ Address	,


/ 1ste session	,
		  	for(int i=1;i<=ENTSIZ;i++){
				Address address=new Address((long)i,"FooStreet "+i, i+" Foo", "FooCity"+i);
				session.save(address);
				for(int j=1;j<=COLLSIZ;j++){	
					int k=10*i+j;
					Employee employee=new Employee((long)k,"Foo"+k,(double)k);
					address.getEmployees().add(employee);
					employee.setAddress(address);
					employee.setLiving(new Address((long)k,"LivingStreet",k+" living","LivingCity"+k));
					session.save(employee.getLiving());
					session.save(employee);
				}
		  	}

/ 2de session	,
			Query query=session.createQuery("from Address a where a.zipcode like '%Foo%'");
			List<Address>addresses=query.list();
/ *
			ListIterator<Address>addressIterator=addresses.listIterator();
			while(addressIterator.hasNext()){
				Address address=addressIterator.next();
				Set<Employee>employees=address.getEmployees();
				Iterator<Employee>employeeIterator=employees.iterator();
/ **
				while(employeeIterator.hasNext()){
					Employee employee=employeeIterator.next();
/ +
					Address address2=employee.getLiving();
					String c=address2.getZipcode();
/ ***
					boolean b=false;
				}
			}

/ +
/ employee.address=Address inst	, employee.living=Address proxy	, 
/ emoloyee.address is een inst	, want vlak erboven is address def	,
/ employee.living wordt resolved bij ***	,

/ we zien bij ** en bij *** batching	, ** van de coll en *** van de ent	,

/ Dus we zien steeds 3 coll in query result	, en steeds 3 entities in query result	,
 

/ we zien	,

foo=> select*from address;
 id__ | address_line1__ | zipcode__ |    city__    
------+-----------------+-----------+--------------
    1 | FooStreet 1     | 1 Foo     | FooCity1
   11 | LivingStreet    | 11 living | LivingCity11
   12 | LivingStreet    | 12 living | LivingCity12
   13 | LivingStreet    | 13 living | LivingCity13
   14 | LivingStreet    | 14 living | LivingCity14
   15 | LivingStreet    | 15 living | LivingCity15
    2 | FooStreet 2     | 2 Foo     | FooCity2
   21 | LivingStreet    | 21 living | LivingCity21
   22 | LivingStreet    | 22 living | LivingCity22
   23 | LivingStreet    | 23 living | LivingCity23
   24 | LivingStreet    | 24 living | LivingCity24
   25 | LivingStreet    | 25 living | LivingCity25
    3 | FooStreet 3     | 3 Foo     | FooCity3
   31 | LivingStreet    | 31 living | LivingCity31
   32 | LivingStreet    | 32 living | LivingCity32
   33 | LivingStreet    | 33 living | LivingCity33
   34 | LivingStreet    | 34 living | LivingCity34
   35 | LivingStreet    | 35 living | LivingCity35
    4 | FooStreet 4     | 4 Foo     | FooCity4
   41 | LivingStreet    | 41 living | LivingCity41
   42 | LivingStreet    | 42 living | LivingCity42
   43 | LivingStreet    | 43 living | LivingCity43
   44 | LivingStreet    | 44 living | LivingCity44
   45 | LivingStreet    | 45 living | LivingCity45
    5 | FooStreet 5     | 5 Foo     | FooCity5
   51 | LivingStreet    | 51 living | LivingCity51
   52 | LivingStreet    | 52 living | LivingCity52
   53 | LivingStreet    | 53 living | LivingCity53
   54 | LivingStreet    | 54 living | LivingCity54
   55 | LivingStreet    | 55 living | LivingCity55
(30 rows)

foo=> select*from employee;
 id_ | name_ | salary_ | address_ | living_ 
-----+-------+---------+----------+---------
  11 | Foo11 |      11 |        1 |      11
  12 | Foo12 |      12 |        1 |      12
  13 | Foo13 |      13 |        1 |      13
  14 | Foo14 |      14 |        1 |      14
  15 | Foo15 |      15 |        1 |      15
  21 | Foo21 |      21 |        2 |      21
  22 | Foo22 |      22 |        2 |      22
  23 | Foo23 |      23 |        2 |      23
  24 | Foo24 |      24 |        2 |      24
  25 | Foo25 |      25 |        2 |      25
  31 | Foo31 |      31 |        3 |      31
  32 | Foo32 |      32 |        3 |      32
  33 | Foo33 |      33 |        3 |      33
  34 | Foo34 |      34 |        3 |      34
  35 | Foo35 |      35 |        3 |      35
  41 | Foo41 |      41 |        4 |      41
  42 | Foo42 |      42 |        4 |      42
  43 | Foo43 |      43 |        4 |      43
  44 | Foo44 |      44 |        4 |      44
  45 | Foo45 |      45 |        4 |      45
  51 | Foo51 |      51 |        5 |      51
  52 | Foo52 |      52 |        5 |      52
  53 | Foo53 |      53 |        5 |      53
  54 | Foo54 |      54 |        5 |      54
  55 | Foo55 |      55 |        5 |      55
(25 rows)

/ 1313

/ alleen batch-size in Address's <class batch-size="3">

/ Address	,
<class 
	name="Address" 
	table="address"
	batch-size="3"
>
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
 		fetch="select"
 	>
<!--  		<cache usage="read-write"/>	
 --> 		
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"
		fetch="select"
	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="select"
	/>


/ *
/ De 1ste query, die er altijd is	, (1)	,

select address0_.id__ as id__1_0_, address0_.address_line1__ as address_2_0_, address0_.zipcode__ as zipcode_3_0_, address0_.city__ as city__4_0_ 
from address address0_ 
where address0_.zipcode__ like '%Foo%'
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_] : [BIGINT]) - [1]
Address.setId()
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_] : [VARCHAR]) - [FooStreet 1]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_] : [VARCHAR]) - [1 Foo]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_] : [VARCHAR]) - [FooCity1]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_] : [BIGINT]) - [2]
Address.setId()
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_] : [VARCHAR]) - [FooStreet 2]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_] : [VARCHAR]) - [2 Foo]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_] : [VARCHAR]) - [FooCity2]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_] : [BIGINT]) - [3]
Address.setId()
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_] : [VARCHAR]) - [FooStreet 3]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_] : [VARCHAR]) - [3 Foo]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_] : [VARCHAR]) - [FooCity3]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_] : [BIGINT]) - [4]
Address.setId()
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_] : [VARCHAR]) - [FooStreet 4]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_] : [VARCHAR]) - [4 Foo]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_] : [VARCHAR]) - [FooCity4]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_] : [BIGINT]) - [5]
Address.setId()
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_] : [VARCHAR]) - [FooStreet 5]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_] : [VARCHAR]) - [5 Foo]
HibernateLog --> 09:53:02 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_] : [VARCHAR]) - [FooCity5]

/ We zien voor iedere coll een query (N)	,

/ Dit willen we staks anders	,

/ **
select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee employees0_ 
where employees0_.address_=?
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo11]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [11.0]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [11]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]

HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo12]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [12.0]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [12]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]

HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo13]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [13.0]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [13]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]

HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo14]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [14.0]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [14]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]

HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo15]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [15.0]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [15]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:54:19 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]

/ we zien
employee	Employee  (id=30)	
	address	Address  (id=32)	
	living	Address_$$_jvst76c_1  (id=45)	

/ ***

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?, ?)
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [14]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [13]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [15]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [13]
Address.setId()
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [13 living]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity13]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [14]
Address.setId()
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [14 living]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity14]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [15]
Address.setId()
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [15 living]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity15]
HibernateLog --> 12:43:44 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_N_1_bidir_fetch_ehcache.Address.employees#13]

/ we zien <class name="Address" batch-size="3">	,

/ ***
/ volgende	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?)
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [11]

HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [11]
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [11 living]
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity11]

HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [12]
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 living]
HibernateLog --> 12:49:18 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity12]

/ **
/ volgende	, 

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee employees0_ 
where employees0_.address_=?
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [21]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo21]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [21.0]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [21]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [21]

HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [22]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo22]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [22.0]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [22]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [22]

HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [23]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo23]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [23.0]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [23]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [23]

HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [24]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo24]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [24.0]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [24]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [24]

HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [25]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo25]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [25.0]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [25]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 12:52:45 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [25]

/ ***

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?, ?)
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [23]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [24]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [25]

HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [23]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [23 living]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity23]

HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [24]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [24 living]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity24]

HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [25]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [25 living]
HibernateLog --> 12:55:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity25]

/ ***
/ volgede	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?)
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [22]
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [21]

HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [21]
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [21 living]
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity21]

HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [22]
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [22 living]
HibernateLog --> 12:57:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity22]


/ 1313

/ <class name="Address" batch-size="3">
/ <set batch-size="3">


/ * 
/ Hetzelfde	, 1 query voor alle werk addresses	,

select address0_.id__ as id__1_0_, address0_.address_line1__ as address_2_0_, address0_.zipcode__ as zipcode_3_0_, address0_.city__ as city__4_0_ 
from address address0_ 
where address0_.zipcode__ like '%Foo%'

/ **

/ We zien 3 collecties tegelijk in 1 query	,

select employees0_.address_ as address_4_0_1_, employees0_.id_ as id_1_1_1_, employees0_.id_ as id_1_1_0_, employees0_.name_ as name_2_1_0_, employees0_.salary_ as salary_3_1_0_, employees0_.address_ as address_4_1_0_, employees0_.living_ as living_5_1_0_ 
from employee employees0_ 
where employees0_.address_ in (?, ?, ?)
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [3]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [11]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo12]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [12.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [12]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo13]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [13.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [13]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo14]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [14.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [14]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo15]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [15.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [15]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [21]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo21]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [21.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [21]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [21]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [22]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo22]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [22.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [22]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [22]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [23]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo23]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [23.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [23]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [23]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [24]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo24]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [24.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [24]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [24]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [25]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo25]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [25.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [25]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [25]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [31]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo31]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [31.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [31]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [31]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [32]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo32]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [32.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [32]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [32]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [33]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo33]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [33.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [33]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [33]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [34]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo34]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [34.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [34]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [34]

HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [35]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo35]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [35.0]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [35]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:25:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [35]

/ we zien <set batch-size="3"> 	, dus 3 collecties (van 5)	, 

/ ***

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?, ?)
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [15]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [21]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [22]

HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [15]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [15 living]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity15]

HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [21]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [21 living]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity21]

HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [22]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [22 living]
HibernateLog --> 13:35:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity22]


/ 1313	.

/ fetch="subselect" ivp batch-size="3" in de coll	,


/ Address
<class 
	name="Address" 
	table="address"
	batch-size="3"
>
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
 		fetch="subselect"
 	>
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ CollBatchApp	,
			Query query=session.createQuery("from Address a where a.zipcode like '%Foo%'");
			List<Address>addresses=query.list();
/ *
			ListIterator<Address>addressIterator=addresses.listIterator();
			while(addressIterator.hasNext()){
				Address address=addressIterator.next();
				Set<Employee>employees=address.getEmployees();
				Iterator<Employee>employeeIterator=employees.iterator();
/ **
				while(employeeIterator.hasNext()){
					Employee employee=employeeIterator.next();
					Address address2=employee.getLiving();
					String c=address2.getZipcode();
/ ***
					boolean b=false;
				}
			}

/ *


/ **
select employees0_.address_ as address_4_0_1_, employees0_.id_ as id_1_1_1_, employees0_.id_ as id_1_1_0_, employees0_.name_ as name_2_1_0_, employees0_.salary_ as salary_3_1_0_, employees0_.address_ as address_4_1_0_, employees0_.living_ as living_5_1_0_ 
from employee employees0_ 
where employees0_.address_ in (
	select address0_.id__ 
	from address address0_ 
	where address0_.zipcode__ like '%Foo%'
)
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [11]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo12]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [12.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [12]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo13]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [13.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [13]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo14]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [14.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [14]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo15]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [15.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [15]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [21]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo21]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [21.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [21]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [21]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [22]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo22]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [22.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [22]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [22]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [23]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo23]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [23.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [23]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [23]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [24]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo24]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [24.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [24]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [24]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [25]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo25]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [25.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [25]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [2]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [25]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [31]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo31]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [31.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [31]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [31]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [32]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo32]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [32.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [32]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [32]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [33]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo33]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [33.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [33]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [33]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [34]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo34]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [34.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [34]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [34]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [35]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo35]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [35.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [35]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [3]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [35]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [41]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo41]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [41.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [41]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [41]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [42]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo42]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [42.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [42]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [42]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [43]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo43]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [43.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [43]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [43]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [44]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo44]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [44.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [44]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [44]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [45]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo45]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [45.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [45]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [4]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [45]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [51]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo51]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [51.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [51]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [51]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [52]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo52]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [52.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [52]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [52]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [53]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo53]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [53.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [53]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [53]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [54]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo54]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [54.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [54]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [54]

HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [55]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo55]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [55.0]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [55]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [5]
HibernateLog --> 10:59:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [55]

/ ***
/ See hierboven	, batch-size="3"	, 1 query in (?,?,?)	,  onveranderd	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?, ?)
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [14]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [21]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [15]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [14]
Address.setId()
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [14 living]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity14]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [15]
Address.setId()
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [15 living]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity15]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [21]
Address.setId()
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [21 living]
HibernateLog --> 13:59:44 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity21]

/ ***
/ volgende	,
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__ in (?, ?, ?)
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [13]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [22]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [23]

HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [13]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [13 living]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity13]

HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [22]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [22 living]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity22]

HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [23]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [23 living]
HibernateLog --> 14:01:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity23]

/ 13	. 

/ we create hibernate_xml_N_1_fetch_coll_ehcache	,

/ het create van de db tables doen we 1 keer, en daarna niet meer	,

$ vi Address.hbm.xml
<class 
	name="Address" 
	table="address_coll"

$ vi Employee.hbm.xml
<class 
	name="Employee" 
	table="employee_coll"


/ we doen 1 keer	,

$ vi hibernate_cfg.xml
	<property name="hbm2ddl.auto">create</property>



$ vi CollBatchApp.java

			for(int i=1;i<=ENTSIZ;i++){
				Address address=new Address((long)i,"FooStreet "+i, i+" Foo", "FooCity"+i);
				session.save(address);
				for(int j=1;j<=COLLSIZ;j++){	
					int k=10*i+j;
					Employee employee=new Employee((long)k,"Foo"+k,(double)k);
					address.getEmployees().add(employee);
					employee.setAddress(address);
					employee.setLiving(new Address((long)k,"LivingStreet",k+" living","LivingCity"+k));
					session.save(employee.getLiving());
					session.save(employee);
				}
		  	}

/ Vervolgens niet meer	, beide comment out	,


/ 13	. 

/ EntFetchApp	,

/ <many-to-one fetch="join"> 

/ werkt alleen op session.get	, session.createCriteria	, NIET op session.createQuery, tenzij je de query aanpast	,

/ hql query moeten we zelf doen	, dit heeft NIETS te doen met <many-to-one fetch="join">



/ EntFetchApp	,

/ 1 address	, meerdere employees	,

/ we see that fetch="join" works with .get and .createCriteria	, 
/ but not with .createQuery	, tenzij we de query aanpassen	,

/ we have to adjust .createQuery("from Employee") to .createQuery("from Employee e left join fetch e.living")

/ 1ste session	,

			Address address=new Address(1l,"FooStreet"+1, 1+"Foo", "FooCity"+1);
			session.save(address);
			for(int j=1;j<+ENTSIZ;j++){		
				int k=10*1+j;
				Employee employee=new Employee((long)k,"Foo"+k,(double)k);
				address.getEmployees().add(employee);
				employee.setAddress(address);
				employee.setLiving(new Address((long)k,"LivingStreet",k+" living","LivingCity"+k));
				session.save(employee.getLiving());
				session.save(employee);
			}


/ 2de session	,
			Employee employee=(Employee)session.get(Employee.class, 11l);
/ *
			Set<Employee>employees=address2.getEmployees();
			Iterator<Employee>iterator=employees.iterator();
/ **
			while (iterator.hasNext()) {
				Employee employee = (Employee) iterator.next();
				Address living =employee.getLiving();
				String zip=living.getZipcode();
/ ***

/ 1313

/ eerst default <many-to-one name="living" fetch="select">

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"		/ inderdaad een proxy	,
	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="true/false"
		lazy="proxy"		/ ! heeft geen effect	, door fetch=join is lazy false, employee.living is een Address inst, geen Address proxy
		fetch="select"

	/>

/ *
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address address0_ where address0_.id__=?
HibernateLog --> 15:20:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 15:20:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [FooStreet1]
HibernateLog --> 15:20:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1Foo]
HibernateLog --> 15:20:42 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity1]

/ **
select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee employees0_ 
where employees0_.address_=?
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo11]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [11.0]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [11]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]

HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo12]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [12.0]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [12]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]

HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo13]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [13.0]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [13]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]

HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo14]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [14.0]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [14]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:28:15 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]

/ gewoon de 5 employees in the coll	,

/ we see , because <many-to-one name="living" fetch="select">	,

employee	Employee  (id=61)	
	address	Address  (id=50)	
	living	Address_$$_jvstabc_1  (id=63)	


/ ***
/ Steeds 1 living address	,

/ ***
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__=?
HibernateLog --> 15:34:20 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [13]

HibernateLog --> 15:34:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:34:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [13 living]
HibernateLog --> 15:34:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity13]

/ ***
/ volgende	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__=?
HibernateLog --> 15:36:20 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [11]
HibernateLog --> 15:36:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:36:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [11 living]
HibernateLog --> 15:36:20 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity11]


/ 1313

/ <many-to-one name="living" fetch="join">

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"		/ inderdaad een proxy	,
	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="true/false"
		lazy="proxy"		/ ! heeft geen effect	, door fetch=join is lazy false, employee.living is een Address inst, geen Address proxy
		fetch="select"

	/>

/ we see that the fk living_ is joined with the entity Employee itself	,

/ **
/ als <many-to-one not-null="true">	, inner join	,
/ als <many-to-one not-null="false">	, left outer join	,

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_, 
 address1_.id__ as id__1_0_2_, address1_.address_line1__ as address_2_0_2_, address1_.zipcode__ as zipcode_3_0_2_, address1_.city__ as city__4_0_2_ 
from employee employees0_ 
left outer join address address1_ on employees0_.living_=address1_.id__ 
where employees0_.address_=?

HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [11]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo11]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [11.0]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [11]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [11 living]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity11]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]

HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [12]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo12]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [12.0]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [12]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [12 living]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity12]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]

HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [13]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo13]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [13.0]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [13]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [13 living]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity13]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]

HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [14]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo14]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [14.0]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [14]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [14 living]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity14]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:40:06 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]

HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [15]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo15]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [15.0]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [15]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [15 living]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity15]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 15:53:32 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]

/ we see	, omdat nu <many-to-one name="living" fetch="join">	,

employee	Employee  (id=61)	
	address	Address  (id=50)	
	living	Addres  (id=...)


/ ***
/ NO QUERY	, because the living addresses are already in the join	,

/ 3de session	,

			org.hibernate.Criteria 	criteria=session.createCriteria(Employee.class);
			criteria.add(Restrictions.idEq(11l));
			Employee employee2=(Employee)criteria.uniqueResult();
/*
			employees=address2.getEmployees();
			iterator=employees.iterator();
/**
			while (iterator.hasNext()) {
				Employee employee = (Employee) iterator.next();
				Address living =employee.getLiving();
/***

/ precies als hierboven	,



/ 4de session	,

			Query query=session.createQuery("from Employee e left join fetch e.living where e.id=11");

select employee0_.id_ as id_1_1_0_, address1_.id__ as id__1_0_1_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_, employee0_.living_ as living_5_1_0_, 
 address1_.address_line1__ as address_2_0_1_, address1_.zipcode__ as zipcode_3_0_1_, address1_.city__ as city__4_0_1_ 
from employee employee0_ left outer join address address1_ on employee0_.living_=address1_.id__ 
where employee0_.id_=11
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [11]
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [11]
Address.setId()
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [11 living]
HibernateLog --> 09:28:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [LivingCity11]

			List<Employee>employees6=query.list();



/ 13	.

/ N_1_bidir_fetch_ehcache

/ EntFetchApp	,

/ <set ... fetch="join" >
/ en in <many-to-one TODO


/ Address
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"	/ ! niets, is in feite false	, dat komt door fetch=join	,
 		fetch="join"
 	>
<!--  		<cache usage="read-write"/>	
 --> 		
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"

	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="join/select"	/ als fetch=join	, dan nog een 2de join erbij (voor de living)	, anders niet	,

	/>

/ <set fetch=join>	, dan is employee.address = Address inst	, not a proxy	,
// <many-to-one fetch="join/select"> , als join, dan is employee.living Address inst, anders proxy	,


/ 2de session	,

			Address address2=(Address)session.get(Address.class, 1l);
/*
			Set<Employee>employees=address2.getEmployees();
			Iterator<Employee>iterator=employees.iterator();
			while (iterator.hasNext()) {
				Employee employee = (Employee) iterator.next();
/ **
				Address living =employee.getLiving();
/ ***

/ 1313

/ <many-to-one name="living" fetch="select" > , de default	,

/ we join alleen de coll met de owner	,

/*

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.address_ as address_4_0_1_, 
	employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 

from address address0_ 										/ owner of coll
left outer join employee employees1_ on address0_.id__=employees1_.address_ 			/ employee in coll,	because employee.fk=owner.id
where address0_.id__=?

/ **
employee	Employee  (id=61)	
	address	Address  (id=53)	
	living	Address_$$_jvst1e_1  (id=63)	

/ ***
/ 1+N problem	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.address_ as address_4_0_1_, 
	employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 

from address address0_ 
left outer join employee employees1_ on address0_.id__=employees1_.address_ 
where address0_.id__=?

HibernateLog --> 12:41:58 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [14]
HibernateLog --> 12:41:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [null]
Address.setId()
HibernateLog --> 12:41:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:41:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [14 living]
HibernateLog --> 12:41:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity14]
HibernateLog --> 12:41:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [null]

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.address_ as address_4_0_1_, 
	employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 

from address address0_ 
left outer join employee employees1_ on address0_.id__=employees1_.address_ 
where address0_.id__=?

HibernateLog --> 12:50:35 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [13]
HibernateLog --> 12:50:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [null]
Address.setId()
HibernateLog --> 12:50:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:50:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [13 living]
HibernateLog --> 12:50:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity13]
HibernateLog --> 12:50:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [null]

/ HIER HIER


/ 1313

/ <many-to-one ... fetch="join">

/ *
/ joins coll with owner	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.address_ as address_4_0_1_, 
	employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_, 
	address2_.id__ as id__1_0_3_, address2_.address_line1__ as address_2_0_3_, address2_.zipcode__ as zipcode_3_0_3_, address2_.city__ as city__4_0_3_ 
from address address0_ 
left outer join employee employees1_ on address0_.id__=employees1_.address_ 
left outer join address address2_ on employees1_.living_=address2_.id__ where address0_.id__=?

HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [11]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_3_] : [BIGINT]) - [11]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [FooStreet1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1Foo]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo11]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [11.0]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [11]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_3_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_3_] : [VARCHAR]) - [11 living]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_3_] : [VARCHAR]) - [LivingCity11]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]

HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [12]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_3_] : [BIGINT]) - [12]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo12]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [12.0]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [12]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_3_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_3_] : [VARCHAR]) - [12 living]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_3_] : [VARCHAR]) - [LivingCity12]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]

HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [13]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_3_] : [BIGINT]) - [13]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo13]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [13.0]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [13]
Address.setId()
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_3_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_3_] : [VARCHAR]) - [13 living]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_3_] : [VARCHAR]) - [LivingCity13]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]

HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [14]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_3_] : [BIGINT]) - [14]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo14]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [14.0]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [14]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_3_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_3_] : [VARCHAR]) - [14 living]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_3_] : [VARCHAR]) - [LivingCity14]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 12:18:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]

/ **
employee	Employee  (id=61)	
	address	Address  (id=50)	
	id	11	
	living	Address  (id=63)	

/ ***
/ GEEN queries	, geen 1+N probleem	



/ of	,


/ 13	.

/ N_1_bidir_fetch_ehcache

/ CollFetchApp	,

/ <set ... fetch="join" >
/ <many-to-one fetch="select"

/ There are 5 working addressees	, and at each one there work 5 Employees	,
/ the employees also have a living address	,

/ 1313	

/ Address
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
 		fetch="join"
 	>
<!--  		<cache usage="read-write"/>	
 --> 		
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"
		fetch="select"

	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="select"
	/>

/ CollFetchApp	,
			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Foo"));
			List<Address>addresses=criteria.list();
/*
			ListIterator<Address>listIterator=addresses.listIterator();
			while(listIterator.hasNext()){
				Address address=(Address)listIterator.next();
				Set<Employee>employees=address.getEmployees();
				Iterator<Employee>iterator=employees.iterator();
/**
				while (iterator.hasNext()) {
					Employee employee = (Employee) iterator.next();
					Address living =employee.getLiving();
					String zip=living.getZipcode();
/***

/*

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address this_ 
left outer join employee employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Foo]

HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [11]
Address.setId()
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [FooStreet 1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [1 Foo]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [FooCity1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [11]

HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo12]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [12.0]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [12]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [12]

HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [21]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo21]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [21.0]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [21]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [FooStreet 2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [2 Foo]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [FooCity2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [21]

HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [22]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo22]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [22.0]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [22]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [2]
HibernateLog --> 14:05:27 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [22]

/ **
/ NOTHING

/ ***
/ 1+N problem

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.address_ as address_4_0_1_, employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 
from address address0_ 
left outer join employee employees1_ on address0_.id__=employees1_.address_ 
where address0_.id__=?
HibernateLog --> 14:51:14 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 14:51:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [null]
HibernateLog --> 14:51:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 14:51:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 living]
HibernateLog --> 14:51:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity12]
HibernateLog --> 14:51:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [null]

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.address_ as address_4_0_1_, employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 
from address address0_ 
left outer join employee employees1_ on address0_.id__=employees1_.address_ 
where address0_.id__=?
HibernateLog --> 14:53:11 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [11]
HibernateLog --> 14:53:11 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [null]
HibernateLog --> 14:53:11 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 14:53:11 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [11 living]
HibernateLog --> 14:53:11 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity11]
HibernateLog --> 14:53:11 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [null]

/ TODO (why join met employee)

/ we see	,
employee	Employee  (id=30)	
	address	Address  (id=39)	
	living	Address_$$_jvst5e5_1  (id=32)	

/ 1313	

/ Address
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
 		fetch="join"
 	>
<!--  		<cache usage="read-write"/>	
 --> 		
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"
		fetch="select"

	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="join"		/ !
	/>

/ CollFetchApp	,
			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Foo"));
			List<Address>addresses=criteria.list();
/*
			ListIterator<Address>listIterator=addresses.listIterator();
			while(listIterator.hasNext()){
				Address address=(Address)listIterator.next();
				Set<Employee>employees=address.getEmployees();
				Iterator<Employee>iterator=employees.iterator();
/**
				while (iterator.hasNext()) {
					Employee employee = (Employee) iterator.next();
					Address living =employee.getLiving();
					String zip=living.getZipcode();
/***

/ *
select this_.id__ as id__1_0_2_, this_.address_line1__ as address_2_0_2_, this_.zipcode__ as zipcode_3_0_2_, this_.city__ as city__4_0_2_, 
	employees2_.address_ as address_4_0_4_, employees2_.id_ as id_1_1_4_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_, address3_.id__ as id__1_0_1_, 
	address3_.address_line1__ as address_2_0_1_, address3_.zipcode__ as zipcode_3_0_1_, address3_.city__ as city__4_0_1_ 
from address this_ 
left outer join employee employees2_ on this_.id__=employees2_.address_ 
left outer join address address3_ on employees2_.living_=address3_.id__ where this_.zipcode__ like ?

HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Foo]

HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [11]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [11]
Address.setId()
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [11 living]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [LivingCity11]
Address.setId()
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [FooStreet 1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [1 Foo]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [FooCity1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_4_] : [BIGINT]) - [1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_4_] : [BIGINT]) - [11]

HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [12]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo12]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [12.0]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [12]
Address.setId()
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [12 living]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [LivingCity12]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_4_] : [BIGINT]) - [1]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_4_] : [BIGINT]) - [12]

HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [21]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [21]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo21]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [21.0]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [21]
Address.setId()
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [21 living]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [LivingCity21]
Address.setId()
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [FooStreet 2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [2 Foo]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [FooCity2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_4_] : [BIGINT]) - [2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_4_] : [BIGINT]) - [21]

HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [22]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [22]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo22]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [22.0]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [22]
Address.setId()
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [22 living]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [LivingCity22]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_4_] : [BIGINT]) - [2]
HibernateLog --> 15:00:54 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_4_] : [BIGINT]) - [22]

/**
/ NOTHING
/***
/ NOTHING

/ we see	,
 
employee	Employee  (id=30)	
	address	Address  (id=32)	
	living	Address  (id=45)	



/ 13	.

/ N_1_bidir_fetch_ehcache

/ EntFetchApp	,

/ SAMENVATTING

/ <set ... fetch="join" >
/ <many-to-one fetch


/ Address
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
 		fetch="select/subselect/join"
 	>
<!--  		<cache usage="read-write"/>	
 --> 		
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"
		fetch="select/join"

	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="select/join"
	/>

/ EntFetchApp

			Address address2=(Address)session.get(Address.class, 1l);
/*
			Set<Employee>employees=address2.getEmployees();
			Iterator<Employee>iterator=employees.iterator();
/**
			while (iterator.hasNext()) {
				Employee employee = (Employee) iterator.next();
				Address living =employee.getLiving();
				String zip=living.getZipcode();
/***

/ 1313
<set fetch="select">, <many-to-one name="living" fetch ="select">
/*
/ 1 querie Address#1
/ **
/ 1 querie 5 Employee#1i
/ ***
/ for each Employee#1i queries living Address#1i	: N+1 problem	,

/ 1313
<set fetch="join">, <many-to-one name="living" fetch ="select">
/*
/ queries Address#1 en 5 Employee#1i
/ **
/ nothig 
/ ***
/ for each Employee#1i queries living Address#1i	: 1+N problem

/ 1313
<set fetch="join">, <many-to-one name="living" fetch ="join">
/*
/ queries Address#1 en 5 Employee#1i
/ **
/ nothig 
/ ***
/ for each Employee#1i queries living Address#1i	: 1+N problem		



/ Einde SAMENVATTING

/ 7	 .

/ Hibenate.init

/ 7	. 

/ component_ehcache

/ een Employee heeft een Address, maar nu is Address geen entity, maar een component	,

/ Lees	,
http://www.tutorialspoint.com/hibernate/hibernate_component_mappings.htm

/ Address.hbm.xml is er nu niet	, de H config van Address is nu in Employee.hbm.xml	, Address is geen zelfstandige entity	,

/ In hibernate.cfg.xml moeten we alleen Address.hbm.xml	,

/ Employee
/ 	eigne H. props	,
	<component name="address" class="Address">
			<property
				name="addressLine1"
				column="address_line1__"
			/>
			<property 
				name="zipcode" 
				column="zipcode__">
			</property>
			<property 
				name="city"
				column="city__">
			</property>
	</component>

/ er is dus GEEN Address.hbm.xml

/ Employee	,
    private long id;
    private String name;
    private double salary;
    private Address address;
    public Employee(Long id,String name, double salary) {

/ Address	,
	public class Address {
	    private String addressLine1;
	    private String zipcode;
	    private String city;

/ Main	,
/ 1ste session	,
			Address address=new Address("foostreet", "12 foo", "FooCity12");
			Employee employee=new Employee(1l,"Foo1",1.00);
			employee.setAddress(address);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			employee2.setAddress(address);

			session.save(employee);
			session.save(employee2);

			tx.commit();

/ we zien	,

Hibernate: insert into employee (name_, salary_, address_line1__, zipcode__, city__, id_) values (?, ?, ?, ?, ?, ?)
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [foostreet]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [VARCHAR] - [12 foo]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [VARCHAR] - [FooCity12]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [6] as [BIGINT] - [1]

Hibernate: insert into employee (name_, salary_, address_line1__, zipcode__, city__, id_) values (?, ?, ?, ?, ?, ?)
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [foostreet]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [VARCHAR] - [12 foo]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [VARCHAR] - [FooCity12]
HibernateLog --> 16:33:56 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [6] as [BIGINT] - [2]

foo=> select*from employee;
 id_ | name_ | salary_ | address_line1__ | zipcode__ |  city__   
-----+-------+---------+-----------------+-----------+-----------
   1 | Foo1  |       1 | foostreet       | 12 foo    | FooCity12
   2 | Foo2  |       2 | foostreet       | 12 foo    | FooCity12
(2 rows)

/ 2de session	,
	        employee = (Employee) session.get(Employee.class, 1l);

/ we zien	,
employee	Employee  (id=46)	
	address	Address  (id=49)	
		addressLine1	"foostreet" (id=54)	
		city	"FooCity12" (id=55)	
		zipcode	"12 foo" (id=56)	
	id	1	
	name	"Foo1" (id=50)	
	salary	1.0	

			




/ 7	.

/ 1_N_bidir_ehcache

/ lazy, coll
/ lazy, ref	,

/ Met <set lazy="false/true/extra" name="employees"> wordt de coll init bij .get(container)/ coll.size()/ coll.iterate()
/ Met <many-to-one lazy="false/proxy/no-proxy" class="Address"> is container.item  een proxy of een inst	, doen we later proxy.mth()	, dan wordt de proxy init	, dus wordt alsnog de inst create, maar dan als proxy.handler.target	,
/ Met <class lazy="true/false" name="Address"> hetzelfde result als <many-to-one lazy="false/proxy" class="Address">	,

/ We kunnen bij bidir combineren: 
<class name="Address" lazy="true/false">
	<set lazy="true" name="employees"> 	/ lazy=true is de default	,

/ Main	,
/ 2de session	,
	        address=(Address)session.get(Address.class, 12l);
	        Set<Employee>employees=address.getEmployees();
	        Iterator<Employee>iterator=employees.iterator();
	        while(iterator.hasNext()){
	        	Employee e=iterator.next();

/ als <class name="Address" lazy="false"> 
/ e.getAddress()=Address inst	,
/ als <class name="Address" lazy="true"> 
/ e.getAddress()=Address proxy 

/ Maar we kunnen het ook <many-to-one doen	,

<class name="Address" lazy="true">		/ default	,
	<set lazy="true" name="employees"> 	/ default	,

<class name="Employee">
	<many-to-one lazy="false/proxy">

/ als <many-to-one lazy="false">	, dan is e.getAddress()=Address inst	,
/ als <many-to-one lazy="true">	, 	dan is e.getAddress()=Address proxy	,

/ 7	.

/ N_1_bidir_ehcache	,

<class 
	name="Address"
>
	<set
 		name="employees"
 		inverse="true"
 		lazy="extra"
 	>

<class 
	name="Employee" 
>
	<many-to-one 
...
		lazy="false"
	/>

/ Main	,

	        employee = (Employee) session.get(Employee.class, 1l);
/ employee.address=Address proxy/instance	 als <many-to-one lazy="proxy/false">

	        address=(Address)session.get(Address.class, 12l);
	        Set<Employee>employees=address.getEmployees();
/ GEEN coll.init	, want lazy=extra	,
	        employees.size();
/ size query	, want lazy=extra	,
	        Iterator<Employee>iterator=employees.iterator();
	        while(iterator.hasNext()){
	        	Employee e=iterator.next();
/ e.address=Address inst	, want lazy=false	,

/ Ipv. lazy=false in <many-to-one ...> kunnen we ook <class name="Address" lazy="false">

/ 13	. 

/ lazy init exception	, als je een proxy hebt, en buiten de session (tussen 2 sessions door)	, een method call op de proxy	, H. kan dan niet de proxy init	,




/ 13	. 

/ N_1_bidir_ehcache	,

/ we query een Employee not lazy	, welke queries zien we?

/ Employee	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"
		insert="false"
		update="false"
		lazy="false"
	/>

/ Main	,
	        employee = (Employee) session.get(Employee.class, 1l);


select employee0_.id_ as id_1_1_0_, employee0_.name_ as name_2_1_0_, employee0_.salary_ as salary_3_1_0_, employee0_.address_ as address_4_1_0_ 
from employee employee0_ 
where employee0_.id_=?
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo1]
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [1.0]
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [12]

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address address0_ 
where address0_.id__=?
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [foostreet]
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [12 foo]
HibernateLog --> 11:11:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity12]

/ we zien dat meteen ook de Address ref , Address#12 resolved is	,




/ Einde HIBERNATE PERFORMANCE

/ HIBERNATE PERFORMANCE

/ hibernate_xml_N_1_bidir_fetch_coll_ehcache  

/ TMP


			Query query=session.createQuery("from Address a left join  a.employees where a.zipcode like '%Work'" );

select address0_.id__ as id__1_0_0_, employees1_.id_ as id_1_1_1_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

			Query query=session.createQuery("from Address a left join fetch  a.employees where a.zipcode like '%Work'" );

select address0_.id__ as id__1_0_0_, employees1_.id_ as id_1_1_1_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_, employees1_.address_ as address_4_0_0__, employees1_.id_ as id_1_1_0__ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'



/ Einde TMP

/ 13

$ vi CollFetch.java

			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Foo"));
			List<Address>addresses=criteria.list();
/*
			ListIterator<Address>listIterator=addresses.listIterator();
			while(listIterator.hasNext()){
				Address address=(Address)listIterator.next();
				Set<Employee>employees=address.getEmployees();
				Iterator<Employee>iterator=employees.iterator();
/**
				while (iterator.hasNext()) {
					Employee employee = (Employee) iterator.next();
					Address living =employee.getLiving();
					String zip=living.getZipcode();
/***



/ Address
<class 
	name="Address" 
	table="address_coll"
>
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
		fetch="select"
 	>
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
<class 
	name="Employee" 
	table="employee_coll"
>
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"
		fetch="select"
	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="select"
	/>

/*
select this_.id__ as id__1_0_0_, this_.address_line1__ as address_2_0_0_, this_.zipcode__ as zipcode_3_0_0_, this_.city__ as city__4_0_0_ 
from address_coll this_ 
where this_.zipcode__ like ?
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Foo]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [FooStreet 1]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1 Foo]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity1]

HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [2]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [FooStreet 2]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [2 Foo]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity2]

HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [3]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [FooStreet 3]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [3 Foo]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity3]

HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [4]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [FooStreet 4]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [4 Foo]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity4]

HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [5]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [FooStreet 5]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [5 Foo]
HibernateLog --> 07:33:08 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [FooCity5]

/**
/ N keer, een coll

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo11]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [11.0]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [11]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]

HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo12]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [12.0]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [12]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]

HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo13]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [13.0]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [13]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]

HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo14]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [14.0]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [14]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]

HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo15]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [15.0]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [15]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:35:10 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]

/***
/ N keer	, een entity	,
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address_coll address0_ 
where address0_.id__=?
HibernateLog --> 07:39:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [13]

HibernateLog --> 07:39:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 07:39:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [13 living]
HibernateLog --> 07:39:01 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity13]


/ 13

/ Address
<class 
	name="Address" 
	table="address_coll"
>
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
		fetch="join"
 	>
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
<class 
	name="Employee" 
	table="employee_coll"
>
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"
		fetch="select"
	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="select"
	/>

/ HIER HIER

/*
/ join van de set met de owner	,

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address_coll this_ 
left outer join employee_coll employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 07:44:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Foo]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [111]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [WorkStreet 1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [1 Work]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [WorkCity1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [11]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo12]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [12.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [112]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [12]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo13]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [13.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [113]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [13]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo14]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [14.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [114]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [14]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo15]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [15.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [115]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [15]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [21]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo21]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [21.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [121]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [WorkStreet 2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [2 Work]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [WorkCity2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [21]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [22]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo22]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [22.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [122]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [22]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [23]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo23]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [23.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [123]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [23]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [24]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo24]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [24.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [124]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [24]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [25]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo25]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [25.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [125]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [2]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [25]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [31]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo31]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [31.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [131]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [WorkStreet 3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [3 Work]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [WorkCity3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [31]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [32]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo32]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [32.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [132]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [32]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [33]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo33]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [33.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [133]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [33]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [34]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo34]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [34.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [134]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [34]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [35]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo35]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [35.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [135]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [3]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [35]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [41]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo41]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [41.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [141]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [WorkStreet 4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [4 Work]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [WorkCity4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [41]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [42]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo42]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [42.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [142]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [42]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [43]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo43]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [43.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [143]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [43]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [44]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo44]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [44.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [144]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [44]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [45]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo45]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [45.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [145]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [4]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [45]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [51]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo51]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [51.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [151]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [WorkStreet 5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [5 Work]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [WorkCity5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [51]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [52]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo52]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [52.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [152]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [52]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [53]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo53]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [53.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [153]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [53]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [54]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo54]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [54.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [154]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [54]

HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [55]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo55]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [55.0]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [155]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [5]
HibernateLog --> 09:42:57 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [55]




/ **
/ NO QJUERY, zit al in de join bij *

/ ***
/ N queries	, steeds een ent, een living address	, 

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.address_ as address_4_0_1_, employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.id__=?
HibernateLog --> 07:49:35 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [15]

HibernateLog --> 07:49:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [null]
HibernateLog --> 07:49:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 07:49:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [15 living]
HibernateLog --> 07:49:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity15]
HibernateLog --> 07:49:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [null]

/ Die null's zijn de id en address fk van de employee die werkt op living address 15	, die employee is er niet	,

/ Waarom doet hij hier een join met een employee, die op die living address zou werken?
/ TODO

/ 13	.

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
		fetch="select"
 	>
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		lazy="proxy"
		fetch="select"
	/>
	<many-to-one 
		name="living"
		column="living_"
		not-null="false"
		lazy="proxy"
		fetch="join"
	/>


/ CollFetchApp	,
			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Foo"));
			List<Address>addresses=criteria.list();
/*
			ListIterator<Address>listIterator=addresses.listIterator();
			while(listIterator.hasNext()){
				Address address=(Address)listIterator.next();
				System.out.println("ZIP: "+address.getZipcode());
				Set<Employee>employees=address.getEmployees();
				Iterator<Employee>iterator=employees.iterator();
/**
				while (iterator.hasNext()) {
					Employee employee = (Employee) iterator.next();
					Address living =employee.getLiving();
					String zip=living.getZipcode();
/***
					boolean b=false;

/*
list van work addresses	,
/**
list van employees & their living address	,
/***
/ NO QUERY	,

/**
select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_, 
	address1_.id__ as id__1_0_2_, address1_.address_line1__ as address_2_0_2_, address1_.zipcode__ as zipcode_3_0_2_, address1_.city__ as city__4_0_2_ 
from employee_coll employees0_ 
left outer join address_coll address1_ on employees0_.living_=address1_.id__ 
where employees0_.address_=?

HibernateLog --> 09:14:47 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [111]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo11]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [11.0]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [111]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [111 living]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity111]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]

HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [112]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo12]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [12.0]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [112]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [112 living]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity112]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]

HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [113]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo13]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [13.0]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [113]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [113 living]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity113]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]

HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [114]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo14]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [14.0]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [114]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [114 living]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity114]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]

HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_2_] : [BIGINT]) - [115]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo15]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [15.0]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [115]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_2_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_2_] : [VARCHAR]) - [115 living]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_2_] : [VARCHAR]) - [LivingCity115]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 09:14:48 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]

/ 13	.

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 		lazy="false"
		fetch="select"
 	>
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ OR
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
		fetch="join"
 	>


/ CollFetchApp	,
			Address address=(Address)session.get(Address.class, 1l);
/*
			Set<Employee>employees=address.getEmployees();
			Iterator<Employee>iterator=employees.iterator();
			while (iterator.hasNext()) {
				Employee employee = (Employee) iterator.next();
				Address living =employee.getLiving();
				String zip=living.getZipcode();
/**
				boolean b=false;
				
			}

/ we hebben 1 work address	,  

/*
/ with lazy=false, there are 2 queries , with fetch=join, 1 query	,
/ with fetch=join, we kunnen lazy=true/false	,

/** 
/ In both cases the same: 1+N problem, for every zip a new query for the address	,

/ with lazy false : there are 2 queries	, because in Address's mapping	, <set lazy=false> , dus in een living address wil hij de set van employees init	, die er niet zijn	, 
/ Ook hier probeert H de set van employees van een living address te init	, maar die is er niet, vandaar de nulls	,


/*
/ lazy=false, fetch="select"	,

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ from address_coll address0_ where address0_.id__=?
HibernateLog --> 07:37:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 07:37:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [WorkStreet 1]
HibernateLog --> 07:37:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1 Work]
HibernateLog --> 07:37:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [WorkCity1]
HibernateLog --> 07:37:05 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address.employees#1]

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ from employee_coll employees0_ where employees0_.address_=?
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo11]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [11.0]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [111]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo12]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [12.0]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [112]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo13]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [13.0]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [113]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo14]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [14.0]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [114]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo15]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [15.0]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [115]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 07:20:28 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]

/**
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address_coll address0_ 
where address0_.id__=?
HibernateLog --> 08:32:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [115]
HibernateLog --> 08:32:43 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 08:32:43 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [115 living]
HibernateLog --> 08:32:43 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity115]

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?
HibernateLog --> 08:32:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [115]


/*
/ lazy=true, fetch=join

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.address_ as address_4_0_1_, 
	employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.id__=?
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]

HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [11]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [WorkStreet 1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1 Work]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [WorkCity1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo11]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [11.0]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [111]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [12]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo12]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [12.0]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [112]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [13]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo13]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [13.0]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [113]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [14]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo14]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [14.0]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [114]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [15]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_2_] : [VARCHAR]) - [Foo15]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_2_] : [DOUBLE]) - [15.0]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_2_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_2_] : [BIGINT]) - [115]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [1]
HibernateLog --> 07:26:38 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]

/ **

select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.address_ as address_4_0_1_, employees1_.id_ as id_1_1_1_, employees1_.id_ as id_1_1_2_, employees1_.name_ as name_2_1_2_, employees1_.salary_ as salary_3_1_2_, employees1_.address_ as address_4_1_2_, employees1_.living_ as living_5_1_2_ 
from address_coll address0_ left 
outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.id__=?
HibernateLog --> 08:40:17 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [111]
HibernateLog --> 08:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_2_] : [BIGINT]) - [null]
Address.setId()
HibernateLog --> 08:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 08:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [111 living]
HibernateLog --> 08:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity111]
HibernateLog --> 08:40:17 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_1_] : [BIGINT]) - [null]
Address.setAddressLine1()

/ Ook hier probeert H de set van employees van een living address te init	, maar die is er niet, vandaar de nulls	,


/ 13	.

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 		lazy="false"
		fetch="select"
 	>
 		<key
 			column="address_"
 			not-null="false"
 		/>
 		<one-to-many class="Employee"/>
 	</set>

/ CollFetchApp	,

			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Work"));
			List<Address>addresses=criteria.list();
/*
			ListIterator<Address>listIterator=addresses.listIterator();
			while(listIterator.hasNext()){
				Address address=(Address)listIterator.next();
				Set<Employee>employees=address.getEmployees();
				Iterator<Employee>iterator=employees.iterator();
				while (iterator.hasNext()) {
					Employee employee = (Employee) iterator.next();
					Address living =employee.getLiving();
					String zip=living.getZipcode();
/**
					
				}
			}

/ Nu een coll work addresses	, zonet 1 work address	,

'/ bij ** zien we  een overbodige query , omdat <set lazy=false> wil H ook bij een living address de set van employees fill (er werken geen employees op het living address, dus de set is leeg)	, op de lazy=false manier, dwz een query er na, geen join	,

/*
select this_.id__ as id__1_0_0_, this_.address_line1__ as address_2_0_0_, this_.zipcode__ as zipcode_3_0_0_, this_.city__ as city__4_0_0_ 
from address_coll this_ 
where this_.zipcode__ like ?
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [WorkStreet 1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [1 Work]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [WorkCity1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [WorkStreet 2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [2 Work]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [WorkCity2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [WorkStreet 3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [3 Work]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [WorkCity3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [WorkStreet 4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [4 Work]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [WorkCity4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_0_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [WorkStreet 5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [5 Work]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [WorkCity5]

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [51]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo51]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [51.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [151]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [51]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [52]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo52]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [52.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [152]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [52]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [53]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo53]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [53.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [153]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [53]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [54]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo54]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [54.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [154]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [54]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [55]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo55]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [55.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [155]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [5]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [55]

Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ from employee_coll employees0_ where employees0_.address_=?
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [41]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo41]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [41.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [141]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [41]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [42]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo42]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [42.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [142]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [42]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [43]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo43]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [43.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [143]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [43]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [44]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo44]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [44.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [144]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [44]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [45]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo45]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [45.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [145]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [4]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [45]

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [31]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo31]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [31.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [131]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [31]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [32]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo32]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [32.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [132]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [32]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [33]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo33]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [33.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [133]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [33]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [34]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo34]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [34.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [134]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [34]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [35]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo35]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [35.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [135]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [3]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [35]

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ where employees0_.address_=?
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [21]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo21]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [21.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [121]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [21]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [22]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo22]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [22.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [122]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [22]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [23]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo23]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [23.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [123]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [23]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [24]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo24]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [24.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [124]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [24]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [25]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo25]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [25.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [125]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [2]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [25]

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [11]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo11]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [11.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [111]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [12]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo12]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [12.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [112]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [13]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo13]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [13.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [113]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [14]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo14]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [14.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [114]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [14]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [15]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo15]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [15.0]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_1_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_1_] : [BIGINT]) - [115]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [1]
HibernateLog --> 08:18:05 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [15]

/**
select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_ 
from address_coll address0_ 
where address0_.id__=?
HibernateLog --> 08:21:51 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [113]
HibernateLog --> 08:21:51 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_0_] : [VARCHAR]) - [LivingStreet]
HibernateLog --> 08:21:51 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_0_] : [VARCHAR]) - [113 living]
HibernateLog --> 08:21:51 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_0_] : [VARCHAR]) - [LivingCity113]

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?
HibernateLog --> 08:21:51 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [113]

/ we zien extra query, nutteloos bij een living address	, maar dat komt dus door de <set lazy=false>	: een living address heeft ook een set, en deze probeert hij te init	, bij fetch="join" zien we nulls	, 

/ 13	.

/ Address	,
	<set
 		name="employees"
 		inverse="true"
 		lazy="true"
		fetch="join"
 	>

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address_coll this_ 
left outer join employee_coll employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 09:50:15 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

HibernateLog --> 09:50:58 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 09:51:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 09:51:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 09:51:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 09:51:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:51:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [111]
HibernateLog --> 09:51:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [WorkStreet 1]
HibernateLog --> 09:51:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [1 Work]
HibernateLog --> 09:51:35 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [WorkCity1]
HibernateLog --> 09:51:36 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 09:51:36 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [11]

HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo12]
HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [12.0]
HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [112]
HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 09:52:13 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [12]

HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [13]
HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo13]
HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [13.0]
HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [113]
HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 10:01:14 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [13]

/ 13	. 

/ We debug	,

			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Work"));
			List<Address>addresses=criteria.list();
/s
SessionImpl.list(Criteria) line: 1682	
			for( int i=0; i<size; i++ ) {
/ size=1
				final List currentResults = loaders[i].list(this);
/s
CriteriaLoader(Loader).doList(SessionImplementor, QueryParameters, ResultTransformer) line: 2553	
			result = doQueryAndInitializeNonLazyCollections( session, queryParameters, true, forcedResultTransformer );
/s
CriteriaLoader(Loader).doQueryAndInitializeNonLazyCollections(SessionImplementor, QueryParameters, boolean, ResultTransformer) line: 354	
				result = doQuery( session, queryParameters, returnProxies, forcedResultTransformer );
/s
CriteriaLoader(Loader).doQuery(SessionImplementor, QueryParameters, boolean, ResultTransformer) line: 910	
		final SqlStatementWrapper wrapper = executeQueryStatement( queryParameters, false, afterLoadActions, session );

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address_coll this_ 
left outer join employee_coll employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 10:24:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

			return processResultSet( rs, queryParameters, session, returnProxies, forcedResultTransformer, maxRows, afterLoadActions );
/s
		for ( count = 0; count < maxRows && rs.next(); count++ ) {
			if ( DEBUG_ENABLED )
				LOG.debugf( "Result set row: %s", count );
			Object result = getRowFromResultSet(
					rs,
					session,
					queryParameters,
					lockModesArray,
					optionalObjectKey,
					hydratedObjects,
					keys,
					returnProxies,
					forcedResultTransformer
			);
/ 1ste	,

HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [11]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo11]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [11.0]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [111]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_2_0_1_] : [VARCHAR]) - [WorkStreet 1]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([zipcode_3_0_1_] : [VARCHAR]) - [1 Work]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([city__4_0_1_] : [VARCHAR]) - [WorkCity1]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 10:36:29 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [11]

/ we zien	,
result	Address  (id=3212)	
	addressLine1	null	
	city	null	
	employees	HashSet<E>  (id=3213)	
[]
	id	1	
	zipcode	null	

/ 2de	,

HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [12]
HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id__1_0_1_] : [BIGINT]) - [1]
HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_0_] : [VARCHAR]) - [Foo12]
HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_0_] : [DOUBLE]) - [12.0]
HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_1_0_] : [BIGINT]) - [1]
HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([living_5_1_0_] : [BIGINT]) - [112]
HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_3_] : [BIGINT]) - [1]
HibernateLog --> 10:37:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_3_] : [BIGINT]) - [12]

/ we zien	,
result	Address  (id=3212)	
	addressLine1	null	
	city	null	
	employees	HashSet<E>  (id=3213)	
[]
	id	1	
	zipcode	null	

/ 3de, ..., 25ste	,

/ 13	.

/ Lees boek(674)

/ Maar als we	,

			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Work"));
			criteria.setResultTransformer(org.hibernate.Criteria.DISTINCT_ROOT_ENTITY);
			List<Address>addresses=criteria.list();

/ dan zien we precies dezelfde result set (25 entries)	, maar H maakt nu maar 5 addresses	, ipv 25	, elk met de set van 5 Employee's	, 
/ TODO 

/ Als we 
	lazy="false"
	fetch="select"
/ dan zien we 2 queries, eerst de 5 Address's	, en worden er 5 addresses create	, en dan een query die 25 Employee's geeft	, die worden in de sets van deze 5 Address's set	, 

/ we kunnen ook in HQL	,

			Query query=session.createQuery("select distinct a from Address a left join fetch a.employees where a.zipcode like '%Work'" );
			List<Address>addresses=query.list();
			ListIterator<Address>listIterator=addresses.listIterator();
			while(listIterator.hasNext()){
				Address address=(Address)listIterator.next();
...

/ 13	.

/ Lees boek(671)

/ we kunnen joins maken met criteria, door ze achter elkaar te schakelen, 
/ ipv createCriteria kunnen we ook .createAlias	, 

/ TMP
			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Work"));
			criteria.createAlias("employees", "es");
			criteria.setResultTransformer(org.hibernate.Criteria.DISTINCT_ROOT_ENTITY);
			List<Address>addresses=criteria.list();
			ListIterator<Address>listIterator=addresses.listIterator();
			while(listIterator.hasNext()){
				Address address=(Address)listIterator.next();

/we zien	,

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	es1_.id_ as id_1_1_0_, es1_.name_ as name_2_1_0_, es1_.salary_ as salary_3_1_0_, es1_.address_ as address_4_1_0_, es1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll es1_ on this_.id__=es1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 08:16:47 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

 
/ 7	.

/ DIFFERENCE JOIN & JOIN FETCH IN HQL



/ 13	.

			Query query=session.createQuery("from Address a left join  a.employees  where a.zipcode like '%Work'" );
/=
			Query query=session.createQuery("select a,es from Address a left join  a.employees es  where a.zipcode like '%Work'" );

			List<Address>addresses=query.list();

select address0_.id__ as id__1_0_0_, employees1_.id_ as id_1_1_1_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

addresses	ArrayList<E>  (id=42)	
	elementData	Object[25]  (id=59)	
		[0]	Object[2]  (id=61)	
			[0]	Address  (id=66)	
			[1]	Employee  (id=67)	
		[1]	Object[2]  (id=62)	
			[0]	Address  (id=66)	
			[1]	Employee  (id=70)	

/ Er zijn 25 van deze entries	, 
/ Address#1 bijv 5 keer , en bij elk, 	Employee#j (j=1,...,5)	, 
/ dus Address#1 zien we 5 keer	, en iedere Emplooyee is een andere	,
/ er zijn 5 Address insts	, 25 Employee insts	,
/ Maar de set in ieder van de 5 Address's is LEEG	, en bij een "left join fetch" is de set NIET leeg	,
////////////////////////////////////////////////////////

/ 13	.

			Query query=session.createQuery(" select a from Address a left join  a.employees  where a.zipcode like '%Work'" );
			List<Address>addresses=query.list();

select address0_.id__ as id__1_0_, address0_.address_line1__ as address_2_0_, address0_.zipcode__ as zipcode_3_0_, address0_.city__ as city__4_0_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

/we zien	,
addresses	ArrayList<E>  (id=113)	
	elementData	Object[25]  (id=114)	
		[0]	Address  (id=65)	
...
/ we zien 25 entries	, 5 verschillende Address insts	, de PersistenSet's zijn LEEG	, 
/ Dat is wel logisch, 	want we select a	, en niet a,es	, als es alias voor a.employees	,
//////////////////////////////////////////////////////////////////
/ als we click op een PersistentSet	, dan 	,
select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?

/13	.

			Query query=session.createQuery(" select distinct a from Address a left join  a.employees  where a.zipcode like '%Work'" );
			List<Address>addresses=query.list();

select distinct address0_.id__ as id__1_0_, address0_.address_line1__ as address_2_0_, address0_.zipcode__ as zipcode_3_0_, address0_.city__ as city__4_0_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

/ we zien	,
addresses	ArrayList<E>  (id=243)	
	elementData	Object[7]  (id=244)	
		[0]	Address  (id=131)	
		[1]	Address  (id=152)	
...
/ we zien 5 entries, 5 verschillende Address insts	, met lege PersistenSet, want we query alleen naar a	, niet naar a,es waar es alias voor a.employees	,


/ 13	.
			Query query=session.createQuery(" from Address a left join fetch a.employees  where a.zipcode like '%Work'" );
/ =
			Query query=session.createQuery(" select a from Address a left join fetch  a.employees  where a.zipcode like '%Work'" );
			List<Address>addresses=query.list();

select address0_.id__ as id__1_0_0_, 
	employees1_.id_ as id_1_1_1_, 
	address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_, employees1_.address_ as address_4_0_0__, employees1_.id_ as id_1_1_0__ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

addresses	ArrayList<E>  (id=146)	
	elementData	Object[25]  (id=147)	
		[0]	Address  (id=66)	
		[1]	Address  (id=66)	
		[2]	Address  (id=66)	
		[3]	Address  (id=66)	
		[4]	Address  (id=66)	
		[5]	Address  (id=142)	
		[6]	Address  (id=142)	
		[7]	Address  (id=142)	
....

/ we zien 25 entries	5 verschillende Address insts	, ze hebben alle 5 een INITIALIZED PersistentSet	, omdat we "left join fetch" doen	,

/ als we in debugger click op een PersistentSet	, zien we	,

select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_, employees0_.living_ as living_5_1_1_ 
from employee_coll employees0_ 
where employees0_.address_=?
HibernateLog --> 12:27:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [5]

/ Dus in 1 van de 5 Address's is de set init	,  

/ 13	.

			Query query=session.createQuery("  select distinct a from Address a left join fetch  a.employees  where a.zipcode like '%Work'" );
			List<Address>addresses=query.list();

select distinct address0_.id__ as id__1_0_0_, 
	employees1_.id_ as id_1_1_1_, 
	address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_, employees1_.address_ as address_4_0_0__, employees1_.id_ as id_1_1_0__ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

/ we zien 5 entries	, 5 verschillende Address inst	, elk met INITIALIZED set	,

/ 13	.
			Query query=session.createQuery(" from Address a left join fetch a.employees  where a.zipcode like '%Work'" );
/=
			Query query=session.createQuery("select a  from Address a left join fetch a.employees  where a.zipcode like '%Work'" );
/=
			Query query=session.createQuery("select a,es  from Address a left join fetch a.employees es where a.zipcode like '%Work'" );
/ TODO

/ 13	. 

/ criteria, fetch join	,

/ SAMENVATTING CRITERIA

file:///home/eric/Devel/Java/Ehcache/hibernate_xml_N_1_bidir_fetch_coll_ehcache 

/ 7	. 

/ De global 
<set fetch="join"></set>
/ werkt WEL met criteria	,
/ we kunnen ook
	.setFetchMode(...,FetchMode.JOIN)

/ 7	. 

/ Verschil	,

/ A
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
/ B
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createAlias("employees", "employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
/ C
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		

/ A
/ WH of,	
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)


/ A
select this_.id__ as id__1_0_0_, this_.address_line1__ as address_2_0_0_, this_.zipcode__ as zipcode_3_0_0_, this_.city__ as city__4_0_0_ 
from address_coll this_ 
where this_.zipcode__ like ?

/ 5 Adddress	, elk Address heeft lege set van Employees	,

/ B
select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees1_.id_ as id_1_1_0_, employees1_.name_ as name_2_1_0_, employees1_.salary_ as salary_3_1_0_, employees1_.address_ as address_4_1_0_, employees1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employees1_ on this_.id__=employees1_.address_ 
where this_.zipcode__ like ?

/ 15 paren van Address, Employee, in Address is employees set leeg	,

/ C
select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employee1_.id_ as id_1_1_0_, employee1_.name_ as name_2_1_0_, employee1_.salary_ as salary_3_1_0_, employee1_.address_ as address_4_1_0_, employee1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employee1_ on this_.id__=employee1_.address_ 
where this_.zipcode__ like ?

/ 15 Address	, elk met lege employees set	,

/ MORGEN

/ 7	. 

/ verschil	,
/ A
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
/ B
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createAlias("employees", "employees")
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
/ C
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		


/ De createAlias geeft een Employee result naast de Address result in de hashmap	,
/ Het result met .createAlias  

/ A
select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address_coll this_ 
left outer join employee_coll employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?

/ B
select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees1_.id_ as id_1_1_0_, employees1_.name_ as name_2_1_0_, employees1_.salary_ as salary_3_1_0_, employees1_.address_ as address_4_1_0_, employees1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employees1_ on this_.id__=employees1_.address_ 
where this_.zipcode__ like ?

/ C
select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employee1_.id_ as id_1_1_0_, employee1_.name_ as name_2_1_0_, employee1_.salary_ as salary_3_1_0_, employee1_.address_ as address_4_1_0_, employee1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employee1_ on this_.id__=employee1_.address_ 
where this_.zipcode__ like ?


/ Einde SAMENVATTING CRITERIA



/ we kunnen	,

/ Address.hbm.xml
	<set
 		name="employees"
 		inverse="true"
  		lazy="true"
		fetch="join"
 	>

/ CollFetch.class	,
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		
/ of	,

/ Address.hbm.xml
	<set
 		name="employees"
 		inverse="true"
  		lazy="true"
		fetch="select"
 	>

/ CollFetch.class	,
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		

/ In beide gevallen zien we de set INITIALIZED,

/ 13	. 

/ we houden	,

/ Address.hbm.xml
	<set
 		name="employees"
 		inverse="true"
  		lazy="true"
		fetch="select"
 	>

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees","employees")
				.list();		
/ set is NIET initialized	,

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		
/ set is WEL initialized	,

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createAlias("employees", "employees")
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		
/ set is WEL initialized	,

/ 13	. 

/ Address.hbm.xml
	<set
 		name="employees"
 		inverse="true"
  		lazy="true"
		fetch="select"
 	>

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createAlias("employees", "employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
			for(Object obj:objects){
				Map map=(Map)obj;
				Address address=(Address)map.get(org.hibernate.Criteria.ROOT_ALIAS);
				Employee employee=(Employee)map.get("employees");
				boolean b=false;
			}

/ Nu krijgen we niet Address terug, toen we .setResultTransformer(org.hibernate.Criteria.ROOT_ENITTY) deden	, 
/ Maar	,
/ We zien dat de set in de Address initialized is	, klopt, dat is hij ook bij Criteria.ROOT_ENTITY	,

objects	ArrayList<E>  (id=34)	
	elementData	Object[33]  (id=54)	
		[0]	HashMap<K,V>  (id=56)	
			table	HashMap$Entry<K,V>[4]  (id=61)	
				[1]	HashMap$Entry<K,V>  (id=64)	
					value	Address  (id=71)	
						addressLine1	"WorkStreet 1" (id=76)	
						city	"WorkCity1" (id=77)	
						employees	PersistentSet  (id=78)	
							set	HashSet<E>  (id=88)	
				[3]	HashMap$Entry<K,V>  (id=66)	
					value	Employee  (id=74)	
						address	Address  (id=71)	
						id	11	
						living	Address_$$_jvsta51_0  (id=216)	
						name	"Foo11" (id=233)	
						salary	11.0	

/ 13	. 

/ Als we 	,
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		

/ dan	,
objects	ArrayList<E>  (id=460)	
	elementData	Object[15]  (id=467)	
		[0]	Address  (id=473)	
		[1]	Address  (id=473)	
...
/ De Address's hebben lege set	,

/ 13	. 

/ Deze zijn hetzelfde	,

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		
			boolean b=false;
			}
			{
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees", "employees")
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		
			boolean b=false;
			}

/ MORGEN	,

my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.CollFetchApp at localhost:57664	

/ 1	, 
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
			boolean b=false;
			}
/ 2
			{
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
			boolean b=false;
			}

/ 1
Hibernate: select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, employee1_.id_ as id_1_1_0_, employee1_.name_ as name_2_1_0_, employee1_.salary_ as salary_3_1_0_, employee1_.address_ as address_4_1_0_, employee1_.living_ as living_5_1_0_ from address_coll this_ inner join employee_coll employee1_ on this_.id__=employee1_.address_ where this_.zipcode__ like ?

/ 15 Address's,

/ 2	,
Hibernate: select this_.id__ as id__1_0_0_, this_.address_line1__ as address_2_0_0_, this_.zipcode__ as zipcode_3_0_0_, this_.city__ as city__4_0_0_ from address_coll this_ where this_.zipcode__ like ?

/ 5 Address's,


/ MORGEN	,

/ 13.

/ Verschil 
				.createCriteria("employees")
/ en 
				.createCriteria("employees","employees")

/ Met .createCriteria("employees") zien we 25 HashMap's	, elk met 1 entries: een Address , in de Address is employees NIET initialized	, 
/ Met .createCriteria("employees","employees") zien we 25 HashMap's	, elk met 2 entries: een Address en een Employee	, in de Address is employees NIET initialized	, 

/ Address's mapping	,
	<set
 		name="employees"
 		inverse="true"
  		lazy="true"
		fetch="select"
 	>

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees","employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
/ of	,
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees","employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		

/ Met	,.createCriteria("employees")
/ we zien 25 entries, 5 Address's , in elk Address is de set NIET initialized	,

objects	ArrayList<E>  (id=37)	
	elementData	Object[33]  (id=54)	
		[0]	HashMap<K,V>  (id=56)	
			table	HashMap$Entry<K,V>[1]  (id=84)	
				[0]	HashMap$Entry<K,V>  (id=87)	
					value	Address  (id=93)	
						addressLine1	"WorkStreet 1" (id=95)	
						city	"WorkCity1" (id=96)	
						employees	PersistentSet  (id=97)	
							set	null	
							storedSnapshot	null	
						id	1	
						zipcode	"1 Work" (id=102)	
...
		[24]	HashMap<K,V>  (id=83)	
	size	25	


/ Met	,.createCriteria("employees","employees")	,
/ we zien 25 entries, 5 Address's en voor elk de 5 Employee's , in de Address is de set NIET initialized	,

objects	ArrayList<E>  (id=41)	
	elementData	Object[33]  (id=54)	
		[0]	HashMap<K,V>  (id=56)	
			table	HashMap$Entry<K,V>[4]  (id=87)	
				[1]	HashMap$Entry<K,V>  (id=130)	
					value	Address  (id=71)	
						addressLine1	"WorkStreet 1" (id=73)	
						city	"WorkCity1" (id=74)	
						employees	PersistentSet  (id=75)	
							set 	null	
						id	1	
						zipcode	"1 Work" (id=80)	
				[3]	HashMap$Entry<K,V>  (id=131)	
					value	Employee  (id=158)	
						address	Address  (id=71)	
						id	12	
						living	Address_$$_jvst9c7_0  (id=162)	
						name	"Foo12" (id=168)	
						salary	12.0	
		[2]	HashMap<K,V>  (id=85)	
...
		[24]	HashMap<K,V>  (id=128)	
	size	25	





/ 13	.

/ Maar als we .createCriteria(Employee.class) 	, dan is de set altijd NOT filled	,
/ TODO

/ 13	. 

/ criteria geeft default alleen de root quantity 	,

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		

/ hij geeft alleen Address's	,







/ 13	.

			List<Address>addresses=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employee1_.id_ as id_1_1_0_, employee1_.name_ as name_2_1_0_, employee1_.salary_ as salary_3_1_0_, employee1_.address_ as address_4_1_0_, employee1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employee1_ on this_.id__=employee1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 07:59:30 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

addresses	ArrayList<E>  (id=39)	
	elementData	Object[33]  (id=54)	
		[0]	Address  (id=56)	
...

/ we zien 25 entries, 5 verschillende Address	,  en de Address's set is LEEG	,

/ dit is als	,
			Query query=session.createQuery(" select a from Address a left join  a.employees  where a.zipcode like '%Work'" );

/ 13	.

			List<Address>addresses=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ROOT_ENTITY)
				.list();		

/ we hebben VERVANGEN
				.createCriteria("employees")
/ DOOR
				.setFetchMode("employees", FetchMode.JOIN)

/ we moeten nu NIET OOK
				.createCriteria("employees")
/ want dan doet setFetchMode NIETS	,

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address_coll this_ 
left outer join employee_coll employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 08:49:08 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

addresses	ArrayList<E>  (id=39)	
	elementData	Object[33]  (id=54)	
		[0]	Address  (id=56)	
...

/ we zien 25 entries, 5 verschillende Address	,  en de Address's set is INITIALIZED,

/ dit is als	,
			Query query=session.createQuery(" select a from Address a left join fetch  a.employees  where a.zipcode like '%Work'" );

/ 13	. 

			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			Criterion criterion=Restrictions.like("zipcode", "%Work");
			Projection projection=Projections.id();
			criteria.add(criterion).setProjection(projection);
			List<Object>objects=criteria.list();

select this_.id__ as y0_ 
from address_coll this_ 
where this_.zipcode__ like ?
HibernateLog --> 10:56:55 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

objects	ArrayList<E>  (id=57)	
	elementData	Object[10]  (id=66)	
		[0]	Long  (id=68)	
			value	1	
		[1]	Long  (id=69)	
			value	2	
		[2]	Long  (id=73)	
		[3]	Long  (id=74)	
		[4]	Long  (id=93)	

/ 13	.

			List<Object>objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setProjection(Projections.rowCount())
				.list();		


select count(*) as y0_ 
from address_coll this_ 
inner join employee_coll employees1_ on this_.id__=employees1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 11:02:14 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

objects	ArrayList<E>  (id=37)	
	elementData	Object[10]  (id=54)	
		[0]	Long  (id=56)	
			value	25	



/ 13	.

			List<Object>objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createAlias("employees","employees")
				.setProjection(Projections.property("employees.name"))
				.list();		

Hibernate: select employees1_.name_ as y0_ 
from address_coll this_ 
inner join employee_coll employees1_ on this_.id__=employees1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 10:56:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

objects	ArrayList<E>  (id=39)	
	elementData	Object[33]  (id=54)	
		[0]	"Foo11" (id=56)	
		[1]	"Foo12" (id=57)	
...
/ 25 entries , alle names van de employees	, 
/ OK

/  13	,
















/ 13	.
			org.hibernate.Criteria criteria=session.createCriteria(Address.class);
			criteria.add(Restrictions.like("zipcode", "%Work"));
			criteria.setFetchMode("employees", FetchMode.JOIN);
			criteria.setResultTransformer(org.hibernate.Criteria.DISTINCT_ROOT_ENTITY);
			List<Address>addresses=criteria.list();

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address_coll this_ 
left outer join employee_coll employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 09:55:19 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

/ TODO

/ Einde DIFFERENCE JOIN & JOIN FETCH IN HQL

/ 7	.

/ BOOK (647)

/ als we hibernate.cfg.xml veranderen, moeten we opnieuw mvn clean install	,

/ 13	.

				Query query=session.createQuery("from Address a join a.employees where a.zipcode like '%Work'");

select address0_.id__ as id__1_0_0_, employees1_.id_ as id_1_1_1_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_ 
from address_coll address0_ 
inner join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

1 Work:Foo11
1 Work:Foo13
1 Work:Foo15
2 Work:Foo21
2 Work:Foo23
2 Work:Foo25
3 Work:Foo31
3 Work:Foo33
3 Work:Foo35
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
5 Work:Foo51
5 Work:Foo53
5 Work:Foo55

/ allemaal	,


/ 13	.

				Query query=session.createQuery("from Address a left join a.employees where a.zipcode like '%Work'");

select address0_.id__ as id__1_0_0_, employees1_.id_ as id_1_1_1_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where address0_.zipcode__ like '%Work'

1 Work:Foo11
1 Work:Foo13
1 Work:Foo15
2 Work:Foo21
2 Work:Foo23
2 Work:Foo25
3 Work:Foo31
3 Work:Foo33
3 Work:Foo35
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
5 Work:Foo51
5 Work:Foo53
5 Work:Foo55

/ 13	.
			Query query=session.createQuery("from Address a left join a.employees e where a.zipcode like '%Work' and e.salary>30");

				List<Object>objects=query.list();

select address0_.id__ as id__1_0_0_, 
	employees1_.id_ as id_1_1_1_, 
	address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where (address0_.zipcode__ like '%Work') and employees1_.salary_>30


3 Work:Foo31
3 Work:Foo33
3 Work:Foo35
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
5 Work:Foo51
5 Work:Foo53
5 Work:Foo55

/ 13	.

/ left join e where e.salary>30 , dus als je een restrictie op de rhs legt, ondermijnt de outer join	, want null voldoet niet aan deze restrictie	, dus outer join = inner join	, 
/ daarom doen we with ipv where	, 
/ where doen we hieronder	,

				Query query=session.createQuery("from Address a left join a.employees e with e.salary>30 where a.zipcode like '%Work'");

select address0_.id__ as id__1_0_0_, 
	employees1_.id_ as id_1_1_1_, 
	address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, 
	employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ and (employees1_.salary_>30) 
where address0_.zipcode__ like '%Work'

3 Work:Foo31
3 Work:Foo33
3 Work:Foo35
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
5 Work:Foo51
5 Work:Foo53
5 Work:Foo55
2 Work:null
1 Work:null

/ De list is 2 langer	, de laatste 2 entries hebben alleen een Address	, geen Employee	,

/ 13	.

				Query query=session.createQuery("from Address a left join fetch a.employees e where a.zipcode like '%Work' and e.salary>30");

/ outer join=inner join, omdat where e.salary>30 null uitsluit	,

select address0_.id__ as id__1_0_0_, employees1_.id_ as id_1_1_1_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_, employees1_.address_ as address_4_0_0__, employees1_.id_ as id_1_1_0__ 
from address_coll address0_ 
left outer join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where (address0_.zipcode__ like '%Work') 
and employees1_.salary_>30

3 Work:Foo31
3 Work:Foo35
3 Work:Foo33
3 Work:Foo31
3 Work:Foo35
3 Work:Foo33
3 Work:Foo31
3 Work:Foo35
3 Work:Foo33
4 Work:Foo45
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
4 Work:Foo41
4 Work:Foo43
5 Work:Foo53
5 Work:Foo51
5 Work:Foo55
5 Work:Foo53
5 Work:Foo51
5 Work:Foo55
5 Work:Foo53
5 Work:Foo51
5 Work:Foo55

/ 13	.

				Query query=session.createQuery("from Address a left join fetch a.employees e with e.salary>30 where a.zipcode like '%Work'");
/ ERR	, met fetch join kun je geen with	,
/ een fetch join wil WH alleen hele collections	,

				Query query=session.createQuery("from Address a join fetch a.employees e where a.zipcode like '%Work' and e.salary>30");

select address0_.id__ as id__1_0_0_, employees1_.id_ as id_1_1_1_, address0_.address_line1__ as address_2_0_0_, address0_.zipcode__ as zipcode_3_0_0_, address0_.city__ as city__4_0_0_, employees1_.name_ as name_2_1_1_, employees1_.salary_ as salary_3_1_1_, employees1_.address_ as address_4_1_1_, employees1_.living_ as living_5_1_1_, employees1_.address_ as address_4_0_0__, employees1_.id_ as id_1_1_0__ 
from address_coll address0_ 
inner join employee_coll employees1_ on address0_.id__=employees1_.address_ 
where (address0_.zipcode__ like '%Work') 
and employees1_.salary_>30

3 Work:Foo35
3 Work:Foo33
3 Work:Foo31
3 Work:Foo35
3 Work:Foo33
3 Work:Foo31
3 Work:Foo35
3 Work:Foo33
3 Work:Foo31
4 Work:Foo43
4 Work:Foo45
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
4 Work:Foo41
4 Work:Foo43
4 Work:Foo45
4 Work:Foo41
5 Work:Foo53
5 Work:Foo51
5 Work:Foo55
5 Work:Foo53
5 Work:Foo51
5 Work:Foo55
5 Work:Foo53
5 Work:Foo51
5 Work:Foo55

/ 13	.

/ we set een max aantal results	,

				Query query=session.createQuery("from Address a left join fetch a.employees e where a.zipcode like '%Work' and e.salary>30");
				query.setMaxResults(2);
				List<Address>addresses=query.list();
				for(Address address:addresses){
...

/ we zien	,

3 Work:Foo35
3 Work:Foo33
3 Work:Foo31
4 Work:Foo45
4 Work:Foo43
4 Work:Foo41

/ we kunnen ook start bij een result	, deze telt vanaf 0	,

				Query query=session.createQuery("from Address a left join fetch a.employees e where a.zipcode like '%Work' and e.salary>30");
				query.setMaxResults(2);
				query.setFirstResult(2);
				List<Address>addresses=query.list();
				for(Address address:addresses){

/ we zien	,

5 Work:Foo53
5 Work:Foo55
5 Work:Foo51

/ 7	.

<query name="join_with_salary">
	<![CDATA[
	from Address a left join fetch a.employees e where a.zipcode like '%Work' and e.salary>30
	]]>
</query>

/ TODO

 

/ Einde HIBERNATE PERFORMANCE

/ POSTGRES

/ 7	.

/ serial	,

/ 13	.

/ we mogen de serial column name use	, het hoeft niet	,

foo=> drop table p;create table p(id serial primary key,name varchar(255) not null);\d+ p
foo=> insert into p(name) values('foo');select*from p;
INSERT 0 1
 id | name 
----+------
  1 | foo
(1 row)

foo=> insert into p(name) values('foo');select*from p;
INSERT 0 1
 id | name 
----+------
  1 | foo
  2 | foo
(2 rows)

/ of	,
foo=> insert into p(id,name) values(default,'foo');select*from p;
INSERT 0 1
 id | name 
----+------
  1 | foo
  2 | foo
  3 | foo
(3 rows)


/ 13	,

/ als we alleen een serial column hebben	, moeten we de column name use in insert	, 

foo=> drop table p;create table p(id serial primary key);\d+ p
DROP TABLE
CREATE TABLE
                                             Table "public.p"
 Column |  Type   |                   Modifiers                    | Storage | Stats target | Description 
--------+---------+------------------------------------------------+---------+--------------+-------------
 id     | integer | not null default nextval('p_id_seq'::regclass) | plain   |              | 
Indexes:
    "p_pkey" PRIMARY KEY, btree (id)
Has OIDs: no

foo=> insert into p(id) values(default);
INSERT 0 1
foo=> insert into p(id) values(default);
INSERT 0 1
foo=> insert into p(id) values(default);select*from p;
INSERT 0 1
 id 
----
  1
  2
  3
(3 rows)

foo=> insert into p() values();select*from p;
/ ERR	,

/ 7	.

/ outer join	,

/ en verschil	,
foo=> select*from p left join r on p.id=r.ref and r.ref>6;
/ en	,
foo=> select*from p left join r on p.id=r.ref where r.ref>6;

/ Met where r.ref>6 verdwijnt effect outer join	, want null voldoet niet aan r.ref>6	,

=> drop table p;create table p(id serial primary key);\d+ p
...
foo=> delete from p;
DELETE 5
foo=> insert into p(id) values(default),(default);
INSERT 0 2
foo=> select*from p;
 id 
----
  6
  7
(2 rows)
foo=> insert into p(id) values(default),(default);
INSERT 0 2
foo=> select*from p;
 id 
----
  6
  7
  8
  9
(4 rows)


foo=> create table r(id serial primary key,ref int not null references p(id));
foo=> \d+ r;
                                             Table "public.r"
 Column |  Type   |                   Modifiers                    | Storage | Stats target | Description 
--------+---------+------------------------------------------------+---------+--------------+-------------
 id     | integer | not null default nextval('r_id_seq'::regclass) | plain   |              | 
 ref    | integer | not null                                       | plain   |              | 

foo=> insert into r(ref) values(6),(7);
INSERT 0 2
foo=> select*from r;
 id | ref 
----+-----
  1 |   6
  2 |   7
(2 rows)

foo=> select*from p inner join r on p.id=r.ref;
/ =
foo=> select*from p join       r on p.id=r.ref;

 id | id | ref 
----+----+-----
  6 |  1 |   6
  7 |  2 |   7
(2 rows)

foo=> select*from p left join r on p.id=r.ref;
/=
foo=> select*from p left outer join r on p.id=r.ref;
 id | id | ref 
----+----+-----
  6 |  1 |   6
  7 |  2 |   7
  8 |    |    
  9 |    |    
(4 rows)


=> select*from p left join r on p.id=r.ref and r.ref>6;
 id | id | ref 
----+----+-----
  7 |  2 |   7
  8 |    |    
  6 |    |    
  9 |    |    
(4 rows)

foo=> select*from p left join r on p.id=r.ref where r.ref>6;
 id | id | ref 
----+----+-----
  7 |  2 |   7
(1 row)




/ Einde POSTGRES

/ HIBERNATE CRITERIA DEBUG

/ Intermezzo
			List objects=session.createCriteria(Address.class)
/ valt in de ctor van CreateImpl	,
				.createCriteria("employees")
/ valt in de ctor van CreateImpl$Subcriteria	,

/ In meer detail	,

			List objects=session.createCriteria(Address.class)
/s
	public CriteriaImpl(String entityOrClassName, SessionImplementor session) {
		this(entityOrClassName, ROOT_ALIAS, session);
/s
	public CriteriaImpl(String entityOrClassName, String alias, SessionImplementor session) {
		this.session = session;
		this.entityOrClassName = entityOrClassName;
		this.cacheable = false;
		this.rootAlias = alias;
	}
/s
	private List<Subcriteria> subcriteriaList = new ArrayList<Subcriteria>();

			List objects=session.createCriteria(Address.class)
/s
	public CriteriaImpl(String entityOrClassName, SessionImplementor session) {
		this(entityOrClassName, ROOT_ALIAS, session);
/s
	public CriteriaImpl(String entityOrClassName, String alias, SessionImplementor session) {
		this.session = session;
		this.entityOrClassName = entityOrClassName;
		this.cacheable = false;
		this.rootAlias = alias;
	}
/s
	private List<Subcriteria> subcriteriaList = new ArrayList<Subcriteria>();

				.createCriteria("employees")
/s
	public Criteria createCriteria(String associationPath) {
224		return createCriteria( associationPath, JoinType.INNER_JOIN );
/s
	public Criteria createCriteria(String associationPath, JoinType joinType) {
		return new Subcriteria( this, associationPath, joinType );
/s
CriteriaImpl$Subcriteria.<init>(CriteriaImpl, Criteria, String, JoinType, CriteriaImpl$1) line: 444	


/ Einde Intermezzo





/ 7	.

			List objects=session.createCriteria(Address.class)

/ we zien	,

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employee1_.id_ as id_1_1_0_, employee1_.name_ as name_2_1_0_, employee1_.salary_ as salary_3_1_0_, employee1_.address_ as address_4_1_0_, employee1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employee1_ on this_.id__=employee1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 10:47:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

/s
	public CriteriaImpl(String entityOrClassName, SessionImplementor session) {
		this(entityOrClassName, ROOT_ALIAS, session);

/ Intermezzo

public class CriteriaImpl implements Criteria, Serializable {

public interface Criteria extends CriteriaSpecification {

public interface CriteriaSpecification {

	/**
	 * The alias that refers to the "root" entity of the criteria query.
	 */
	public static final String ROOT_ALIAS = "this";

	/**
	 * Each row of results is a <tt>Map</tt> from alias to entity instance
	 */
	public static final ResultTransformer ALIAS_TO_ENTITY_MAP = AliasToEntityMapResultTransformer.INSTANCE;

	/**
	 * Each row of results is an instance of the root entity
	 */
	public static final ResultTransformer ROOT_ENTITY = RootEntityResultTransformer.INSTANCE;

	/**
	 * Each row of results is a distinct instance of the root entity
	 */
	public static final ResultTransformer DISTINCT_ROOT_ENTITY = DistinctRootEntityResultTransformer.INSTANCE;

	/**
	 * This result transformer is selected implicitly by calling <tt>setProjection()</tt>
	 */
	public static final ResultTransformer PROJECTION = PassThroughResultTransformer.INSTANCE;

/ Einde Intermezzo

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
/s
	public static SimpleExpression like(String propertyName, Object value) {
		// todo : update this to use LikeExpression
		return new SimpleExpression( propertyName, value, " like " );
/t
/s
CriteriaImpl.add(Criterion) line: 172	
		add( this, expression );
/ this=CriteriaImpl inst	,

/t
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
/s
	public Criteria createCriteria(String associationPath) {
		return createCriteria( associationPath, JoinType.INNER_JOIN );
/s
	public Criteria createCriteria(String associationPath, JoinType joinType) {
		return new Subcriteria( this, associationPath, joinType );
/ this=CriteriaImpl inst	,
/ associationPath="employees"
/s
		private Subcriteria(Criteria parent, String path, JoinType joinType) {
			this( parent, path, null, joinType );
/s
		private Subcriteria(Criteria parent, String path, String alias, JoinType joinType) {
			this( parent, path, alias, joinType, null );
/s
		private Subcriteria(Criteria parent, String path, String alias, JoinType joinType, Criterion withClause) {
			this.alias = alias;
			this.path = path;
			this.parent = parent;
			this.joinType = joinType;
			this.withClause = withClause;
			this.hasRestriction = withClause != null;
			CriteriaImpl.this.subcriteriaList.add( this );
this	CriteriaImpl$Subcriteria  (id=95)	
parent	CriteriaImpl  (id=53)	
path	"employees" (id=92)	
alias	null	
joinType	JoinType  (id=99)	
withClause	null	

/t
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
/s
CriteriaImpl$Subcriteria.setResultTransformer(ResultTransformer) line: 675	
		public Criteria setResultTransformer(ResultTransformer resultProcessor) {
			CriteriaImpl.this.setResultTransformer(resultProcessor);

/ is inderdaad op de sub criteria	,

/ maar toch 	,
CriteriaImpl.setResultTransformer(ResultTransformer) line: 265	
/ Dus WH maakt het niet uit waar je .setResultTransformer neer zet, op de criteria of op een sub criteria	,

/t
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
/s
CriteriaImpl$Subcriteria.list() line: 619	
		before();
		if ( flushMode != null ) {
/ TODO 
		if ( cacheMode != null ) {
/ TODO 

/t
			return CriteriaImpl.this.list();
/s
CriteriaImpl.list() line: 378	
			return session.list( this );
/s
SessionImpl.list(Criteria) line: 1657	

		String[] implementors = factory.getImplementors( criteriaImpl.getEntityOrClassName() );
[my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address]

			loaders[i] = new CriteriaLoader(
					getOuterJoinLoadable( implementors[i] ),
					factory,
					criteriaImpl,
					implementors[i],
					getLoadQueryInfluencers()
				);
/s
CriteriaLoader.<init>(OuterJoinLoadable, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers) line: 88	
		super( factory, loadQueryInfluencers );

		translator = new CriteriaQueryTranslator(
				factory, 
				criteria, 
				rootEntityName, 
				CriteriaQueryTranslator.ROOT_SQL_ALIAS
			);

/ Intermezzo

public class CriteriaQueryTranslator implements CriteriaQuery {
	public static final String ROOT_SQL_ALIAS = Criteria.ROOT_ALIAS + '_';
this_

/ Einde Intermezzo

	public CriteriaQueryTranslator(
			final SessionFactoryImplementor factory,
	        final CriteriaImpl criteria,
	        final String rootEntityName,
	        final String rootSQLAlias) throws HibernateException {
		this.rootCriteria = criteria;
		this.rootEntityName = rootEntityName;
		this.sessionFactory = factory;
		this.rootSQLAlias = rootSQLAlias;
		this.helper = new SessionFactoryHelper(factory);
		createAliasCriteriaMap();
		createAssociationPathCriteriaMap();
		createCriteriaEntityNameMap();
		createCriteriaSQLAliasMap();

/ criteria=CriteriaImpl(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address:this[Subcriteria(employees:)][zipcode like %Work])
/ rootSQLAlias=this_


		createAliasCriteriaMap();
/s
CriteriaQueryTranslator.createAliasCriteriaMap() line: 151	
		aliasCriteriaMap.put( rootCriteria.getAlias(), rootCriteria );
/ rootCriteria.getAlias()="this"

		Iterator<CriteriaImpl.Subcriteria> iter = rootCriteria.iterateSubcriteria();
		while ( iter.hasNext() ) {
			Criteria subcriteria = iter.next();
			if ( subcriteria.getAlias() != null ) {
/ NEE
				Object old = aliasCriteriaMap.put( subcriteria.getAlias(), subcriteria );
/ NIET
/ Dit is WH verschil	,
	.createCriteria("employee")
/ en	,
	.createCriteria("employee","employee")


/t
		createAssociationPathCriteriaMap();
/s
		final Iterator<CriteriaImpl.Subcriteria> iter = rootCriteria.iterateSubcriteria();
		while ( iter.hasNext() ) {
			CriteriaImpl.Subcriteria crit = iter.next();
			String wholeAssociationPath = getWholeAssociationPath( crit );
"employees"
			Object old = associationPathCriteriaMap.put( wholeAssociationPath, crit );
			JoinType joinType = crit.getJoinType();
INNER_JOIN
			old = associationPathJoinTypesMap.put( wholeAssociationPath, joinType );

/t
		createCriteriaEntityNameMap();
/s
CriteriaQueryTranslator.createCriteriaEntityNameMap() line: 228	

		final CriteriaInfoProvider rootProvider = new EntityCriteriaInfoProvider(
				(Queryable) sessionFactory.getEntityPersister( rootEntityName )
		);
/ heeft Address-persister	,
		criteriaInfoMap.put( rootCriteria, rootProvider);
		nameCriteriaInfoMap.put( rootProvider.getName(), rootProvider );

		for ( final String key : associationPathCriteriaMap.keySet() ) {
/ key="employees"
			final Criteria value = associationPathCriteriaMap.get( key );
value	CriteriaImpl$Subcriteria  (id=95)	, 
Subcriteria(employees:)

			final CriteriaInfoProvider info = getPathInfo( key );
/ heeft Employee-perister	,
			criteriaInfoMap.put( value, info );
{CriteriaImpl(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address:this[Subcriteria(employees:)][zipcode like %Work])=org.hibernate.loader.criteria.EntityCriteriaInfoProvider@49f5cd23, 
Subcriteria(employees:)=org.hibernate.loader.criteria.EntityCriteriaInfoProvider@5cc0a9f2}

			nameCriteriaInfoMap.put( info.getName(), info );
{my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address=org.hibernate.loader.criteria.EntityCriteriaInfoProvider@49f5cd23, 
my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Employee=org.hibernate.loader.criteria.EntityCriteriaInfoProvider@5cc0a9f2}

/t
createCriteriaSQLAliasMap


	private void createCriteriaSQLAliasMap() {
		for(final Criteria crit : criteriaInfoMap.keySet()){
			final CriteriaInfoProvider value = criteriaInfoMap.get( crit );
			String alias = crit.getAlias();
alias 	"this"
/ bij Address	,

			if ( alias == null ) {
				// the entity name
				alias = value.getName();
			}
alias	"my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Employee" (id=198)	
/ bij Employee	,

			criteriaSQLAliasMap.put( crit, StringHelper.generateAlias( alias, i++ ) );
this0_

		criteriaSQLAliasMap.put( rootCriteria, rootSQLAlias );
/ altijd	, maar hadden we zojuist al set	, door dezelfde erover heen	,

{CriteriaImpl(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address:this[Subcriteria(employees:)][zipcode like %Work])=this_, 
Subcriteria(employees:)=employee2_}

/t
CriteriaLoader.<init>(OuterJoinLoadable, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers) line: 95	

		translator = new CriteriaQueryTranslator(
				factory, 
				criteria, 
				rootEntityName, 
				CriteriaQueryTranslator.ROOT_SQL_ALIAS
			);
/d

		querySpaces = translator.getQuerySpaces();
[address_coll, employee_coll]

		CriteriaJoinWalker walker = new CriteriaJoinWalker(
				persister, 
				translator,
				factory, 
				criteria, 
				rootEntityName, 
				loadQueryInfluencers
			);
/s
	public AbstractEntityJoinWalker(
			OuterJoinLoadable persister,
			SessionFactoryImplementor factory,
			LoadQueryInfluencers loadQueryInfluencers,
			String alias) {
		super( factory, loadQueryInfluencers );
		this.persister = persister;
		this.alias = ( alias == null ) ? generateRootAlias( persister.getEntityName() ) : alias;
/ alias==null	, 
/ generateRootAlias( persister.getEntityName() )
/s
		return CriteriaQueryTranslator.ROOT_SQL_ALIAS;
"this_"

		if ( translator.hasProjection() ) {			
/ NEE
		else {
			initAll( translator.getWhereCondition(), translator.getOrderBy(), LockOptions.NONE );
			// root entity comes last
			userAliasList.add( criteria.getAlias() ); //root entity comes *last*
			resultTypeList.add( translator.getResultType( criteria ) );
			includeInResultRowList.add( true );
			userAliases = ArrayHelper.toStringArray( userAliasList );
			resultTypes = ArrayHelper.toTypeArray( resultTypeList );
			includeInResultRow = ArrayHelper.toBooleanArray( includeInResultRowList );
		}

...
CriteriaLoader(Loader).doList(SessionImplementor, QueryParameters, ResultTransformer) line: 2561	
			result = doQueryAndInitializeNonLazyCollections( session, queryParameters, true, forcedResultTransformer );
/ TODO



/ 13	. 

/ we slaan stuk over	,

/s
CriteriaJoinWalker(JoinWalker).addAssociationToJoinTree(AssociationType, String[], String, PropertyPath, int, JoinType) line: 256	

		OuterJoinableAssociation assoc = new OuterJoinableAssociation(
				path,
				type, 
				alias, 
				aliasedLhsColumns, 
				subalias, 
				joinType, 
				getWithClause(path),
				hasRestriction( path ),
				getFactory(),
				loadQueryInfluencers.getEnabledFilters()
		);

assoc	OuterJoinableAssociation  (id=465)	
	enabledFilters	HashMap<K,V>  (id=469)	
	hasRestriction	false	
	joinable	OneToManyPersister  (id=451)	
OneToManyPersister(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address.employees)
	joinableType	SetType  (id=416)	
	joinType	JoinType  (id=155)	
	lhsAlias	"this_" (id=128)	
	lhsColumns	String[1]  (id=442)	
[this_.id__]
	on	"" (id=477)	
	propertyPath	PropertyPath  (id=448)	
PropertyPath[employees]
	rhsAlias	"employee1_" (id=463)	
	rhsColumns	String[1]  (id=484)	
[address_]

/ 13	. 

/ Employee heeft ook een set	, voor deze wil H. ook een join create	, maar de joinType==NONE	, dus er gebeurt NIETS	, 

/ we komen weer in 	,

CriteriaJoinWalker(JoinWalker).walkEntityTree(OuterJoinLoadable, String, PropertyPath, int) line: 550	

		for ( int i = 0; i < n; i++ ) {
			Type type = persister.getSubclassPropertyType(i);
			if ( type.isAssociationType() ) {
				walkEntityAssociationTree(
					( AssociationType ) type,
					persister,
					i,
					alias,
					path,
					persister.isSubclassPropertyNullable(i),
					currentDepth
				);
/s
CriteriaJoinWalker(JoinWalker).walkEntityAssociationTree(AssociationType, OuterJoinLoadable, int, String, PropertyPath, boolean, int) line: 415	

		String[] aliasedLhsColumns = JoinHelper.getAliasedLHSColumnNames(
				associationType, alias, propertyNumber, persister, getFactory()
		);
[employee1_.living_]
		String[] lhsColumns = JoinHelper.getLHSColumnNames(
				associationType, propertyNumber, persister, getFactory()
		);
[living_]
		String lhsTable = JoinHelper.getLHSTableName(associationType, propertyNumber, persister);
employee_coll

		PropertyPath subPath = path.append( persister.getSubclassPropertyName(propertyNumber) );
PropertyPath[employees.living]
		JoinType joinType = getJoinType(
				persister,
				subPath,
				propertyNumber,
				associationType,
				persister.getFetchMode( propertyNumber ),
				persister.getCascadeStyle( propertyNumber ),
				lhsTable,
				lhsColumns,
				nullable,
				currentDepth
		);
NONE
		addAssociationToJoinTreeIfNecessary(
				associationType,
				aliasedLhsColumns,
				alias,
				subPath,
				currentDepth,
				joinType
		);
/ NIETS	, want joinType=NONE

/ 13	.

/ later	,

CriteriaJoinWalker(JoinWalker).initPersisters(List, LockOptions, JoinWalker$AssociationInitCallback) line: 1070	

/ TODO

/ Dan	,
CriteriaJoinWalker(AbstractEntityJoinWalker).initStatementString(String, String, String, String, LockOptions) line: 118	

this
	sql	"select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, employee1_.id_ as id_1_1_0_, employee1_.name_ as name_2_1_0_, employee1_.salary_ as salary_3_1_0_, employee1_.address_ as address_4_1_0_, employee1_.living_ as living_5_1_0_ from address_coll this_ inner join employee_coll employee1_ on this_.id__=employee1_.address_ where this_.zipcode__ like ?" (id=791)	

/ 13

/t
CriteriaJoinWalker.<init>(OuterJoinLoadable, CriteriaQueryTranslator, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers, String) line: 125	
			initAll( translator.getWhereCondition(), translator.getOrderBy(), LockOptions.NONE );
/d

/t
CriteriaLoader.<init>(OuterJoinLoadable, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers) line: 106	
		CriteriaJoinWalker walker = new CriteriaJoinWalker(
				persister, 
				translator,
				factory, 
				criteria, 
				rootEntityName, 
				loadQueryInfluencers
			);
/d
		initFromWalker(walker);
/s
		persisters = walker.getPersisters();
		collectionPersisters = walker.getCollectionPersisters();
		ownerAssociationTypes = walker.getOwnerAssociationTypes();
		lockOptions = walker.getLockModeOptions();
		lockModeArray = walker.getLockModeArray();
		suffixes = walker.getSuffixes();
		collectionSuffixes = walker.getCollectionSuffixes();
		owners = walker.getOwners();
		collectionOwners = walker.getCollectionOwners();
		sql = walker.getSQLString();
		aliases = walker.getAliases();

/t
		userAliases = walker.getUserAliases();
		resultTypes = walker.getResultTypes();
		includeInResultRow = walker.includeInResultRow();
[false, true]
		resultRowLength = ArrayHelper.countTrue( includeInResultRow );

/t
SessionImpl.list(Criteria) line: 1681	

			loaders[i] = new CriteriaLoader(
					getOuterJoinLoadable( implementors[i] ),
					factory,
					criteriaImpl,
					implementors[i],
					getLoadQueryInfluencers()
				);
/d
			for( int i=0; i<size; i++ ) {
				final List currentResults = loaders[i].list(this);
...
/s
CriteriaLoader(Loader).doList(SessionImplementor, QueryParameters, ResultTransformer) line: 2553	
			result = doQueryAndInitializeNonLazyCollections( session, queryParameters, true, forcedResultTransformer );
/s
CriteriaLoader(Loader).doQueryAndInitializeNonLazyCollections(SessionImplementor, QueryParameters, boolean, ResultTransformer) line: 354	
				result = doQuery( session, queryParameters, returnProxies, forcedResultTransformer );
/s
CriteriaLoader(Loader).doQuery(SessionImplementor, QueryParameters, boolean, ResultTransformer) line: 920	
			return processResultSet( rs, queryParameters, session, returnProxies, forcedResultTransformer, maxRows, afterLoadActions );
/s
CriteriaLoader(Loader).processResultSet(ResultSet, QueryParameters, SessionImplementor, boolean, ResultTransformer, int, List<AfterLoadAction>) line: 949	
		for ( count = 0; count < maxRows && rs.next(); count++ ) {
			Object result = getRowFromResultSet(
					rs,
					session,
					queryParameters,
					lockModesArray,
					optionalObjectKey,
					hydratedObjects,
					keys,
					returnProxies,
					forcedResultTransformer
			);
/s
CriteriaLoader(Loader).getRowFromResultSet(ResultSet, SessionImplementor, QueryParameters, LockMode[], EntityKey, List, EntityKey[], boolean, ResultTransformer) line: 718	

		Object[] row = getRow(
				resultSet,
				persisters,
				keys,
				queryParameters.getOptionalObject(),
				optionalObjectKey,
				lockModesArray,
				hydratedObjects,
				session
		);
row	Object[2]  (id=965)	
	[0]	Employee  (id=966)	
	[1]	Address  (id=924)	
/ Altijd	,

		return forcedResultTransformer == null
/ JA
				? getResultColumnOrRow( row, queryParameters.getResultTransformer(), resultSet, session )
/s
resultTransformer	AliasToEntityMapResultTransformer  (id=842)	

/ Klopt	, we deden	,
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		

/t
/s
CriteriaLoader.getResultColumnOrRow(Object[], ResultTransformer, ResultSet, SessionImplementor) line: 148	
		return resolveResultTransformer( transformer ).transformTuple(
				getResultRow( row, rs, session),
				getResultRowAliases()
		);
/s
	protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
		return translator.getRootCriteria().getResultTransformer();
/ arg wordt niet used	, toch weer Criteria.ALIAS_TO_ENTITY_MAP	,
/t
/s
	protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
			throws SQLException, HibernateException {
		else {
			result = toResultRow( row );
/s
CriteriaLoader.toResultRow(Object[]) line: 180	

///////////////////////////////////////////
/ HOW DOES CRITERIA RESULT SHOW , ALIAS_TO_ENTITY_MAP ->  HASHMAP	,
/ hierboven: de query geeft altijd Object[2]{Address, Employee}	, 

/ pakt alleen de 1ste	,

		else {
			Object[] result = new Object[ resultRowLength ];
			int j = 0;
			for ( int i = 0; i < row.length; i++ ) {
				if ( includeInResultRow[i] ) result[j++] = row[i];

/t
/s
	getResultRowAliases
[this]
/t
/s
AliasToEntityMapResultTransformer.transformTuple(Object[], String[]) line: 51	
		Map result = new HashMap(tuple.length);
		for ( int i=0; i<tuple.length; i++ ) {
			String alias = aliases[i];
			if ( alias!=null ) {
				result.put( alias, tuple[i] );
/ alias="this"
/ tuple[0]=Address


/ 7	.

				.createCriteria("employees", "employees")

select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees1_.id_ as id_1_1_0_, employees1_.name_ as name_2_1_0_, employees1_.salary_ as salary_3_1_0_, employees1_.address_ as address_4_1_0_, employees1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employees1_ on this_.id__=employees1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 10:59:25 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

/s
	public Criteria createCriteria(String associationPath, String alias) {
		return createCriteria( associationPath, alias, JoinType.INNER_JOIN );
/s
	public Criteria createCriteria(String associationPath, String alias, JoinType joinType) {
		return new Subcriteria( this, associationPath, alias, joinType );
/ associationPath="employees"
/ alias="employees"

/ met .createCriteria("employees") is alias==null
/ WH
/ TODO

...
/s
			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees", "employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
/s
SessionImpl.list(Criteria) line: 1663	
			loaders[i] = new CriteriaLoader(
					getOuterJoinLoadable( implementors[i] ),
					factory,
					criteriaImpl,
					implementors[i],
					getLoadQueryInfluencers()
				);
/s
CriteriaLoader.<init>(OuterJoinLoadable, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers) line: 86	
...
		CriteriaJoinWalker walker = new CriteriaJoinWalker(
				persister, 
				translator,
				factory, 
				criteria, 
				rootEntityName, 
				loadQueryInfluencers
		);
...
/s
CriteriaJoinWalker.<init>(OuterJoinLoadable, CriteriaQueryTranslator, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers, String) line: 123	
		else {
			initAll( translator.getWhereCondition(), translator.getOrderBy(), LockOptions.NONE );
...
/s
CriteriaJoinWalker(AbstractEntityJoinWalker).initAll(String, String, LockOptions, JoinWalker$AssociationInitCallback) line: 85	
		walkEntityTree( persister, getAlias() );
/s
		for ( int i = 0; i < n; i++ ) {
			Type type = persister.getSubclassPropertyType(i);
			if ( type.isAssociationType() ) {
				walkEntityAssociationTree(
					( AssociationType ) type,
					persister,
					i,
					alias,
					path,
					persister.isSubclassPropertyNullable(i),
					currentDepth
				);
			}
/s
CriteriaJoinWalker(JoinWalker).walkEntityAssociationTree(AssociationType, OuterJoinLoadable, int, String, PropertyPath, boolean, int) line: 415	
...
		addAssociationToJoinTreeIfNecessary(
				associationType,
				aliasedLhsColumns,
				alias,
				subPath,
				currentDepth,
				joinType
		);
/s
CriteriaJoinWalker(JoinWalker).addAssociationToJoinTree(AssociationType, String[], String, PropertyPath, int, JoinType) line: 238	
		// important to generate alias based on size of association collection
		// *before* adding this join to that collection
		String subalias = generateTableAlias( associations.size() + 1, path, joinable );
/s
CriteriaJoinWalker.generateTableAlias(int, PropertyPath, Joinable) line: 276	
			if (joinable.consumesEntityAlias() && ! translator.hasProjection()) {
				includeInResultRowList.add( subcriteria != null && subcriteria.getAlias() != null );
				if (sqlAlias!=null) {
					if ( subcriteria.getAlias() != null ) {
/ JA, als we .criteria("employees","employees")
/ NEE, als we .criteria("employees")
						userAliasList.add( subcriteria.getAlias() );
						resultTypeList.add( translator.getResultType( subcriteria ) );
					}
				}
			}

/t
CriteriaJoinWalker.<init>(OuterJoinLoadable, CriteriaQueryTranslator, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers, String) line: 128	
		else {
			initAll( translator.getWhereCondition(), translator.getOrderBy(), LockOptions.NONE );
/d
...
			resultTypeList.add( translator.getResultType( criteria ) );


/s
CriteriaJoinWalker.includeInResultRow() line: 82	
		return includeInResultRow;
[true,true]
		resultRowLength = ArrayHelper.countTrue( includeInResultRow );
/ 2

/t
SessionImpl.list(Criteria) line: 1646	
		for( int i=0; i <size; i++ ) {

			loaders[i] = new CriteriaLoader(
					getOuterJoinLoadable( implementors[i] ),
					factory,
					criteriaImpl,
					implementors[i],
					getLoadQueryInfluencers()
				);
/d
			for( int i=0; i<size; i++ ) {
				final List currentResults = loaders[i].list(this);
...
/s
CriteriaLoader(Loader).doQuery(SessionImplementor, QueryParameters, boolean, ResultTransformer) line: 920	
...
/s
CriteriaLoader.toResultRow(Object[]) line: 180	
		if ( resultRowLength == row.length ) {
/ JA	, 2==2
			return row;
/t
/s
	getResultRowAliases()
["employees","this"]
/t
/s
AliasToEntityMapResultTransformer.transformTuple(Object[], String[]) line: 51	

/ hij set ze er alle 2 in	,

		Map result = new HashMap(tuple.length);
		for ( int i=0; i<tuple.length; i++ ) {
			String alias = aliases[i];
			if ( alias!=null ) {
				result.put( alias, tuple[i] );



/ 7	. 

			List objects=session.createCriteria(Address.class)
				.createCriteria("employees")



CriteriaJoinWalker.<init>(OuterJoinLoadable, CriteriaQueryTranslator, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers, String) line: 132	
		else {
			initAll( translator.getWhereCondition(), translator.getOrderBy(), LockOptions.NONE );
			// root entity comes last
			userAliasList.add( criteria.getAlias() ); //root entity comes *last*
[this]
			resultTypeList.add( translator.getResultType( criteria ) );
[org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address)]
			includeInResultRowList.add( true );
[false, true]
			userAliases = ArrayHelper.toStringArray( userAliasList );
[this]
			resultTypes = ArrayHelper.toTypeArray( resultTypeList );
[org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address)]
			includeInResultRow = ArrayHelper.toBooleanArray( includeInResultRowList );
[false, true]

/ TODO

/ 7	.

				.createAlias("employees", "employees")
/=
				.createCriteria("employees", "employees")


			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createAlias("employees", "employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		


				.createAlias("employees", "employees")
/s
	public Criteria createAlias(String associationPath, String alias) {
		return createAlias( associationPath, alias, JoinType.INNER_JOIN );
/s
	public Criteria createAlias(String associationPath, String alias, JoinType joinType) {
		new Subcriteria( this, associationPath, alias, joinType );

/ Dus precies hetzelfde als	

/ 7	.

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		

				.setFetchMode("employees", FetchMode.JOIN)
/s
CriteriaImpl.setFetchMode(String, FetchMode) line: 185	
	public Criteria setFetchMode(String associationPath, FetchMode mode) {
		fetchModes.put( associationPath, mode );

/t
				.list();		
/s
CriteriaJoinWalker.<init>(OuterJoinLoadable, CriteriaQueryTranslator, SessionFactoryImplementor, CriteriaImpl, String, LoadQueryInfluencers, String) line: 127	
			userAliasList.add( criteria.getAlias() ); //root entity comes *last*
[this]
			resultTypeList.add( translator.getResultType( criteria ) );
[org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address)]
			includeInResultRowList.add( true );
[false, true]
			userAliases = ArrayHelper.toStringArray( userAliasList );
[this]
			resultTypes = ArrayHelper.toTypeArray( resultTypeList );
[org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_N_1_bidir_fetch_coll_ehcache.Address)]
			includeInResultRow = ArrayHelper.toBooleanArray( includeInResultRowList );
[false, true]


/ Einde HIBERNATE CRITERIA DEBUG

/ HIBERNATE CRITERIA

file:///home/eric/Devel/Java/Ehcache/hibernate_xml_N_1_bidir_fetch_coll_ehcache 

/13	.

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		

Hibernate: select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employee1_.id_ as id_1_1_0_, employee1_.name_ as name_2_1_0_, employee1_.salary_ as salary_3_1_0_, employee1_.address_ as address_4_1_0_, employee1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employee1_ on this_.id__=employee1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 11:22:25 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

/ we zien 25 entries	, die uit alleen een Address bestaan,  5 verschillende Address, elk met PersistentSet leeg	, dus 5 entries hebben dezelfde Address	,

/ 13	.

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.createCriteria("employees", "employees")
/=
				.createAlias("employees", "employees")
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		


Hibernate: select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees1_.id_ as id_1_1_0_, employees1_.name_ as name_2_1_0_, employees1_.salary_ as salary_3_1_0_, employees1_.address_ as address_4_1_0_, employees1_.living_ as living_5_1_0_ 
from address_coll this_ 
inner join employee_coll employees1_ on this_.id__=employees1_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 11:29:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

/ we zien 25 entries	, die uit een Address en een Employee bestaan,  5 verschillende Address, elk met PersistentSet leeg	, en elke Address heeft andere Employee, dus 5 entries hebben dezelfde Address	, en een verschillende Employee	,

/ 13	.

			List objects=session.createCriteria(Address.class)
				.add(Restrictions.like("zipcode", "%Work"))
				.setFetchMode("employees", FetchMode.JOIN)
				.setResultTransformer(org.hibernate.Criteria.ALIAS_TO_ENTITY_MAP)
				.list();		
Hibernate: select this_.id__ as id__1_0_1_, this_.address_line1__ as address_2_0_1_, this_.zipcode__ as zipcode_3_0_1_, this_.city__ as city__4_0_1_, 
	employees2_.address_ as address_4_0_3_, employees2_.id_ as id_1_1_3_, employees2_.id_ as id_1_1_0_, employees2_.name_ as name_2_1_0_, employees2_.salary_ as salary_3_1_0_, employees2_.address_ as address_4_1_0_, employees2_.living_ as living_5_1_0_ 
from address_coll this_ 
left outer join employee_coll employees2_ on this_.id__=employees2_.address_ 
where this_.zipcode__ like ?
HibernateLog --> 11:34:10 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [%Work]

/ we zien 25 entries	, die uit alleen een Address bestaan,  5 verschillende Address, elk met PersistentSet INITIALIZED, dus 5 entries hebben dezelfde Address	,





/ Einde HIBERNATE CRITERIA

/ SPRING 

/ 7	. 

/ we hadden in eclipse, in window, preferences, maven, archetypes	,
/ WH add remote catalog...
Remote: repo1
Edit
Catalog file: http://repo1.maven.org/maven2/archetype-catalog.xml
description: repo1

/ 7	. 

/ op de spring site, 
/ projects	, spring framework , quick start	,

<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>4.1.1.RELEASE</version>
    </dependency>
</dependencies>


/ we maken een maven-archetype-quickstart project spring_xml	,
group id: my.test.own
artifact id: spring_xml

/ 7	. 

/ we import spring_knight	,

$ vi pom.xml

	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-context</artifactId>
	    <version>4.1.1.RELEASE</version>
	</dependency>
	
	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-aspects</artifactId>
	    <version>4.1.1.RELEASE</version>
	</dependency>

    	<dependency>
      		<groupId>junit</groupId>
      		<artifactId>junit</artifactId>
      		<version>4.11</version>
      		<scope>test</scope>
    	</dependency>

	<dependency>
	    <groupId>log4j</groupId>
	    <artifactId>log4j</artifactId>
	    <version>1.2.17</version>
	</dependency>

/ we hoeven alleen spring-context en spring-aspects	,

[eric@localhost spring_knight]$ mvn dependency:tree

[INFO] sia.ch01:spring_knight:jar:1.0-SNAPSHOT
[INFO] +- junit:junit:jar:4.11:test
[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] +- org.springframework:spring-context:jar:4.1.1.RELEASE:compile
[INFO] |  +- org.springframework:spring-aop:jar:4.1.1.RELEASE:compile
[INFO] |  |  \- aopalliance:aopalliance:jar:1.0:compile
[INFO] |  +- org.springframework:spring-beans:jar:4.1.1.RELEASE:compile
[INFO] |  +- org.springframework:spring-core:jar:4.1.1.RELEASE:compile
[INFO] |  |  \- commons-logging:commons-logging:jar:1.1.3:compile
[INFO] |  \- org.springframework:spring-expression:jar:4.1.1.RELEASE:compile
[INFO] +- org.springframework:spring-aspects:jar:4.1.1.RELEASE:compile
[INFO] |  \- org.aspectj:aspectjweaver:jar:1.8.2:compile
[INFO] \- log4j:log4j:jar:1.2.17:compile

/ welke hebben we precies nodig	?
/ TODO

$ vi knight.xml		,

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
    	http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"
        
        >

	<bean 	
		id="quest" 
		class="sia.ch01.HolyGrailQuest">
	</bean>
	<bean 
		id="knight" 
		class="sia.ch01.KnightOfTheRoundTable">
        <property 
			name="quest" 
			ref="quest"
		/>
		<constructor-arg
			value="Bedivere"
		/>
	</bean>
	
	<bean
		id="minstrel"
		class="sia.ch01.Minstrel"
	></bean>
	
	<aop:config>
		<aop:aspect 
			ref="minstrel"
		>
			<aop:pointcut
				id="questPointcut"
				expression="execution(* *.embarkOnQuest(..)) and target(bean)"	
			/>
			<aop:before
				method="singBefore"
				pointcut-ref="questPointcut"
				arg-names="bean"
			/>
			<aop:after-returning
				method="singAfter"
				pointcut-ref="questPointcut"
				arg-names="bean"
			/>
		</aop:aspect>
	</aop:config>
	
	</beans>

$ vi App.java

	ApplicationContext c=new ClassPathXmlApplicationContext("knight.xml");
	Knight k=(Knight)c.getBean("knight");
	k.embarkOnQuest();	

/ 7	.

/ Einde SPRING

/ WICKET

/ Maak in eclipse een nieuwe maven project	, 
/ Location: Devel/Java/Wicket
/ org.apache.wicket:wicket-archetype-quickstart:7.0.0-M3
Group Id: my.test.own
Artifact Id: wicket_quickstart

/ maven	, Goals: jetty:run
/ OK
/ Geef localhost:8080
/ OK

11522  2909 11521 28370 pts/61   11521 Sl+   1000   0:12 /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/bin/java -agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:33492 -Dmaven.home=/usr/share/maven -Dclassworlds.conf=/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace/.metadata/.plugins/org.eclipse.m2e.launching/launches/m2conf1527380789360839949.tmp -Dmaven.bootclasspath=/usr/share/maven/boot/plexus-classworlds.jar -Dfile.encoding=UTF-8 -classpath /usr/share/maven/boot/plexus-classworlds.jar org.codehaus.classworlds.Launcher -B -s /home/eric/.m2/settings.xml jetty:run

/ we kunnen dus debug	,
/ TODO

/ we kunnen ook in test/ Start start als Java application	,
/ OK
/ Geef localhost:9090
/ OK

/ stop zoals we altijd doen	,

/ 7	.

/ we willen 
$ mvn jetty:stop

/ Daarom moeten we 	,
			<plugin>
				<groupId>org.eclipse.jetty</groupId>
				<artifactId>jetty-maven-plugin</artifactId>
				<version>${jetty9.version}</version>
				<configuration>
					<stopKey>stop</stopKey>
					<stopPort>1313</stopPort>
					<stopWait>10</stopWait>
...
				</configuration>
			</plugin>

/ Nu kunnen we 	,
$ mvn jetty:stop

 
/ 7	.

[eric@localhost Wicket]$ pwd
/home/eric/Devel/Java/Wicket
[eric@localhost Wicket]$ unzip  ~/Downloads/wicket-in-action-1.0-source.zip 
[eric@localhost Wicket]$ cd wicket-in-action-1.0/

 

/ Einde WICKET

/ WICKET GENERICS

/ Lees	,
http://brie.com/brian/blog/?p=61

[eric@localhost Wicket]$ unzip  ~/Downloads/hippo02.zip 
/ we edit	,
$ vi pom.xml
        <groupId>my.test.own</groupId>
        <artifactId>wicket_hippo02</artifactId>


/ 7	.

/ my.test.own.wicket_quickstart

$ vi MyPage2.java

ublic class MyPage2 extends WebPage {
	private TextField<Integer> field;

	public MyPage2(final PageParameters parameters) {
		field=new TextField<Integer>("field", new PropertyModel<Integer>(this, "counter"));
/ 2 generics moeten dezelfde zijn	,
				Integer value=field.getModelObject();
/ Moet Integer zijn	, omdat we niet

/ 7	.

		field=new TextField<Integer>("field", new Model<Integer>(7));
				Integer value=field.getModelObject();
/ OK

/ Intermezzo

/ int -> String	,

		Integer integer=7;
//		String string=(String)integer;
/ NEE
		int i=7;
//		String s=(String)i;
/ NEE
		String string=integer.toString();
	
		String s=String.valueOf(i);
		s=Integer.toString(i);


/ Einde Intermezzo


/ Einde WICKET GENERICS

/ WICKET MODELS

/ als we een nieuwe page maken, moeten we 	,

$ mvn test

/ omdat we Start ook willen run in src/test/java	,

--- maven-resources-plugin:2.6:resources (default-resources) @ wicket_quickstart ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] Copying 4 resources

[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ wicket_quickstart ---
[INFO] Compiling 5 source files to /home/eric/Devel/Java/Wicket/wicket_quickstart/target/classes

[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ wicket_quickstart ---
[INFO] Copying 1 resource

[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ wicket_quickstart ---
[INFO] Compiling 3 source files to /home/eric/Devel/Java/Wicket/wicket_quickstart/target/test-classes

[INFO] --- jetty-maven-plugin:9.2.2.v20140723:run (default-cli) @ wicket_quickstart ---
...

/ 7	.

		Serializable ser=MyTest.pick("d", new ArrayList<String>());
		
	}
	static<T>T pick(T a,T b){
		return b;
	}
/ OK

/ T=Serializable	,


/ 7	.

 List<A> is a subtype of List<?>

/ 7	.

$ vi Page3.java

/ in page	,
/ in form	,
		IModel<String>model=new Model<String>();
		field=new TextField<String>("field", model);
		
		Button button=new Button("submit"){
			public void onSubmit() {
				IModel<String>model=field.getModel();
				String value=model.getObject();
/*
				label.setDefaultModelObject(value);

/ in page,	
		label=new Label("message", new Model<String>(""));
		add(label);

		IModel<String>model2=(IModel<String>)label.getDefaultModel();
/**
		String string= model2.getObject();
/***
		
		Object object= label.getDefaultModelObject();
/****


/* 
/ Als we TextField<Integer> en z'n model ook , dan bij * ERR, niet vanwege de assign, maar intern in model.getObject()	, omdat deze method de "7" string wil cast naar Integer, 	en dat kan niet	, (we hadden 7 gegeven in de textfield)	,

/**
/ een form component doet een IModel<T> cast, over de IModel<?> heen, wij doen het hier dus zelf	,
/***
/ gaat dan vanzelf	,

/****
/  we kunnen alleen aan Object assign	,

/ 7	. 

/////////////////////////////////
/ VERSCHIL MODEL EN PROPERTYMODEL

/ bij 'n property model is de binding 2-way	, bij Model 1-way	, we moeten set value zelf doen	,

$ vi Page2.java


	public MyPage2(final PageParameters parameters) {
		super(parameters);
		
		Form<String>form=new Form<String>("form");				// we use form model niet, dus generics maakt niet uit	,
		IModel<Integer>model=new PropertyModel<Integer>(this, "counter");
		field=new TextField<Integer>("field", model);
		form.add(field);
		Button button=new Button("submit")
		form.add(button);
		add(form);

		label=new Label("message", new PropertyModel<X>(this, "counter"));
		add(label);

/ Dit is OK	, 

$ vi Page3.java

	public MyPage3(final PageParameters parameters) {
		super(parameters);
		
		Form<String>form=new Form<String>("form");
		
		IModel<String>model=new Model<String>();
		field=new TextField<String>("field", model);
		form.add(field);
		
		Button button=new Button("submit")
		{
			public void onSubmit() {
				IModel<String>model=field.getModel();
				String value=model.getObject();
				label.setDefaultModelObject(value);
/*
			}
		};
		form.add(button);
		add(form);
		
		IModel<String>model2=new Model<String>("");
		label=new Label("message", model2);
		add(label);
		

/* 
/ dit moeten we nu zelf doen	,

/ 7	.

$ vi MyPage3a.html

		{
		Label widget=new Label("dummy", 13);
		IModel<Integer>model=(IModel<Integer>)widget.getDefaultModel();
		Integer integer=model.getObject();
		boolean b=false;		
		}
		{
		IModel<Integer>model=new Model<Integer>(13);
		TextField<Integer>widget=new TextField<Integer>("dummy",model); 
		model=widget.getModel();
		Integer integer=model.getObject();
		boolean b=false;
		}
		{
		IModel<Integer>model=new Model<Integer>(13);	
		Label widget=new Label("dummy", model);
		model=(IModel<Integer>)widget.getDefaultModel();
		Integer integer=model.getObject();
		boolean b=false;
		}
/ OK
/ als widget 'n component is, dan getModel()=(IModel<T>)getDefaultModel()	, bij Label doen we dat met de hand	,

/ 7	.

/ Opmerkingen over Wicket	,

		IModel<String>model2=new Model<String>("");
		label=new Label("message", model2);
		add(label);
		
		IModel<String>model3=(IModel<String>)label.getDefaultModel();
		String string= model3.getObject();

		IModel<?>model4=label.getDefaultModel();
		Object object=model4.getObject();
/=
		Object object= label.getDefaultModelObject();

/ 7	

/ Page4	,

public class MyForm<T> extends Form<T>{
	public MyForm(String id) {
		super(id);
		
	}
}
/ we moeten super(id) call	, want Form<T> heeft geen default ctor	,

/ 7. 	


/ we hebben MyForm5	, MyPage5	, Person5	,

$ vi MyForm5.java

public class MyForm5<T extends Serializable> extends Form<T>{
	
	private T t;

	public T getT() {
		return t;
	}
	public void setT(T t) {
		this.t = t;
	}

	public MyForm5(String id) {
		super(id);
	}
	
	public void  set() {
		setModel(new Model<T>(t));

		IModel<String>nameModel=new PropertyModel<String>(t, "name");
		TextField<String>name=new TextField<String>("name", nameModel);
		add(name);

		IModel<String>addressModel=new PropertyModel<String>(t, "address");
		TextField<String>address=new TextField<String>("address", addressModel);
		add(address);

	}
	@Override
	protected void onSubmit() {
		IModel<T>model=this.getModel();
		T t=model.getObject();
		boolean b=false;
	}

$ vi MyPage5.java

public class MyPage5 extends WebPage {

	public MyPage5(final PageParameters parameters) {
		super(parameters);
		
		MyForm5<Person5>form=new MyForm5<Person5>("form");
		Person5 person=new Person5();
		form.setT(person5);
		form.set();
		add(form);
    }

$ vi MyPage5.html

		<form  wicket:id="form">
		
			<input  wicket:id="name" type="text">
			<br>
			<input wicket:id="address" type="text">
			<br>		
			<input  type="submit" value ="Set">
			
		</form>

$ vi Person5.java

public class Person5 implements Serializable{
	private String name;
	private String address;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
}


/ we moeten T extends Serializable	,
/ anderrs gaat new Model<T>(t) NIET	,
public class MyForm5<T extends Serializable> extends Form<T>{
	public void  set() {
		setModel(new Model<T>(t));

/ we zien in submit, dat t een Person5	 is	,
/ In submit wilde we doen	,
	t.getName()
/ Maar dat kan niet	, omdat T extends Serializable	,

/ Ook Person5 implements Serializable, omdat er een Model omheen moet	,

/ 7	.

/ we hebben MyForm6, Person6, IP6, MyPage6	,

/ we willen MyForm6.onSubmit t.getName()	,  

$ vi MyForm6.java

public class MyForm6<T extends IP6> extends Form<T>{
	
	private T t;

	public T getT() {
		return t;
	}
	public void setT(T t) {
		this.t = t;
	}

	protected void onSubmit() {
		IModel<T>model=this.getModel();
		T t=model.getObject();
		boolean b=false;
		String name=t.getName();
		String address=t.getAddress();
		System.out.println(name);
		System.out.println(address);
		
	}
/ OK



	public MyPage6(final PageParameters parameters) {
		super(parameters);

		
		MyForm6<Person6>form6=new MyForm6<Person6>("form");
		Person6 person6=new Person6();
		form6.setT(person6);
		form6.set();
		add(form6);

/ we kunnen NIET 
		IP6 person6=new Person6();
		form6.setT(person6);

/ want MyForm6.setT verwacht een Person6	, niet een IP6	,

/ we kunnen OOK	,
		IP6 person6=new Person6();
		form6.setT((Person6)person6);

/ 7	.

/ MyForm7	, MyPage7	, Person7	,

/ met Person7.getAddress().getStreet()

$ vi MyForm7.java

public class MyForm7<T extends Serializable> extends Form<T>{

	public void  set() {
		setModel(new Model<T>(t));

		IModel<String>nameModel=new PropertyModel<String>(t, "name");
		TextField<String>name=new TextField<String>("name", nameModel);
		add(name);

		IModel<String>addressModel=new PropertyModel<String>(t, "address.street");
		TextField<String>address=new TextField<String>("address.street", addressModel);
		add(address);

	}

	protected void onSubmit() {
		IModel<T>model=this.getModel();
		T t=model.getObject();
		Person7 person7=(Person7)t;
		String name=person7.getName();
		String street=person7.getAddress().getStreet();
		System.out.println(name);
		System.out.println(street);
		boolean b=false;
	}

$ vi MyPage7.java

		MyForm7<Person7>form7=new MyForm7<Person7>("form");
		Person7 person7=new Person7();
		form7.setT(person7);
		form7.set();
		add(form7);

/ person.getName()==person.getAddress()==null	,


$ vi MyPage7.html

		<form  wicket:id="form">
		
			<input  wicket:id="name" type="text">
			<br>
			<input wicket:id="address.street" type="text">
			<br>		
			<input  type="submit" value ="Set">
			
		</form>

/ 7	. 

/ MyPage8.html, MyPage8.java, MyForm8.java, Person8.java	, Address8.java	,

/ CompoundPropertyModel	,

$ vi MyPage8.html
		<form  wicket:id="form">
		
			<input  wicket:id="name" type="text">
			<br>
			<input wicket:id="address.street" type="text">
			<br>		
			<input  type="submit" value ="Set">
			
		</form>

$ vi MyPage8.java

		MyForm8<Person8>form8=new MyForm8<Person8>("form");
		Person8 person8=new Person8();
		form8.setT(person8);
		form8.set();
		add(form8);

$ vi MyForm8.java

public class MyForm8<T extends Serializable> extends Form<T>{

	public void  set() {
		setModel(new CompoundPropertyModel<T>(t));

		TextField<String>name=new TextField<String>("name");
		add(name);

		TextField<String>street=new TextField<String>("address.street");
		add(street);

	}
	@Override
	protected void onSubmit() {
		IModel<T>model=this.getModel();
		T t=model.getObject();
		Person8 person8=(Person8)t;
		String name=person8.getName();
		String street=person8.getAddress().getStreet();
		System.out.println(name);
		System.out.println(street);
		boolean b=false;
	}


$ vi Person8.java

public class Person8 implements Serializable{
	private String name;
	private Address8 address;
...

$ vi Address8.java

public class Address8 implements Serializable{
	private String street;
...


/ Einde WICKET MODELS

/ WICKET LAYOUT

/ we maken in eclipse een nieuw wicket maven project	, wicket-book	, met de wicket-archetype-quickstart	,


/ 7	.

$ vi Ch710.java

public class Ch710 extends WebPage {
	private static final long serialVersionUID = 1L;

	public Ch710(final PageParameters parameters) {
		super(parameters);

		Label label=new Label("dexter", "Omelette du fromage");
		add(label);
		Label label2=new Label("deedee","That's all you can say!");
		add(label2);
    }
}

$ vi Ch710.html

	<body>
		<blockquote wicket:id="dexter"></blockquote>
		<blockquote wicket:id="deedee"></blockquote>
	</body>

/ we zien	,

<body>
		<blockquote wicket:id="dexter">Omelette du fromage</blockquote>
		<blockquote wicket:id="deedee">That's all you can say!</blockquote>
</body>

/ 7	.

$ vi C711.html

	<body>
		<div wicket:id="container">
			<blockquote wicket:id="dexter"></blockquote>
			<blockquote wicket:id="deedee"></blockquote>		
		</div>
		<a href="#" wicket:id="link">Visible</a>
	</body>

$ vi Ch711.java

		final WebMarkupContainer container=new WebMarkupContainer("container");
		add(container);

		Label label=new Label("dexter", "Omelette du fromage");
		container.add(label);
		Label label2=new Label("deedee","That's all you can say!");
		container.add(label2);
		
		Link<Integer>link=new Link<Integer>("link"){
			@Override
			public void onClick() {
				container.setVisible(! container.isVisible());
				
			}

		};
		add(link);

		Link<Integer>ajaxLink=new AjaxFallbackLink<Integer>("ajaxLink") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				container.setVisible(! container.isVisible());
				if(target!=null){
					target.add(container);
				}
				
			}
		};
		container.setOutputMarkupPlaceholderTag(true);
		add(ajaxLink);

/ we zien	, als container zichtbaar	,

<body>
		<div wicket:id="container">
			<blockquote wicket:id="dexter">Omelette du fromage</blockquote>
			<blockquote wicket:id="deedee">That's all you can say!</blockquote>		
		</div>
		<a href="./?6-7.ILinkListener-link" wicket:id="link">Visible</a>
		<a href="./?0-1.ILinkListener-ajaxLink" wicket:id="ajaxLink" id="ajaxLink1">ajax Visible</a>
	

</body>

/ we zien	, als container niet zichtbaar	,

<body>
		<div id="container2" style="display:none"></div>
		<a href="./?5-6.ILinkListener-link" wicket:id="link">Visible</a>
		<a href="./?5-6.ILinkListener-ajaxLink" wicket:id="ajaxLink" id="ajaxLink1">ajax Visible</a>
</body>

/ 7	.

$ vi Ch711a.java

public class Ch711a extends WebPage {
	private static final long serialVersionUID = 1L;
	public class MyContainer extends WebMarkupContainer{
		public MyContainer(String id) {
			super(id);
			Label label=new Label("dexter", "Omelette du fromage");
			add(label);
			Label label2=new Label("deedee","That's all you can say!");
			add(label2);

		}
	}
	

	public Ch711a(final PageParameters parameters) {
		super(parameters);
		
		final WebMarkupContainer container=new MyContainer("container");
		add(container);

		
		Link<Integer>link=new Link<Integer>("link"){
			@Override
			public void onClick() {
				container.setVisible(! container.isVisible());
				
			}

		};
		add(link);
		
		Link<Integer>ajaxLink=new AjaxFallbackLink<Integer>("ajaxLink") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				container.setVisible(! container.isVisible());
				if(target!=null){
					target.add(container);
				}
				
			}
		};
		container.setOutputMarkupPlaceholderTag(true);
		add(ajaxLink);
		
		
    } 

	
}

$ vi Ch711a.html

	<body>
		<div wicket:id="container">
			<blockquote wicket:id="dexter"></blockquote>
			<blockquote wicket:id="deedee"></blockquote>		
		</div>
		<a href="#" wicket:id="link">Visible</a>
		<a href="#" wicket:id="ajaxLink">ajax Visible</a>
	</body>

/ 7	.

/ we kunnen de MyContainer ook in eigen class file	,

$ vi MyContainer.java

public class MyContainer extends WebMarkupContainer{
	public MyContainer(String id) {
		super(id);
		Label label=new Label("dexter", "Omelette du fromage");
		add(label);
		Label label2=new Label("deedee","That's all you can say!");
		add(label2);

	}
}

$ vi Ch711b.java

public class Ch711b extends WebPage {
	private static final long serialVersionUID = 1L;

	public Ch711b(final PageParameters parameters) {
		super(parameters);
		
		final WebMarkupContainer container=new MyContainer("container");
		add(container);
...

/ 7	.

/ PANEL IN WICKET

/ panel

/ we kunnen ook <wicket:link> om de MyPanel.css niet in src/main/webapp te set, maar in src/main/java	,  

$ vi Ch712a.html

<body>
	<div wicket:id="container">This get's replaced</div>
	<div wicket:id="container2">This get's replaced</div>
		
	<a href="#" wicket:id="link">Visible</a>
	<a href="#" wicket:id="ajaxLink">ajax Visible</a>
	<a href="#" wicket:id="swapLink">swap</a>

</body>

$ vi MyPanel.html

<head>
<wicket:head>
	<wicket:link>
		<link href="MyPanel.css" rel="stylesheet"/>
	</wicket:link>
</wicket:head>
</head>
<body>
	<h1>This tag will not be used.</h1>
	<wicket:panel>
		<h3 wicket:id="dexter">This text will be overwritten<h3>
		<h3 wicket:id="deedee">This text will be overwritten</h3>
	</wicket:panel>
</body>

$ vi Ch712a.java

	private Component container;
	private Component container2;

	public Ch712a(final PageParameters parameters) {
		super(parameters);
		
		container=new MyPanel("container");
		add(container);
		container2=new MyPanel("container2");
		add(container2);
...
		Link<Integer>ajaxLink=new AjaxFallbackLink<Integer>("ajaxLink") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				container.setVisible(! container.isVisible());
				if(target!=null){
					target.add(container);
				}
				
			}
		};
		container.setOutputMarkupPlaceholderTag(true);
//		container.setOutputMarkupId(true);
		add(ajaxLink);
...


$ vi MyPanel.java

public class MyPanel extends Panel{
	public MyPanel(String id) {
		super(id);
		Label label=new Label("dexter", "Omelette du fromage");
		add(label);
		Label label2=new Label("deedee","That's all you can say!");
		add(label2);

	}
}

$ vi WicketApplication.java

	public void init()
	{
		super.init();
		
		  getMarkupSettings().setStripWicketTags(true);


/ Voor ajax moeten we altijd  de container een id geven	,
	container.setOutputMarkupPlaceholderTag(true);
// of	,
	container.setOutputMarkupId(true);

/ Maar hier moeten we 
	container.setOutputMarkupPlaceholderTag(true);
/ want dan	, als er in HTML ,
<div id="container2">
	...
</div>
/ dan wordt deze vervangen door 
<div id="container2">/div>
/ Met container.setOutputMarkupId(true) gebeurt dat niet als we de component isVisible=false set	,	

/ we zien,	

<head>

	<link href="./wicket/resource/my.test.own.wicket_book.MyPanel/MyPanel-ver-1416219826000.css" rel="stylesheet">
	
<script type="text/javascript" src="./wicket/resource/org.apache.wicket.resource.JQueryResourceReference/jquery/jquery-1.11.1-ver-1415797672000.js"></script>
<script type="text/javascript" src="./wicket/resource/org.apache.wicket.ajax.AbstractDefaultAjaxBehavior/res/js/wicket-event-jquery-ver-1415797672000.js"></script>
<script type="text/javascript" src="./wicket/resource/org.apache.wicket.ajax.AbstractDefaultAjaxBehavior/res/js/wicket-ajax-jquery-ver-1415797672000.js"></script>
<script type="text/javascript" src="./wicket/resource/org.apache.wicket.ajax.AbstractDefaultAjaxBehavior/res/js/wicket-ajax-jquery-debug-ver-1415797672000.js"></script>

	<meta charset="utf-8">
	<title>Apache Wicket Quickstart</title>
	<link href="http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:regular,bold" rel="stylesheet" type="text/css">
	<link rel="stylesheet" href="style.css" type="text/css" media="screen" title="Stylesheet">
</head>

</script>
	<meta charset="utf-8">
	<title>Apache Wicket Quickstart</title>
	<link href="http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:regular,bold" rel="stylesheet" type="text/css">
	<link rel="stylesheet" href="style.css" type="text/css" media="screen" title="Stylesheet">
<script type="text/javascript">
</script>
<div wicket:id="container" id="container2">
	<wicket:panel>
		<h3 wicket:id="dexter">Omelette du fromage</h3>
		<h3 wicket:id="deedee">That's all you can say!</h3>
	</wicket:panel>
</div>
		
<a href="./?2-3.ILinkListener-link" wicket:id="link">Visible</a>
<a href="./?2-3.ILinkListener-ajaxLink" wicket:id="ajaxLink" id="ajaxLink1">ajax Visible</a>


</body>


/ 13	. 
/ als we steeds 
localhost:8080

/ dus NIET reload localhost:8080/?12 bijv	,

/ dan zien we steeds een andere id in
<div wicket:id="container" id="container2">
/ id="container2"/ "containera" / ...

/ en de href's veranderen in	,
<a href="./?2-3.ILinkListener-link" wicket:id="link">Visible</a>
/ later	, "./?10-1.ILinkListener-link" 	, ...

/ 13	.

/ als niet visible, zien we alleen	,

<div wicket:id="container" id="container2"></div>

/ 13	. 

/ we add nog een link	,

		Link<Integer>swapLink=new Link<Integer>("swapLink"){
			@Override
			public void onClick() {
				container.replaceWith(alt);
				
				Component component=container;
				container=alt;
				alt=component;
				
			}
			private Component alt=new EmptyPanel("container");
		};
		add(swapLink);

/ we hoeven geen EmptyPanel.html te create	,

/ als we swap click , is de hele container WEG	, dus we zien NIET	, zoals bij not visible set	,
<div id="container2" style="display:none"></div>
/ er is gewoon niets	,
/ als we swap hebben click  , heeft visible click geen zin (ajax of niet)	,

/ Einde PANEL IN WICKET

/ 7	. 

/ FRAGMENTS IN WICKET

/ met panels moeten we geen eigen html page maken	, maar de markup van de fragment moet in die van de page	,

/ In new MyFragment("container",this) is "container" de wicket:id in HTML	, en in MyFragment zien we super(id,"myfragment",page)	, hier is id="container"	, en "myfragment" is de wicket:id in HTML 	, van de 

/ we kunnen WH op een component maar 1 fragment add	,

$ vi  Ch713.java

	private Component container;

	public Ch713(final PageParameters parameters) {
		super(parameters);
		
		container=new MyFragment("container",this);
		add(container);
		container=new MyOtherFragment("container2",this);
		add(container);
...

$ vi Ch713.html

	<div wicket:id="container">This get's replaced</div>
	<div wicket:id="container2">This get's replaced</div>
	
	<wicket:fragment wicket:id="myfragment">
		<h3 wicket:id="dexter">This text will be overwritten</h3>
		<h3 wicket:id="deedee">This text will be overwritten</h3>
	</wicket:fragment>
	
	<wicket:fragment wicket:id="myotherfragment">
		<h3 wicket:id="foo">This text will be overwritten</h3>
		<h3 wicket:id="bar">This text will be overwritten</h3>
	</wicket:fragment>

$ vi MyFragment.java

	public MyFragment(String id,WebPage page) {
		super(id,"myfragment",page);
		Label label=new Label("dexter", "Omelette du fromage");
		add(label);
		Label label2=new Label("deedee","That's all you can say!");
		add(label2);

	}

$ vi MyOtherFragment.java

	public MyOtherFragment(String id,WebPage page) {
		super(id,"myotherfragment",page);
		Label label=new Label("foo", "Foo is Foo");
		add(label);
		Label label2=new Label("bar","Bar is Bar!");
		add(label2);

	}

/ stackoverflow	,

/ Einde FRAGMENTS IN WICKET

/ 7	.

/ Lees	,
https://wicket.apache.org/guide/guide/urls.html

/ In wicket_quickstart , MyLinks.java/MyLinks.html	,

/ 13	. 
/ we kunnen in MyLinks.java	,

		BookmarkablePageLink<Integer>blink=new BookmarkablePageLink<Integer>("blink", MyTarget.class);
		add(blink);

/ of in MyLinks.html	,

	<wicket:link>
	<a href="MyTarget.html">my target</a>
	</wicket:link>

/ In beide gevallen zien we in HTML	,
	<a href="./wicket/bookmarkable/my.test.own.wicket_quickstart.MyTarget">my target</a>

/ als we geen <wicket:link> om deze a	, dan gaat hij naar localhost:8080/MyTarget.html	, en die is er niet, 	ERR	,
/ TODO

/ 13	. 

/ Als we in MyLinks.java	,

		Link<Integer>link2=new Link<Integer>("link2") {
			@Override
			public void onClick() {
				setResponsePage(MyTarget.class);
				
			}
		};

/ dan zien in in HTML	,
	<a wicket:id="link2" id="link214" href="./?6-2.ILinkListener-link2">link2</a>

/ Maar als we er op click , komen we toch in 	,
http://localhost:8080/wicket/bookmarkable/my.test.own.wicket_quickstart.MyTarget

/ Hieromheen <wicket:link> set is zinloos	,

/ 13	.

	<a wicket:id="elink">elink</a>


		ExternalLink elink=new ExternalLink("elink", new Model<String>("//www.google.com"));
		add(elink);

/ 13	.

$ vi WicketApplication.java

	public void init()
	{
		super.init();
		
		mountPage("/mytarget", MyTarget.class);


/ Als we nu click op 1 van de mytarget links, zien  we niet meer de bookmarkable url, maar	,
http://localhost:8080/mytarget

/ we zien ook dat binnen <wicket:link>	, 
	<a href="./target">

/ 7	.

/ wicket-in-action	,

$ vi WicketInActionApplication.java

   getMarkupSettings().setStripWicketTags(true);

/ We zien in de result HTML GEEN <wicket:extend> of <wicket:link>

/ 7	.

/ project wicket-book	,

/ INHERITANCE IN WICKET 


/ 13	. 

/ we zagen bij panels in wicket dat we 
/ in de panel's html <wicket:panel> use (en <wicket:head>)	, 
/ in de container's html <div id="panel"> 	, 

/ inh werkt met <wicket:extend/>, <wicket:child/>	,

/ In wicket-in-action	,

Index.html
	-------------------------ChildPage.html
|	-------------------------------------------------CheesrPage.html					|
|					|			|
| 					|			|
AbstractBasePage.html		BasePage.html		BasePage.html
/ met menu	,

/ we zien een extend op AbstractBasePage, en op BasePage	,

/ we maken ook zoiets	,

$ vi Index.html

<wicket:extend>
<wicket:link>
<a href="Ch722_1.html">Ch722_1</a>
<a href="Ch722_2.html">Ch722_2</a>
</wicket:link>
</wicket:extend>

$ vi Index.java

public class Index extends AbstractBasePage {
	public Index(final PageParameters parameters) {
		super(parameters);
    } 
}

$ vi AbstractBasePage.html

<h1>Before child</h1>
<wicket:child/>
<h1>After child</h1>

$ vi AbstractBasePage.java

public class AbstractBasePage extends WebPage {
	public AbstractBasePage(final PageParameters parameters) {
		super(parameters);
    } 
}

$ vi Ch722_1/2.html

<wicket:extend>
<h1>Ch722_1/2</h1>
</wicket:extend>

$ vi Ch722_1/2.java

public class Ch722_1/2 extends BasePage {
	public Ch722_1/2(final PageParameters parameters) {
		super(parameters);
    } 
}








/ Einde WICKET LAYOUT

/ WICKET FORM COMPONENTS

/ 7	. 

/ button	,

/ Lees
/ boek(70)

/ Lees	,
http://ci.apache.org/projects/wicket/apidocs/7.x/

public Button(String id, IModel<String> model)
Constructor taking an model for rendering the 'label' of the button (the value attribute of the input/button tag). Use a StringResourceModel for a localized value.

$ vi Ch64.html

		<form wicket:id="form">
			<input type="submit" wicket:id="button">
			
			<input type="submit" wicket:id="link">
<!-- 			
			<a wicket:id="link">link</a>
 -->		
 		</form>

$ vi Ch64.java

		Form<Integer>form=new Form<Integer>("form", new Model<Integer>(13));
		add(form);
		
		Button button=new Button("button", new Model<String>("X")){
			public void onSubmit() {
				IModel<String>model=this.getModel();
				String string=model.getObject();
				LOG.info("submit "+string);
			}
		};
		form.add(button);
		
		Link<String>link=new Link<String>("link",new Model<String>("Y")) {
			@Override
			public void onClick() {
				IModel<String>model=this.getModel();
				String string=model.getObject();
				LOG.info("link "+string);
				
				
			}
		};
		form.add(link);
		IModel<String>model=link.getModel();
		AttributeModifier attributeModifier=new AttributeModifier("value", model);
		link.add(attributeModifier);


/ we kunnen een Button , of een Link set op een <input type="submit", of een <a 	, 
/ WH kunnen we alles door elkaar use	,
		
/ we zien dat bij Wicket's Button de model de value attr geeft	,  bij Wicket's Link moeten we het zelf doen	,

/ we zien	,

<form id="form1" method="post" action="./?0-3.IFormSubmitListener-form">
	<div style="width:0px;height:0px;position:absolute;left:-100px;top:-100px;overflow:hidden">
		<input type="hidden" name="form1_hf_0" id="form1_hf_0">
	</div>
	<input type="submit" name="button" id="button2" value="X">
	<input type="submit" onclick="var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; if (win == window) { window.location.href='./?0-3.ILinkListener-form-link'; } ;return false" value="Y">
<!-- 			
	<a wicket:id="link">link</a>
 -->		
 /form>

/ 13	. 

/ we hebben iets uitgebreid	,

$ vi Ch64.html

			<input type="text" wicket:id="field">
			<input type="submit" wicket:id="button">
			<input type="submit" wicket:id="link">

/ we zien	,

<body>
	<form id="form1" method="post" action="./?1-4.IFormSubmitListener-form">
		<div style="width:0px;height:0px;position:absolute;left:-100px;top:-100px;overflow:hidden"><input type="hidden" name="form1_hf_0" id="form1_hf_0"></div>
		<input type="text" value="45" name="field">
		<input type="submit" name="button" id="button2" value="X">
		<input type="submit" onclick="var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; if (win == window) { window.location.href='./?1-4.ILinkListener-form-link'; } ;return false" value="Y">
 	</form>
	

</body>


$ vi Ch64.java
/ TODO

/ 7	

/ we maken cp van Ch64	, Ch64_1	,

/ see	,
TextField<T>(FormComponent<T>).setType(Class<?>) line: 1078	
/ ,
TextField<T>(AbstractTextComponent<T>).resolveType() line: 153	
/ ,
TextField<T>(Component).getConverter(Class<C>) line: 1366	

Thread [qtp1326354973-20] (Suspended (breakpoint at line 1366 in Component))	
	TextField<T>(Component).getConverter(Class<C>) line: 1366	
	TextField<T>(Component).getDefaultModelObjectAsString(Object) line: 1671	
	TextField<T>(Component).getDefaultModelObjectAsString() line: 1646	
	TextField<T>(FormComponent<T>).getModelValue() line: 1293	
	TextField<T>(FormComponent<T>).getValue() line: 877	
	TextField<T>.onComponentTag(ComponentTag) line: 108	
	TextField<T>(Component).internalRenderComponent() line: 2513	
	TextField<T>(MarkupContainer).onRender() line: 1540	
	TextField<T>(Component).internalRender() line: 2372	
	TextField<T>(Component).render() line: 2300	
	Form<T>(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Form<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Form<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1576	
	Form<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1500	
	Form<T>.onComponentTagBody(MarkupStream, ComponentTag) line: 1683	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Form<T>(Component).internalRenderComponent() line: 2557	
	Form<T>(MarkupContainer).onRender() line: 1540	
	Form<T>(Component).internalRender() line: 2372	
	Form<T>(Component).render() line: 2300	
	Ch64_0(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Ch64_0(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Ch64_0(Page).onRender() line: 879	
	Ch64_0(WebPage).onRender() line: 142	
	Ch64_0(Component).internalRender() line: 2372	
	Ch64_0(Component).render() line: 2300	
	Ch64_0(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 837	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 97	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ServletHandler$CachedChain.doFilter(ServletRequest, ServletResponse) line: 1650	
	ServletHandler.doHandle(String, Request, HttpServletRequest, HttpServletResponse) line: 583	
	ServletHandler(ScopedHandler).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 143	
	ConstraintSecurityHandler(SecurityHandler).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 577	
	SessionHandler.doHandle(String, Request, HttpServletRequest, HttpServletResponse) line: 223	
	WebAppContext(ContextHandler).doHandle(String, Request, HttpServletRequest, HttpServletResponse) line: 1125	
	ServletHandler.doScope(String, Request, HttpServletRequest, HttpServletResponse) line: 515	
	SessionHandler.doScope(String, Request, HttpServletRequest, HttpServletResponse) line: 185	
	WebAppContext(ContextHandler).doScope(String, Request, HttpServletRequest, HttpServletResponse) line: 1059	
	WebAppContext(ScopedHandler).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 141	
	Server(HandlerWrapper).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 97	
	Server.handle(HttpChannel<?>) line: 497	
	HttpConnection$HttpChannelOverHttp(HttpChannel<T>).handle() line: 311	
	HttpConnection.onFillable() line: 248	
	AbstractConnection$2.run() line: 540	
	QueuedThreadPool.runJob(Runnable) line: 610	
	QueuedThreadPool$3.run() line: 539	
	Thread.run() line: 745	

/t
TextField<T>(Component).getDefaultModelObjectAsString(Object) line: 1676	
			final IConverter converter = getConverter(objectClass);

			// Model string from property
			final String modelString = converter.convertToString(modelObject, getLocale());
"7"
...
/t
TextField<T>.onComponentTag(ComponentTag) line: 108	
		tag.put("value", getValue());

/ Ch64_0	, 
/ = Ch64, maar dat maar 1 form	, 

/ 7	.

/ <input name="name" value="74" is niet wat meegezonden wordt	,  maar wat er in de model van de input staat (=wat we ingetypt hebben)	,
/ stel dat we "748" mee, dan wordt WH via getters op wicket value="748"	, 
/ maar als we in dev tools value="7148" set	, zien we die in de input ook	, 


/ 7	.  

/ Ch64_1 

		<form wicket:id="form4">	
			<select wicket:id="list4"></select>
			<input type="submit" wicket:id="button4">
 		</form>


$ vi Ch64_1.java

public class Ch64_1 extends WebPage {
		{
		Form<Integer>form=new Form<Integer>("form4", new Model<Integer>(13));
		add(form);
		
		final class MyType{
			private final int id;
			private final String name;
			public MyType(int id,String name) {
				this.id=id;
				this.name=name;
			}
			
		}
		
		final class Cont{
			private MyType myType;

			public MyType getMyType() {
				return myType;
			}

			public void setMyType(MyType myType) {
				this.myType = myType;
			}
		}
		
		Cont cont=new Cont();
		List<MyType>myTypes=Arrays.asList(
				new MyType(1, "Value1"),
				new MyType(2, "Value2"),
				new MyType(3, "Value3"),
				new MyType(4, "Value4")
				);
		
		IModel<MyType>model=new PropertyModel<MyType>(cont, "myType");
		IChoiceRenderer<MyType>choiceRenderer=new ChoiceRenderer<MyType>("name", "id");
		final ListChoice<MyType>list=new ListChoice<MyType>("list4", model,myTypes,choiceRenderer);
		form.add(list);
		cont.setMyType(myTypes.get(2));
		
		form.add(list);
		
		Button button=new Button("button4", new Model<String>("X")){
			public void onSubmit() {
				IModel<MyType>model=list.getModel();
				MyType myType=model.getObject();
				LOG.info("submit "+myType.id+","+myType.name);
			}
		};
		form.add(button);

		}

/ we zien een list met Value1, ... . De value="1", ... op de items	,

/ Maar als we	,
		IChoiceRenderer<MyType>choiceRenderer=new ChoiceRenderer<MyType>("id", "name");

/ dan zien we juist een list met 1,2,..., 	en is in HTML value="Value1", ...

/ 7	. 

/ SPRING-BOOK

/ In spring-book project, 
/ mvn clean test
/ run application Start	,

/ Einde SPRING-BOOK

/ WICKET REPEATING VIEW LISTVIEW

/ 7	.

/ we deploy nu ook in tomcat7	, 
$ vi pom.xml

	<properties>
		<tomcat.version>2.2</tomcat.version>
	</properties>
	<plugin>
		<groupId>org.apache.tomcat.maven</groupId>
		<artifactId>tomcat7-maven-plugin</artifactId>
		<version>${tomcat.version}</version>
		<configuration>
    			<port>8080</port>
    			<path>/${project.artifactId}</path>
    			<url>http://localhost:8080/manager/text</url>
    			<server>my_tomcat</server>
 		</configuration>
	</plugin>

/ 7	.


/ In Start.java hebben we de port op 9090 set	,
		http.setPort(9090);

/ mvn clean test
/ run Start as Java application	,
/ Geef localhost:9090 

/ RepeatingView, ListView	,

/ Beide extends AbstractRepeater	,

/ MORGEN	,
/ source code ajax form	,
http://www.wicket-library.com/wicket-examples/index.html
/ Kies ajax	,
http://www.wicket-library.com/wicket-examples/ajax/
/ Kies Form example

/ een RepeatingView op een table gaat NIET OK	, see rview1_2	, in Ch55.java/html	,
/ WH niet geschikt voor een table	,
/ TODO

/ 13	. 

/ een repeating view is een template , niet een parent,	 al doe je rview.add(label)

		<li wicket:id="rvlist"></li>

		RepeatingView rview=new RepeatingView("rvlist");
		add(rview);
		for(int i=0;i<5;i++){
			String id=Integer.toString(i+100);
			Label label=new Label(id, "value "+String.valueOf(i));
			rview.add(label);

/ een repeating view geeft templates	, meerdere	, deze worden gekoppeld aan de label obj uit Java	, we zien ook dat de templates de id van het label hebben	, dus het klopt	,

/ met 	add(rview); we add het template aan de page, of alle instances, alle li's	,

<li wicket:id="rvlist" id="id1001">value 0</li>
<li wicket:id="rvlist" id="id1002">value 1</li>


/ in een andere page doen we met de hand	,

		<div wicket:id="label4"></div>

		Label label=new Label("label4", "Foo Bar");
		label.setOutputMarkupId(true);
		add(label);

/ we zien dan 	
<div wicket:id="label4" id="label41">Foo Bar</div>

/ hier is dus de <div> de repeating view template	, 



/ 13	. 

/ gen id's	,

		    <li wicket:id="rvlist"></li>
		    <div wicket:id="rvlist0"></div>


		RepeatingView rview=new RepeatingView("rvlist");
		add(rview);
		for(int i=0;i<5;i++){
			String id=Integer.toString(i+100);
			Label label=new Label(id, "value "+String.valueOf(i));
			rview.add(label);

		RepeatingView rview=new RepeatingView("rvlist0");
		add(rview);
		for(int i=0;i<5;i++){
			String id=rview.newChildId();
			Label label=new Label(id, "value "+String.valueOf(i));
			rview.add(label);



/ we zien	,

		<h2>rvlist</h2>
		
		<li id="id1001">value 0</li>
		<li id="id1012">value 1</li>
		<li id="id1023">value 2</li>
		<li id="id1034">value 3</li>
		<li id="id1045">value 4</li>
		
		
		<h2>rvlist0</h2>
		<div id="id16">value 0</div>
		<div id="id27">value 1</div>
		<div id="id38">value 2</div>
		<div id="id49">value 3</div>
		<div id="id5a">value 4</div>
	
	
/ we zien dat 
			String id=rview.newChildId();
/ voor iedere RepeatableView steeds opnieuw begint met 1,2,... en dat er ook steeds een getal achter komt, maar die loopt in de page door	, 1,2,...,a,..., f,10, 11, ...
/ dus hierna komen	,
		<li id="id1b" 
		<li id="id2c" 
		<li id="id3d"
		<li id="id4e" 
		<li id="id5f"

<ul>
	   	<li id="id110"
		<li id="id211"
		<li id="id312"
		<li id="id413"
		<li id="id514"

/ 13	. 

/ repeating view is template voor container	,

		    <div wicket:id="rvmenu">
		        <a  wicket:id="link">
		            <span wicket:id="caption"></span>
		        </a>
		    </div>

		RepeatingView rview=new RepeatingView("rvmenu");
		add(rview);
		List<MenuItem>menu=createMenu();
		int i=1001;
		for(MenuItem item:menu){
			String id=Integer.toString(i++);
			WebMarkupContainer container=new WebMarkupContainer(id);
			container.setOutputMarkupId(true);
			rview.add(container);
			BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>("link", item.getDestination());
			container.add(link);
			link.setOutputMarkupId(true);
			Label label=new Label("caption",item.getCaption());
			label.setOutputMarkupId(true);
			link.add(label);
		}

<div wicket:id="rvmenu" id="id100123">
	<a wicket:id="link" id="link24" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		<span wicket:id="caption" id="caption25">Home</span>
	</a>
</div>
<div wicket:id="rvmenu" id="id100226">
        <a wicket:id="link" id="link27" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
            <span wicket:id="caption" id="caption28">Cheeses</span>
        </a>
</div>

/ we zien dat iedere repeating view een container is	, met de juiste id	,  (eig. repeating view template)	, en deze hebben ieder een eigen id	, daarom kunnen we  de link id "link" geven	, want alle link's zitten in de andere container	, en we zien ook dat de id doortelt: "id1000226" , "link27", "caption28"

/ 13	. 

/ ListView is WH als RepeatableView: ListView is een template, voor  ListItem is als WebMarkupContainer	, dus <li wicket:id="lvmenu" id="id037">

		ListView<MenuItem> lview=new ListView<MenuItem>("lvmenu",menu) {
			@Override
			protected void populateItem(ListItem<MenuItem> item) {
				item.setOutputMarkupId(true);
				MenuItem menuItem=item.getModel().getObject();
				BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>("link"	,menuItem.getDestination());
				item.add(link);
				link.setOutputMarkupId(true);
				Label label=new Label("lcaption", menuItem.getCaption());
				link.add(label);
				label.setOutputMarkupId(true);

/ we zien	,

<li wicket:id="lvmenu" id="id037">
	<a wicket:id="link" id="link38" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
        	<span wicket:id="lcaption" id="lcaption39">Home</span>
	</a>
</li>
<li wicket:id="lvmenu" id="id15a">
	<a wicket:id="link" id="link5b" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
        	<span wicket:id="lcaption" id="lcaption5c">Cheeses</span>
	</a>
</li>

/ 13	. 

/ listdataprovider

/ we kunnen deze use op een <tr><td/>...</tr>
/ maar hoeft niet perse	, ook <div><div/>...</div>

	<table>
		<tr wicket:id="row">
		   <td wicket:id="datum"></td>
		</tr>
	</table>

/ of	,

		<div wicket:id="row">
		   <div wicket:id="datum"></div>
		</div>

		List<Person> persons = Arrays.asList(new Person("Foo","Street 1"),new Person("Bar","Lane 7"));
		ListDataProvider<Person> listDataProvider = new ListDataProvider<Person>(persons);
		DataView<Person> dataView = new DataView<Person>("row", listDataProvider) {
		  @Override
		  protected void populateItem(Item<Person> item) {
			item.setOutputMarkupId(true);
		    Person person = item.getModelObject();
		    RepeatingView repeatingView = new RepeatingView("datum");

		    {
		    Label label=new Label(repeatingView.newChildId(), person.getName());
		    label.setOutputMarkupId(true);
		    repeatingView.add(label);
		    }
		    {
    		Label label=new Label(repeatingView.newChildId(), person.getAddress()); 
    		label.setOutputMarkupId(true);
		    repeatingView.add(label);
		    }
		    item.add(repeatingView); 
		  }
		};
		dataView.setOutputMarkupId(true);
		add(dataView);

/ als we 	,
	<table>
		<tr wicket:id="row">
		   <td wicket:id="datum"></td>
		</tr>
	</table>

/ we zien	,

	<table>
		<tbody><tr>
		   <th>Name</th><th>Surename</th><th>Address</th><th>Email</th>
		</tr>
		<tr wicket:id="row" id="id11">
		   <td wicket:id="datum" id="id12">Foo</td><td wicket:id="datum" id="id23">Street 1</td>
		</tr><tr wicket:id="row" id="id24">
		   <td wicket:id="datum" id="id15">Bar</td><td wicket:id="datum" id="id26">Lane 7</td>
		</tr>
		</tbody>
	</table>


/ als we	,
		<div wicket:id="row">
		   <div wicket:id="datum"></div>
		</div>

/ dan zien we	,

		<div wicket:id="row" id="id11">
		   <div wicket:id="datum" id="id12">Foo</div><div wicket:id="datum" id="id23">Street 1</div>
		</div><div wicket:id="row" id="id24">
		   <div wicket:id="datum" id="id15">Bar</div><div wicket:id="datum" id="id26">Lane 7</div>
		</div>
	
	
/ 13	. 

/ gofilter	,

/ in wicket-extensions	,

[eric@localhost wicket]$ pwd
/home/eric/.m2/repository/org/apache/wicket
[eric@localhost wicket]$ for j in $(find -name "*.jar");do echo $j;jar tvf $j|grep -i gofilter;done
./wicket-extensions/1.3.7/wicket-extensions-1.3.7.jar
  1633 Thu Jul 23 10:11:40 CEST 2009 org/apache/wicket/extensions/markup/html/repeater/data/table/filter/GoFilter.class
   878 Thu Jul 23 10:11:38 CEST 2009 org/apache/wicket/extensions/markup/html/repeater/data/table/filter/GoFilter.html
  1165 Thu Jul 23 10:11:40 CEST 2009 org/apache/wicket/extensions/markup/html/repeater/data/table/filter/GoFilter$1.class

/ 13	. 

/ we willen wicket-examples	,

/ we hebben POM en sources.jar van search.maven.org 	, en zelf in maven struct set	,
[eric@localhost Examples]$  pwd
/home/eric/Devel/Java/Wicket/Examples
[eric@localhost Examples]$ ls
pom.xml  src 
/ Toen hebben we import maven project	, 
/ en hebben jetty:run
/ ERR
/ TODO

/ 13	.

/ we hebben my-webapp en my-main	,

/ my-wabapp's pom	,

	<groupId>my.test.own</groupId>
	<version>0.0.1-SNAPSHOT</version>
  	<artifactId>my-webapp</artifactId>
  	<packaging>war</packaging>
  	<name>My Webapp</name>
  	<url>http://maven.apache.org</url>
  	<dependencies>
	<dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
            <scope>provided</scope>
        </dependency>
  	</dependencies>
  	<build>
    		<finalName>my-webapp</finalName>
  	</build>	

/ Deze moeten we $ mvn clean install

/ my-main pom	,

	<groupId>my.test.own</groupId>
	<version>0.0.1-SNAPSHOT</version>
  	<artifactId>my-main</artifactId>
  	<packaging>war</packaging>
  	<name>My Main</name>
  	<url>http://maven.apache.org</url>
  	<dependencies>
    	<dependency>
    		<groupId>my.test.own</groupId>
    		<artifactId>my-webapp</artifactId>
    		<version>0.0.1-SNAPSHOT</version>
    		<type>war</type>
    	</dependency>		
  	</dependencies>
  	<build>
    		<finalName>my-main</finalName>
	<plugins>
		<plugin>
			<groupId>org.mortbay.jetty</groupId>
			<artifactId>jetty-maven-plugin</artifactId>
		</plugin>
	</plugins>
  </build>

/ Deze kunnen we dan $ mvn jetty:run -Djetty.port=9090

/ we maken met org.apache.wicket:wicket-archetype-quickstart:7.0.0.M4 een mvn project wicket-examples-import, en doen in de pom	,
		<dependency>
		    <groupId>org.apache.wicket</groupId>
		    <artifactId>wicket-examples</artifactId>
		    <version>${wicket.version}</version>
		    <type>war</type>
		</dependency>

/ Maar dan ERR	,
2015-01-02 08:20:41.488:WARN:oejuc.AbstractLifeCycle:main: FAILED org.eclipse.jetty.annotations.ServletContainerInitializersStarter@148a8965: java.lang.NoClassDefFoundError: org/apache/catalina/core/ApplicationContextFacade
java.lang.NoClassDefFoundError: org/apache/catalina/core/ApplicationContextFacade

/ Dit is een Tomcat class type	,
/ TODO

/ als we  de dep op wicket-examples rm, dus alleen wicket-archetype-quickstart doen, dan OK	, 
/ hier zien we org.eclipse.jetty	,

/ 13	. 

/ In my-main hebben we org.mortbay.jetty:jetty-maven-plugin	, 
/ OK

/ In my-main2 hebben we org.eclipse.jetty:jetty-maven-plugin	, 

	<plugin>
		<groupId>org.eclipse.jetty</groupId>
		<artifactId>jetty-maven-plugin</artifactId>
		<version>${jetty.version}</version>
		<configuration>
                	<httpConnector>
                    		<port>9090</port>
                	</httpConnector>
            	</configuration>
	</plugin>
/ OK

/ 13	. 

/ we hebben maven project org.apache.tomcat.maven:tomcat-maven-archetype:2.2 create	,
/ we doen in my-tomcat	,
$ mvn clean install

/ Daarna zullen we doen in my-tomcat-webapp	,
$ mvn tomcat7:run

[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO] 
[INFO] my-tomcat
[INFO] my-tomcat-api
[INFO] my-tomcat-api-impl
[INFO] my-tomcat-webapp
[INFO] my-tomcat-webapp-exec
[INFO] my-tomcat-webapp-it
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building my-tomcat 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-tomcat ---
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0.1:enforce (enforce-java) @ my-tomcat ---
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.pom (4 KB at 37.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.pom (4 KB at 91.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-api/1.0.1/enforcer-api-1.0.1.jar (10 KB at 140.7 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/enforcer/enforcer-rules/1.0.1/enforcer-rules-1.0.1.jar (60 KB at 583.6 KB/sec)
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ my-tomcat ---
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/pom.xml to /home/eric/.m2/repository/my/test/own/my-tomcat/0.0.1-SNAPSHOT/my-tomcat-0.0.1-SNAPSHOT.pom
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building my-tomcat-api 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-tomcat-api ---
[INFO] Deleting /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api/target
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0.1:enforce (enforce-java) @ my-tomcat-api ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ my-tomcat-api ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ my-tomcat-api ---
[INFO] Compiling 1 source file to /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ my-tomcat-api ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ my-tomcat-api ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.13:test (default-test) @ my-tomcat-api ---
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.pom (6 KB at 122.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.pom (3 KB at 58.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.pom (3 KB at 70.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-booter/2.13/surefire-booter-2.13.jar (35 KB at 392.8 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/maven-surefire-common/2.13/maven-surefire-common-2.13.jar (221 KB at 1452.8 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-api/2.13/surefire-api-2.13.jar (152 KB at 867.0 KB/sec)
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ my-tomcat-api ---
[INFO] Building jar: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api/target/my-tomcat-api-0.0.1-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ my-tomcat-api ---
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api/target/my-tomcat-api-0.0.1-SNAPSHOT.jar to /home/eric/.m2/repository/my/test/own/my-tomcat-api/0.0.1-SNAPSHOT/my-tomcat-api-0.0.1-SNAPSHOT.jar
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api/pom.xml to /home/eric/.m2/repository/my/test/own/my-tomcat-api/0.0.1-SNAPSHOT/my-tomcat-api-0.0.1-SNAPSHOT.pom
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building my-tomcat-api-impl 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-tomcat-api-impl ---
[INFO] Deleting /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/target
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0.1:enforce (enforce-java) @ my-tomcat-api-impl ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ my-tomcat-api-impl ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ my-tomcat-api-impl ---
[INFO] Compiling 1 source file to /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ my-tomcat-api-impl ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ my-tomcat-api-impl ---
[INFO] Compiling 1 source file to /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/target/test-classes
[INFO] 
[INFO] --- maven-surefire-plugin:2.13:test (default-test) @ my-tomcat-api-impl ---
[INFO] Surefire report directory: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/target/surefire-reports
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.pom (3 KB at 56.6 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/surefire-providers/2.13/surefire-providers-2.13.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/surefire-providers/2.13/surefire-providers-2.13.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-providers/2.13/surefire-providers-2.13.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-providers/2.13/surefire-providers-2.13.pom (3 KB at 52.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.13/surefire-junit4-2.13.jar (78 KB at 1188.4 KB/sec)

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running my.test.own.my_tomcat.api.impl.TestDefaultHelloService
Jan 02, 2015 9:48:36 AM org.apache.coyote.AbstractProtocol init
INFO: Initializing ProtocolHandler ["http-bio-auto-1"]
Jan 02, 2015 9:48:36 AM org.apache.catalina.core.StandardService startInternal
INFO: Starting service Tomcat
Jan 02, 2015 9:48:36 AM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.47
Jan 02, 2015 9:48:36 AM org.apache.catalina.startup.DigesterFactory register
WARNING: Could not get url for /javax/servlet/jsp/resources/jsp_2_0.xsd
Jan 02, 2015 9:48:36 AM org.apache.catalina.startup.DigesterFactory register
WARNING: Could not get url for /javax/servlet/jsp/resources/jsp_2_1.xsd
Jan 02, 2015 9:48:36 AM org.apache.catalina.startup.DigesterFactory register
WARNING: Could not get url for /javax/servlet/jsp/resources/jsp_2_2.xsd
Jan 02, 2015 9:48:36 AM org.apache.catalina.startup.DigesterFactory register
WARNING: Could not get url for /javax/servlet/jsp/resources/web-jsptaglibrary_1_1.dtd
Jan 02, 2015 9:48:36 AM org.apache.catalina.startup.DigesterFactory register
WARNING: Could not get url for /javax/servlet/jsp/resources/web-jsptaglibrary_1_2.dtd
Jan 02, 2015 9:48:36 AM org.apache.catalina.startup.DigesterFactory register
WARNING: Could not get url for /javax/servlet/jsp/resources/web-jsptaglibrary_2_0.xsd
Jan 02, 2015 9:48:36 AM org.apache.catalina.startup.DigesterFactory register
WARNING: Could not get url for /javax/servlet/jsp/resources/web-jsptaglibrary_2_1.xsd
Jan 02, 2015 9:48:37 AM org.apache.catalina.core.ApplicationContext log
INFO: Initializing Spring root WebApplicationContext
Jan 02, 2015 9:48:37 AM org.springframework.web.context.ContextLoader initWebApplicationContext
INFO: Root WebApplicationContext: initialization started
Jan 02, 2015 9:48:37 AM org.springframework.context.support.AbstractApplicationContext prepareRefresh
INFO: Refreshing Root WebApplicationContext: startup date [Fri Jan 02 09:48:37 CET 2015]; root of context hierarchy
Jan 02, 2015 9:48:37 AM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
INFO: Loading XML bean definitions from URL [file:/home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/target/classes/META-INF/spring-context.xml]
Jan 02, 2015 9:48:37 AM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
INFO: Loading XML bean definitions from class path resource [META-INF/cxf/cxf.xml]
Jan 02, 2015 9:48:37 AM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
INFO: Loading XML bean definitions from class path resource [META-INF/cxf/cxf-servlet.xml]
Jan 02, 2015 9:48:37 AM org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider registerDefaultFilters
INFO: JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning
Jan 02, 2015 9:48:38 AM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons
INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@901846d: defining beans [cxf,org.apache.cxf.bus.spring.BusWiringBeanFactoryPostProcessor,org.apache.cxf.bus.spring.Jsr250BeanPostProcessor,org.apache.cxf.bus.spring.BusExtensionPostProcessor,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,helloService#default,testServices,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor]; root of factory hierarchy
Jan 02, 2015 9:48:38 AM org.apache.cxf.endpoint.ServerImpl initDestination
INFO: Setting the server's publish address to be /testServices
Jan 02, 2015 9:48:38 AM org.springframework.web.context.ContextLoader initWebApplicationContext
INFO: Root WebApplicationContext: initialization completed in 985 ms
Jan 02, 2015 9:48:38 AM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-auto-1-34284"]
Tomcat started on port:34284
Jan 02, 2015 9:48:38 AM org.apache.coyote.AbstractProtocol pause
INFO: Pausing ProtocolHandler ["http-bio-auto-1-34284"]
Jan 02, 2015 9:48:38 AM org.apache.catalina.core.StandardService stopInternal
INFO: Stopping service Tomcat
Jan 02, 2015 9:48:38 AM org.apache.catalina.core.ApplicationContext log
INFO: Closing Spring root WebApplicationContext
Jan 02, 2015 9:48:38 AM org.springframework.context.support.AbstractApplicationContext doClose
INFO: Closing Root WebApplicationContext: startup date [Fri Jan 02 09:48:37 CET 2015]; root of context hierarchy
Jan 02, 2015 9:48:38 AM org.springframework.beans.factory.support.DefaultSingletonBeanRegistry destroySingletons
INFO: Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@901846d: defining beans [cxf,org.apache.cxf.bus.spring.BusWiringBeanFactoryPostProcessor,org.apache.cxf.bus.spring.Jsr250BeanPostProcessor,org.apache.cxf.bus.spring.BusExtensionPostProcessor,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,helloService#default,testServices,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor]; root of factory hierarchy
Jan 02, 2015 9:48:38 AM org.apache.coyote.AbstractProtocol stop
INFO: Stopping ProtocolHandler ["http-bio-auto-1-34284"]
Jan 02, 2015 9:48:43 AM org.apache.tomcat.util.net.AbstractEndpoint shutdownExecutor
WARNING: The executor associated with thread pool [http-bio-auto-1] has not fully shutdown. Some application threads may still be running.
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 7.273 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] 
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ my-tomcat-api-impl ---
[INFO] Building jar: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/target/my-tomcat-api-impl-0.0.1-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ my-tomcat-api-impl ---
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/target/my-tomcat-api-impl-0.0.1-SNAPSHOT.jar to /home/eric/.m2/repository/my/test/own/my-tomcat-api-impl/0.0.1-SNAPSHOT/my-tomcat-api-impl-0.0.1-SNAPSHOT.jar
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-api-impl/pom.xml to /home/eric/.m2/repository/my/test/own/my-tomcat-api-impl/0.0.1-SNAPSHOT/my-tomcat-api-impl-0.0.1-SNAPSHOT.pom
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building my-tomcat-webapp 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-tomcat-webapp ---
[INFO] Deleting /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/target
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0.1:enforce (enforce-java) @ my-tomcat-webapp ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ my-tomcat-webapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ my-tomcat-webapp ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ my-tomcat-webapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ my-tomcat-webapp ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-surefire-plugin:2.13:test (default-test) @ my-tomcat-webapp ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-war-plugin:2.3:war (default-war) @ my-tomcat-webapp ---
[INFO] Packaging webapp
[INFO] Assembling webapp [my-tomcat-webapp] in [/home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/target/my-tomcat-webapp-0.0.1-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [/home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/src/main/webapp]
[INFO] Webapp assembled in [45 msecs]
[INFO] Building war: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/target/my-tomcat-webapp-0.0.1-SNAPSHOT.war
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ my-tomcat-webapp ---
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/target/my-tomcat-webapp-0.0.1-SNAPSHOT.war to /home/eric/.m2/repository/my/test/own/my-tomcat-webapp/0.0.1-SNAPSHOT/my-tomcat-webapp-0.0.1-SNAPSHOT.war
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/pom.xml to /home/eric/.m2/repository/my/test/own/my-tomcat-webapp/0.0.1-SNAPSHOT/my-tomcat-webapp-0.0.1-SNAPSHOT.pom
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building my-tomcat-webapp-exec 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-tomcat-webapp-exec ---
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0.1:enforce (enforce-java) @ my-tomcat-webapp-exec ---
[INFO] 
[INFO] --- tomcat7-maven-plugin:2.2:exec-war-only (tomcat-war-exec) @ my-tomcat-webapp-exec ---
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ my-tomcat-webapp-exec ---
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-exec/pom.xml to /home/eric/.m2/repository/my/test/own/my-tomcat-webapp-exec/0.0.1-SNAPSHOT/my-tomcat-webapp-exec-0.0.1-SNAPSHOT.pom
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-exec/target/my-tomcat-webapp-exec-0.0.1-SNAPSHOT-war-exec.jar to /home/eric/.m2/repository/my/test/own/my-tomcat-webapp-exec/0.0.1-SNAPSHOT/my-tomcat-webapp-exec-0.0.1-SNAPSHOT-exec-war.jar
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building my-tomcat-webapp-it 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.pom (11 KB at 183.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-dependency-plugin/2.4/maven-dependency-plugin-2.4.jar (132 KB at 1097.6 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.pom (13 KB at 290.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/mojo/mojo-parent/30/mojo-parent-30.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/mojo/mojo-parent/30/mojo-parent-30.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/mojo/mojo-parent/30/mojo-parent-30.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/mojo/mojo-parent/30/mojo-parent-30.pom (27 KB at 619.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/mojo/selenium-maven-plugin/2.3/selenium-maven-plugin-2.3.jar (71 KB at 1102.0 KB/sec)
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-tomcat-webapp-it ---
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0.1:enforce (enforce-java) @ my-tomcat-webapp-it ---
[INFO] 
[INFO] --- maven-dependency-plugin:2.4:unpack (unzip-webapp) @ my-tomcat-webapp-it ---
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.pom (3 KB at 59.9 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/plexus/plexus-io/2.0/plexus-io-2.0.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/plexus/plexus-io/2.0/plexus-io-2.0.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-io/2.0/plexus-io-2.0.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-io/2.0/plexus-io-2.0.pom (2 KB at 35.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.pom (5 KB at 124.3 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/asm/asm/3.0/asm-3.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/asm/asm/3.0/asm-3.0.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/asm/asm/3.0/asm-3.0.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/maven/shared/maven-dependency-analyzer/1.2/maven-dependency-analyzer-1.2.jar (28 KB at 295.3 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/asm/asm/3.0/asm-3.0.jar (42 KB at 389.8 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-archiver/2.0/plexus-archiver-2.0.jar (176 KB at 1488.8 KB/sec)
[INFO] Configured Artifact: my.test.own:my-tomcat-webapp:0.0.1-SNAPSHOT:war
[INFO] Unpacking /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp/target/my-tomcat-webapp-0.0.1-SNAPSHOT.war to /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/webapp with includes "" and excludes ""
[INFO] 
[INFO] --- maven-compiler-plugin:2.5.1:testCompile (default) @ my-tomcat-webapp-it ---
[INFO] Compiling 1 source file to /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/test-classes
[INFO] 
[INFO] --- tomcat7-maven-plugin:2.2:run-war-only (tomcat-run) @ my-tomcat-webapp-it ---
[INFO] Running war on http://localhost:9898/
[INFO] Creating Tomcat server configuration at /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/tomcat
[INFO] create webapp with contextPath: 
Jan 02, 2015 9:48:54 AM org.apache.coyote.AbstractProtocol init
INFO: Initializing ProtocolHandler ["http-bio-9898"]
Jan 02, 2015 9:48:55 AM org.apache.catalina.core.StandardService startInternal
INFO: Starting service Tomcat
Jan 02, 2015 9:48:55 AM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.47
Jan 02, 2015 9:48:57 AM org.apache.catalina.core.ApplicationContext log
INFO: No Spring WebApplicationInitializer types detected on classpath
Jan 02, 2015 9:48:57 AM org.apache.catalina.core.ApplicationContext log
INFO: Initializing Spring root WebApplicationContext
2015-01-02 09:48:57,415 [localhost-startStop-1] INFO  org.springframework.web.context.ContextLoader  - Root WebApplicationContext: initialization started
2015-01-02 09:48:57,477 [localhost-startStop-1] INFO  org.springframework.web.context.support.XmlWebApplicationContext  - Refreshing Root WebApplicationContext: startup date [Fri Jan 02 09:48:57 CET 2015]; root of context hierarchy
2015-01-02 09:48:57,526 [localhost-startStop-1] INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader  - Loading XML bean definitions from URL [jar:file:/home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/webapp/WEB-INF/lib/my-tomcat-api-impl-0.0.1-SNAPSHOT.jar!/META-INF/spring-context.xml]
2015-01-02 09:48:57,633 [localhost-startStop-1] INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader  - Loading XML bean definitions from class path resource [META-INF/cxf/cxf.xml]
2015-01-02 09:48:57,659 [localhost-startStop-1] INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader  - Loading XML bean definitions from class path resource [META-INF/cxf/cxf-servlet.xml]
2015-01-02 09:48:57,694 [localhost-startStop-1] INFO  org.springframework.context.annotation.ClassPathBeanDefinitionScanner  - JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning
2015-01-02 09:48:57,695 [localhost-startStop-1] INFO  org.springframework.context.annotation.ClassPathBeanDefinitionScanner  - JSR-330 'javax.inject.Named' annotation found and supported for component scanning
2015-01-02 09:48:58,085 [localhost-startStop-1] INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader  - Loading XML bean definitions from ServletContext resource [/WEB-INF/applicationContext.xml]
2015-01-02 09:48:58,157 [localhost-startStop-1] INFO  org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor  - JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
2015-01-02 09:48:58,177 [localhost-startStop-1] INFO  org.springframework.beans.factory.support.DefaultListableBeanFactory  - Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@5accc38c: defining beans [cxf,org.apache.cxf.bus.spring.BusWiringBeanFactoryPostProcessor,org.apache.cxf.bus.spring.Jsr250BeanPostProcessor,org.apache.cxf.bus.spring.BusExtensionPostProcessor,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,helloService#default,testServices,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor]; root of factory hierarchy
Jan 02, 2015 9:48:58 AM org.apache.cxf.endpoint.ServerImpl initDestination
INFO: Setting the server's publish address to be /testServices
2015-01-02 09:48:58,469 [localhost-startStop-1] INFO  org.springframework.web.context.ContextLoader  - Root WebApplicationContext: initialization completed in 1053 ms
Jan 02, 2015 9:48:58 AM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-9898"]
[INFO] 
[INFO] --- selenium-maven-plugin:2.3:start-server (default) @ my-tomcat-webapp-it ---
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.pom (6 KB at 123.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.pom (2 KB at 22.9 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.pom (2 KB at 31.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.pom (155 B at 3.7 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.pom (4 KB at 79.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/mortbay/jetty/project/6.1.9/project-6.1.9.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/mortbay/jetty/project/6.1.9/project-6.1.9.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/mortbay/jetty/project/6.1.9/project-6.1.9.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/mortbay/jetty/project/6.1.9/project-6.1.9.pom (12 KB at 305.4 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.pom (5 KB at 111.7 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/jcip/jcip-annotations/1.0/jcip-annotations-1.0.pom
[INFO] Downloaded: http://maven.repository.redhat.com/earlyaccess/all/net/jcip/jcip-annotations/1.0/jcip-annotations-1.0.pom (491 B at 0.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/yaml/snakeyaml/1.8/snakeyaml-1.8.pom
[INFO] Downloaded: http://maven.repository.redhat.com/earlyaccess/all/org/yaml/snakeyaml/1.8/snakeyaml-1.8.pom (14 KB at 23.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.pom (3 KB at 69.4 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/gmaven/1.3/gmaven-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/gmaven/1.3/gmaven-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven/1.3/gmaven-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven/1.3/gmaven-1.3.pom (42 KB at 928.4 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/codehaus-parent/1/codehaus-parent-1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/codehaus-parent/1/codehaus-parent-1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/codehaus-parent/1/codehaus-parent-1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/codehaus-parent/1/codehaus-parent-1.pom (4 KB at 80.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.pom (2 KB at 37.6 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/runtime/gmaven-runtime/1.3/gmaven-runtime-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/runtime/gmaven-runtime/1.3/gmaven-runtime-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime/1.3/gmaven-runtime-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime/1.3/gmaven-runtime-1.3.pom (3 KB at 69.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.pom (2 KB at 42.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/feature/gmaven-feature/1.3/gmaven-feature-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/feature/gmaven-feature/1.3/gmaven-feature-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature/1.3/gmaven-feature-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature/1.3/gmaven-feature-1.3.pom (2 KB at 36.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.pom (3 KB at 56.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.pom (3 KB at 75.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/slf4j/slf4j-parent/1.5.10/slf4j-parent-1.5.10.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/slf4j/slf4j-parent/1.5.10/slf4j-parent-1.5.10.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/slf4j/slf4j-parent/1.5.10/slf4j-parent-1.5.10.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/slf4j/slf4j-parent/1.5.10/slf4j-parent-1.5.10.pom (9 KB at 209.7 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.pom (2 KB at 38.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.pom (3 KB at 51.3 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.pom (2 KB at 32.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/sonatype/gshell/gshell/2.0/gshell-2.0.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/sonatype/gshell/gshell/2.0/gshell-2.0.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/sonatype/gshell/gshell/2.0/gshell-2.0.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/sonatype/gshell/gshell/2.0/gshell-2.0.pom (15 KB at 323.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/sonatype/gossip/gossip/1.0/gossip-1.0.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/sonatype/gossip/gossip/1.0/gossip-1.0.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/sonatype/gossip/gossip/1.0/gossip-1.0.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/sonatype/gossip/gossip/1.0/gossip-1.0.pom (20 KB at 454.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.pom (17 KB at 377.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.pom (3 KB at 47.7 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/groovy/groovy-all-minimal/1.5.8/groovy-all-minimal-1.5.8.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/groovy/groovy-all-minimal/1.5.8/groovy-all-minimal-1.5.8.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/groovy/groovy-all-minimal/1.5.8/groovy-all-minimal-1.5.8.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/groovy/groovy-all-minimal/1.5.8/groovy-all-minimal-1.5.8.pom (18 KB at 398.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.pom (27 KB at 607.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.pom (6 KB at 47.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-parent/2.0rc2/selenium-parent-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-parent/2.0rc2/selenium-parent-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-parent/2.0rc2/selenium-parent-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-parent/2.0rc2/selenium-parent-2.0rc2.pom (8 KB at 165.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.pom (3 KB at 65.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-remote-driver/2.0rc2/selenium-remote-driver-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-remote-driver/2.0rc2/selenium-remote-driver-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-remote-driver/2.0rc2/selenium-remote-driver-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-remote-driver/2.0rc2/selenium-remote-driver-2.0rc2.pom (3 KB at 72.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-api/2.0rc2/selenium-api-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-api/2.0rc2/selenium-api-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-api/2.0rc2/selenium-api-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-api/2.0rc2/selenium-api-2.0rc2.pom (4 KB at 92.3 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/com/google/guava/guava/r09/guava-r09.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/com/google/guava/guava/r09/guava-r09.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/com/google/guava/guava/r09/guava-r09.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/com/google/guava/guava/r09/guava-r09.pom (4 KB at 77.3 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.pom (3 KB at 54.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.pom (31 KB at 719.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/httpcomponents/httpclient/4.0.1/httpclient-4.0.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/httpcomponents/httpclient/4.0.1/httpclient-4.0.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpclient/4.0.1/httpclient-4.0.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpclient/4.0.1/httpclient-4.0.1.pom (7 KB at 150.9 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/httpcomponents/httpcomponents-client/4.0.1/httpcomponents-client-4.0.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/httpcomponents/httpcomponents-client/4.0.1/httpcomponents-client-4.0.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpcomponents-client/4.0.1/httpcomponents-client-4.0.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpcomponents-client/4.0.1/httpcomponents-client-4.0.1.pom (9 KB at 224.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.pom (7 KB at 170.6 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/james/apache-mime4j/0.6/apache-mime4j-0.6.pom
[INFO] Downloaded: http://maven.repository.redhat.com/earlyaccess/all/org/apache/james/apache-mime4j/0.6/apache-mime4j-0.6.pom (14 KB at 23.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/james/james-project/1.2/james-project-1.2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/james/james-project/1.2/james-project-1.2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/james/james-project/1.2/james-project-1.2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/james/james-project/1.2/james-project-1.2.pom (3 KB at 62.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/james/james-parent/1.1/james-parent-1.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/james/james-parent/1.1/james-parent-1.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/james/james-parent/1.1/james-parent-1.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/james/james-parent/1.1/james-parent-1.1.pom (12 KB at 250.6 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/commons-codec/commons-codec/1.4/commons-codec-1.4.pom
[INFO] Downloaded: http://maven.repository.redhat.com/earlyaccess/all/commons-codec/commons-codec/1.4/commons-codec-1.4.pom (11 KB at 13.3 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.pom (2 KB at 38.1 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.pom (2 KB at 30.3 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.pom (4 KB at 82.6 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.pom (4 KB at 68.4 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/commons-io/commons-io/2.0.1/commons-io-2.0.1.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/commons-io/commons-io/2.0.1/commons-io-2.0.1.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/commons-io/commons-io/2.0.1/commons-io-2.0.1.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/commons-io/commons-io/2.0.1/commons-io-2.0.1.pom (9 KB at 187.2 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/commons/commons-parent/15/commons-parent-15.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/commons/commons-parent/15/commons-parent-15.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/commons/commons-parent/15/commons-parent-15.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/commons/commons-parent/15/commons-parent-15.pom (31 KB at 719.7 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.pom (4 KB at 71.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/java/dev/jna/jna/3.2.2/jna-3.2.2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/java/dev/jna/jna/3.2.2/jna-3.2.2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/java/dev/jna/jna/3.2.2/jna-3.2.2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/java/dev/jna/jna/3.2.2/jna-3.2.2.pom (2 KB at 36.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.pom (2 KB at 44.6 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.pom (2 KB at 25.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.pom (3 KB at 72.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/client-drivers/selenium-client-drivers/1.0.2/selenium-client-drivers-1.0.2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/client-drivers/selenium-client-drivers/1.0.2/selenium-client-drivers-1.0.2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/client-drivers/selenium-client-drivers/1.0.2/selenium-client-drivers-1.0.2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/client-drivers/selenium-client-drivers/1.0.2/selenium-client-drivers-1.0.2.pom (5 KB at 96.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-rc/1.0.2/selenium-rc-1.0.2.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-rc/1.0.2/selenium-rc-1.0.2.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-rc/1.0.2/selenium-rc-1.0.2.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-rc/1.0.2/selenium-rc-1.0.2.pom (7 KB at 155.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/commons-codec/commons-codec/1.5/commons-codec-1.5.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/commons-codec/commons-codec/1.5/commons-codec-1.5.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/commons-codec/commons-codec/1.5/commons-codec-1.5.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/commons-codec/commons-codec/1.5/commons-codec-1.5.pom (10 KB at 237.5 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/commons/commons-parent/20/commons-parent-20.pom
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/commons/commons-parent/20/commons-parent-20.pom
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/commons/commons-parent/20/commons-parent-20.pom
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/commons/commons-parent/20/commons-parent-20.pom (33 KB at 724.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/jcip/jcip-annotations/1.0/jcip-annotations-1.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/yaml/snakeyaml/1.8/snakeyaml-1.8.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.jar
[INFO] Downloaded: http://maven.repository.redhat.com/earlyaccess/all/net/jcip/jcip-annotations/1.0/jcip-annotations-1.0.jar (3 KB at 2.7 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/sonatype/gossip/gossip/1.0/gossip-1.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/plexus/plexus-utils/1.5.5/plexus-utils-1.5.5.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.jar
[INFO] Downloaded: http://maven.repository.redhat.com/earlyaccess/all/org/yaml/snakeyaml/1.8/snakeyaml-1.8.jar (252 KB at 164.0 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/apache/james/apache-mime4j/0.6/apache-mime4j-0.6.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/xml-apis/xml-apis/1.3.04/xml-apis-1.3.04.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/commons-io/commons-io/2.0.1/commons-io-2.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.jar
[INFO] Downloading: http://maven.repository.redhat.com/earlyaccess/all/commons-codec/commons-codec/1.5/commons-codec-1.5.jar
[INFO] Downloaded: http://maven.repository.redhat.com/earlyaccess/all/org/apache/james/apache-mime4j/0.6/apache-mime4j-0.6.jar (337 KB at 111.8 KB/sec)
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/sonatype/gossip/gossip/1.0/gossip-1.0.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/plexus/plexus-utils/1.5.5/plexus-utils-1.5.5.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/xml-apis/xml-apis/1.3.04/xml-apis-1.3.04.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/commons-io/commons-io/2.0.1/commons-io-2.0.1.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.jar
[INFO] Downloading: http://maven.repository.redhat.com/techpreview/all/commons-codec/commons-codec/1.5/commons-codec-1.5.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/mortbay/jetty/servlet-api-2.5/6.1.9/servlet-api-2.5-6.1.9.jar (130 KB at 793.4 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/mx4j/mx4j-tools/3.0.1/mx4j-tools-3.0.1.jar (486 KB at 1709.0 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo/1.3/gmaven-mojo-1.3.jar (10 KB at 27.9 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/bouncycastle/bcpkix-jdk15on/1.48/bcpkix-jdk15on-1.48.jar (572 KB at 1671.0 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-api/1.3/gmaven-runtime-api-1.3.jar (22 KB at 55.9 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-api/1.3/gmaven-feature-api-1.3.jar (17 KB at 42.9 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-1.5/1.3/gmaven-runtime-1.5-1.3.jar (45 KB at 101.4 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/slf4j/slf4j-api/1.5.10/slf4j-api-1.5.10.jar (24 KB at 52.9 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/feature/gmaven-feature-support/1.3/gmaven-feature-support-1.3.jar (14 KB at 27.4 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/runtime/gmaven-runtime-support/1.3/gmaven-runtime-support-1.3.jar (78 KB at 154.6 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/sonatype/gossip/gossip/1.0/gossip-1.0.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/sonatype/gshell/gshell-io/2.0/gshell-io-2.0.jar (22 KB at 40.7 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/jetty-repacked/7.6.1/jetty-repacked-7.6.1.jar (996 KB at 1797.7 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-utils/1.5.5/plexus-utils-1.5.5.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/sonatype/gossip/gossip/1.0/gossip-1.0.jar (79 KB at 137.2 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/gmaven/gmaven-mojo-support/1.3/gmaven-mojo-support-1.3.jar (31 KB at 47.5 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/com/thoughtworks/qdox/qdox/1.10/qdox-1.10.jar (168 KB at 257.3 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/plexus/plexus-utils/1.5.5/plexus-utils-1.5.5.jar (246 KB at 365.7 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar (2264 KB at 3295.2 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-chrome-driver/2.0rc2/selenium-chrome-driver-2.0rc2.jar (10 KB at 13.3 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-htmlunit-driver/2.0rc2/selenium-htmlunit-driver-2.0rc2.jar (48 KB at 64.9 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-server/2.37.0/selenium-server-2.37.0.jar (2288 KB at 2986.9 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-remote-control/2.0rc2/selenium-remote-control-2.0rc2.jar (308 KB at 393.7 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpmime/4.0.1/httpmime-4.0.1.jar (25 KB at 31.8 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/xml-apis/xml-apis/1.3.04/xml-apis-1.3.04.jar
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/nekohtml/nekohtml/1.9.14/nekohtml-1.9.14.jar (122 KB at 138.0 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/xml-apis/xml-apis/1.3.04/xml-apis-1.3.04.jar (190 KB at 204.7 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit-core-js/2.8/htmlunit-core-js-2.8.jar (892 KB at 905.7 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/commons-io/commons-io/2.0.1/commons-io-2.0.1.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/cssparser/cssparser/0.9.5/cssparser-0.9.5.jar (248 KB at 245.3 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/net/sourceforge/htmlunit/htmlunit/2.8/htmlunit-2.8.jar (940 KB at 910.1 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/commons-io/commons-io/2.0.1/commons-io-2.0.1.jar (156 KB at 146.8 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-iphone-driver/2.0rc2/selenium-iphone-driver-2.0rc2.jar (11 KB at 9.7 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/client-drivers/selenium-java-client-driver/1.0.2/selenium-java-client-driver-1.0.2.jar (54 KB at 44.5 KB/sec)
[INFO] Downloading: http://repo.maven.apache.org/maven2/commons-codec/commons-codec/1.5/commons-codec-1.5.jar
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-firefox-driver/2.0rc2/selenium-firefox-driver-2.0rc2.jar (640 KB at 516.6 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/commons-codec/commons-codec/1.5/commons-codec-1.5.jar (72 KB at 54.1 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/seleniumhq/selenium/selenium-ie-driver/2.0rc2/selenium-ie-driver-2.0rc2.jar (908 KB at 677.6 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/bouncycastle/bcprov-jdk15/140/bcprov-jdk15-140.jar (1557 KB at 1106.7 KB/sec)
[INFO] Downloaded: http://repo.maven.apache.org/maven2/org/codehaus/groovy/groovy-all/1.7.5/groovy-all-1.7.5.jar (5354 KB at 3231.0 KB/sec)
Created dir: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/selenium
Launching Selenium Server
Waiting for Selenium Server...
[INFO] Redirecting output to: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/selenium/server.log
[INFO] User extensions: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/selenium/user-extensions.js
Selenium Server started
[INFO] 
[INFO] --- maven-surefire-plugin:2.13:test (selenium-integration-tests) @ my-tomcat-webapp-it ---
[INFO] Surefire report directory: /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running my.test.own.my_tomcat.webapp.test.SimpleTest
log4j:WARN No appenders could be found for logger (com.gargoylesoftware.htmlunit.WebClient).
log4j:WARN Please initialize the log4j system properly.
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.587 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] 
[INFO] --- tomcat7-maven-plugin:2.2:shutdown (tomcat-shutdown) @ my-tomcat-webapp-it ---
Jan 02, 2015 9:49:49 AM org.apache.coyote.AbstractProtocol pause
INFO: Pausing ProtocolHandler ["http-bio-9898"]
Jan 02, 2015 9:49:49 AM org.apache.catalina.core.StandardService stopInternal
INFO: Stopping service Tomcat
Jan 02, 2015 9:49:49 AM org.apache.catalina.core.ApplicationContext log
INFO: Closing Spring root WebApplicationContext
2015-01-02 09:49:49,521 [localhost-startStop-2] INFO  org.springframework.web.context.support.XmlWebApplicationContext  - Closing Root WebApplicationContext: startup date [Fri Jan 02 09:48:57 CET 2015]; root of context hierarchy
2015-01-02 09:49:49,523 [localhost-startStop-2] INFO  org.springframework.beans.factory.support.DefaultListableBeanFactory  - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@5accc38c: defining beans [cxf,org.apache.cxf.bus.spring.BusWiringBeanFactoryPostProcessor,org.apache.cxf.bus.spring.Jsr250BeanPostProcessor,org.apache.cxf.bus.spring.BusExtensionPostProcessor,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,helloService#default,testServices,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor]; root of factory hierarchy
Jan 02, 2015 9:49:49 AM org.apache.coyote.AbstractProtocol stop
INFO: Stopping ProtocolHandler ["http-bio-9898"]
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ my-tomcat-webapp-it ---
[INFO] Installing /home/eric/Devel/Java/Maven/my-tomcat/my-tomcat-webapp-it/pom.xml to /home/eric/.m2/repository/my/test/own/my-tomcat-webapp-it/0.0.1-SNAPSHOT/my-tomcat-webapp-it-0.0.1-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] my-tomcat ......................................... SUCCESS [3.123s]
[INFO] my-tomcat-api ..................................... SUCCESS [3.952s]
[INFO] my-tomcat-api-impl ................................ SUCCESS [10.228s]
[INFO] my-tomcat-webapp .................................. SUCCESS [0.539s]
[INFO] my-tomcat-webapp-exec ............................. SUCCESS [2.551s]
[INFO] my-tomcat-webapp-it ............................... SUCCESS [1:02.485s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1:23.024s
[INFO] Finished at: Fri Jan 02 09:49:49 CET 2015
[INFO] Final Memory: 44M/279M
[INFO] ------------------------------------------------------------------------

/ Daarna in my-tomcat-webapp	,
$ mvn tomcat7:run
/ OK 

/ TODO 
/ Study selenium	,

/ 13	. 

/ we hebben my-main	, deze include my-webapp en is org.mortbay.jetty:jetty-maven-plugin	,	jetty:run
/ we hebben my-main2	, deze include my-webapp en is org.eclipse.jetty:jetty-maven-plugin	, jetty:run
/ en is ook org.apache.tomcat.maven:tomcat7-maven-plugin	, maar die doet NIET include my-webapp	, tomcat7:run	, maar wel gewoon een jsp	,

/ in my-main3	, we hebben org.eclipse.jetty:jetty-maven-plugin, org.apache.tomcat.maven:tomcat7-maven-plugin en een index.jsp, en nu doet de tomcat plugin OK

 <properties>
	  <jetty.version>9.3.0.M1</jetty.version>
	  <tomcat.version>2.2</tomcat.version>
  </properties>
 <build>
    <finalName>my-main3</finalName>
	<plugins>
		<plugin>
			<groupId>org.eclipse.jetty</groupId>
			<artifactId>jetty-maven-plugin</artifactId>
			<version>${jetty.version}</version>
			<configuration>
                <httpConnector>
                    <port>9090</port>
                </httpConnector>
               <webApp>
               		<contextPath>/${build.finalName}</contextPath>
               </webApp>
            </configuration>
		</plugin>
		<plugin>
			<groupId>org.apache.tomcat.maven</groupId>
			<artifactId>tomcat7-maven-plugin</artifactId>
			<version>${tomcat.version}</version>
			<configuration>
    				<port>9090</port>
  			</configuration>
		</plugin>
	</plugins>
  </build>

/ Bij tomcat7	, 
http://localhost:9090/my-main3/
/ dan toont hij index.jsp	,

/ Bij jetty9	, 
http://localhost:9090/my-main3/
/ dan toont hij index.jsp	,

/ bij de jetty plugin is de default context path /	, bij tomcat7 blijkbaar 

/ Lees	,
http://tomcat.apache.org/
/ click linksboven in vertical menu	, 'Maven plugin'	,
http://tomcat.apache.org/maven-plugin.html
/ click 'Version 2.2'	,
http://tomcat.apache.org/maven-plugin-2.2/
/we zijn op	,
Apache /  Apache Tomcat /  Apache Tomcat Maven plugin /  About Apache Tomcat Maven Plugin
/ click link 'Documentation	,
http://tomcat.apache.org/maven-plugin-2.2/run-mojo-features.html

/ onder Goals 	,
Goals to manipulate deployed projects within Tomcat
Goals to obtain information from Tomcat

/ we kunnen ook in het horizontale menu boven	,
Modules, Apache Tomcat Maven Plugin: Tomcat 7.x	, 
/ we komen op	,
http://tomcat.apache.org/maven-plugin-2.2/tomcat7-maven-plugin/index.html
Apache /  Apache Tomcat /  Apache Tomcat Maven plugin /  Apache Tomcat Maven Plugin :: Tomcat 7.x /  Introduction
/ hier zien we de link 'goals page'	,
/ click tomcat7:run
/ we zien path , de default is /${project.artifactId}	, klopt	,

/ Lees	,
http://eclipse.org/jetty/documentation/current/jetty-maven-plugin.html
/ over configure jetty:run 	, ...

/ 13	. 

/ we doen eerst	,
[eric@localhost apache-tomcat-7.0.57]$ bin/catalina.sh run

/ we dachten dat we een WEB-INF/web.xml moesten hebben, 	maar dat is niet zo	, 
/ dat komt omdat we alleen index.jsp hebben	, 
/ als we andere server components hebben, bijv een servlet, dan moet het	, see in 13. 	hieronder	,
/ lees toch	,
/ als we WEB-INF/web.xml hebben in src/main/webapp	, zien we in eclipse deze onder	,
Deployed Resources
	webapp
/ Maar ook verschijnt er Deployment Descriptor:...

/ Inderdaad	, we hebben src/main/webapp	, maar in eclipse zien we deze niet (onder Java Resources)	, we zien hem onder Deployed Resources	,

/ we use tomcat-7.0.57	, 

/ tomcat-7.0.53 ERR
/ TODO

$ vi conf/tomcat-users.xml

<role rolename="manager-gui"/>
<user username="tomcat" password="s3cret" roles="manager-gui"/>

/ nu kunnen we inlog op localhost:8080/manager of localhost:8080/manager/html	,

/ In tomcat-users.xml kunnen we NIET 2 regels maken zoals,	
<user username="tomcat" password="s3cret" roles="manager-gui"/>
<user username="tomcat" password="s3cret" roles="manager-script"/>
/ we moeten WEL	,
<user username="tomcat" password="s3cret" roles="manager-gui,manager-script"/>

/ 13	. 

/ my-main3 	, 

/ tomcat7:deploy ipv tomcat7:run

$ vi ~/.m2/settings.xml
...
       <servers>
        <server>
                <id>my_tomcat</id>
                <username>tomcat</username>
                <password>s3cret</password>
        </server>
        </servers>
</settings>

$ vi pom.xml
...
		<plugin>
			<groupId>org.apache.tomcat.maven</groupId>
			<artifactId>tomcat7-maven-plugin</artifactId>
			<version>${tomcat.version}</version>
			<configuration>
    				<port>8080</port> 				/ default
    				<path>/${project.artifactId}</path>		/ default
    				<url>http://localhost:8080/manager/text</url>
    				<server>my_tomcat</server>
  			</configuration>
		</plugin>
	</plugins>
  </build>

/ start tomcat7	, 
[eric@localhost apache-tomcat-7.0.57]$ bin/catalina.sh run

$ mvn tomcat7:undeploy tomcat7:deploy

/ we zien	,
[eric@localhost apache-tomcat-7.0.57]$ bin/catalina.sh run
...
n 02, 2015 3:04:42 PM org.apache.catalina.startup.HostConfig undeploy
INFO: Undeploying context [/my-main3]
Jan 02, 2015 3:04:43 PM org.apache.catalina.startup.HostConfig deployWAR
INFO: Deploying web application archive /home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.57/webapps/my-main3.war

/ Geef 
localhost:8080/my-main3
/ of	,
localhost:8080/manager
/ of	,
localhost:8080/examples

/ we zien in tomcat	,
[eric@localhost apache-tomcat-7.0.57]$ pwd
/home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.57
[eric@localhost apache-tomcat-7.0.57]$ ls webapps/
docs  examples  host-manager  manager  my-main3  my-main3.war  ROOT

/ 13	. 

/ jetty standalone	,
/ TODO

/ 13	. 

/ my-main3	,

/ see my-webapp	,

/ we maken een servlet die javax.servlet.http.HttpServlet extends	, 

/ maar dan moeten we wel in pom	,

	<dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
            <scope>provided</scope>
        </dependency>
 
$ vi src/main/java/own/test/my/MyServlet.java

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        PrintWriter out = response.getWriter();
        out.println( "MyServlet Executed" );
        out.flush();
        out.close();
  }

$ vi src/main/webapp/WEB-INF/web.xml

<?xml version="1.0" encoding="utf-8"?>

<webapp>

 <servlet>
    <servlet-name>foo</servlet-name>
    <servlet-class>own.test.my.MyServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>foo</servlet-name>
    <url-pattern>/foo/*</url-pattern>
  </servlet-mapping>
</webapp>

/ Geef
localhost:8080/my-main3
My Main 3
/ we zien index.jsp

/ Geef
localhost:8080/my-main3/foo/my
/ of	,
localhost:8080/my-main3/foo
MyServlet Executed
/ dan zien we de servlet


/ we hebben  dus in <webapp/> alle attributes rm, zoals xmlns	, 
/ als we hetzelfde doen in pom.xml , dan ook OK	. 
/ TODO

/ 13. 	

/ in my-main4	,

/ we doen in my-main3	,
$ clean install
[eric@localhost repository]$ ls my/test/own/my-main3/0.0.1-SNAPSHOT/
maven-metadata-local.xml     my-main3-0.0.1-SNAPSHOT.pom  my-main3-0.0.1-SNAPSHOT.war  _remote.repositories

/ Kunnen we deze use in my-main4	?

/ we hebben my-main4 delete uit ecliopse, hij is nog in fs	,
/ Allemaal kruisjes	, ERRs	,
/ TODO
/ in my-main3	, Copy of web.xml	, heeft 0d0a ipv 0a, 
/ TODO

/ 13	. 

/ In project wicket-examples-step-by-step proberen we stap voor stap wicket-examples	,

$ vi pom.xml

			<plugin>
				<groupId>org.eclipse.jetty</groupId>
				<artifactId>jetty-maven-plugin</artifactId>
				<version>${jetty9.version}</version>
				<configuration>
					<httpConnector>
	                    <port>9090</port>
	                </httpConnector>
	                <webApp>
               			<contextPath>/${project.artifactId}</contextPath>
               		</webApp>
			...
			</plugin>
			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<version>${tomcat.version}</version>
				<configuration>
	    			<port>8080</port>
	    			<path>/${project.artifactId}</path>
	    			<url>http://localhost:8080/manager/text</url>
	    			<server>my_tomcat</server>
 	 			</configuration>
			</plugin>

jetty:run
tomcat7:run
/ we kunnen tomcat7 zelf start	,  en 	,
tomcat7:undeploy tomcat7:deploy

/ 13	 

/ we willen debug wicket	,

/ we start Tomcat op de command line	,

/ simple-webapp starten we in eclipse, dus dan in de run config 	,
	-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n
/ is -Xnoagent -Djava.compiler=NONE nodig?
/ TODO

/ maar tomcat op de command line (we doen NIET tomcat7:run, maar tomcat7:deploy)	, en we edit
$ vi bin/catalina.sh
CATALINA_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n"

/ dan in ecliopse maken we de debug config	,
Remote Java Application
	wicket-examples-step-by-step
Project: wicket-examples-step-by-step
Connection type: Standard (socket attach)
Host : localhost
Port :8000
/ click Debug
/ Het window verdwijnt, en er lijkt niets te gebeuren, totdat we in de browser geven	,
http://localhost:8080/wicket-examples-step-by-step/helloworld/
/ dan valt de debugger in eclipse in	,

public class HelloWorld extends WicketExamplePage
{
	public HelloWorld()
	{
->		add(new Label("message", "Hello World!"));

/ omdat we daar een b hadden set	,

/ 13	. 

/ we geven 
http://localhost:8080/wicket-examples-step-by-step/repeater

/ wat gebeurt er?
$ vi WEB-INF/web.xml
      <filter>
                <filter-name>RepeaterExamplesApplication</filter-name>
                <filter-class>org.apache.wicket.protocol.http.WicketFilter</filter-class>
                <init-param>
                        <param-name>applicationClassName</param-name>
                        <param-value>org.apache.wicket.examples.repeater.RepeaterApplication</param-value>
                </init-param>
        </filter>
        
        <filter-mapping>
                <filter-name>RepeaterExamplesApplication</filter-name>
                <url-pattern>/repeater/*</url-pattern>
                <dispatcher>REQUEST</dispatcher>
                <dispatcher>INCLUDE</dispatcher>
        </filter-mapping>
  
/ Dus 	,
$ vi RepeaterApplication.java
	public Class<? extends Page> getHomePage()
	{
		return Index.class;
	}

/ Dus	,
$ vi Index.java
...
$ vi Index.html
<wicket:link>
<a href="SimplePage.html">Simple DataView Example - simple example of a dataview</a><br/>
...

/ Vanwege <wicket:link> zien we bookmarkable links	,
http://localhost:8080/wicket-examples-step-by-step/repeater/wicket/bookmarkable/org.apache.wicket.examples.repeater.SimplePage?0
/ Als we NIET <wicket:link>, dan als we de link click	,
http://localhost:8080/wicket-examples-step-by-step/SimplePage.html
/ en die is er niet	,

/ als we edit, doe dan de run config	,
tomcat7:undeploy tomcat7:deploy

/ 13	. 

/ als we click op de link 'Simple DataView Example - simple example of a dataview'	, dan vallen we in 	,
	public SimplePage()
	{
->		add(new DataView<Contact>("simple", new ContactDataProvider())

/ 13	. 
/////////////////////////////////////////////////////////////////////
/ DEBUGGER VALT IN WICKET APPLICATION
/ als we Run as Debug 
tomcat7:undeploy tomcat7:deploy
/ dan valt  code in	,
public class RepeaterApplication extends WebApplication
{
->	private final ContactsDatabase contactsDB = new ContactsDatabase(50);
/s
ContactsDatabase.<init>(int) line: 50	
/=
	public ContactsDatabase(int count)
	{
		for (int i = 0; i < count; i++)
		{
			add(ContactGenerator.getInstance().generate());
/s
ContactGenerator.generate() line: 72	
...

/t
->	private final ContactsDatabase contactsDB = new ContactsDatabase(50);
/d
...
RepeaterApplication.init() line: 47	

/ geef	,
http://localhost:8080/wicket-examples-step-by-step/repeater/
/ dan vallen we in	,
SimplePage.<init>() line: 39	
/=
	public SimplePage()
	{
		add(new DataView<Contact>("simple", new ContactDataProvider())
/s
ContactDataProvider.size() line: 60	
		return getContactsDB().getCount();
/s
ContactDataProvider.getContactsDB() line: 36	
		return DatabaseLocator.getDatabase();
/s
DatabaseLocator.getDatabase() line: 34	
		RepeaterApplication app = (RepeaterApplication)Application.get();
/ calls ThreadCcontext.getApplication()
/TODO
app	RepeaterApplication  (id=6581)	
		return app.getContactsDB();

/ later	,
	public Iterator<Contact> iterator(long first, long count)
	{
->		return getContactsDB().find(first, count, new SortParam<String>("firstName", true)).iterator();
/s
/ eerst weer in getContactsDB	, net als net	, 
/ new SortParam is in wicket-extensions	,
/s
ContactsDatabase.find(long, long, SortParam) line: 92	
		return getIndex(sort).subList((int)first, (int)(first + count));
/s
ContactsDatabase.getIndex(SortParam) line: 104	
		if (sort.getProperty().equals("firstName")){
/ JA
			return sort.isAscending() ? fnameIdx : fnameDescIdx;
[[Contact id=32 firstName=Abby lastName=Nelson homePhone=706-555-8247 cellPhone=665-555-5262], 
[Contact id=50 firstName=Christopher lastName=Fisher homePhone=377-555-1084 cellPhone=442-555-8130], 
[Contact id=9 firstName=Debra lastName=Baker homePhone=812-555-1780 cellPhone=776-555-5232], 
[Contact id=49 firstName=Debra lastName=Davis homePhone=573-555-2605 cellPhone=615-555-1733], 
[Contact id=2 firstName=Douglas lastName=Rose homePhone=377-555-2700 cellPhone=431-555-3754], 
[Contact id=25 firstName=Douglas lastName=Smiith homePhone=388-555-2882 cellPhone=760-555-4772], 
....

/ later	,
	public SimplePage()
	{
		add(new DataView<Contact>("simple", new ContactDataProvider())
		{
			private static final long serialVersionUID = 1L;

			@Override
			protected void populateItem(final Item<Contact> item)

/ populateItem is een DataView method	, in feite een RefreshingView method	,
/ de hierarchy is	,
java.lang.Object
org.apache.wicket.Component
org.apache.wicket.MarkupContainer
org.apache.wicket.markup.html.WebMarkupContainer
org.apache.wicket.markup.repeater.AbstractRepeater
org.apache.wicket.markup.repeater.RepeatingView
org.apache.wicket.markup.repeater.RefreshingView<T>
org.apache.wicket.markup.repeater.AbstractPageableView<T>
org.apache.wicket.markup.repeater.data.DataViewBase<T>
org.apache.wicket.markup.repeater.data.DataView<T>

/ in populateItem	,
			protected void populateItem(final Item<Contact> item) {
				Contact contact = item.getModelObject();
item	Item<T>  (id=3962)	
[Item [Component id = 1]]
contact	Contact  (id=3967)	
[Contact id=23 firstName=Abby lastName=Gonzalez homePhone=805-555-6357 cellPhone=784-555-7144]

				item.add(new ActionPanel("actions", item.getModel()));
/ ActionPanel.class is inner class van BasePage.java	, en is een Panel met een link, "select"	,

/ In SimplePage.html	,
	<tr wicket:id="simple">
		<td><span wicket:id="actions">[actions]</span></td>
		<td><span wicket:id="contactid">[contactid]</span> </td>
...
/ we zien "actions"	, 

/ In BasePage$ActionPanel.html	,
<wicket:panel xmlns:wicket="http://wicket.apache.org">
<a href="#" wicket:id="select">select</a>
</wicket:panel>

/ volgende contact	,

			protected void populateItem(final Item<Contact> item)
			{
				Contact contact = item.getModelObject();

[Item [Component id = 2]]
[Contact id=27 firstName=Abby lastName=Jones homePhone=578-555-3655 cellPhone=730-555-5428]

/ 7	. 

/ multiple ways to create table	,

/ in wicket examples	,

/ Geef
http://localhost:8080/wicket-examples-step-by-step/repeater
/ en click op een link, bijv	,
http://localhost:8080/wicket-examples-step-by-step/repeater/wicket/bookmarkable/org.apache.wicket.examples.repeater.SimplePage?2

/ 13	. 

/ In SimplePage	,

/ je geeft in htm 1 header row en 1 data row	, en die data row wordt repeated	,
/ maar je moet wel alle th's en td's geven	,

<table cellspacing="0" class="dataview">
        <tr>
		..
        </tr>
                <td><span wicket:id="..."
                <td><span wicket:id="..."
		...

               add(new DataView<Contact>("simple", new ContactDataProvider()) {
                        @Override
                        protected void populateItem(final Item<Contact> item) {
                                Contact contact = item.getModelObject();
                                item.add(new ActionPanel("actions", item.getModel()));
				...

/ 13	. 

/ DataTablePage 	,

/ je geeft in html 1 table, 

    <table class="dataview" cellspacing="0" wicket:id="table">[table]</table>

                List<IColumn<Contact, String>> columns = new ArrayList<>();
		...
               	columns.add(new PropertyColumn<Contact, String>(new Model<>("Cell Phone"), "cellPhone"));
                SortableContactDataProvider dataProvider = new SortableContactDataProvider();
                DataTable<Contact, String> dataTable = new DefaultDataTable<>("table", columns,
                                dataProvider, 8);


/ HIER HIER HIER
 


/ RM



/ 13	. 

/ een ListView is meer dan een RepeatableView	,

$ vi Ch55.html	,

		<ul>
		    <li wicket:id="rvlist4">
		    	<span wicket:id="label"></span>
		    </li>
		</ul>

$ vi Ch55.java

		RepeatingView rview=new RepeatingView("rvlist4");
		add(rview);
		for(int i=0;i<5;i++){
			String id=rview.newChildId();
			Link<Integer>link=new Link<Integer>(id) {
				@Override
				public void onClick() {
					setResponsePage(Page55.class);
				}
			};
			rview.add(link);
			link.setOutputMarkupId(true);
			Label label=new Label("label","Value "+id);
			link.add(label);
			label.setOutputMarkupId(true);
			
		}

/ er staat 	,
		    <li wicket:id="rvlist4">
		RepeatingView rview=new RepeatingView("rvlist4");
/ Dus worden er <li/>'s create	, 

/ we doen 
			rview.add(link);

/ dat betekent dat de <li/> zelf de link wordt	, 
/ als we willen dat de <li/> een link contains, moeten we	,

			WebMarkupContainer li=new WebMarkupContainer(id);
			li.setOutputMarkupId(true);
			rview.add(li);
			BookmarkablePageLink<Integer>a=new BookmarkablePageLink<Integer>("link", Page55.class);
			li.add(a);

/ ListView doet dit automatisch, we hoeven dus niet zelf een WebMarkupContainer te create	,

/ Ook kunnen we aan ListView de list geven	, we hoeven zelf geen for loops te program	, maar dit is minor of importance	, 

/ bij repeating view moeten we zelf een id 


/ als we op label setMarkupId , of setOutputMarkupId	, dan verschijnen id="id01" bijv op de li	,
/ TODO

/ 7	.

/ id's	,

/ Het lijkt dat we van hoofd elems verschillende id's moeten geven, en van children niet: Wicket geeft de children een eigen id	,
/ TODO

$ vi Ch55a.html

		<a href ="#" wicket:id="link">
			<span wicket:id="label"></span>
		</a>
		<a href="#" wicket:id="link2">
			<span wicket:id="label"></span>
		</a>

$ vi Ch55a.java

		{
		Link<Integer>link=new Link<Integer>("link") {
			
			@Override
			public void onClick() {
				// TODO Auto-generated method stub
				
			}
		};
		add(link);
		link.setOutputMarkupId(true);
		Label label=new Label("label","Foo");
		label.setOutputMarkupId(true);
		link.add(label);
		}

		{
		Link<Integer>link=new Link<Integer>("link2") {
			
			@Override
			public void onClick() {
				// TODO Auto-generated method stub
				
			}
		};
		add(link);
		link.setOutputMarkupId(true);
		Label label=new Label("label","Foo");
		label.setOutputMarkupId(true);
		link.add(label);
		}

/ we zien	,

		<a href="./?0-1.ILinkListener-link" id="link1">
			<span id="label2">Foo</span>
		</a>
		<a href="./?0-1.ILinkListener-link2" id="link23">
			<span id="label4">Foo</span>
		</a>

/ 7	.

/ WEBMARKUPCONTAINER

/ Wat doet een WebMarkupContainer	?

/ we hadden boven al gezien dat de directe child van de webpage een unieke wicket:id moeten geven	, dat doen we hieronder aan de WebMarkupContainer in het 1ste geval, en aan de  link in het 2de geval	,

/ als we 

$ vi Ch55.html

		<ul>
		    <li wicket:id="rvmenu">
		        <a  wicket:id="link">
		            <span wicket:id="caption"></span>
		        </a>
		    </li>
		</ul>
	
		<ul>
		    <li wicket:id="rvnocontmenu">
		       
		            <span wicket:id="caption"></span>
		        
		    </li>
		</ul>

////////////////////////////////////////////////
/ we set de repeatedview dus op de li's	, in het 1ste geval zijn de li's dus webmarkupcontainers	, in het 2de geval zijn de li's links	,


$ vi Ch55.java

		{
		RepeatingView rview=new RepeatingView("rvmenu");
		add(rview);
		List<MenuItem>menu=createMenu();
		for(MenuItem item:menu){
			String id=rview.newChildId();
			WebMarkupContainer container=new WebMarkupContainer(id);
			container.setOutputMarkupId(true);
			rview.add(container);
			BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>("link", item.getDestination());
			container.add(link);
			link.setOutputMarkupId(true);
			Label label=new Label("caption",item.getCaption());
			label.setOutputMarkupId(true);
			link.add(label);
		}
		}

		{
		RepeatingView rview=new RepeatingView("rvnocontmenu");
		add(rview);
		List<MenuItem>menu=createMenu();
		for(MenuItem item:menu){
			String id=rview.newChildId();
			BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>(id, item.getDestination());
			rview.add(link);
			link.setOutputMarkupId(true);
			Label label=new Label("caption",item.getCaption());
			label.setOutputMarkupId(true);
			link.add(label);
		}
		}

/ we zien dat de eerste list een list is met a's	, en de tweede een gewone list, die toch links zijn, maar er zijn geen a's	,

<ul>
		    <li id="id117">
		        <a id="link18" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="caption19">Home</span>
		        </a>
		    </li><li id="id21a">
		        <a id="link1b" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="caption1c">Cheeses</span>
		        </a>
		    </li><li id="id31d">
		        <a id="link1e" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="caption1f">Wines</span>
		        </a>
		    </li><li id="id420">
		        <a id="link21" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="caption22">Recipes</span>
		        </a>
		    </li>
		</ul>

/ en	,

<ul>
		    <li id="id123" onclick="var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; if (win == window) { window.location.href='./wicket/bookmarkable/my.test.own.wicket_book.Page55'; } ;return false">
		       
		            <span id="caption24">Home</span>
		        
		    </li><li id="id225" onclick="var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; if (win == window) { window.location.href='./wicket/bookmarkable/my.test.own.wicket_book.Page55'; } ;return false">
		       
		            <span id="caption26">Cheeses</span>
		        
		    </li><li id="id327" onclick="var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; if (win == window) { window.location.href='./wicket/bookmarkable/my.test.own.wicket_book.Page55'; } ;return false">
		       
		            <span id="caption28">Wines</span>
		        
		    </li><li id="id429" onclick="var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; if (win == window) { window.location.href='./wicket/bookmarkable/my.test.own.wicket_book.Page55'; } ;return false">
		       
		            <span id="caption2a">Recipes</span>
		        
		    </li>
		</ul>


/ Einde WEBMARKUPCONTAINER

/ 7	. 

/ bij een listview is de webmarkupcontainer er al	,


/ we kunnen dezelfde wicket id use binnen verschillende wicket id's	,

		<ul>
		    <li wicket:id="rvmenu">
		        <a  wicket:id="link">
		            <span wicket:id="caption"></span>
		        </a>
		    </li>
		</ul>
		
		<ul>
		    <li wicket:id="lvmenu">
		        <a  wicket:id="link">
		            <span wicket:id="lcaption"></span>
		        </a>
		    </li>
		</ul>


/ we vergl	,

		{
		RepeatingView rview=new RepeatingView("rvmenu");
		add(rview);
		List<MenuItem>menu=createMenu();
		for(MenuItem item:menu){
			String id=rview.newChildId();
			WebMarkupContainer container=new WebMarkupContainer(id);
			container.setOutputMarkupId(true);
			rview.add(container);
			BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>("link", item.getDestination());
			container.add(link);
			link.setOutputMarkupId(true);
			Label label=new Label("caption",item.getCaption());
			label.setOutputMarkupId(true);
			link.add(label);
		}
		}
		
		{
		List<MenuItem>menu=createMenu();
		ListView<MenuItem> lview=new ListView<MenuItem>("lvmenu",menu) {
			@Override
			protected void populateItem(ListItem<MenuItem> item) {
				MenuItem menuItem=item.getModel().getObject();
				BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>("link", menuItem.getDestination());
				item.add(link);
				link.setOutputMarkupId(true);
				Label label=new Label("lcaption", menuItem.getCaption());
				link.add(label);
				label.setOutputMarkupId(true);
			}
		};
		add(lview);

		}

/ we zien de generic MenuItem in ListItem<MenuItem>	,
/ we zien dus dat WH een ListItem een WebMarkupContainer is	, 
/ de naam ListItem is logisch, want is bind aan een <li/>	,

/ 7	. 

/ Dezelfde wicket code als in lvmenu hierboven	,
/ Alleen andere HTML	,

		List<MenuItem>menu=createMenu();
		ListView<MenuItem> lview=new ListView<MenuItem>("lvmenu2",menu) {
			@Override
			protected void populateItem(ListItem<MenuItem> item) {
				MenuItem menuItem=item.getModel().getObject();
				BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>("link"	,menuItem.getDestination());
				item.add(link);
				link.setOutputMarkupId(true);
				Label label=new Label("lcaption", menuItem.getCaption());
				link.add(label);
				label.setOutputMarkupId(true);
				
		<div>
		    <div wicket:id="lvmenu">
		        <a  wicket:id="link">
		            <span wicket:id="lcaption"></span>
		        </a>
		    </div>
		</div>	

/ we zien hetzelfde, 	maar niet in een list	,

<div>
		    <div>
		        <a id="link43" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="lcaption44">Home</span>
		        </a>
		    </div><div>
		        <a id="link45" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="lcaption46">Cheeses</span>
		        </a>
		    </div><div>
		        <a id="link47" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="lcaption48">Wines</span>
		        </a>
		    </div><div>
		        <a id="link49" href="./wicket/bookmarkable/my.test.own.wicket_book.Page55">
		            <span id="lcaption4a">Recipes</span>
		        </a>
		    </div>
		</div>

/ 7	. 

/ we doen net als op tutorial	,
https://wicket.apache.org/guide/guide/repeaters.html#repeaters_2

/we doen	,
				Label label=new Label("lcaption", new PropertyModel<MenuItem>(item.getModel(), "caption"));

/ de manier om de caption property te bind	,

		List<MenuItem>menu=createMenu();
		ListView<MenuItem> lview=new ListView<MenuItem>("lvmenu3",menu) {
			@Override
			protected void populateItem(ListItem<MenuItem> item) {
				MenuItem menuItem=item.getModel().getObject();
				BookmarkablePageLink<Integer>link=new BookmarkablePageLink<Integer>("link"	,menuItem.getDestination());
				item.add(link);
				link.setOutputMarkupId(true);
				Label label=new Label("lcaption", new PropertyModel<MenuItem>(item.getModel(), "caption"));
				link.add(label);
				label.setOutputMarkupId(true);
				
			}
		};
		add(lview);

		<div>
		    <div wicket:id="lvmenu3">
		        <a  wicket:id="link">
		            <span wicket:id="lcaption"></span>
		        </a>
		    </div>
		</div>

/ we kunnen	,
				Label label=new Label("lcaption", new PropertyModel<MenuItem>(item.getModel(), "caption"));
/ of	,
				Label label=new Label("lcaption", new PropertyModel<MenuItem>(item.getModel().getObject(), "caption"));

/ we zijn de laatste gewend	,

/ 7	. 

/ we doen self in Ch55b.java/.html

	<span wicket:id="label"></span>
	<br>
	<span wicket:id="label2"></span>
	<br>
	<span wicket:id="label3"></span>
	<br>
	<span wicket:id="label4"></span>
	<br>

		{
		Person p=new Person();
		p.setName("Foo Bar");
		Label label=new Label("label",p.getName());
		label.setOutputMarkupId(true);
		add(label);
		}
		{
		Person p=new Person();
		p.setName("Foo Bar");
		IModel<String>model=new Model<String>(p.getName());
		Label label=new Label("label2",model);
		add(label);
		}
		{
		Person p=new Person();
		p.setName("Foo Bar");
		IModel<Person>model=new Model<Person>(p);
		PropertyModel<String>pmodel=new PropertyModel<String>(model.getObject(), "name");
		Label label=new Label("label3",pmodel);
		add(label);
		}
		{
		Person p=new Person();
		p.setName("Foo Bar");
		IModel<Person>model=new Model<Person>(p);
		PropertyModel<String>pmodel=new PropertyModel<String>(model, "name");
		Label label=new Label("label4",pmodel);
		add(label);
		}

/ Beide kunnen	,
		PropertyModel<String>pmodel=new PropertyModel<String>(model.getObject(), "name");
/ en	,
		PropertyModel<String>pmodel=new PropertyModel<String>(model, "name");

/ Verklaring	,

/ We zien in de code	,

	public final Object getInnermostModelOrObject()
	{
		Object object = getTarget();
		while (object instanceof IModel)
		{
			Object tmp = ((IModel<?>)object).getObject();
			if (tmp == object)
/ NEE
			{
				break;
			}
			object = tmp;
		}
		return object;

/ als we 'n model hebben gegeven ipv model.getObject()	, doet hij het alsnog	,

/ we zijn in 	,

	PropertyModel<T>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 265	
	PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 83	
	Label(Component).getDefaultModelObject() line: 1618	
	Label(Component).getDefaultModelObjectAsString() line: 1646	
	Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Label(Component).internalRenderComponent() line: 2557	
	Label(WebComponent).onRender() line: 56	
	Label(Component).internalRender() line: 2372	
	Label(Component).render() line: 2300	
	Ch55b(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Ch55b(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Ch55b(Page).onRender() line: 879	
	Ch55b(WebPage).onRender() line: 142	
	Ch55b(Component).internalRender() line: 2372	
	Ch55b(Component).render() line: 2300	
	Ch55b(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 837	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ServletHandler$CachedChain.doFilter(ServletRequest, ServletResponse) line: 1650	
	ServletHandler.doHandle(String, Request, HttpServletRequest, HttpServletResponse) line: 583	
	ServletHandler(ScopedHandler).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 143	
	ConstraintSecurityHandler(SecurityHandler).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 577	
	SessionHandler.doHandle(String, Request, HttpServletRequest, HttpServletResponse) line: 223	
	WebAppContext(ContextHandler).doHandle(String, Request, HttpServletRequest, HttpServletResponse) line: 1125	
	ServletHandler.doScope(String, Request, HttpServletRequest, HttpServletResponse) line: 515	
	SessionHandler.doScope(String, Request, HttpServletRequest, HttpServletResponse) line: 185	
	WebAppContext(ContextHandler).doScope(String, Request, HttpServletRequest, HttpServletResponse) line: 1059	
	WebAppContext(ScopedHandler).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 141	
	Server(HandlerWrapper).handle(String, Request, HttpServletRequest, HttpServletResponse) line: 97	
	Server.handle(HttpChannel<?>) line: 497	
	HttpConnection$HttpChannelOverHttp(HttpChannel<T>).handle() line: 311	
	HttpConnection.onFillable() line: 248	
	AbstractConnection$2.run() line: 540	
	QueuedThreadPool.runJob(Runnable) line: 610	
	QueuedThreadPool$3.run() line: 539	
	Thread.run() line: 745	

/ Einde Verklaring	,

/ 7	. 

/ ListDataProvider

/ We kunnen met/zonder RepeatingView	,

/ in project wicket-book	,

	<table>
	<tr>
			 <th>Name</th><th>Surename</th><th>Address</th><th>Email</th>
		</tr>
		<tr wicket:id="rows">
		   <td wicket:id="dataRow"></td>
		</tr>
	</table>
	
		<table>
		<tr>
		   <th>Name</th><th>Surename</th><th>Address</th><th>Email</th>
		</tr>
		<tr wicket:id="rows2">
		   <td wicket:id="name"></td>
		   <td wicket:id="address"></td>
		</tr>
	</table>

$ vi Ch55c.java

		{
		List<Person> persons = Arrays.asList(new Person("Foo","Street 1"),new Person("Bar","Lane 7"));
		ListDataProvider<Person> listDataProvider = new ListDataProvider<Person>(persons);
		DataView<Person> dataView = new DataView<Person>("rows", listDataProvider) {
		  @Override
		  protected void populateItem(Item<Person> item) {
		    Person person = item.getModelObject();
		    RepeatingView repeatingView = new RepeatingView("dataRow");
		    repeatingView.add(new Label(repeatingView.newChildId(), person.getName()));
		    repeatingView.add(new Label(repeatingView.newChildId(), person.getAddress()));    
		    item.add(repeatingView); 
		  }
		};
		add(dataView);
		}
		
		{
		List<Person> persons = Arrays.asList(new Person("Foo","Street 1"),new Person("Bar","Lane 7"));
		ListDataProvider<Person> listDataProvider = new ListDataProvider<Person>(persons);
		DataView<Person> dataView = new DataView<Person>("rows2", listDataProvider) {
		  @Override
		  protected void populateItem(Item<Person> item) {
		    Person person = item.getModelObject();

		    item.add(new Label("name", person.getName()));
		    item.add(new Label("address", person.getAddress()));    
		  }
		};
		add(dataView);
		}

/ we zien	,
	
	<table>
		<tbody><tr>
		   <th>Name</th><th>Surename</th><th>Address</th><th>Email</th>
		</tr>
		<tr>
		   <td id="id11">Foo</td><td id="id22">Street 1</td>
		</tr><tr>
		   <td id="id13">Bar</td><td id="id24">Lane 7</td>
		</tr>
	</tbody></table>
	
		<table>
		<tbody><tr>
		   <th>Name</th><th>Surename</th><th>Address</th><th>Email</th>
		</tr>
		<tr>
		   <td id="name5">Foo</td>
		   <td id="address6">Street 1</td>
		</tr><tr>
		   <td id="name7">Bar</td>
		   <td id="address8">Lane 7</td>
		</tr>
	</tbody></table>


/ repeatingView.newChildId() is achtereenvolgens "1" en "2"	, het wordt dan "id1" en "id2" , en er komt nog een getal achter	,
/ zonder RepeatingView moeten we zelf de id's geven, "name" en "address"	, en er komt nog een getal achter	,

/ we kunnen of zelf alle obj add, of 1 repeater, die de list van objs heeft	, 


	

</body>
	


	

</body>

/ Einde RM

 
/ Einde WICKET FORM COMPONENTS

/ MY WICKET COMPONENTS

/ 7. 	

/ in wicket-examples-step-by-step project	, 
/ we maken my.components 

/ zoals het nu moeten we geven,	
http://localhost:8080/wicket-examples-step-by-step/my
/ dit kan NIET	,
http://localhost:8080/wicket-examples-step-by-step/my/index.html
/ TODO

/ we kunnen Index extends MyPage	,
/ Index.html moet dan <wicket:extend> hebben	, en MyPage moet <wicket:child/> hebben	,
/ MyPage mag abstract zijn	,
/ Maar bij ons hoeft Index niet MyPage, extends WebPage is OK	,

/ we maken MyFirst.html	,
Hello, <span wicket:id="label"></span>, how are you?
/ we moeten dan de wicket label component in de MyFirst ctor bijv	, als we hem 	,
public class MyFirst extends WebPage {
	public MyFirst() {
		Label l=new Label("label","Foo Bar");
		add(l);
	}

/ Lees	,
http://www.tutorialspoint.com/java/java_date_time.htm
     	SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd"); 
      	String input = args.length == 0 ? "1818-11-11" : args[0]; 
      	Date t; 
      	try { 
          t = ft.parse(input); 

/ we hebben in MyFirst X implements Serializable	, en X.toString
/ OK
/ Y extends DetachableModel  TODO, Y is dus niet ser	,
/ In MySecond willen we DataView	,

/ HIER HIER HIER



/ Einde MY WICKET COMPONENTS

/ MONITOR HIBERNATE EHCACHE 

/ 7	.

/ in project hibernate_xml_N_1_bidir_join_ehcache	,

/ in Main	,
		session = sessionFactory.openSession();
	        address=(Address)session.get(Address.class, 12l);
	        Set<Employee>employees=address.getEmployees();
/ PersistentSet.set==null	,
/ in pc's collection

/ als hij later de set initialize	, dan aut ook in de pc.collection cache	, want de persistentset zit al in de cache, is nu leeg	,

/ 7	.

 <defaultCache 
    		maxBytesLocalHeap="100M" 
			eternal="true"
  			statistics="true">
 			<persistence strategy="none" />
    </defaultCache>   
    
    <cache 
    		name="my.test.own.hibernate_xml_N_1_bidir_join_ehcache.Employee"
   			maxBytesLocalHeap="100M" 
			eternal="true"
  			
   	>
 			<persistence strategy="none" />

      </cache> 

/ 7	.

/ in project ehcach-my	,
$ vi log4j.properties

log4j.rootLogger=debug,A1
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%d{HH:mm:ss} %-5p %c - %m%n

$ vi pom.xml

	<dependency>
	    <groupId>org.slf4j</groupId>
	    <artifactId>slf4j-log4j12</artifactId>
	    <version>${slf4j.version}</version>
	</dependency>

/ dan zien we vanzelf dat ehcache logs doet	,

/ 13	. 

/ we kunnen in Display view	,

java.util.Iterator<Object> iterator=container.getEmployeeCache().getKeys().iterator();
while(iterator.hasNext())System.out.println(iterator.next());
/ select allebei en inspect	,

net.sf.ehcache.Ehcache cache=container.getCachemanager().getCache("employees");
java.util.Iterator<Object> iterator=cache.getKeys().iterator();
//while(iterator.hasNext())System.out.println(iterator.next());
cache.get(new Integer(1)).getObjectValue();
/ als we de 3de niet comment out, dan window van 4de line meteen weg	,

/ 7	.

/ in project hibernate_xml_N_1_bidir_join_ehcache	,

/ Lees	,
http://ehcache.org/documentation/2.8/code-samples

/ we maken Main4	,

my.test.own.hibernate_xml_N_1_bidir_join_ehcache.Employee
my.test.own.hibernate_xml_N_1_bidir_join_ehcache.Address
my.test.own.hibernate_xml_N_1_bidir_join_ehcache.Address.employees

/ Lees	,
http://stackoverflow.com/questions/2961070/ehcache-default-cache-in-java

My understanding is that the "default cache" is actually a template for new caches that get created, rather than being a specific named cache.

CacheManager.getCache will only return a cache instance if it has already been created, so you'll need to tell it to create a new one, using something like addCacheIfAbsent(). The name doesn't matter, it will be created on demand using the default cache settings.

/ er is CacheManager.getCache en .getEhcache	,
/ class Cache implements Ehcache	,

/ 7	.

/ we hebben Main4 in hibernate_xml_N_1_join_ehcache, hibernate_xml_N_1_ehcache

/ Dus bij hibernate_xml_N_1_join_ehcache verschijnen de employees in de 1ste session NIET in 2c	,
/ TODO

/ in project hibernate_xml_N_1_bidir_join_ehcache	,
/ in Main4	,

	protected void setUp() throws Exception {
...
            cacheManager=CacheManager.getInstance();
            addressCache=cacheManager.getEhcache("my.test.own.hibernate_xml_N_1_bidir_join_ehcache.Address");
            employeeCache=cacheManager.getEhcache("my.test.own.hibernate_xml_N_1_bidir_join_ehcache.Employee");
            employeesCache=cacheManager.getEhcache("my.test.own.hibernate_xml_N_1_bidir_join_ehcache.Address.employees");


/ 7	.

		public void afterTransactionCompletion(boolean success) {
			while ( !processes.isEmpty() ) {
					processes.poll().doAfterTransactionCompletion( success, session );
/s
	public void doAfterTransactionCompletion(boolean success, SessionImplementor session) throws HibernateException {
		final EntityPersister persister = getPersister();
		if ( success && isCachePutEnabled( persister, getSession() ) ) {
/s
	private boolean isCachePutEnabled(EntityPersister persister, SessionImplementor session) {
		return persister.hasCache()
				&& !persister.isCacheInvalidationRequired()
				&& session.getCacheMode().isPutEnabled();

/ Address	,
	public boolean isCacheInvalidationRequired() {
false
/ want	,
		return hasFormulaProperties() ||
false
				( !isVersioned() && ( entityMetamodel.isDynamicUpdate() || getTableSpan() > 1 ) );
!isVersioned()=true
entityMetamodel.isDynamicUpdate()=false
getTableSpan()=1

/ In hibernate_xml_N_1_ehcache/Main4  is bij 
	Address getTableSpan()=1	,
	Employee getTableSpan()=1	,
/ In hibernate_xml_N_1_join_ehcache/Main4  is bij	,
	Address getTableSpan()=1	,
	Employee getTableSpan()=2	,	 WH door de join table	,
/ TODO


/ 7	.

/ Lees	,
http://www.javacodegeeks.com/2011/05/avoid-concurrentmodificationexception.html

/ we deden in hibernate_xml_N_1_bidir_ehcache, Main4	,

	        Iterator<Employee>iterator=employees.iterator();
	        while(iterator.hasNext()){	        	
	        	Employee e=iterator.next();
	        	e.setAddress(null);
	        	employees.remove(e);
	        }
/ Maar dan	,
java.util.ConcurrentModificationException

/ 7	.

/ we hebben Main4 in hibernate_xml_N_1_join_ehcache, hibernate_xml_N_1_ehcache

/ eerst session 1	,

		session4=sessionFactory.openSession();
	        address=(Address)session4.get(Address.class, 12l);
/ uit 2c
/ coll in 2c =lock	,
	        Set<Employee>employees=address.getEmployees();
/ lege pset	,
	        
            employee=(Employee)session4.get(Employee.class, 2l);
            employees.size();
/ pset initialized uit db	, coll in 2c=[1,2]	,
			session4.beginTransaction().commit();
/ coll in 2c=[1,2]	,

//////////////////////////////////////////////////////////////////////////////
			
			session2 = sessionFactory.openSession();
//			CacheManager.getInstance().clearAll();
	        address=(Address)session2.get(Address.class, 12l);
/ uit 2c	,
	        employees=address.getEmployees();
/ lege pset	,
	        
            employee2=(Employee)session2.get(Employee.class, 2l);
            employees.remove(employee2);
/ pset init uit 2c	, coll in 2c is nog steeds	[1,2]
			session2.beginTransaction().commit();
/ coll in 2c=lock

/  coll in 2c is invalidated	,






/ Einde MONITOR HIBERNATE EHCACHE

/ WICKET STYLE

/ 7	.

/ In wicket-book project maken Ch61.java/.html

$ vi pom.xml

		<plugin>
				<groupId>org.eclipse.jetty</groupId>
				<artifactId>jetty-maven-plugin</artifactId>
				<version>${jetty9.version}</version>
				<configuration>
				
		            <httpConnector>
		                    <port>9090</port>
		            </httpConnector>

/ we deden EERST	,
jetty:run -Djetty.port=9090

/ we maken een run confg	, wicket-book(4)	,
jetty:run
VM arguments: -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=9000,server=y,suspend=n

/ we maken een debug config, Remote Java Application	,
project wicket-book
host: localhost
port: 9000

/ run eerst de 1ste, dan de tweede	, 
/ geef 
localhost:9090
/ Eclipse's debugger valt in Ch61.java
 
/ 7	.

/ we maken in wicket-book Man61.java/.html	,

/ we maken 2 forms	, een met een model en de fields die een property model hebben	, en een die een compoundproperty heeft, en de fields geen model	,

/ als we een form submit, zien we de results ook in de andere	, omdat beide de person obj edit die een field is in Tut62	,

$ vi Man61.html

<form wicket:id="form">
	<input type="text" wicket:id="name">
	<input type="text" wicket:id="address">
	<input type="submit" value="Go">
</form>

<form wicket:id="form2">
	<input type="text" wicket:id="name">
	<input type="text" wicket:id="address">
	<input type="submit" value="Go">
</form>

$ vi Man61.java

	private Person person;
	
	

	public Tut61(final PageParameters parameters) {
		super(parameters);

		{
			Form<Person>form=new MyForm<Person>("form",person);
			add(form);
		
		}
		{
			Form<Person>form=new MyForm<Person>("form2",person);
			add(form);
		
		}
    } 
	
	public Person getPerson() {
		return person;
	}

	public void setPerson(Person person) {
		this.person = person;
	}


	
	private class MyForm<T extends Serializable> extends Form<T>{
		
		private T t;


		public MyForm(String id,T t) {
			super(id);
			this.t=t;
			
			IModel<T>mt=new Model<T>(t);
			setModel(mt);
			
			IModel<String>mname=new PropertyModel<String>(t, "name");
			IModel<String>maddress=new PropertyModel<String>(t, "address");
			FormComponent<String>cname=new TextField<String>("name", mname);
			FormComponent<String>caddress=new TextField<String>("address", maddress);
			add(cname);
			add(caddress);
		}
		@Override
		protected void onSubmit() {
			IModel<T>mt=getModel();
			T t=mt.getObject();
			System.out.println(t);
			
		}
	}
	
	private class MyForm2<T extends Serializable> extends Form<T>{
		
		private T t;


		public MyForm2(String id,T t) {
			super(id);
			this.t=t;
			
			IModel<T>mt=new CompoundPropertyModel<T>(t);
			setModel(mt);
			
			FormComponent<String>cname=new TextField<String>("name");
			FormComponent<String>caddress=new TextField<String>("address");
			add(cname);
			add(caddress);
		}
		@Override
		protected void onSubmit() {
			IModel<T>mt=getModel();
			T t=mt.getObject();
			System.out.println(t);
			
		}
	}

	private class Person implements Serializable{	
		private static final long serialVersionUID = 1L;

		
		private String name;
		private String address;
		
		
		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public String getAddress() {
			return address;
		}

		public void setAddress(String address) {
			this.address = address;
		}
	}

/ 7	.

/ we maken Man52.java/.html en Man52Panel.java/.html

$ vi Man52.java

	public Man52(final PageParameters parameters) {
		super(parameters);

		Panel panel=new Man52Panel("panel");
		add(panel);
	
    } 

$ vi Man52.html

<head>
<meta charset="UTF-8">
<title>Man52</title>
<wicket:head>
<wicket:link>
	<link href="Man52.css" rel="stylesheet">
</wicket:link>
</wicket:head>
</head>

<body>
	<div wicket:id="panel"></div>
</body>

$ vi Main52.css

div{
	border:solid 2px blue;
}

$ vi Man52Panel.java

	public Man52Panel(String id) {
		super(id);
		Link<Void>link=new Link<Void>("link") {
			@Override
			public void onClick() {
				logger.info("Main52Panel");
				
			}
		};
		link.setOutputMarkupId(true);
		add(link);
    } 

$ vi Main52Panel.html

<head>
<meta charset="UTF-8">
<title>Man52Panel</title>
<wicket:head>
<wicket:link>
	<link href="Man52Panel.css" rel="stylesheet">
</wicket:link>
</wicket:head>

</head>
<body>

<wicket:panel>
	<a href="#" wicket:id="link">link</a>
</wicket:panel>

</body>

$ vi Man52Panel.css

a{
	color:#aaa;
}

/ we zien	,

<html>
<head>
</head>
<body><wicket:link>
	<link href="./wicket/resource/my.test.own.wicket_book.Man52Panel/Man52Panel-ver-1421939350000.css" rel="stylesheet">
</wicket:link>

<meta charset="UTF-8">
<title>Man52</title>

<wicket:link>
	<link href="./wicket/resource/my.test.own.wicket_book.Man52/Man52-ver-1421939350000.css" rel="stylesheet">
</wicket:link>

	<div wicket:id="panel">
	<wicket:panel>
		<a href="./?0-1.ILinkListener-panel-link" wicket:id="link" id="link1">link</a>
	</wicket:panel>
	</div>

</body></html>

/ <link> is juist geen link, maar wordt voor css used	, <a> is de link	, 
/ we zien dus 2 css files included	,

/ We zien NIET	,
<meta charset="UTF-8">
<title>Man52Panel</title>

/ we kunnen in Man52 WEGLATEN	,
<wicket:head>
</wicket:head>

/ 7	.

/ Ipv een link kunnen we ook een button use, 
/ een button MOET in een form	,
/ een link hoeft NIET in een form (mag wel).

/ we maken 	,

$ vi Man52.html

	<div wicket:id="panel"></div>

 	<a href="#" wicket:id="link">link</a>
 	<form wicket:id="form" action="">
		<input wicket:id="button" type="submit">
	</form>

$ vi Man52.java

		panel=new Man52Panel("panel");
		add(panel);
	
		IModel<String>model=new Model<String>("Press");
		Link<String>link=new Link<String>("link",model) {
			@Override
			public void onClick() {
				if(getPanel().isVisible()){
					getPanel().setVisible(false);
				}else{
					getPanel().setVisible(true);
				}
				
				IModel<String>model=getModel();
				String value=model.getObject();
				logger.info(value);
				
			}
		};
		add(link);
	
		
		Form<String>form=new Form<String>("form");
		Button button=new Button("button",model){
			@Override
			public void onSubmit() {
				if(getPanel().isVisible()){
					getPanel().setVisible(false);
				}else{
					getPanel().setVisible(true);
				}
			};
		};
		form.add(button);
		add(form);

/ we kunnen een link ook een model geven	, en doorgeven aan page die wordt linked, maar wij log alleen de model object	, 
/ bij button verschijnt model als label op het button	,

/ eclipse geeft geen @Override op onSubmit method, wel als we een nieuwe type create	,

	private class MyButton extends Button{	
		public MyButton(String id) {
			super(id);
		}
		@Override
		public void onSubmit() {
			// TODO Auto-generated method stub
			super.onSubmit();
		}
	}
/ Deze use wij niet	,

/ 7	. 

/ over links	,
		IModel<String>model=new Model<String>("Press");
		Link<String>link=new Link<String>("link",model) {
			@Override
			public void onClick() {
				IModel<String>model=getModel();
				String value=model.getObject();
				logger.info(value);

/ als model is IModel<String>,	 dan moeten we Link<String>	, 
/ TODO

/ 7	.

/ we hebben met inheritance ipv panels	,
/ maar dan kunnen we het panel niet laten verdwijnen, alleen de hele page, omdat we de handler in de sub page moeten set	,

/ In Man52 is er een ref naar de panel, in Man54 niet	, de on click handler in de link kan in Man54 niet ref naar de panel, maar via een inh truc wel naar de hele (sub)page	, we maken dus de hele page onzichtbaar	,

/ Man52Panel en Man54Child verschillen nauwelijks	, alleen Man54Child krijgt een handler fct om de (sub) page invisible te maken	,

/ Man52.html
	<div wicket:id="panel"></div>
/ Man54.html
	<wicket:child/>

/ Man52Panel.html
<wicket:panel>
	<a href="#" wicket:id="link">link</a>
</wicket:panel>
/ Man54Child.html
<wicket:extend>
	<a href="#" wicket:id="link2">link</a>
</wicket:extend>

/ we moeten in  Man54Child de link link2 id geven, want link is er al in de (parent) page	,

/ het verschil is dat Man54Child (Man54) 1 page is	, en er zijn 2 pages Man52 en Man52Panel, die inj wordt	,

/ je geeft in WicketApplication	,

	@Override
	public Class<? extends WebPage> getHomePage()
	{
		return Man52.class;
	}
/ of
		return Man54Child.class;

/ Bij Man52 zien we	,
<div wicket:id="panel">
	<wicket:panel>
		<a href="./?0-1.ILinkListener-panel-link" wicket:id="link" id="link1">link</a>
	</wicket:panel>
</div>

/ bij Man54Child	,
<wicket:child>
	<wicket:extend>
		<a href="./?0-1.ILinkListener-link2" wicket:id="link2" id="link21">link</a>
	</wicket:extend>
</wicket:child>  

/ In Man52 hebben we een panel field, en in Man52.html moet dan ook 	,
	<div wicket:id="panel"></div>
/ In Man54 is de panel field er niet en zien we 	,
	<wicket:child/>

/ In Main52Panel zien we	,
<wicket:panel>...
/ In Main54Child zien we
<wicket:extend>...

/ 7	.

/ 13	.

/ In wicket-book project, Main62	,

/ In Main62.html	,
div wicket:id="name" style="color:blue;font-style:italic"></div>

/ In Main62.java
			Label label=new Label("name", person.getName());
			label.add(new AttributeModifier("style","color:red;font-weight:bold;"));

/ we zien	,
<div wicket:id="name" style="color:red;font-weight:bold">Foo</div>

/ dus de hele style uit html is overwrite	, 

/ 13	. 

/ In Main62.html
<div wicket:id="name2" style="color:blue;font-style:italic"></div>
/ In Main62.java
			Label label=new Label("name2", person.getName());
			label.add(new AttributeAppender("style", "color:red;font-weight:bold;"));
/ we zien	,
<div wicket:id="name2" style="color:blue;font-style:italic;color:red;font-weight:bold">Foo</div>

/ de browser leest vlnr dus blue wordt overwrite door red	,

/ 13	.

<div wicket:id="name3" style="color:blue;font-style:italic;"></div>
<div wicket:id="name4" style="color:blue;font-style:italic;"></div>
<div wicket:id="name5" style="color:blue;font-style:italic;"></div>

		{
			Person person=new Person();
			person.setName("Foo");
			Label label=new Label("name3", person.getName());
			add(label);
			label.add(AttributeModifier.replace("style", "color:red;font-weight:bold"));
		}
		{
			Person person=new Person();
			person.setName("Foo");
			Label label=new Label("name4", person.getName());
			add(label);
			label.add(AttributeModifier.append("style", "color:red;font-weight:bold"));
		}
		{
			Person person=new Person();
			person.setName("Foo");
			Label label=new Label("name5", person.getName());
			add(label);
			label.add(AttributeModifier.prepend("style", "color:red;font-weight:bold"));
		}

/ we zien	,
<body>
<div wicket:id="name3" style="color:red;font-weight:bold">Foo</div>
<div wicket:id="name4" style="color:blue;font-style:italic; color:red;font-weight:bold">Foo</div>
<div wicket:id="name5" style="color:red;font-weight:bold; color:blue;font-style:italic;">Foo</div>

/ replace replaces inderdaad de hele style	, niet aparte 	, 

/ 7	. 

/ we lezen 17 in Manual	,

/ 13	. 

/ red asterisk 	,

$ vi Man171.html

<div wicket:id="name" style="color:blue;font-style:italic;"></div>

$ vi Man171.java

			Label label=new Label("name", person.getName());
			label.add(new MyBehavior());

	private class MyBehavior extends Behavior{
		@Override
		public void afterRender(Component component) {
			Response response=component.getResponse();
			StringBuffer buffer=new StringBuffer(200);
			buffer.append("<b style='color:red;font-weight:bold;'>*</b>");
			response.write(buffer);
			
		}
	}

/ we zien	,

<div wicket:id="name" style="color:blue;font-style:italic;">Foo</div>
<b style="color:red;font-weight:bold;">*</b>

/ als we beforeRender use, dan verschijnt * voor de label, als we afterRender, dan erachter	, 

/ 13	. 

/ we voegen nu de * achter een text field in een form 	,

$ vi Man171.java

		{
			
			person=new Person();

			Person person=new Person();
			person.setName("Foo");
			Label label=new Label("name", person.getName());
			add(label);
			label.add(new MyBehavior());
		}
		{
			Form<Person>form=new MyForm<Person>("form",person);
			add(form);
		
		}

	private class MyForm<T extends Serializable> extends Form<T>{
		
		private T t;


		public MyForm(String id,T t) {
			super(id);
			this.t=t;
			
			IModel<T>mt=new Model<T>(t);
			setModel(mt);
			
			IModel<String>mname=new PropertyModel<String>(t, "name");
			IModel<String>maddress=new PropertyModel<String>(t, "address");
			FormComponent<String>cname=new TextField<String>("name", mname);

			Behavior behavior=new MyBehavior();
			cname.add(behavior);
			FormComponent<String>caddress=new TextField<String>("address", maddress);
			caddress.add(behavior);

			add(cname);
			add(caddress);
		}
		@Override
		protected void onSubmit() {
			IModel<T>mt=getModel();
			T t=mt.getObject();
			System.out.println(t);
			
		}
	}

	

	private class Person implements Serializable{	
...
	}
	
	private class MyBehavior extends Behavior{
		@Override
		public void afterRender(Component component) {
			Response response=component.getResponse();
			StringBuffer buffer=new StringBuffer(200);
			buffer.append("<b style='color:red;font-weight:bold;'>*</b>");
			response.write(buffer);
			
		}
	}


/ 7	. 

/ Zoek in google op	,
wicket behavior javascript

/ 7	. 

/ Lees	,
http://www.wicket-library.com/wicket-examples/repeater/

/ 7	.

/ Lees	,
https://cwiki.apache.org/confluence/display/WICKET/Everything+about+Wicket+internationalization

/ in wicket-book project	,

$ vi Ch12_1_2.html

	<div wicket:id="second"></div>
	<wicket:message key="first"></wicket:message>
	<div wicket:id="third"></div>

$ vi Ch12_1_2.java

		Label label=new Label("second",new Model<String>("Foo Bar"));
		add(label);

		Label label3=new Label("third",new ResourceModel("third"));
		add(label3);

$ vi Ch12_1_2.properties

first=My First Label
third=My Third Label


/ 7	. 

/ SimpleResourceModel	,

/ bundle is de .properties file	,

/ in project wicket-book	,

/ 13	. 

/ we kunnen de property krijgen door een var te resolve,	

$ vi Ch12_1_2a.java

		WeatherStation ws=new WeatherStation();
		ws.setCurrentStatus("raining");
		IModel<String>model3=new StringResourceModel("weather.${currentStatus}",this,new Model<WeatherStation>(ws));
		Label label3=new Label("weatherMessage",model3);
		add(label3);
	
		
	}
	private class WeatherStation implements Serializable{
		private String currentStatus;
/ en getters/setters	,

$ vi Ch12_1_2a.properties

 weather.sunny=Don't forget sunscreen!
 weather.raining=You might need an umbrella
 weather.snowing=Got your skis?
 weather.overcast=Best take a coat to be safe

$ vi Ch12_1_2a.html

	<div wicket:id="weatherMessage"></div>

/we zien	,
You might need an umbrella

/ In 
		IModel<String>model3=new StringResourceModel("weather.${currentStatus}",this,new Model<WeatherStation>(ws));
/ wordt ${currentStatus} tegen ws bepaald	, 

/ Wat doet this	?
/ TODO

/ 13	.

/ we kunnen ook in de regel var's te resolve,	


$ vi Ch12_1_2a.java
		WeatherStation ws=new WeatherStation();
		ws.setCurrentStatus("raining");
		ws.setCurrentTemperature(4);
		ws.setUnits("\u00b0C");
		
		IModel<String>model4=new StringResourceModel("weather.message",this,new Model<WeatherStation>(ws));
		Label label4=new Label("weatherMessage2",model4);
		add(label4);

	private class WeatherStation implements Serializable{
		private static final long serialVersionUID = 1L;
		private String currentStatus;
		private int currentTemperature;
		private String units;
/ en getters/setters	,

$ vi Ch12_1_2a.properties

weather.message=Weather station reports that the temperature is ${currentTemperature} ${units}

/ we zien	,
Weather station reports that the temperature is 4 °C

/ 7	.

/ we kunnen ook TODO	,

$ vi Ch12_1_2a.java

				
		Object[]params=new Object[]{
				new Date(),
				new PropertyModel<String>(model,"currentStatus"),
				new PropertyModel<Integer>(model,"currentTemperature"),
				new PropertyModel<String>(model,"units")
		};
		IModel<String>model5=new StringResourceModel("weather.detail",this,model,params);
		
		Label label5=new Label("weatherMessage5",model5);
		add(label5);

$ vi Ch12_1_2a.properties

weather.detail=The report for {0,date}, shows the temperature as {2,number,###.##} {3} and the weather to be {1}

/ we zien	,

The report for Feb 3, 2015, shows the temperature as 4 °C and the weather to be raining

/ In de string zijn date, number format types	, in {0,date}

/ als we {0}, ipv {0,date}	, dus als we 	,
weather.detail=The report for {0}, shows the temperature as {2,number,###.##} {3} and the weather to be {1}
/ dan zien we	,
The report for 2/3/15 9:00 AM, shows the temperature as 4 °C and the weather to be raining

/ we kunnen ze ook door elkaar use, dus	, 
	{2,number,###.##} or ${currentTemperature}
/ we zien	,
	4 or 4
/////////////////////////////////////////////////////////////////////////////////
/ WH komt ${currentTemperatur} uit de model, en {2} uit de params	,
/ we geven de laatste 3 params values uit de model, dus bij die komt het op hetzelfde neer	,

/ 7	. 

/ project wicket-book

/ Misc	,

/ Lees	,
http://stackoverflow.com/questions/5395603/wicket-changing-the-text-of-an-ajaxbutton-on-submit



/ Het model op een (Ajax)Button verschijnt op het button als we <input type="submit"> use, en NIET <button>	, want het model verschijnt als value-attribute, en dat werkt zo alleen met <input type="submit">

$ vi Misc.html

	<h1 wicket:id="label0"></h1>
	
	<form wicket:id="form">
		
		<input type="submit" wicket:id="button">
		
		<label for="button3">Foo Bar</label>		
		<input id="button3" type="submit" value="Foo Bar">
	</form>

$ vi Misc.java

		IModel<String>model0=new ResourceModel("label");
		Label label0=new Label("label0",model0);
		label0.setOutputMarkupId(true);
		add(label0);
		
		Form<Void>form=new Form<Void>("form");
		IModel<String>model=new ResourceModel("button");
		AjaxButton button=new AjaxButton("button", model,form){
			@Override
			protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
				// TODO Auto-generated method stub
				super.onSubmit(target, form);
			}
		
		};
		form.add(button);

		add(form);

$ vi Misc.properties
label=My Label
button=My Button

/ we zien in HTML	,

<h1 wicket:id="label0" id="label03">My Label</h1>

<form wicket:id="form" id="form1" method="post" action="./?0-3.IFormSubmitListener-form"><div style="width:0px;height:0px;position:absolute;left:-100px;top:-100px;overflow:hidden">
	<input type="hidden" name="form1_hf_0" id="form1_hf_0"></div>
	<input type="button" wicket:id="button" name="button" id="button2" value="My Button">

	<label for="button3">Foo Bar</label>		
	<input id="button3" type="submit" value="Foo Bar">
</form>

/ Kunnen we ook het for attribute program in wicket? Met AttributeModifier? Hoe dan met id van de target, de <input type="submit">?
/ Met zoiets als	,
		Label label=new Label("label", model);
		Behavior behavior=new AttributeModifier("for", model);
/ TODO

/ 7	. 

/ form's model	,

/ we kunnen 2 dingen doen	,

		Form<PersonSer>form=new Form<PersonSer>("form5",model){
/ or	,
		Form<PersonSer>form=new Form<PersonSer>("form5"){
...
		form.setModel(model);

/ 7	.

/ we kunnen 	,

		dropdown=new DropDownChoice<String>("dropdown",model3,list);
/ of	,
		dropdown=new DropDownChoice<String>("dropdown",list);
		dropdown.setModel(model3);

/ In Man11_4d2 veranderen we de model van een label, en we zien de label view veranderd	,

/ 7	.

/ form & model

///////////////////////
/ In een form moeten we een <input type="submit"> opnemen, zonder wicket:id dus	, en dan valt hij in de Form.onSubmit	,

///////////////////////
/ als we submit, in het model van het form write	,

$ vi Misc3.java

public class Misc3 extends WebPage{
	public Misc3() {
		Form<Data>form=new MyForm("form");
		add(form);
		
		boolean b=false;
		
	}
	
	private class MyForm extends Form<Data>{
		public MyForm(String id) {
			super(id);
			Data d=new Data();
			d.setS("Foo");
			d.setI(13);
			IModel<Data>model=new CompoundPropertyModel<>(d);
			setDefaultModel(model);
			FormComponent<String>s=new TextField<>("s");
			add(s);
			FormComponent<Integer>i=new TextField<>("i");
			add(i);
			
		}
		@Override
		protected void onSubmit() {
			super.onSubmit();
			Data d=getModelObject();
			boolean b=false;
		}
		
	}
	private class Data implements Serializable{
		String s;
		int i;
		public String getS() {
			return s;
		}
		public void setS(String s) {
			this.s = s;
		}
		public int getI() {
			return i;
		}
		public void setI(int i) {
			this.i = i;
		}
	}
}

$ vi Misc3.html

	<form wicket:id="form">
		<input type="text" wicket:id="s">
		<input type="text" wicket:id="i">
		<input type="submit">
	</form>

/ we zien omdat we de model al hebben init in de text fields Foo en 13	, 
/ maar dat hoeven we niet te doen	,
/ als we click op submit, zien we dat in het model staat wat we in de text fields hebben gegeven	,

/ 7	. 

/ we voegen een zelf wicket button toe	,


$ vi Misc3.java

	private class MyForm extends Form<Data>{
		public MyForm(String id) {
			super(id);
			Data d=new Data();
			d.setS("Foo");
			d.setI(13);
			IModel<Data>model=new CompoundPropertyModel<>(d);
			setDefaultModel(model);
			FormComponent<String>s=new TextField<>("s");
			add(s);
			FormComponent<Integer>i=new TextField<>("i");
			add(i);
			FormComponent<String>b=new Button("b"){
				@Override
				public void onSubmit() {
					super.onSubmit();
					System.out.println("************************");
					System.out.println("In Button");
					System.out.println("************************");

				}
			};
			add(b);
			
		}
		@Override
		protected void onSubmit() {
//			super.onSubmit();
			Data d=getModelObject();
			System.out.println("************************");
			System.out.println(d);
			System.out.println(d.getS());
			System.out.println(d.getI());
			System.out.println("************************");
			boolean b=false;
		}
		
	}

/ we zien als we click op het ajax-button	,

************************
In Button
************************
************************
my.test.own.wicket_book.Misc3$Data@363fe0c7
Foo
13
************************

/ we zien als we click op het niet-wicket button	, net als eerst	,

************************
my.test.own.wicket_book.Misc3$Data@363fe0c7
Foo
13
************************



/ 7	. 

/ we maken een form met een ajax submit button	,

$ vi Misc3.java

	private class MyForm extends Form<Data>{
		public MyForm(String id) {
			super(id);
			Data d=new Data();
			d.setS("Foo");
			d.setI(13);
			IModel<Data>model=new CompoundPropertyModel<>(d);
			setDefaultModel(model);
			FormComponent<String>s=new TextField<>("s");
			add(s);
			FormComponent<Integer>i=new TextField<>("i");
			add(i);
			FormComponent<String>b=new Button("b"){
				@Override
				public void onSubmit() {
					super.onSubmit();
					System.out.println("************************");
					System.out.println("In Button");
					System.out.println("************************");

				}
			};
			add(b);
			FormComponent<String>aj=new AjaxButton("aj",new Model<String>("Click")) {
				@Override
				protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
					super.onSubmit(target, form);
					System.out.println("************************");
					System.out.println("In Ajax Button");
					System.out.println("************************");
	
				}
			};
			aj.setOutputMarkupId(true);
			add(aj);
			
	
			
		}
		@Override
		protected void onSubmit() {
			super.onSubmit();
			Data d=getModelObject();
			System.out.println("************************");
			System.out.println(d);
			System.out.println(d.getS());
			System.out.println(d.getI());
			System.out.println("************************");
			boolean b=false;
		}
		
	}

/ we hoeven in de ajax buttons' onSubmit NIET	,
	target.add(...) 
	target.add(...) 
/ met op ... een  component die je door ajax wil laten veranderen	,


/ Einde WICKET STYLE

/ WICKET RENDER STACKTRACES

/ In Man11_4d3	, 

/ we komen in	,

	Man11_4d3$1.onBeforeRender() line: 48	
/=
			@Override
			protected void onBeforeRender() {
				super.onBeforeRender();
			}
	Man11_4d3$1(Component).internalBeforeRender() line: 949	
/ label
	Man11_4d3$1(Component).beforeRender() line: 1017	
/ label
	Man11_4d3(MarkupContainer).onBeforeRenderChildren() line: 1712	
/ this=Man11_4d3
	Man11_4d3(Page).renderPage() line: 1018	
	Man11_4d3(Component).onBeforeRender() line: 3869	
	Man11_4d3(Page).onBeforeRender() line: 801	
	Man11_4d3(Component).internalBeforeRender() line: 949	
	Man11_4d3(Component).beforeRender() line: 1017	
	Man11_4d3(Component).internalPrepareForRender(boolean) line: 2207	
	Man11_4d3(Page).internalPrepareForRender(boolean) line: 242	
	Man11_4d3(Component).render() line: 2296	
	Man11_4d3(Page).renderPage() line: 1018	
/ this=Man11_4d3
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
/ this=WebPageRenderer	,
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 837	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 241	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 208	
	StandardWrapperValve.invoke(Request, Response) line: 220	
	StandardContextValve.invoke(Request, Response) line: 122	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 503	
	StandardHostValve.invoke(Request, Response) line: 170	
	ErrorReportValve.invoke(Request, Response) line: 103	
	AccessLogValve.invoke(Request, Response) line: 950	
	StandardEngineValve.invoke(Request, Response) line: 116	
	CoyoteAdapter.service(Request, Response) line: 421	
	Http11Processor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1070	
	Http11Protocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 611	
	JIoEndpoint$SocketProcessor.run() line: 314	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ Later	,

	Man11_4d3$2.onBeforeRender() line: 62	
/ textfield	,
	Man11_4d3$2(Component).internalBeforeRender() line: 949	
	Man11_4d3$2(Component).beforeRender() line: 1017	
/ textfield	,
	Man11_4d3(MarkupContainer).onBeforeRenderChildren() line: 1712	
/ this=Man11_4d3
	Man11_4d3(Component).onBeforeRender() line: 3869	
	Man11_4d3(Page).onBeforeRender() line: 801	
	Man11_4d3(Component).internalBeforeRender() line: 949	
	Man11_4d3(Component).beforeRender() line: 1017	
	Man11_4d3(Component).internalPrepareForRender(boolean) line: 2207	
	Man11_4d3(Page).internalPrepareForRender(boolean) line: 242	
	Man11_4d3(Component).render() line: 2296	
	Man11_4d3(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	


/ later	, 

	TextField<T>(AbstractTextComponent<T>).getModelType(IModel<?>) line: 165	
	TextField<T>(AbstractTextComponent<T>).resolveType() line: 152	
	TextField<T>(AbstractTextComponent<T>).onBeforeRender() line: 142	
	TextField<T>(Component).internalBeforeRender() line: 949	
	TextField<T>(Component).beforeRender() line: 1017	
this=TextField<T>
	Man11_4d3(MarkupContainer).onBeforeRenderChildren() line: 1712	
this=Man11_4d3
	Man11_4d3(Component).onBeforeRender() line: 3869	
this=Man11_4d3
	Man11_4d3(Page).onBeforeRender() line: 801	
this=Man11_4d3
	Man11_4d3(Component).internalBeforeRender() line: 949	
this=Man11_4d3
	Man11_4d3(Component).beforeRender() line: 1017	
this=Man11_4d3
	Man11_4d3(Component).internalPrepareForRender(boolean) line: 2207	
this=Man11_4d3
	Man11_4d3(Page).internalPrepareForRender(boolean) line: 242	
this=Man11_4d3
	Man11_4d3(Component).render() line: 2296	
this=Man11_4d3
	Man11_4d3(Page).renderPage() line: 1018	
this=Man11_4d3
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	

/ Later	,

/ 1ste child	,

Daemon Thread [http-bio-9090-exec-253] (Suspended (breakpoint at line 2288 in Component))	
	HtmlHeaderContainer(Component).render() line: 2288	
	Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Man11_4d3(Page).onRender() line: 879	
	Man11_4d3(WebPage).onRender() line: 142	
	Man11_4d3(Component).internalRender() line: 2372	
	Man11_4d3(Component).render() line: 2300	
				internalPrepareForRender(true);
/d (hierboven)
			}

			// Do the render
			internalRender();

	Man11_4d3(Page).renderPage() line: 1018	

/ later	,
/ 2de child	,

	Man11_4d3$1(Component).render() line: 2288	
/ label
	Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Man11_4d3(Page).onRender() line: 879	
	Man11_4d3(WebPage).onRender() line: 142	
	Man11_4d3(Component).internalRender() line: 2372	
	Man11_4d3(Component).render() line: 2300	
				internalPrepareForRender(true);
/d
			}

			// Do the render
			internalRender();

	Man11_4d3(Page).renderPage() line: 1018	

/ later	,

	Man11_4d3$1.onRender() line: 47	
/=
			@Override protected void onRender() {
				super.onRender();
			}
	Man11_4d3$1(Component).internalRender() line: 2372	
	Man11_4d3$1(Component).render() line: 2300	
	Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Man11_4d3(Page).onRender() line: 879	
	Man11_4d3(WebPage).onRender() line: 142	
	Man11_4d3(Component).internalRender() line: 2372	
	Man11_4d3(Component).render() line: 2300	
	Man11_4d3(Page).renderPage() line: 1018	

/ later	,

Daemon Thread [http-bio-9090-exec-253] (Suspended (breakpoint at line 2288 in Component))	
	TextField<T>(Component).render() line: 2288	
/ this=TextField<T> 
	Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Man11_4d3(Page).onRender() line: 879	
	Man11_4d3(WebPage).onRender() line: 142	
	Man11_4d3(Component).internalRender() line: 2372	
	Man11_4d3(Component).render() line: 2300	
	Man11_4d3(Page).renderPage() line: 1018	




/ Einde WICKET RENDER STACKTRACES

/ WICKET MODEL UPDATE

/ In Man11_4db : ajax en niet-ajax button update een textfield en dropdown in een form	,
/ compound property model 	,

/ In Man11_4d5a: ajax en niet-ajax button renew their label when we click on it	,

/ we kunnen niet compound property model use met button	,
/ voor button moeten we apart model ,dan property model zijn	,
/ TODO

/ 7	.

/ Man11_4db	,

/ als we click op de buttons , zien we het textfield en dropdown veranderen, omdat we het compound property model veranderen	,

$ vi Man11_4db.html

<form wicket:id="form">

	<input type="text" wicket:id="f">
	<select  wicket:id="d"></select>
	<input type="submit" wicket:id="a">
	<input type="submit" wicket:id="b">
	
</form>
<h1 wicket:id="label"></h1>

$ vi Man11_4db.java

public class Man11_4db extends WebPage {
	private static final long serialVersionUID = 1L;
	
	private static final Logger logger=LoggerFactory.getLogger(Man11_4db.class);
	
	private FormComponent<String >field;
	private Label label;
	private FormComponent<String >dropdown;
	private FormComponent<String>abtn;
	private FormComponent<String>btn;
	
	
	

	public Man11_4db(final PageParameters parameters) {
		super(parameters);

		Form<Data>form=new MyForm2("form");
		add(form);
		label=new Label("label",new Model<String>(""));
		label.setOutputMarkupId(true);
		add(label);


    } 
	
	
	private class Data implements Serializable{
		private String l;
		private String f;
		private String d;
		private String b;
		private String a;
		
		public String getL() {
			return l;
		}
		public void setL(String l) {
			this.l = l;
		}
		public String getF() {
			return f;
		}
		public void setF(String f) {
			this.f = f;
		}
		public String getD() {
			return d;
		}
		public void setD(String d) {
			this.d = d;
		}
		
		public Data() {
		}
		public String getB() {
			return b;
		}
		public void setB(String b) {
			this.b = b;
		}
		public String getA() {
			return a;
		}
		public void setA(String a) {
			this.a = a;
		}

		
	}
	


	
	private class MyForm2 extends Form<Data>{
		private FormComponent<String>text;
		public MyForm2(String id) {
			super(id);
			
			Data data=new Data();
//			data.setL("Initial");
			data.setF("initial");
			data.setD("0Initial");
			data.setA("Initial");
			data.setB("Initial");
			IModel<Data>model=new CompoundPropertyModel<>(data);
			setModel(model);
			
//			Label label=new Label("l");
//			label.setOutputMarkupId(true);
//			add(label);
			
			field=new TextField<String>("f");
			field.setOutputMarkupId(true);
			add(field);

			List<String>list=Arrays.asList("0Initial","aInitial","bInitial");
//			ChoiceRenderer<String>renderer=new ChoiceRenderer<String>();
			dropdown=new DropDownChoice<String>("d",list);
			dropdown.setOutputMarkupId(true);
			add(dropdown);
			
			IModel<String>model5=new Model<String>("Press");
			abtn=new ABtn("a",model5);
			add(abtn);
			
			IModel<String>model6=new Model<String>("Press");
			btn=new Btn("b",model6);
			add(btn);
		}
		
	}
	
	private class ABtn extends AjaxButton{
		public ABtn(String id,IModel<String>model) {
			super(id,model);
		}
		@Override
		protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
			String value=dropdown.getModelObject();
			label.setDefaultModelObject(value);
			if(target!=null){
				target.add(dropdown);
				target.add(field);
				target.add(abtn);
			}
			Data data=new Data();
//			data.setL("New L");
			data.setF("aNew");
			data.setD("aInitial");			
			data.setA("aNew");
			data.setB("aNew");
//			IModel<Data>model=new CompoundPropertyModel<>(data);
//			((Form<Data>)form).setModel(model);
			((Form<Data>)form).getModel().setObject(data);
		}
		
	}
	
	private class Btn extends Button{
		public Btn(String id,IModel<String>model){
			super(id,model);
		}
		@Override
		public void onSubmit(){
			String value=dropdown.getModelObject();
			label.setDefaultModelObject(value);
			
			Data data=new Data();
//			data.setL("New L");
			data.setF("bNew");
			data.setD("bInitial");
			data.setA("bNew");
			data.setB("bNew");
//			IModel<Data>model=new CompoundPropertyModel<>(data);
//			((Form<Data>)form).setModel(model);
			((Form<Data>)getForm()).getModel().setObject(data);
		}
		
	}
	
}

/ 7	. 

/ Verander label op buttons	, 

/ we kunnen dit alleen met een property model	, niet met de compoundpropertymodel 	,
/ TODO

/ als we click op button met Initial, verschijnt er op het button New	,
/ als we click op ajax button met Initial, verschijnt er op het button aNew	,

$ vi Man11_4d5a.html

<form wicket:id="form">
	<input wicket:id="button" type="submit">
	<input wicket:id="abtn" type="submit">
</form>

$ vi Man11_4d5a.java

public class Man11_4d5a extends WebPage {
	
	private class Data implements Serializable{
		
		private String button;
		private String abtn;
		
		
		
		public String getButton() {
			return button;
		}
		public void setButton(String button) {
			this.button = button;
		}
		public String getAbtn() {
			return abtn;
		}
		public void setAbtn(String abtn) {
			this.abtn = abtn;
		}
	}
	
	
	private class MyForm extends Form<Data>{
		
		public MyForm(String id) {
			super(id);
			
			
			IModel<String>model=new PropertyModel<String>(data, "button");
			button=new Button("button",model){
				protected void onRender() {
					super.onRender();
				};
				@Override
				public void onSubmit(){
					super.onSubmit();
					
					data.setButton("New");				
				}
			};
			button.setOutputMarkupId(true);
			add(button);
			
			IModel<String>amodel=new PropertyModel<String>(data, "abtn");
			abtn=new AjaxButton("abtn",amodel) {
				@Override
				protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
					super.onSubmit(target, form);
					if(target!=null){
						target.add(abtn);
					}
					data.setAbtn("aNew");
				}
			};
			abtn.setOutputMarkupId(true);
			add(abtn);
		}
		
		
	}
	
	private static final long serialVersionUID = 1L;
	
	private static final Logger logger=LoggerFactory.getLogger(Man11_4d5a.class);
	private FormComponent<String> button;
	private FormComponent<String>abtn;
	private Data data;


	public Man11_4d5a(final PageParameters parameters) {
		super(parameters);
		
		data=new Data();
		data.setButton("Initial");
		data.setAbtn("Initial");

		Form<Data>form=new MyForm("form");
		add(form);
		

	
		
	}




/ Einde WICKET MODEL UPDATE

/ WICKET MODEL COMPOUND

/ In WICKET MODEL UPDATE hebben we Man11_4b en Man11_4d5a	,
/ In Man11_4b hebben we een compound model, maar dat is de model van een form	, 
/ In Man11_4d5a veranderen we het label van een button	,

/ In Man11_4d6 hebben we een compound property model, maar is default model van de page	,

$ vi Man11_4d6.html

	<div wicket:id="l"></div>
	<input type="text" wicket:id="f">
	<select  wicket:id="d"></select>
	<input type="submit" wicket:id="a">
	<a href="#" wicket:id="link">link</a>


$ vi Man11_4d6.java

		Data data=new Data();
		data.setF("Initial");
		data.setL("Initial");
		data.setD("Initial");
		data.setA("Initial");
		data.setB("Initial");
		model=new CompoundPropertyModel<>(data);
		setDefaultModel(model);
		
		Label label=new Label("l");
		label.setOutputMarkupId(true);
		add(label);
		
		field=new TextField<String>("f");
		field.setOutputMarkupId(true);
		add(field);

		List<String>list=Arrays.asList("Initial","New");
//		ChoiceRenderer<String>renderer=new ChoiceRenderer<String>();
		dropdown=new DropDownChoice<String>("d",list);
		dropdown.setOutputMarkupId(true);
		add(dropdown);
		
		IModel<String>model5=new Model<String>("Button");
		abtn=new Button("a",model5);
		add(abtn);
		
		IModel<String>model7=new Model<String>("Link");
		link=new Link<String>("link",model7) {
			@Override
			public void onClick() {
				Data data=new Data();
				data.setF("New");
				data.setL("New");
				data.setD("New");
				data.setA("New");
				data.setB("New");

				getParent().setDefaultModelObject(data);
/ of	,
				((IModel<Data>)getParent().getDefaultModel()).setObject(data);
			}
		};
		add(link);

	private class Data implements Serializable{
		private String l;
		private String f;
		private String d;
		private String b;
		private String a;
/ + getters/setters

/ Wat doet model7 op de link?
/ TODO

/ Als we de link click, zien we de label, textfield en dropdown veranderen	, 

/ we kunnen op page alleen setDefaultModel	, op form setModel	,

/ we maken Man11_4d6a	, met form	,
/ TODO

/ Form.setModel=setDefaultModel	, een Form is een MarkupContainer	, en die heeft de method setDefaultModel	,
/ Component heeft ook setDefaultModel, vandaar dat Label hem ook heeft	,
/ MarkupContainer.setDefaultModel is in feite Component.setDefaultModel	,



/ Einde WICKET MODEL COMPOUND

/ DEBUG WICKET MODEL COMPOUND

/ we debug Man11_4d6	,

		IModel<String>model5=new Model<String>("Button");
		abtn=new Button("a",model5){
/s
	Man11_4d6$4(Component).setModelImpl(IModel<?>) line: 3021	
	Man11_4d6$4(Component).<init>(String, IModel<?>) line: 698	
	Man11_4d6$4(MarkupContainer).<init>(String, IModel<?>) line: 120	
	Man11_4d6$4(WebMarkupContainer).<init>(String, IModel<?>) line: 52	
	Man11_4d6$4(LabeledWebMarkupContainer).<init>(String, IModel<?>) line: 70	
	Man11_4d6$4(FormComponent<T>).<init>(String, IModel<T>) line: 477	
	Man11_4d6$4(Button).<init>(String, IModel<String>) line: 86	
	Man11_4d6$4.<init>(Man11_4d6, String, IModel) line: 85	
	Man11_4d6.<init>(PageParameters) line: 85	
...

/ Bij een form component zonder eigen model wordt setModelImpl later called, in onBeforeRender	,

	Man11_4d6$2(Component).setModelImpl(IModel<?>) line: 3021	
model	CompoundPropertyModel$AttachedCompoundPropertyModel<C>  (id=4804)	

	Man11_4d6$2(Component).getDefaultModel() line: 1598	
	Man11_4d6$2(AbstractTextComponent<T>).resolveType() line: 152	
	Man11_4d6$2(AbstractTextComponent<T>).onBeforeRender() line: 142	
	Man11_4d6$2(Component).internalBeforeRender() line: 949	
	Man11_4d6$2(Component).beforeRender() line: 1017	
	Man11_4d6(MarkupContainer).onBeforeRenderChildren() line: 1712	
	Man11_4d6(Component).onBeforeRender() line: 3869	
	Man11_4d6(Page).onBeforeRender() line: 801	
	Man11_4d6(Component).internalBeforeRender() line: 949	
	Man11_4d6(Component).beforeRender() line: 1017	
	Man11_4d6(Component).internalPrepareForRender(boolean) line: 2207	
	Man11_4d6(Page).internalPrepareForRender(boolean) line: 242	
	Man11_4d6(Component).render() line: 2296	
	Man11_4d6(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 837	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 241	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 208	
	StandardWrapperValve.invoke(Request, Response) line: 220	
	StandardContextValve.invoke(Request, Response) line: 122	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 503	
	StandardHostValve.invoke(Request, Response) line: 170	
	ErrorReportValve.invoke(Request, Response) line: 103	
	AccessLogValve.invoke(Request, Response) line: 950	
	StandardEngineValve.invoke(Request, Response) line: 116	
	CoyoteAdapter.service(Request, Response) line: 421	
	Http11Processor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1070	
	Http11Protocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 611	
	JIoEndpoint$SocketProcessor.run() line: 316	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ dit gaan we beter bekijken	,

Man11_4d6(Component).render() line: 2296	
this	Man11_4d6  (id=3952)	
->			internalPrepareForRender(true);
...
/s
Man11_4d6(Component).onBeforeRender() line: 3869	
this	Man11_4d6  (id=3952)	
		onBeforeRenderChildren();
/s
Man11_4d6(MarkupContainer).onBeforeRenderChildren() line: 1712	
this	Man11_4d6  (id=3952)	
			for (final Component child : children)
					child.beforeRender();
/s
Man11_4d6$2(Component).beforeRender() line: 1017	
this	Man11_4d6$2  (id=3989)	
[TextField [Component id = f]]
			internalBeforeRender();
...
/s
Man11_4d6$2(AbstractTextComponent<T>).onBeforeRender() line: 142	
		super.onBeforeRender();
		resolveType();
/s
Man11_4d6$2(AbstractTextComponent<T>).resolveType() line: 152	
			Class<?> type = getModelType(getDefaultModel());
/s
Man11_4d6$2(Component).getDefaultModel() line: 1598	
		IModel<?> model = getModelImpl();
null
		if (model == null)
		{
			// give subclass a chance to lazy-init model
			model = initModel();
/s
Man11_4d6$2(Component).initModel() line: 3795	
		for (Component current = getParent(); current != null; current = current.getParent())
		{
			// Get model
			// Don't call the getModel() that could initialize many in between
			// completely useless models.
			// IModel model = current.getDefaultModel();
			IModel<?> model = current.getModelImpl();
model	CompoundPropertyModel<T>  (id=4061)	

			if (model instanceof IComponentInheritedModel)
			{
				// return the shared inherited
				foundModel = ((IComponentInheritedModel<?>)model).wrapOnInheritance(this);
/s
CompoundPropertyModel<T>.wrapOnInheritance(Component) line: 81	
		return new AttachedCompoundPropertyModel<C>(component);
/s
CompoundPropertyModel$AttachedCompoundPropertyModel<C>.<init>(CompoundPropertyModel, Component) line: 123	
			super(CompoundPropertyModel.this);
...
/s
CompoundPropertyModel$AttachedCompoundPropertyModel<C>(ChainingModel<T>).<init>(Object) line: 42	
		target = modelObject;
modelObject	CompoundPropertyModel<T>  (id=4061)	
/t
CompoundPropertyModel$AttachedCompoundPropertyModel<C>.<init>(CompoundPropertyModel, Component) line: 123	
			super(CompoundPropertyModel.this);
/d
			this.owner = owner;
owner	Man11_4d6$2  (id=4060)	
/t
Man11_4d6$2(Component).initModel() line: 3795	
				foundModel = ((IComponentInheritedModel<?>)model).wrapOnInheritance(this);
/d
foundModel	CompoundPropertyModel$AttachedCompoundPropertyModel<C>  (id=4063)	
/t
Man11_4d6$2(Component).getDefaultModel() line: 1598	
			model = initModel();
/d
model	CompoundPropertyModel$AttachedCompoundPropertyModel<C>  (id=4063)	
	owner	Man11_4d6$2  (id=4060)	
	target	CompoundPropertyModel<T>  (id=4061)	

			setModelImpl(model);
/t
Man11_4d6$2(AbstractTextComponent<T>).resolveType() line: 152	
			Class<?> type = getModelType(getDefaultModel());
/s
Man11_4d6$2(AbstractTextComponent<T>).getModelType(IModel<?>) line: 165	
this	Man11_4d6$2  (id=4060)	
			Class<?> objectClass = ((IObjectClassAwareModel<?>)model).getObjectClass();
/s
CompoundPropertyModel$AttachedCompoundPropertyModel<C>(AbstractPropertyModel<T>).getObjectClass() line: 143	
		final String expression = propertyExpression();
"f"
		final Object target = getInnermostModelOrObject();
/s
CompoundPropertyModel$AttachedCompoundPropertyModel<C>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 261	
this	CompoundPropertyModel$AttachedCompoundPropertyModel<C>  (id=4063)	
		Object object = getTarget();
object	CompoundPropertyModel<T>  (id=4061)	
		while (object instanceof IModel)
		{
			Object tmp = ((IModel<?>)object).getObject();
tmp	Man11_4d6$Data  (id=4065)	
			object = tmp;
/ volgende	,
		while (object instanceof IModel)
/ NEE
		return object;
/t
CompoundPropertyModel$AttachedCompoundPropertyModel<C>(AbstractPropertyModel<T>).getObjectClass() line: 145	
		final Object target = getInnermostModelOrObject();
/d
target	Man11_4d6$Data  (id=4065)	
				return (Class<T>)PropertyResolver.getPropertyClass(expression, target);
expression="f"

/t
Man11_4d6$2(AbstractTextComponent<T>).resolveType() line: 153	
			Class<?> type = getModelType(getDefaultModel());
/d
type	Class<T> (java.lang.String) (id=3290)	
			setType(type);
/s
		typeName = type == null ? null : type.getName();
this	Man11_4d6$2  (id=4060)	
	typeName	"java.lang.String" (id=4105)	

/t
Man11_4d6(MarkupContainer).onBeforeRenderChildren() line: 1712	
			for (final Component child : children)
			{
				// Get next child
				// Call begin request on the child
				// We need to check whether the child's wasn't removed from the
				// component in the meanwhile (e.g. from another's child
				// onBeforeRender)
				if (child.getParent() == this)
				{
					child.beforeRender();
/d
/ volgende	,
			for (final Component child : children)
					child.beforeRender();
child	Man11_4d6$3  (id=4129)	
[DropDownChoice [Component id = d]]

/ 7	. 

/ WICKET ID

/ Waar wordt de id gen ?

Man11_4d6$3(Component).onComponentTag(ComponentTag) line: 3889	
			tag.putInternal(MARKUP_ID_ATTR_NAME, getMarkupId());
/s
Man11_4d6$3(Component).getMarkupId(boolean) line: 1516	
		IMarkupIdGenerator markupIdGenerator = getApplication().getMarkupSettings().getMarkupIdGenerator();
		String markupId = markupIdGenerator.generateMarkupId(this, createIfDoesNotExist);



/ 7	. 


/ Einde DEBUG WICKET MODEL COMPOUND

/ WICKET SERIALIZE

/ 7	. 

/ we maken Man11_4d7	, een kleinere Man11_4d6	,

/ we click op een link	,

	DefaultPageStore(AbstractPageStore).deserializePage(byte[]) line: 150	
		return (IManageablePage) pageSerializer.deserialize(data);

	DefaultPageStore(AbstractCachingPageStore<P>).getPage(String, int) line: 67	
			return deserializePage(data);

	PageStoreManager$SessionEntry.getPage(int) line: 203	
			return getPageStore().getPage(sessionId, id);

	PageStoreManager$PersistentRequestAdapter.getPage(int) line: 357	
				return entry.getPage(id);

	PageStoreManager(AbstractPageManager).getPage(int) line: 82	
		IManageablePage page = getRequestAdapter().getPage(id);

	PageAccessSynchronizer$2(PageManagerDecorator).getPage(int) line: 50	
		return delegate.getPage(id);

	PageAccessSynchronizer$2.getPage(int) line: 246	
					page = super.getPage(pageId);

	DefaultMapperContext.getPageInstance(int) line: 113	
		IManageablePage manageablePage = Session.get().getPageManager().getPage(pageId);

	PageAndComponentProvider(PageProvider).getStoredPage(int) line: 296	
		IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);

	PageAndComponentProvider(PageProvider).resolvePageInstance(Integer, Class<IRequestablePage>, PageParameters, Integer) line: 261	
			page = getStoredPage(pageId);

	PageAndComponentProvider(PageProvider).getPageInstance() line: 166	
			resolvePageInstance(pageId, pageClass, pageParameters, renderCount);

	ListenerInterfaceRequestHandler.getPage() line: 96	
		return pageComponentProvider.getPageInstance();

	ListenerInterfaceRequestHandler.respond(IRequestCycle) line: 157	
		final IRequestablePage page = getPage();

	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 837	
				handler.respond(RequestCycle.this);

	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
			respond(handler);

	RequestCycle.execute(IRequestHandler) line: 265	
			requestHandlerExecutor.execute(handler);

	RequestCycle.processRequest() line: 222	
				execute(handler);

	RequestCycle.processRequestAndDetach() line: 293	
			result = processRequest();

	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
		if (!requestCycle.processRequestAndDetach())

	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
				res = processRequestCycle(requestCycle, webResponse, httpServletRequest,
					httpServletResponse, chain);

	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
		processRequest(request, response, chain);

	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 241	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 208	
	StandardWrapperValve.invoke(Request, Response) line: 220	
	StandardContextValve.invoke(Request, Response) line: 122	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 503	
	StandardHostValve.invoke(Request, Response) line: 170	
	ErrorReportValve.invoke(Request, Response) line: 103	
	AccessLogValve.invoke(Request, Response) line: 950	
	StandardEngineValve.invoke(Request, Response) line: 116	
	CoyoteAdapter.service(Request, Response) line: 421	
	Http11Processor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1070	
	Http11Protocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 611	
	JIoEndpoint$SocketProcessor.run() line: 314	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ we zijn dus in	,
DefaultPageStore(AbstractPageStore).deserializePage(byte[]) line: 152	
		return (IManageablePage) pageSerializer.deserialize(data);
/ data zijn alle bytes	,
/s
JavaSerializer.deserialize(byte[]) line: 104	
			ois = newObjectInputStream(in);
				String applicationName = (String)ois.readObject();
				return ois.readObject();
...
/t
PageStoreManager(AbstractPageManager).getPage(int) line: 85	
		IManageablePage page = getRequestAdapter().getPage(id);
/d
...
/t
ListenerInterfaceRequestHandler.respond(IRequestCycle) line: 184	
		final IRequestablePage page = getPage();
/d
			((Page)page).internalInitialize();
...
/t
		IModel<String>model3=new Model<String>("Link");
		Link link3=new Link<String>("link3",model3) {
			@Override
			public void onClick() {
				Data data=new Data();
				data.setF("New2");
->				((IModel<Data>)getParent().getDefaultModel()).setObject(data);

/ Inderdaad , hier hadden we clicked	,
/ TODO
/s
Man11_4d7(Component).getDefaultModel() line: 1592	

/ Hierna volgt weer render, serialize	,

/ 7	.

/ als we click op een link,	 dan weer	,

	PageAndComponentProvider(PageProvider).resolvePageInstance(Integer, Class<IRequestablePage>, PageParameters, Integer) line: 261	
			page = getStoredPage(pageId);

	PageAndComponentProvider(PageProvider).getPageInstance() line: 166	
			resolvePageInstance(pageId, pageClass, pageParameters, renderCount);

	ListenerInterfaceRequestHandler.getPage() line: 96	
		return pageComponentProvider.getPageInstance();

	ListenerInterfaceRequestHandler.respond(IRequestCycle) line: 157	
		final IRequestablePage page = getPage();

	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 837	
		final IRequestablePage page = getPage();

	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
			respond(handler);

	RequestCycle.execute(IRequestHandler) line: 265	
			requestHandlerExecutor.execute(handler);

	RequestCycle.processRequest() line: 222	
				execute(handler);

	RequestCycle.processRequestAndDetach() line: 293	
			result = processRequest();

	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
		if (!requestCycle.processRequestAndDetach())

	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
				res = processRequestCycle(requestCycle, webResponse, httpServletRequest,
					httpServletResponse, chain);

	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
		processRequest(request, response, chain);

	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 241	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 208	
	StandardWrapperValve.invoke(Request, Response) line: 220	
	StandardContextValve.invoke(Request, Response) line: 122	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 503	
	StandardHostValve.invoke(Request, Response) line: 170	
	ErrorReportValve.invoke(Request, Response) line: 103	
	AccessLogValve.invoke(Request, Response) line: 950	
	StandardEngineValve.invoke(Request, Response) line: 116	
	CoyoteAdapter.service(Request, Response) line: 421	
	Http11Processor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1070	
	Http11Protocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 611	
	JIoEndpoint$SocketProcessor.run() line: 316	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	












/ Einde WICKET SERIALIZE


/ DEBUG WICKET RENDER  

/ Verander deze notes	,
/TODO
/ See BASIC RENDER FUNCTION	,

/ we stop in 	,
Man11_4d3(Component).render() line: 2288	
				internalPrepareForRender(true);
/s
Man11_4d3(Page).internalPrepareForRender(boolean) line: 242	
		super.internalPrepareForRender(setRenderingFlag);
/s
Man11_4d3(Component).internalPrepareForRender(boolean) line: 2207	
		beforeRender();
/s
Man11_4d3(Component).beforeRender() line: 982	
		else
		{
			internalBeforeRender();
/s
Man11_4d3(Component).internalBeforeRender() line: 940	
/ this=Man11_4d3
			onBeforeRender();
/s
Man11_4d3(Page).onBeforeRender() line: 801	
		super.onBeforeRender();
/s
Man11_4d3(Component).onBeforeRender() line: 3868	
		onBeforeRenderChildren();
/s
Man11_4d3(MarkupContainer).onBeforeRenderChildren() line: 1695	
		for (final Component child : children)
			{
				// Get next child
				// Call begin request on the child
				// We need to check whether the child's wasn't removed from the
				// component in the meanwhile (e.g. from another's child
				// onBeforeRender)
				if (child.getParent() == this)
				{
					child.beforeRender();
/s
Man11_4d3$1(Component).beforeRender() line: 982	

/ Hier waren we net ook , maar this =Man11_4d3 	toen	,

		else
		{
			internalBeforeRender();
/s
Man11_4d3$1(Component).internalBeforeRender() line: 949	
			onBeforeRender();
/s
Man11_4d3$1.onBeforeRender() line: 48	

/ onze eigen fct	,
			@Override
			protected void onBeforeRender() {
				super.onBeforeRender();
/s
Man11_4d3$1(Component).onBeforeRender() line: 3868	
		onBeforeRenderChildren();
/ Doet NIETS	,

/ volgende child	,
/ Man11_4d3$2	, 'n TextField	,
			@Override protected void onBeforeRender() {
				super.onBeforeRender();
			}
/s
Man11_4d3$2(AbstractTextComponent<T>).onBeforeRender() line: 142	
	protected void onBeforeRender()
	{
		super.onBeforeRender();
/d
/ WH NIETS
		resolveType();
/s
Man11_4d3$2(AbstractTextComponent<T>).resolveType() line: 152	
			Class<?> type = getModelType(getDefaultModel());
/s
Man11_4d3$2(Component).getDefaultModel() line: 1592	
		IModel<?> model = getModelImpl();
/s
			return (IModel<?>)data_get(0);
/s
			return data;
/t
/s
Man11_4d3$2(AbstractTextComponent<T>).getModelType(IModel<?>) line: 177	
		else
		{
			return null;
/t
Man11_4d3$2(AbstractTextComponent<T>).resolveType() line: 153	
			Class<?> type = getModelType(getDefaultModel());
/d
			setType(type);
/s
	/**
	 * Sets the type that will be used when updating the model for this component. If no type is
	 * specified String type is assumed.
	 * 
	 * @param type
	 * @return this for chaining
	 */
	public FormComponent<T> setType(Class<?> type)
	{
		typeName = type == null ? null : type.getName();
null

\t
Man11_4d3$2(Component).internalBeforeRender() line: 950	
			onBeforeRender();
/d
/ Beide onze eigen onBeforeRender fcts zijn called	, van de label en textfield	,

/t
Man11_4d3(Component).render() line: 2300	
				internalPrepareForRender(true);
/d
			// Do the render
			internalRender();
/s
Man11_4d3(Component).internalRender() line: 2337	
		IMarkupFragment markup = getMarkup();
/s
Man11_4d3(Component).getMarkup() line: 739	

		// No parent, than check associated markup files
		if (parent == null)
/ JA
		{
			// Must be a MarkupContainer to have associated markup file
			if (this instanceof MarkupContainer)
/ JA
			{
				MarkupContainer container = (MarkupContainer)this;
				Markup associatedMarkup = container.getAssociatedMarkup();
/s
/ via Application.get	,
MarkupFactory.getMarkup(MarkupContainer, boolean) line: 194	
		return getMarkup(container, container.getClass(), enforceReload);
/ TODO

/t
				Markup associatedMarkup = container.getAssociatedMarkup();
/ toString():

file:/home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.57/webapps/wicket-book/WEB-INF/classes/my/test/own/wicket_book/Man11_4d3.html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>


<h1 wicket:id="label"></h1>
<input type="text" wicket:id="field">

</body>
</html>

/ In Variables:	

this	Man11_4d3  (id=27200)	
markup	Markup  (id=27227)	
	markupElements	Collections$UnmodifiableRandomAccessList<E>  (id=27228)	
	markupResourceStream	MarkupResourceStream  (id=27229)	
		baseMarkup	null	
		cacheKey	"my.test.own.wicket_book.Man11_4d3_en_US.html" (id=27233)	
		containerInfo	ContainerInfo  (id=27235)	
		doctype	"html" (id=27237)	
		encoding	null	
		markupClassName	"my.test.own.wicket_book.Man11_4d3" (id=27240)	

		resourceStream	UrlResourceStream  (id=27242)	
file:/home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.57/webapps/wicket-book/WEB-INF/classes/my/test/own/wicket_book/Man11_4d3.html

		wicketId	"wicket:id" (id=27244)	
		wicketNamespace	"wicket" (id=27246)	

/t
Man11_4d3(Component).internalRender() line: 2344	
/ Dit is de fct na internalPrepareForRender(true) in de basis fct render	,

		IMarkupFragment markup = getMarkup();
/d
		MarkupElement elem = markup.get(0);
<!DOCTYPE html>
<html>
		if (elem instanceof ComponentTag)
				onRender();
/s
Man11_4d3(WebPage).onRender() line: 136	
		configureResponse((WebResponse)RequestCycle.get().getResponse());
/s
Man11_4d3(WebPage).configureResponse(WebResponse) line: 167	
			contentType = getMarkupType().getMimeType() + "; charset=" + encoding;
contentType	"text/html; charset=UTF-8" (id=27265)	
		response.setContentType(contentType);

/t
Man11_4d3(WebPage).onRender() line: 142	
		// Configure the response such as headers etc.
		configureResponse((WebResponse)RequestCycle.get().getResponse());
/d
		// The rules if and when to insert an xml decl in the response are a bit tricky. Allow the
		// user to replace the default per page and per application.
		renderXmlDecl();
/ TODO

		super.onRender();
/s
Man11_4d3(Page).onRender() line: 879	
		// Loop through the markup in this container
		MarkupStream markupStream = new MarkupStream(getMarkup());
		renderAll(markupStream, null);
/s
Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1588	
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
0
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/s
Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1379	
		// Get the current markup element
		final MarkupElement element = markupStream.get();
<!DOCTYPE html>
<html>
		// If it's a tag like <wicket..> or <span wicket:id="..." >
		if ((element instanceof ComponentTag) && !markupStream.atCloseTag())
/ NEE
		else
		{
			// Render as raw markup
			getResponse().write(element.toCharSequence());

/t
Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1605	
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/d
			markupStream.setCurrentIndex(index);

			if (rawMarkup)
			{
				markupStream.next();

/ volgende	,
		while (markupStream.hasMore())
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
1
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/s
Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1376	
		// Get the current markup element
		final MarkupElement element = markupStream.get();
<head>
		// If it's a tag like <wicket..> or <span wicket:id="..." >
		if ((element instanceof ComponentTag) && !markupStream.atCloseTag())
/ JA
				component = ComponentResolvers.resolve(this, markupStream, tag, null);
[HtmlHeaderContainer [Component id = _header_0]]
				if ((component != null) && (component.getParent() == null))
				{
					autoAdd(component, markupStream);
/s
Man11_4d3(MarkupContainer).autoAdd(Component, MarkupStream) line: 249	
			component.setMarkup(markupStream.getMarkupFragment());
/ component=[HtmlHeaderContainer [Component id = _header_0]]
/ markupStream.getMarkupFragment()=
file:/home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.57/webapps/wicket-book/WEB-INF/classes/my/test/own/wicket_book/Man11_4d3.html
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>

		add(component);
/s
Man11_4d3(MarkupContainer).add(Component...) line: 134	
			// Add to map
			if (put(child) != null)
/ TODO

/t
Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1405	
				component.setMarkup(markupStream.getMarkupFragment());
/d
				component.render();
/ component=[HtmlHeaderContainer [Component id = _header_0]]
...
/ TODO

/t
Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1605	
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/d
			markupStream.setCurrentIndex(index);
1

			if (rawMarkup)
/ NEE
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();

/ volgende,	
		while (markupStream.hasMore())
		{
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
4
			boolean rawMarkup = renderNext(markupStream);
/s
Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1376	
		final MarkupElement element = markupStream.get();
element	RawMarkup  (id=27329)	
<body>

		// If it's a tag like <wicket..> or <span wicket:id="..." >
		if ((element instanceof ComponentTag) && !markupStream.atCloseTag())
/ NEE
		else
		{
			// Render as raw markup
			getResponse().write(element.toCharSequence());

/t
Man11_4d3(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1588	
			boolean rawMarkup = renderNext(markupStream);
/d
			markupStream.setCurrentIndex(index);
4
			if (rawMarkup)
/ JA
				markupStream.next();

/ volgende	,
		while (markupStream.hasMore())
			final int index = markupStream.getCurrentIndex();
5
			boolean rawMarkup = renderNext(markupStream);
/s
Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1376	
		final MarkupElement element = markupStream.get();
element	ComponentTag  (id=27331)	
<h1 wicket:id="label">

			// Get component id
			final String id = tag.getId();
/ "label"
			// Get the component for the id from the given container
			Component component = get(id);
component	Man11_4d3$1  (id=27213)	
[Component id = label]

				component.render();
/s
Man11_4d3$1(Component).render() line: 2288	
			// Invoke prepareForRender only if this is the root component to be rendered
			MarkupContainer parent = getParent();
parent	Man11_4d3  (id=27200)	
[Page class = my.test.own.wicket_book.Man11_4d3, id = 0, render count = 1]
			if ((parent == null) || (parent.getFlag(FLAG_RENDERING) == false) || isAuto())
/ NEE

			// Do the render
			internalRender();
/s
Man11_4d3$1(Component).internalRender() line: 2337	
		// Make sure there is a markup available for the Component
		IMarkupFragment markup = getMarkup();
markup	MarkupFragment  (id=27346)	
file:/home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.57/webapps/wicket-book/WEB-INF/classes/my/test/own/wicket_book/Man11_4d3.html
<h1 wicket:id="label"></h1>

				onRender();
/s
Man11_4d3$1.onRender() line: 51	
			@Override protected void onRender() {
				super.onRender();
/ onze eigen fct

//////////////////////////////////////////
/ render label	,

/s
Man11_4d3$1(WebComponent).onRender() line: 56	
		internalRenderComponent();
/s
///////////////////////////////////////////////
/ BASIC RENDER FUNCTION 
/ wordt called vrijwel direct na eigen @Override protected void onRender	,
///////////////////////////////////////////////
	/**
	 * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.
	 * <p>
	 * Renders the component at the current position in the given markup stream. The method
	 * onComponentTag() is called to allow the component to mutate the start tag. The method
	 * onComponentTagBody() is then called to permit the component to render its body.
	 */
Man11_4d3$1(Component).internalRenderComponent() line: 2500	

		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
<h1 wicket:id="label">
		final ComponentTag tag = openTag.mutable();

		// Call any tag handler
		onComponentTag(tag);
////////////////////////////////////////////////////////////
/ Link, Button , hebben elk eigen onComponentTag fct	,



/s
Man11_4d3$1(Label).onComponentTag(ComponentTag) line: 124	
		super.onComponentTag(tag);
/s
/////////////////////////////////////////////
/ berekent id uit wicket:id	,
//////////////////////////////////////////
Man11_4d3$1(Component).onComponentTag(ComponentTag) line: 3889	
			tag.putInternal(MARKUP_ID_ATTR_NAME, getMarkupId());
/s
		return getMarkupId(true);
/s
Man11_4d3$1(Component).getMarkupId(boolean) line: 1518	
		IMarkupIdGenerator markupIdGenerator = getApplication().getMarkupSettings().getMarkupIdGenerator();
		String markupId = markupIdGenerator.generateMarkupId(this, createIfDoesNotExist);
		return markupId;
/ "label1"

/t
Man11_4d3$1(Component).onComponentTag(ComponentTag) line: 3892	
			tag.putInternal(MARKUP_ID_ATTR_NAME, getMarkupId());
/d

///////////////////////////////////////////
/ label: calls model for render	,
 
Man11_4d3$1(Component).internalRenderComponent() line: 2531	
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
...
/s
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());
///////////////////////////////////

/t
Man11_4d3$1(Component).internalRenderComponent() line: 2531	
		onComponentTag(tag);
/d
			// Render open tag
			if (getRenderBodyOnly())
/ NEE
			else
			{
				renderComponentTag(tag);
/ Doet NIETS in dit geval	,
			markupStream.next();

			// Render the body only if open-body-close. Do not render if open-close.
			if (tag.isOpen())
			{
				// Render the body. The default strategy will simply call the component's
				// onComponentTagBody() implementation.
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/s
DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
		component.onComponentTagBody(markupStream, openTag);
/s
Man11_4d3$1(Label).onComponentTagBody(MarkupStream, ComponentTag) line: 115	
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());
/s
Man11_4d3$1(Component).getDefaultModelObjectAsString() line: 1646	
		return getDefaultModelObjectAsString(getDefaultModelObject());
/s
Man11_4d3$1(Component).getDefaultModelObject() line: 1618	
		final IModel<?> model = getDefaultModel();
/s
		IModel<?> model = getModelImpl();
/s
			return (IModel<?>)data_get(0);

/t
Man11_4d3$1(Component).getDefaultModelObjectAsString(Object) line: 1666	
/=
	public final String getDefaultModelObjectAsString(final Object modelObject)
modelObject	"Initial Label" (id=25788)	

			final Class<?> objectClass = modelObject.getClass();

			final IConverter converter = getConverter(objectClass);
/s
Man11_4d3$1(Component).getConverter(Class<C>) line: 1366	
		return getApplication().getConverterLocator().getConverter(type);

[null,
 null,
 null,
 java.util.Calendar=org.apache.wicket.util.convert.converter.CalendarConverter@63904e12,
 null,
 java.lang.Boolean=org.apache.wicket.util.convert.converter.BooleanConverter@16f5b2cf,
 int=org.apache.wicket.util.convert.converter.IntegerConverter@5cae3fcf,
 null,
 java.sql.Timestamp=org.apache.wicket.util.convert.converter.SqlTimestampConverter@33df5e92,
 java.lang.Integer=org.apache.wicket.util.convert.converter.IntegerConverter@5cae3fcf,
 null,
 java.util.Date=org.apache.wicket.util.convert.converter.DateConverter@db9ddd9,
 long=org.apache.wicket.util.convert.converter.LongConverter@2593d899,
 float=org.apache.wicket.util.convert.converter.FloatConverter@d713815,
 null,
 null,
 short=org.apache.wicket.util.convert.converter.ShortConverter@418f198,
 null,
 java.sql.Date=org.apache.wicket.util.convert.converter.SqlDateConverter@19d3442,
 java.math.BigInteger=org.apache.wicket.util.convert.converter.BigIntegerConverter@77d1d9e1,
 java.lang.Double=org.apache.wicket.util.convert.converter.DoubleConverter@7237803b,
 byte=org.apache.wicket.util.convert.converter.ByteConverter@19c3dc12,
 null,
 null,
 java.lang.Character=org.apache.wicket.util.convert.converter.CharacterConverter@9a52ef5,
 java.sql.Time=org.apache.wicket.util.convert.converter.SqlTimeConverter@3baddbc5,
 boolean=org.apache.wicket.util.convert.converter.BooleanConverter@16f5b2cf,
 java.lang.Byte=org.apache.wicket.util.convert.converter.ByteConverter@19c3dc12,
 null,
 null,
 null,
 null]

		if (converter == null)
/ JA, voor String	,
		{
			return new DefaultConverter<C>(type);

/t
Man11_4d3$1(Label).onComponentTagBody(MarkupStream, ComponentTag) line: 115	
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());
/s
Man11_4d3$1(Component).replaceComponentTagBody(MarkupStream, ComponentTag, CharSequence) line: 4046	
		if (tag.isOpen())
/ JA
		{
			// Get what tag was in the markup; not what the user it might
			// have changed it to.
			markupOpenTag = markupStream.getPreviousTag();
<h1 wicket:id="label">

			// If it was an open tag in the markup as well, than ...
			if (markupOpenTag.isOpen())
/ JA
			{
				// skip any raw markup in the body
				markupStream.skipRawMarkup();


		if (body != null)
		{
			// Write the new body
			getResponse().write(body);
body	"Initial Label" (id=27467)	

/t
Man11_4d3$1(Component).internalRenderComponent() line: 2562	
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/d
				// Render close tag
				if (openTag.isOpen())
				{
					renderClosingComponentTag(markupStream, tag, getRenderBodyOnly());
/ tag=<h1 wicket:id="label" id="label1">

/t
			@Override protected void onRender() {
				super.onRender();
/ d
/ onze fct	,

/ volgende	,

////////////////////////////////////////////
/ render textfield 	,

	field=new TextField<String>("field"){
			@Override protected void onRender() {
				super.onRender();
/s
Man11_4d3$2(MarkupContainer).onRender() line: 1540	
		internalRenderComponent();
/s
Man11_4d3$2(Component).internalRenderComponent() line: 2506	
		final IMarkupFragment markup = getMarkup();
<input type="text" wicket:id="field">

		onComponentTag(tag);

//////////////////////
/ Hoe label	?

/s
Man11_4d3$2(TextField<T>).onComponentTag(ComponentTag) line: 108	
		tag.put("value", getValue());
/s
Man11_4d3$2(FormComponent<T>).getValue() line: 877	
		if (NO_RAW_INPUT.equals(rawInput))
		{
			return getModelValue();
/s
Man11_4d3$2(FormComponent<T>).getModelValue() line: 1293	
		return getDefaultModelObjectAsString();
/s
Man11_4d3$2(Component).getDefaultModelObjectAsString() line: 1646	
		return getDefaultModelObjectAsString(getDefaultModelObject());
/s
Man11_4d3$2(Component).getDefaultModelObjectAsString(Object) line: 1666	
/=
	public final String getDefaultModelObjectAsString(final Object modelObject)
modelObject	"Initial Field" (id=25831)	

/t
Man11_4d3$2(TextField<T>).onComponentTag(ComponentTag) line: 108	
		tag.put("value", getValue());
/d

/t
Man11_4d3$2(Component).internalRenderComponent() line: 2548	
		onComponentTag(tag);
/d
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
///////////////////////////
/ Deze doet NIETS voor textfield	,

/ 7	. 

/ We click de link	, met model update	,

/s
Man11_4d3$3(Link<T>).onLinkClicked() line: 190	
		onClick();
/s
Man11_4d3$3.onClick() line: 76	
/ onze fct	,
				model2.setObject("New Field");
/s
Model<T>.setObject(T) line: 192	
...
/ we komen in 	,
/ TODO
Man11_4d3(Page).renderPage() line: 1018	
/=
	public final void render()
	{
				internalPrepareForRender(true);
/ Calls onze onBeforeRender's	,
			// Do the render
			internalRender();
/s


/ label	,
	Model<T>.getObject() line: 178	
	Model<T>.getObject() line: 46	
	Man11_4d3$1(Component).getDefaultModelObject() line: 1618	
	Man11_4d3$1(Component).getDefaultModelObjectAsString() line: 1646	
	Man11_4d3$1(Label).onComponentTagBody(MarkupStream, ComponentTag) line: 115	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Man11_4d3$1(Component).internalRenderComponent() line: 2557	
	Man11_4d3$1(WebComponent).onRender() line: 56	
	Man11_4d3$1.onRender() line: 51	
	Man11_4d3$1(Component).internalRender() line: 2372	
	Man11_4d3$1(Component).render() line: 2300	
	Man11_4d3(MarkupContainer).renderNext(MarkupStream) line: 1405	




/ Einde DEBUG WICKET RENDER  

/ WICKET FORMS

/ Lees	,
http://wicket.apache.org/guide/guide/modelsforms.html
/ over transient model & jpa	, bij	,
  public JpaLoadableModel(EntityManagerFactory entityManagerFactory, T entity) {

/ en 	,
http://stackoverflow.com/questions/5395603/wicket-changing-the-text-of-an-ajaxbutton-on-submit


/ Einde WICKET FORMS

/ WICKET COMPONENTS

/ In Man11_4c.java

			IModel<Data>model=new Model<Data>();
			ddc=new DropDownChoice<Data>("ddc",model,	list,renderer);
/ OK

/ In Man11_4d.java

			IModel<Data>model=new Model<Data>(new Data());
			setModel(model);

			IModel<String>model2=new PropertyModel<String>(model, "n");

/ In Man11_4d moeten we new Data() doen in 
			IModel<Data>model=new Model<Data>(new Data());
/ In Man11_4c hoeft dat NIET	,
/ TODO


/ Einde WICKET COMPONENTS

/ WICKET REST

/ Lees	,
http://wicket.apache.org/guide/guide/wicketstuff.html
27.6 Module wicketstuff-rest-annotations

/ Lees	,
http://stackoverflow.com/questions/18235950/use-wicket-as-a-rest-api
/ @MountPath is iets van Wicket	,




/ Einde WICKET REST

/ WICKET AJAX

/ 7	.

/ in project wicket-book	,

$ vi Ch1_3_2.java

		Link<Void>link2=new AjaxFallbackLink<Void>("link2") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				counter2++;
				if(target!=null){
					target.add(label2);
					target.add(label3);
				}
				
			}
		};
		add(link2);

		IModel<Integer>model2=new PropertyModel<Integer>(this, "counter2");
		
		label2=new Label("label2",model2);
		label2.setOutputMarkupId(true);
		add(label2);
		
		label3=new Label("label3",model2);
		label3.setOutputMarkupId(true);
		add(label3);

		AjaxLink<Void>link3=new AjaxLink<Void>("link3") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				counter2++;
				if(target!=null){
					target.add(label2);
					target.add(label3);
				}
				
			}
		};
		add(link3);

$ vi Ch1_3_2.html

	<a href="#" wicket:id="link2">lnk2</a>
	<h1 wicket:id="label2"></h1>
	<h1 wicket:id="label3"></h1>
	<a href="#" wicket:id="link3">lnk3</a>


/ als we click op lnk2 of op lnk3	, dan worden EN label2 EN label3 update	,

/ Let op dat we bij components die AJAX notified moeten	,
		label2.setOutputMarkupId(true);
/ want id wordt key in tbl	,
/ TODO



/ 7	.

/ Einde WICKET AJAX

/ WICKET FORMS

/ 7	. 

/ See project wicket-book	, 

$ vi Man11_3.java 

	public Man11_3(final PageParameters parameters) {
		super(parameters);

		Form<Void>form=new MyForm<Void>("form");
		add(form);
    	}	 
	private class MyForm<T > extends Form<T>{
		public MyForm(String id) {
			super(id);
		}
		@Override
		protected void onSubmit() {
			logger.info("...");
		}
	}
}
$ vi Man11_3.java 

<form wicket:id="form">
	<input type="submit" value="Go">
</form>

/ We hoeven in wicket's From GEEN submit field te def	, de onSubmit werkt al	, 
/ ook heeft deze <input> geen wicket:id	,

/ OK

/ 7	.

/ we add een FormComponent	,

$ vi Man11_3.java 

	public Man11_3(final PageParameters parameters) {
		super(parameters);

		Form<Void>form=new MyForm<>("form");
		add(form);

    } 
	

	
	
	private class MyForm<T  > extends Form<T>{
		private FormComponent<String>text;
		public MyForm(String id) {
			super(id);
			IModel<String>model=Model.of("");
			text=new TextField<String>("text",model);
			add(text);
		}
		@Override
		protected void onSubmit() {
			String s=text.getModelObject();
			logger.info("\n"+s+"\n");
		}
	}

$ vi Man11_3.java 

<form wicket:id="form">
	<input type="text" wicket:id="text">
	<input type="submit" value="Go">
</form>

/ we zien in chrome een text field en een button	,
/ OK

/ 7	.

/ See Man11_3b.java

/ We hebben Man11_3.java, Man11_3b.java	,
/ Man11_3a.java TODO

/ form heeft model, een CompoundPropertyModel	,

$ vi Man11_3b.java

	public Man11_3b(final PageParameters parameters) {
		super(parameters);

		Form<D>form=new MyForm2<>("form");
		add(form);
		
		
    	} 

	private class D implements Serializable{
		private String n;
		

		public String getN() {
			return n;
		}

		public void setN(String n) {
			this.n = n;
		}
	}

	private class MyForm2<T extends D> extends Form<D>{
		
		public MyForm2(String id) {
			super(id,new CompoundPropertyModel<D>(new D()));
			add(new TextField<T>("n"));
		}
		@Override
		protected void onSubmit() {
			D d=getModelObject();
			String n=d.getN();logger.info(n);
		}
	}

$ vi Man11_3b.html

<form wicket:id="form">
	<input type="text" wicket:id="n">
	<input type="submit" value="Go">
</form>

/ We kunnen ipv
		public MyForm2(String id) {
			super(id,new CompoundPropertyModel<D>(new D()));
/ ook	,
		public MyForm3(String id) {
			super(id);
			setModel(new CompoundPropertyModel<D>(new D()));

/ Dat kan beter zijn, als je wilt	,
			super(id);
			D d=new D();
			IModel<D>m=new CompoundPropertyModel<D>(d);
			setModel(m);


/ 7	.

/ in project wicket-book	,

$ vi Man11_3c.java

	public Man11_3c(final PageParameters parameters) {
		super(parameters);

		Form<Void>form=new MyForm<>("form");
		add(form);
		label=new Label("label",new Model<String>(""));
		add(label);

    } 
	private FormComponent<String>text;
	private Label label;
	private class MyBtn extends Button{
		public MyBtn(String id) {
			super(id);
		}
		@Override
		public void onSubmit() {
			String value=text.getModelObject();
			label.setDefaultModelObject(value);
			text.setModelObject("");
		}
	}
	private class MyForm<Void> extends Form<Void>{
		
		public MyForm(String id) {
			super(id);
			IModel<String>mt=Model.of("");
			text=new TextField<String>("text",mt);
			add(text);
			FormComponent<String>btn=new MyBtn("btn");
			add(btn);
		}
		@Override
		protected void onSubmit() {
			logger.info("\n**************************************\n");
			String s=label.getDefaultModelObjectAsString();
			logger.info("\n"+s+"\n");
			logger.info("\n**************************************\n");
		}
	}

$ vi Man11_3c.html

<form wicket:id="form">
	<input type="text" wicket:id="text">
	<input type="submit" wicket:id="btn" value="Go">
</form>
<h1 wicket:id="label"></h1>

/ we hebben nu op <input type="submit"> een wicket:id	,

/ de fct onSubmit van het form wordt ook called	, dus die van de btn en van het form worden beide called	,

/ 7	. 

/ ajax button op het form	,

/ we moeten zorgen dat de component c die we door AJAX willen veranderen	, 
/ 13	 c.setOutputMarkup(true)
/ 13	.addTarget(c) in onSubmit()	,

$ vi Man11_3d.java

	public Man11_3d(final PageParameters parameters) {
		super(parameters);

		Form<Void>form=new MyForm<>("form");
		add(form);
		label=new Label("label",new Model<String>(""));
		label.setOutputMarkupId(true);					// !
		add(label);

    } 
	
	private FormComponent<String>text;
	private Label label;
	private class MyBtn extends AjaxButton{
		public MyBtn(String id) {
			super(id);
		}
		@Override
		protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
			String value=text.getModelObject();
			label.setDefaultModelObject(value);
			text.setModelObject("");
			if(target!=null){
				target.add(label);
				target.add(text);				// !  * 
			}
		}
		
	}

	private class MyForm<Void> extends Form<Void>{
		
		public MyForm(String id) {
			super(id);
			IModel<String>mt=Model.of("");
			text=new TextField<String>("text",mt);
			text.setOutputMarkupId(true);				// !
			add(text);
			FormComponent<String>btn=new MyBtn("btn");
			add(btn);
		}
	}

$ vi Man3_11d.html

<form wicket:id="form">
	<input type="text" wicket:id="text">
	<input type="submit" wicket:id="btn" value="Go">
</form>
<h1 wicket:id="label"></h1>

/ is onveranderd	,

/ 7	. 

/ dropdownchoice	,

/ we hebben Man11_4, Man11_4b	,
/ de ddc hebben zelf ook een model
/ OK


$ vi Man11_4.java

	public Man11_4b(final PageParameters parameters) {
		super(parameters);

		Form<Void>form=new MyForm<>("form");
		add(form);
		label=new Label("label",new Model<String>(""));
		label.setOutputMarkupId(true);
		add(label);
	} 

	private class D{
		private String n;
		
		public D(String n){
			setN(n);
		}
		public D() {
		}

		public String getN() {
			return n;
		}

		public void setN(String n) {
			this.n = n;
		}
	}
/ alleen nodig als ddc een propertymodel hieronder	,


	private FormComponent<String>ddc;
	private Label label;
	
	private class MyForm<Void> extends Form<Void>{
		private FormComponent<String>text;
		public MyForm(String id) {
			super(id);
			
			List<String>list=Arrays.asList("Foo Bar","Eric J.","Gee Hee");

			IModel<String>model=new PropertyModel<String>(new D(), "n");
/ of	,
			IModel<String>model=new Model<String>();

			ddc=new DropDownChoice<String>("ddc",model,	list);
			ddc.setOutputMarkupId(true);
			add(ddc);
			FormComponent<String>btn=new MyBtn("btn");
			add(btn);
		}
		
	}
 
	private class MyBtn extends AjaxButton{
		public MyBtn(String id) {
			super(id);
		}
		@Override
		protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
			String value=ddc.getModelObject();
			label.setDefaultModelObject(value);
			if(target!=null){
				target.add(label);
				target.add(ddc);
			}
		}
		
	}

/ OK

/ 7	. 

/ project wicket-book

$ vi Man11_4c.java

			List<Data>list=Arrays.asList(new Data("Foo Bar"),new Data("Eric J."),new Data("Gee Hee"));
			IModel<Data>model=new Model<Data>();
			ddc=new DropDownChoice<Data>("ddc",model,	list);
			ddc.setOutputMarkupId(true);
			add(ddc);

/ we doen dus new Model<Data>()	, 
/ als we een Data inst kiezen en Go click, dan wordt deze model.setObject called met de gekozen Data inst, bijv new Data("Foo Bar")	,

/ In Man11_4b.java

			List<String>list=Arrays.asList("Foo Bar","Eric J.","Gee Hee");
			IModel<String>model=new PropertyModel<String>(new D(), "n");
			ddc=new DropDownChoice<String>("ddc",model,	list);

/ Hier zien we dat de gekozen string bijv "Foo Bar" wordt set in model's target	, dat is de new D()	, 

/ 7	. 

$ vi Main11_4c.java

			List<Data>list=Arrays.asList(new Data("Foo Bar"),new Data("Eric J."),new Data("Gee Hee"));
			IModel<Data>model=new Model<Data>();
			ddc=new DropDownChoice<Data>("ddc",model,	list);
			ddc.setOutputMarkupId(true);
			add(ddc);

/ we zien op de select in de browser NIET "Foo Bar"	, ...	, maar my.test.own.wicket_book.Man11_4c$Data@43cbf461	,

<select wicket:id="ddc" name="ddc" id="ddc3">
<option selected="selected" value="0">my.test.own.wicket_book.Man11_4c$Data@43cbf461</option>
<option value="1">my.test.own.wicket_book.Man11_4c$Data@3192f0d</option>
<option value="2">my.test.own.wicket_book.Man11_4c$Data@44a492a6</option>
</select>

/ De values zijn wel OK	,

/ Maar makkelijk te repareren	,

			List<Data>list=Arrays.asList(new Data("Foo Bar"),new Data("Eric J."),new Data("Gee Hee"));
			IModel<Data>model=new Model<Data>();
			ChoiceRenderer<Data>renderer=new ChoiceRenderer<Data>("n");
			ddc=new DropDownChoice<Data>("ddc",model,	list,renderer);

/ Ipv de index kunnen we WH ook een ander prop geven	, als Data deze zou hebben	, Data moet dan een String/int prop "id" hebben (TODO) 
			ChoiceRenderer<Data>renderer=new ChoiceRenderer<Data>("n","id");

/ 7	.

/ In Man11_4a2 hebben we een dropdownlist zonder eigen model, maar de model=compoundpropertymodel is in Main11_4a2 	,
/ We hebben geen ddc	, maar Man11_4a2 is de model	,

$ vi Man11_4a2.java

	public Man11_4a2(final PageParameters parameters) {
		super(parameters);

		Form<Man11_4a2>form=new MyForm<Void>("form");
		add(form);
		label=new Label("label",new Model<String>(""));
		label.setOutputMarkupId(true);
		add(label);


    } 
	

	private String n;
	
	public String getN() {
		return n;
	}

	public void setN(String n) {
		this.n = n;
	}
	
	private String m;
	
	public String getM() {
		return m;
	}

	public void setM(String m) {
		this.m = m;
	}


	

	private FormComponent<String>c_m;
	private Label label;
	private FormComponent<String>c_n;

	private class MyForm<Void> extends Form<Man11_4a2>{
		
		public MyForm(String id) {
			super(id);
			IModel<Man11_4a2>model=new CompoundPropertyModel<>(Man11_4a2.this);
			setModel(model);
			
			c_n=new TextField<String>("n");
			c_n.setOutputMarkupId(true);
			add(c_n);
			
			List<String>list=Arrays.asList("Foo Bar","Eric J.","Gee Hee");
			c_m=new DropDownChoice<String>("m",list);
			c_m.setOutputMarkupId(true);
			add(c_m);
			
			FormComponent<String>btn=new MyBtn("btn");
			add(btn);
		}
		
	}
	

	private class MyBtn extends AjaxButton{
		public MyBtn(String id) {
			super(id);
		}
		@Override
		protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
			String n=c_n.getModelObject();
			String m=c_m.getModelObject();
...

		}
		
	}

$ vi Man11_4a2.html

<form wicket:id="form">
	<input type="text" wicket:id="n">
	<select wicket:id="m"></select>
	<input type="submit" wicket:id="btn" value="Go">
</form>
<h1 wicket:id="label"></h1>

/ OK	,

/ 7	.

/ Maar we kunnen ook makkelijk een apart object Data create	, met de properties	, en daar het compoundpropertymodel op zetten	,

$ vi Man11_4b3.java

	public Man11_4a3(final PageParameters parameters) {
		super(parameters);

		Form<Data>form=new MyForm<Void>("form");
		add(form);
		label=new Label("label",new Model<String>(""));
		label.setOutputMarkupId(true);
		add(label);


    } 
	

	private class Data{
		private String n;
		
		public String getN() {
			return n;
		}
		
		public void setN(String n) {
			this.n = n;
		}
		
		private String m;
		
		public String getM() {
			return m;
		}
		
		public void setM(String m) {
			this.m = m;
		}
	}


	

	private FormComponent<String>c_m;
	private Label label;
	private FormComponent<String>c_n;

	private class MyForm<Void> extends Form<Data>{
		
		public MyForm(String id) {
			super(id);
			IModel<Data>model=new CompoundPropertyModel<>(new Data());
			setModel(model);
			
			c_n=new TextField<String>("n");
			c_n.setOutputMarkupId(true);
			add(c_n);
			
			List<String>list=Arrays.asList("Foo Bar","Eric J.","Gee Hee");
			c_m=new DropDownChoice<String>("m",list);
			c_m.setOutputMarkupId(true);
			add(c_m);
			
			FormComponent<String>btn=new MyBtn("btn");
			add(btn);
		}
		
	}
	

	private class MyBtn extends AjaxButton{
		public MyBtn(String id) {
			super(id);
		}
		@Override
		protected void onSubmit(AjaxRequestTarget target, Form<?> form) {
			String n=c_n.getModelObject();
			String m=c_m.getModelObject();
...
		}
		
	}

$ vi Man11_4a2.html

<form wicket:id="form">
	<input type="text" wicket:id="n">
	<select wicket:id="m"></select>
	<input type="submit" wicket:id="btn" value="Go">
</form>
<h1 wicket:id="label"></h1>

/ deze html is onveranderd	,

/ OK	,

/ Einde WICKET FORMS

/ WICKET MODELS

/ 7	.

$ vi Ch5_6_2.java

	private String n;
	private IModel<String>model;
	private Label label;
	public Ch5_6_2(final PageParameters parameters) {
		super(parameters);
		
		model=new Model<String>(n);
		label=new Label("label",model);
		label.setOutputMarkupId(true);
		add(label);
		Link<String>link=new Link<String>("link") {
			@Override
			public void onClick() {

				model.setObject("Foo Bar");
/ of	,
				label.setDefaultModelObject("Foo Bar");
				
			}
		};
		add(link);

    } 

$ vi Ch5_6_2.html

	<h1 wicket:id="label"></h1>
	<a href="#"	wicket:id="link">lnk</a>

/ 7	.

/ we zagen	,
			IModel<String>model=new Model<String>();
			ddc=new DropDownChoice<String>("ddc",model,	list);

/ als we Go click wordt model.setObject called, dus wordt view->model 	,

/ 7	. 

/ Als model er niet was	, was van een label string een directe child, en moet bijv de label een db query call	, 
/ nu doet model dat, en label weet van niets	,


/ Einde WICKET MODELS

/ WICKET MODAL WINDOW

/ project wicket-book, file Man18_2	,

/ 7	. 

/ ipv 	
	add(label)
/ doen we	,
	window.setContent(label)

/ window.getContentId()=="content"
//////////////////////////////////////////////////////////
/ als we een component in het modal window willen, moeten we altijd de component id="content" geven	, 
/ maar in HTML schrijven we nooit wicket:id="content" ergens in de <div wicket:id="window">	,

/ we zien het verschil tussen de HTML van een fragment en van een panel: <wicket:fragment wicket:id="..."> heeft een wicket:id	, <wicket:panel> heeft geen wicket:id	, daarom heeft Fragment.<init> een 2de arg dat deze id is	,

/ als we het modal window visible maken verdwijnt wat bij /* staat	,

/ we zien in src code van Component 	,

       /**
         * This is useful, for example, in ajax situations where the component starts out invisible and
         * then becomes visible through an ajax update. With a placeholder tag already in the markup you
         * do not need to repaint this component's parent, instead you can repaint the component
         * directly.
/ TODO
         */
        public final Component setOutputMarkupPlaceholderTag(final boolean outputTag)


/ 7	.

ModalWindow.setContent  calls	,
	omponent.setOutputMarkupPlaceholderTag(true);
/ Dus op de label, myFragment en de myPanel worden deze method called	,
/ we zien in HTML als de modal window niet zichtbaar	,

<div wicket:id="window" id="window16" style="display:none">
	<wicket:panel xmlns:wicket="http://wicket.apache.org">
		<div wicket:id="content" id="content17">I am a modal window</div>		/*
	</wicket:panel>
</div>
<div wicket:id="window2" id="window218" style="display:none">
	<wicket:panel xmlns:wicket="http://wicket.apache.org">
		<div wicket:id="content" id="content19">					/*
			<h3 wicket:id="deedee">That's all you can say!</h3>
		</div>
	</wicket:panel>
</div>
<div wicket:id="window3" id="window31a" style="display:none">
	<wicket:panel xmlns:wicket="http://wicket.apache.org">
		<div id="content1b" style="display:none"></div>					/*
	</wicket:panel>
</div>


$ vi Man18_2.java

		final ModalWindow window=new ModalWindow("window");
		add(window);
		
		Label label=new Label(window.getContentId(),new Model<String>("I am a modal window"));
		window.setContent(label);
		
		window.setTitle("Foo Bar");
		
		AjaxLink<Void>link=new AjaxLink<Void>("link") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				window.show(target);
				
			}
		};
		add(link);
		
		//////////////////////////////////////////////////////
		
		final ModalWindow window2=new ModalWindow("window2");
		add(window2);

		Fragment fragment2=new MyFragment(window2.getContentId(), this);
		window2.setContent(fragment2);
		window2.setTitle("Gee Hee");
		
		AjaxLink<Void>link2=new AjaxLink<Void>("link2") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				window2.show(target);
				
			}
		};
		add(link2);
		
		//////////////////////////////////////////////////////
		
		final ModalWindow window3=new ModalWindow("window3");
		add(window3);

		Panel panel3=new MyPanel(window3.getContentId());
		window3.setContent(panel3);
		window3.setTitle("Eric J.");
		
		AjaxLink<Void>link3=new AjaxLink<Void>("link3") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				window3.show(target);
				
			}
		};
		add(link3);

$ vi Man18_2.html

		<div wicket:id="window"></div>
		<a href="#" wicket:id="link">link</a>
		
		<div wicket:id="window2"></div>
		<a href="#" wicket:id="link2">link</a>
		
		<wicket:fragment wicket:id="myfragment">
			<h3 wicket:id="dexter">This text will be overwritten</h3>
			<h3 wicket:id="deedee">This text will be overwritten</h3>
		</wicket:fragment>
	
		<div wicket:id="window3"></div>
		<a href="#" wicket:id="link3">link</a>

$ vi MyFragment.java

public class MyFragment extends Fragment{
	public MyFragment(String id,WebPage page) {
		super(id,"myfragment",page);
		Label label=new Label("dexter", "Omelette du fromage");
		add(label);
		Label label2=new Label("deedee","That's all you can say!");
		add(label2);

	}

$ vi MyFragment.html
/ Is er niet	, de HTML staat in Man18_2.html

$ vi MyPanel.java

public class MyPanel extends Panel{
	public MyPanel(String id) {
		super(id);
		Label label=new Label("dexter", "Omelette du fromage");
		add(label);
		Label label2=new Label("deedee","That's all you can say!");
		add(label2);

	}

$ vi MyPanel.html

	<wicket:panel>
		<h3 wicket:id="dexter">This text will be overwritten</h3>
		<h3 wicket:id="deedee">This text will be overwritten</h3>
	</wicket:panel>

/ 13	. 

/ we zien dat we voor het label geen HTML hoeven te geven	, en voor het fragment en panel wel	,
/ TODO

/ we zien dat voor het label is generate	, bij ->	,

<div wicket:id="window" id="window4" style="display:none">
	<wicket:panel xmlns:wicket="http://wicket.apache.org">
->		<div wicket:id="content" id="content5">I am a modal window</div>
	</wicket:panel>
</div>

/ bij het fragment zien we onze HTML terug	,

<div wicket:id="window2" id="window26" style="display:none">
	<wicket:panel xmlns:wicket="http://wicket.apache.org">
		<div wicket:id="content" id="content7">
			<h3 wicket:id="dexter">Omelette du fromage</h3>
			<h3 wicket:id="deedee">That's all you can say!</h3>
		</div>
	</wicket:panel>
</div>

/ dit zijn dus de tags window, window2 die we opgeven in onze HTML	, 
/ maar het modal window zelf is andere HTML	,

<div class="wicket-modal" id="_wicket_window_52" role="dialog" aria-labelledby="Foo Bar" style="top: 0px; left: 391px; width: 600px; position: absolute; visibility: visible;">
	<form style="background-color:transparent;padding:0px;margin:0px;border-width:0px;position:static">
		<div id="_wicket_window_53" class="w_blue">
			<div class="w_top_1">
				<div class="w_topLeft" id="_wicket_window_57"></div>
				<div class="w_topRight" id="_wicket_window_58"></div>
				<div class="w_top" id="_wicket_window_56"></div>
			</div>
			<div class="w_left" id="_wicket_window_59">
				<div class="w_right_1">
					<div class="w_right" id="_wicket_window_60">
						<div class="w_content_1" onmousedown="Wicket.Event.stop(event);">
							<div class="w_caption" id="_wicket_window_54">
								<a class="w_close" style="z-index:1" href="#"></a>
								<h3 id="_wicket_window_64" class="w_captionText">Foo Bar</h3>
							</div>
							<div class="w_content_2">
								<div class="w_content_3">
									<div class="w_content">
										<div id="_wicket_window_55" class="w_content_container" style="overflow: auto; height: 422px;">
											<div wicket:id="content" id="content5">I am a modal window</div>
										</div>
									</div>
								</div>
							</div>
	</div></div></div></div><div class="w_bottom_1" id="_wicket_window_63_1"><div class="w_bottomRight" id="_wicket_window_62"></div><div class="w_bottomLeft" id="_wicket_window_61"></div><div class="w_bottom" id="_wicket_window_63"></div></div></div></form></div>

/ in tags window, window2, zien we als we app start niets	, als het label (als div dus) in het modal window verschijnt en we close het modal window, dan verschijnt het label (als div) pas in window tag	, 


/ 7	.

/ project wicket-book	, Ch5_6_2a	, 

/ AjaxEventBehavior	,

$ vi Ch5_6_2a.java

	final ModalWindow window=new ModalWindow("window");
		add(window);
		window.setTitle("Foo Bar");
			
		Label label=new Label(window.getContentId(),new Model<String>("I am a modal window"));
		window.setContent(label);
		
		WebMarkupContainer group=new WebMarkupContainer("group");
		add(group);
		group.setOutputMarkupId(true);
		Behavior behavior=new AjaxEventBehavior("click") {	
			@Override
			protected void onEvent(AjaxRequestTarget target) {
				window.show(target);
				
			}
		};
		group.add(behavior);

$ vi Ch5_6_2a.html

	<div wicket:id="window"></div>
	<div wicket:id="group" style="width:100px;height:100px;position:relative;background:#ccc;"></div>

/ we hoeven in HTML GEEN DOM elem voor de label te maken	,die wordt al create door .setOutputMarkupPlaceHolder	, 

/ we hebben in Man18_2.java
		AjaxLink<Void>link=new AjaxLink<Void>("link") {
			@Override
			public void onClick(AjaxRequestTarget target) {
				window.show(target);

/ Met AjaxEventBehavior kunnen we ook click op een WebMarkupContainer	,
/ WH
/ TODO 

/ Einde WICKET MODAL WINDOW



/ WICKET COMPONENTS
/ 7	.




/ Lees	,
http://stackoverflow.com/questions/7921694/wicket-add-body-tag-attribute
/ over .setTransparentResolver op body	,

/ See in wicket-book project	, AdjustBody.java/.html	,

/ Lees	,
https://cwiki.apache.org/confluence/display/WICKET/Migration+to+Wicket+1.5#MigrationtoWicket1.5-MarkupContainer.isTransparentResolver()removed

/ 7	.

/ Wat is .wrapOnAssignment	?

/ Deze wordt eig. altijd called	, als we een label create met als model een ResourceModel	,
/ in project wicket-book	, Ch12_1_2.java/.html	,
		Label label3=new Label("third",new ResourceModel("third"));
...
/s
Label(Component).<init>(String, IModel<?>) line: 698	
			setModelImpl(wrap(model));
/s
Label(Component).wrap(IModel<V>) line: 4161	
		if (model instanceof IComponentAssignedModel)
		{
			return ((IComponentAssignedModel<V>)model).wrapOnAssignment(this);
/s
ResourceModel.wrapOnAssignment(Component) line: 88	
		return new AssignmentWrapper(component);
/ component=Label
/ this=ResourceModel

/s
ResourceModel$AssignmentWrapper.<init>(ResourceModel, Component) line: 108	
/=
public class ResourceModel extends AbstractReadOnlyModel<String>
	implements
		IComponentAssignedModel<String>
{
	private class AssignmentWrapper extends LoadableDetachableModel<String>
		implements
			IWrapModel<String>
	{
		@Override
		public IModel<String> getWrappedModel()
		{
			return ResourceModel.this;
		}

/t
Label(Component).<init>(String, IModel<?>) line: 698	
			setModelImpl(wrap(model));
/d
/s
Label(Component).setModelImpl(IModel<?>) line: 3021	
			if (model != null)
model	ResourceModel$AssignmentWrapper  (id=101)	
			{
				data_insert(0, model);
/s
Label(Component).data_insert(int, Object) line: 579	
			data = object;
object	ResourceModel$AssignmentWrapper  (id=101)	

//////////////////
/ Dus de data van de component wordt de model	, logisch	,

/t
Ch12_1_2.<init>(PageParameters) line: 36	
		Label label3=new Label("third",new ResourceModel("third"));
/d
		IModel<String>model=new Model<String>("color:red;font-style:italic;");
		label3.add(new AttributeModifier("style",model));
		add(label3);

/ Geef cont	, 

/ we komen in	,

Daemon Thread [http-bio-9090-exec-5] (Suspended (breakpoint at line 124 in ResourceModel$AssignmentWrapper))	
	owns: SocketWrapper<E>  (id=60)	
	ResourceModel$AssignmentWrapper.load() line: 124	
			return Application.get()
				.getResourceSettings()
				.getLocalizer()
				.getString(resourceKey, component, defaultValue);

	ResourceModel$AssignmentWrapper.load() line: 94	

	ResourceModel$AssignmentWrapper(LoadableDetachableModel<T>).getObject() line: 121	
			transientModelObject = load();
	Label(Component).getDefaultModelObject() line: 1618	
				return model.getObject();

	Label(Component).getDefaultModelObjectAsString() line: 1646	
	Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());

	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Label(Component).internalRenderComponent() line: 2557	
			if (tag.isOpen())
			{
				// Render the body. The default strategy will simply call the component's
				// onComponentTagBody() implementation.
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);

	Label(WebComponent).onRender() line: 56	
	Label(Component).internalRender() line: 2372	
	Label(Component).render() line: 2300	
	Ch12_1_2(MarkupContainer).renderNext(MarkupStream) line: 1405	
	Ch12_1_2(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1601	
	Ch12_1_2(Page).onRender() line: 879	
	Ch12_1_2(WebPage).onRender() line: 142	
	Ch12_1_2(Component).internalRender() line: 2372	
	Ch12_1_2(Component).render() line: 2300	
	Ch12_1_2(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 837	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 241	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 208	
	StandardWrapperValve.invoke(Request, Response) line: 220	
	StandardContextValve.invoke(Request, Response) line: 122	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 503	
	StandardHostValve.invoke(Request, Response) line: 170	
	ErrorReportValve.invoke(Request, Response) line: 103	
	AccessLogValve.invoke(Request, Response) line: 950	
	StandardEngineValve.invoke(Request, Response) line: 116	
	CoyoteAdapter.service(Request, Response) line: 421	
	Http11Processor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1070	
	Http11Protocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 611	
	JIoEndpoint$SocketProcessor.run() line: 314	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ we gaan er verder in	,
/s
Localizer.getString(String, Component, String) line: 149	
/ this.cache=
{third-2:third-1-en_US-null-null=My Third Label, first-1-en_US-null-null=My First Label}

/ 7	. 

/ In Ch12_1_2.java, in wicket-book	,

	IModel<String>model3=new ResourceModel("third");
		Label label3=new Label("third",model3);
//		Object o=model3.getObject();
// ERR
// TODO

/ 7	.

/ In Ch12_1_2.java, in proj wicket-book	,
/ .wrapAssignment	,

		IModel<String>model3=new ResourceModel("third");
		Label label3=new Label("third",model3);
		add(label3);
		
		IModel<String>model4=new ResourceModel("fourth").wrapOnAssignment(label3);
		Label label4=new Label("fourth",model4);
		add(label4);

/ in Ch12_1_2.properties
fourth=My Fourth Label

/ in Ch12_1_2.html
	<div wicket:id="fourth"></div>

/ model4 is geen IComponentAssignedModel, zoals ResourceModel	, de wrap is al gedaan, het is een AssignmentWrapper extends LoadableDetachableModel<String>	, dus in new Label("fourth",model4) wordt er niet nog een keer .wrapOnAssignment called	,

/ we komen in	,
ResourceModel$AssignmentWrapper.load() line: 124	
		@Override
		protected String load()
		{
			return Application.get()
				.getResourceSettings()
				.getLocalizer()
				.getString(resourceKey, component, defaultValue);
...
/s
Localizer.getStringIgnoreSettings(String, Component, IModel<?>, Locale, String, String) line: 338	
		if ((cache != null) && ((component == null) || addedToPage))
		{
			cacheKey = getCacheKey(key, component, locale, style, variation);

/ key="fourth"
/ component=label3
/ locale=en_US
this	Localizer  (id=10081)	
	cache	ConcurrentHashMap<K,V>  (id=10105)	
{third-2:third-1-en_US-null-null=My Third Label, 
fourth-2:third-1-en_US-null-null=My Fourth Label, 
first-1-en_US-null-null=My First Label}
	metaDatabase	Localizer$ClassMetaDatabase  (id=10203)	
		nameCounter	AtomicLong  (id=10248)	
		nameToId	ConcurrentHashMap<K,V>  (id=10249)	
{my.test.own.wicket_book.Ch12_1_2=1, org.apache.wicket.markup.html.basic.Label=2}

/ wat is rol component	?

/ 7	.







/ Einde WICKET COMPONENTS

/ WICKET TABLE

/ 7	. 

/ Onze eigen provider	,

$ vi Ch55c.html

	<div wicket:id="row3">
		   <div wicket:id="name"></div>
		   <div wicket:id="address"></div>
	</div>

$ vi Ch55c.java

	private class MyProvider<T extends Serializable> implements IDataProvider<T> {
	 
		private List<T>l;

		public MyProvider(List<T>l) {
			this.l=l;
		}
	        public Iterator<T> iterator(long first, long count)
	        {
	        	long last=first+count;
	        	if(last>l.size())last=l.size();
	        	List<T>sub=l.subList((int)first,(int)last);
	        	return sub.listIterator();
	        }
	 
	        public long size()
	        {
	                return (long)l.size();
	        }
	 
	        @Override
	        public IModel model(T t)
	        {
	                return new Model<T>(t);
	        }
	      
	        @Override
	        public void detach() {
	        
	        }
	 }

		{
			IDataProvider<Person>dataProvider=new MyProvider<Person>(persons);
			DataView<Person> dataView = new DataView<Person>("row3", dataProvider) {

			  @Override
			  protected void populateItem(Item<Person> item) {
			    Person person = item.getModelObject();

			    {
			    Label label=new Label("name", person.getName());
			    label.setOutputMarkupId(true);
			    item.add(label);
			    }
			    {
			    Label label=new Label("address", person.getAddress());
			    label.setOutputMarkupId(true);
			    item.add(label);
			    }
			      
			    
			  }
			};
			add(dataView);
			dataView.setOutputMarkupId(true);
			}
    		} 

/ we zien	,

	<div wicket:id="row3">
	  	<div wicket:id="name" id="nameb">Foo</div>
	  	<div wicket:id="address" id="addressc">Street 1</div>
	</div>
	<div wicket:id="row3">
		   <div wicket:id="name" id="named">Bar</div>
		   <div wicket:id="address" id="addresse">Lane 7</div>
	</div>

/ 7	.

/ proj wicket-exxamples-step-by-step

/ In SimplePage	, 
		add(new DataView<Contact>("simple", new ContactDataProvider()) {
			@Override
			protected void populateItem(final Item<Contact> item)
				Contact contact = item.getModelObject();
/ Hier wordt de transient obj set in het model	,

/ 7	.  

/ proj wicket-exxamples-step-by-step

/ In SortingPage.java	,
		SortableContactDataProvider dp = new SortableContactDataProvider();

/ public class SortableContactDataProvider extends SortableDataProvider<Contact, String> implements IFilterStateLocator<ContactFilter>
	@Override
	public Iterator<Contact> iterator(long first, long count)
	@Override
	public long size()
	@Override
	public IModel<Contact> model(Contact object)
/ Dus implement IDataProvider	,
	@Override
	public ContactFilter getFilterState()
	@Override
	public void setFilterState(ContactFilter state)
/ dus implements IFilterStateLocator	,

public abstract class SortableDataProvider<T, S> implements ISortableDataProvider<T, S>
	private final SingleSortState<S> state = new SingleSortState<>();
	@Override
	public final ISortState<S> getSortState(){
		return state;
	@Override
	public void detach()
/ Dus is abstract, omdat hij NIET IDataProvider impl	,


public interface ISortableDataProvider<T, S> extends IDataProvider<T>, ISortStateLocator<S>

public interface IDataProvider<T> extends IDetachable
	Iterator<? extends T> iterator(long first, long count);
	long size();
	IModel<T> model(T object);

public interface IDetachable extends IClusterable
	void detach();

public interface ISortStateLocator<T> extends IClusterable
	ISortState<T> getSortState();

public interface IFilterStateLocator<T> extends IClusterable
	T getFilterState();
	void setFilterState(T state);

 */
public class SingleSortState<T> implements ISortState<T>, IClusterable {
	@Override
	public void setPropertySortOrder(final T property, final SortOrder order)
	@Override
	public SortOrder getPropertySortOrder(final T property)

public interface ISortState<S> extends IClusterable {
	public void setPropertySortOrder(S property, SortOrder order);
	public SortOrder getPropertySortOrder(S property);



/ Einde WICKET TABLE


/ OPEN IN CHROME

http://localhost:9090/simple-webapp/weather.x?zip=60202

http://dev.mysql.com/doc/refman/5.0/en/subquery-errors.html
http://stackoverflow.com/questions/7869592/how-to-do-an-update-join-in-postgresql
http://www.postgresql.org/docs/9.1/static/datatype-datetime.html

http://ehcache.org/documentation/2.8/code-samples
http://ehcache.org/generated/2.9.0/html/ehc-all/#page/Ehcache_Documentation_Set%2Fco-persist_config_examples.html%23
http://ehcache.org/documentation
https://weblogs.java.net/blog/maxpoon/archive/2007/06/extending_the_n_2.html

http://www.journaldev.com/3481/hibernate-save-vs-saveorupdate-vs-persist-vs-merge-vs-update-explanation-with-examples

http://postgresguide.com/tips/dates.html

http://stackoverflow.com/questions/5459176/difference-between-hibernate-update-by-session-update-and-hibernatetemplate-merg

https://acceptance.scs.mp-objects.com/isbscs/authentication/login-form
https://test.scs.mp-objects.com/pnloms/authentication/login-form

file:///home/eric/Downloads/finalized-invoice-list.pdf

http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-standard-annotations

https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html


/ Einde OPEN IN CHROME


/ GOOGLE

https://www.google.com/landing/2step/features.html
/ we hebben saved in ~	,
Backup-codes-ericjvandervelden.txt



/ Einde GOOGLE

/ WICKET EXAMPLES

/ we maken project wicket-examples-step-by-step

/ 7	.

/ In wicket-examples' pom zien we dependencies bijv. op wicket-ccre, zonder version	,. De pom heeft parent org.apache.wicket:wicket-parent:7.0.0.M4	, en die zien we in de repo	,
/ Daar zien we de dep op wicket-core met version	,  in <dependencyManagement/>	,
/ Lees	,
http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html

Luckily, Maven provides a way for you to consolidate dependency version numbers in the dependencyManagement element. You’ll usually see the dependencyManagement element in a top-level parent POM for an organization or project. Using the dependencyManagement element in a pom.xml allows you to reference a dependency in a child project without having to explicitly list the version. Maven will walk up the parent-child hierarchy until it finds a project with a dependencyManagement element, it will then use the version specified in this dependencyManagement element.

/ 7	.

/ we cp van project wicket-examples	,

org/apache/wicket/examples 
	HelloWorldServlet.java
	WicketExampleApplication.java
org/apache/wicket/examples/helloworld 
	HelloWorld.java
	HelloWorldApplication.java
	HelloWorld.html
org/apache/wicket/examples/repeater 
	RepeaterApplication.java
org/apache/wicket/examples/source 
	...

/ HelloWorldApplication extends WicketExampleApplication

/ Ook in repeater hebben we een appl	, RepeaterApplication	,

/ we extract de war in de org.apache.wicket:wicket-examples:7.0.0.M4 	,
$ pwd
/home/eric/Devel/Java/Wicket
$ jar xvf ~/Downloads/wicket-examples-7.0.0-M4.war
/ Hier zien we ook alle src files	, maar ook de web.xml	,
/ In wicket-examples-7.0.0-M4-sources.jar zien we web.xml NIET, maar die moeten we echt wel hebben	, in wicket-examples-7.0.0-M4-sources.jar zitten alleen de .java files	,

$ vi WEB-INF/web.xml


 	<filter>
                <filter-name>HelloWorldApplication</filter-name>
                <filter-class>org.apache.wicket.protocol.http.WicketFilter</filter-class>
                <init-param>
                  <param-name>applicationClassName</param-name>
                  <param-value>org.apache.wicket.examples.helloworld.HelloWorldApplication</param-value>
                </init-param>
        </filter>
        
        <filter-mapping>
                <filter-name>HelloWorldApplication</filter-name>
                <url-pattern>/helloworld/*</url-pattern>
                <dispatcher>REQUEST</dispatcher>
                <dispatcher>INCLUDE</dispatcher>
        </filter-mapping>
        
        <filter>
                <filter-name>RepeaterExamplesApplication</filter-name>
                <filter-class>org.apache.wicket.protocol.http.WicketFilter</filter-class>
                <init-param>
                        <param-name>applicationClassName</param-name>
                        <param-value>org.apache.wicket.examples.repeater.RepeaterApplication</param-value>
                </init-param>
        </filter>
        
        <filter-mapping>
                <filter-name>RepeaterExamplesApplication</filter-name>
                <url-pattern>/repeater/*</url-pattern>
                <dispatcher>REQUEST</dispatcher>
                <dispatcher>INCLUDE</dispatcher>
        </filter-mapping>
 
        <servlet>
                <servlet-name>HelloWorldServlet</servlet-name>
                <servlet-class>org.apache.wicket.examples.HelloWorldServlet</servlet-class>
        </servlet>

        <servlet-mapping>
                <servlet-name>HelloWorldServlet</servlet-name>
                <url-pattern>/helloworldservlet/*</url-pattern>
        </servlet-mapping>


/ Voor ons tellen de filters	, als we een bepaalde url geven	, pakt hij de juiste appl, door het filter	,
/ we kunnen ook de servlet aan een url bind	,

/ we start tomcat7	,
[eric@localhost apache-tomcat-7.0.57]$ bin/catalina.sh run
...
/ we deploy in tomcat7	, 
$ mvn tomcat7:undeploy tomcat7:deploy	

/vergl met
http://www.wicket-library.com/wicket-examples/helloworld/
/ geef	,
http://localhost:8080/wicket-examples-step-by-step/repeater/
http://localhost:8080/wicket-examples-step-by-step/helloworld/
http://localhost:8080/wicket-examples-step-by-step/helloworldservlet

/ Geef	
http://localhost:8080/wicket-examples-step-by-step/repeater/






/ Einde WICKET EXAMPLES

/ TOMCAT 

[eric@localhost apache-tomcat-7.0.57]$ vi bin/catalina.sh

# [ERICJ]
CATALINA_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,address=9966,server=y,suspend=n"

[eric@localhost apache-tomcat-7.0.57]$ vi conf/server.xml 
   <Connector port="9090" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />

/ Nu kunnen we tomcat start naast onze appl	, maar we zien nog wel ERRS	,
/ TODO

/ We doen in wicket-book's pom.xml	,

			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<version>${tomcat.version}</version>
				<configuration>
	    				<url>http://localhost:9090/manager/text</url>
	    				<server>my_tomcat</server>
 	 			</configuration>
			</plugin>

/ bij tomcat7:deploy hoeven we alleen <url> 	, GEEN <port>	, ook <path>, 
/ maar deze is de default	,
	    			<path>/${project.artifactId}</path>

/ als we  tomcat7:run	, moeten we <port> geven, 
/ TODO

/ Einde TOMCAT 

/ JETTY

/ in wicket-book's pom.xml	,

				<groupId>org.eclipse.jetty</groupId>
				<artifactId>jetty-maven-plugin</artifactId>
				<version>${jetty9.version}</version>
				<configuration>
				
		            <httpConnector>
		                    <port>9090</port>
		            </httpConnector>

/ Als onze appl ook runs	,
/ Maar toch conflict op 8080
/ TODO 

/ Einde JETTY



/ WICKET SOURCE 

[eric@localhost Wicket]$ pwd
/home/eric/Devel/Java/Wicket
[eric@localhost Wicket]$ git clone https://github.com/apache/wicket.git
[eric@localhost Wicket]$ cd wicket
[eric@localhost wicket]$ git tag -l
/ TODO

/ Hier zien we wel de wicket-examples in de src	,
/ Lees	,
http://www.mkyong.com/wicket/how-do-setup-wicket-examples-in-eclipse/
/ TODO
/ HIER HIER HIER
`

/ Einde WICKET SOURCE

/ FEDORA

/ Uit X	, 
ctrl+alt+F>2, dus F2, of F3, ...
/ terug naar X	,
ctrl+alt+F1

/ Ga eruit	, 
$ killall gnome-session
 
/ Einde FEDORA

/ JETTY

/ 7	.

/ jetty9 zelfstandig zoals tomcat7	,

[eric@localhost Jetty]$ pwd
/home/eric/Devel/Java/Jetty
[eric@localhost Jetty]$ tar xxvzf ~/Downloads/jetty-distribution-9.2.6.v20141205.tar.gz 
[eric@localhost Jetty]$ cd jetty-distribution-9.2.6.v20141205/
[eric@localhost jetty-distribution-9.2.6.v20141205]$ ls
bin        etc  license-eplv10-aslv20.html  modules      README.TXT  start.ini  VERSION.txt
demo-base  lib  logs                        notice.html  resources   start.jar  webapps

/ we lezen	,
http://www.eclipse.org/jetty/documentation/current/

[eric@localhost jetty-distribution-9.2.6.v20141205]$ pwd
/home/eric/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205
[eric@localhost jetty-distribution-9.2.6.v20141205]$ java -jar start.jar 
2015-01-05 09:00:50.232:INFO::main: Logging initialized @392ms
2015-01-05 09:00:50.289:WARN:oejs.HomeBaseWarning:main: This instance of Jetty is not running from a separate {jetty.base} directory, this is not recommended.  See documentation at http://www.eclipse.org/jetty/documentation/current/startup.html
2015-01-05 09:00:50.445:INFO:oejs.Server:main: jetty-9.2.6.v20141205
2015-01-05 09:00:50.459:INFO:oejdp.ScanningAppProvider:main: Deployment monitor [file:/home/eric/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/webapps/] at interval 1
2015-01-05 09:00:50.471:INFO:oejs.ServerConnector:main: Started ServerConnector@2695c1b4{HTTP/1.1}{0.0.0.0:8080}
2015-01-05 09:00:50.472:INFO:oejs.Server:main: Started @632ms

/ Geef
localhost:8080
Error 404 - Not Found.

No context on this server matched or handled this request.
Contexts known to this server are:

[eric@localhost jetty-distribution-9.2.6.v20141205]$ cd demo-base/

[eric@localhost demo-base]$ ls
etc  lib  resources  start.d  start.ini  webapps
[eric@localhost demo-base]$ ls webapps/
async-rest.war     README.TXT  test.d         test-jaas.xml  test-jndi.xml  test-spec.xml  test.xml
example-moved.xml  ROOT        test-jaas.war  test-jndi.war  test-spec.war  test.war       xref-proxy.war

[eric@localhost demo-base]$ java -jar ../start.jar 
2015-01-05 09:02:23.183:INFO::main: Logging initialized @420ms
2015-01-05 09:02:23.466:WARN::main: demo test-realm is deployed. DO NOT USE IN PRODUCTION!
2015-01-05 09:02:23.468:INFO:oejs.Server:main: jetty-9.2.6.v20141205
2015-01-05 09:02:23.482:INFO:oejdp.ScanningAppProvider:main: Deployment monitor [file:/home/eric/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/demo-base/webapps/] at interval 1
2015-01-05 09:02:23.913:WARN::main: test webapp is deployed. DO NOT USE IN PRODUCTION!
2015-01-05 09:02:24.473:INFO:oejsh.ContextHandler:main: Started o.e.j.w.WebAppContext@60a943af{/test,file:/tmp/jetty-0.0.0.0-8080-test.war-_test-any-8194949497782332205.dir/webapp/,AVAILABLE}{/test.war}
2015-01-05 09:02:24.587:WARN::main: test-jndi webapp is deployed. DO NOT USE IN PRODUCTION!
2015-01-05 09:02:24.744:INFO:oejsh.ContextHandler:main: Started o.e.j.w.WebAppContext@34b363f8{/test-jndi,file:/tmp/jetty-0.0.0.0-8080-test-jndi.war-_test-jndi-any-2545473013574447912.dir/webapp/,AVAILABLE}{/test-jndi.war}
2015-01-05 09:02:24.935:WARN::main: async-rest webapp is deployed. DO NOT USE IN PRODUCTION!
2015-01-05 09:02:25.031:INFO:oejsh.ContextHandler:main: Started o.e.j.w.WebAppContext@5a3dfc08{/async-rest,[file:/tmp/jetty-0.0.0.0-8080-async-rest.war-_async-rest-any-6070766363191872686.dir/webapp/, jar:file:/tmp/jetty-0.0.0.0-8080-async-rest.war-_async-rest-any-6070766363191872686.dir/webapp/WEB-INF/lib/example-async-rest-jar-9.2.6.v20141205.jar!/META-INF/resources],AVAILABLE}{/async-rest.war}
2015-01-05 09:02:25.039:INFO:oejsh.ContextHandler:main: Started o.e.j.s.h.MovedContextHandler@4d0f5115{/oldContextPath,null,AVAILABLE}
2015-01-05 09:02:25.256:INFO:oejsh.ContextHandler:main: Started o.e.j.w.WebAppContext@28946139{/proxy,file:/tmp/jetty-0.0.0.0-8080-xref-proxy.war-_xref-proxy-any-2171852212076253224.dir/webapp/,AVAILABLE}{/xref-proxy.war}
2015-01-05 09:02:25.305:WARN::main: test-jaas webapp is deployed. DO NOT USE IN PRODUCTION!
2015-01-05 09:02:25.355:INFO:oejsh.ContextHandler:main: Started o.e.j.w.WebAppContext@64d6f6fd{/test-jaas,file:/tmp/jetty-0.0.0.0-8080-test-jaas.war-_test-jaas-any-5141516540938589014.dir/webapp/,AVAILABLE}{/test-jaas.war}
2015-01-05 09:02:25.451:INFO:oejsh.ContextHandler:main: Started o.e.j.w.WebAppContext@5e223ed2{/,file:/home/eric/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/demo-base/webapps/ROOT/,AVAILABLE}{/ROOT}
2015-01-05 09:02:25.556:WARN::main: test-spec webapp is deployed. DO NOT USE IN PRODUCTION!
Calling TestListener.contextInitialized
2015-01-05 09:02:25.633:INFO:oejsh.ContextHandler:main: Started o.e.j.w.WebAppContext@1a12b4d3{/test-spec,[file:/tmp/jetty-0.0.0.0-8080-test-spec.war-_test-spec-any-8819481114796518847.dir/webapp/, jar:file:/tmp/jetty-0.0.0.0-8080-test-spec.war-_test-spec-any-8819481114796518847.dir/webapp/WEB-INF/lib/test-web-fragment-9.2.6.v20141205.jar!/META-INF/resources],AVAILABLE}{/test-spec.war}
2015-01-05 09:02:25.640:INFO:oejs.ServerConnector:main: Started ServerConnector@15363c8e{HTTP/1.1}{0.0.0.0:8080}
2015-01-05 09:02:25.649:INFO:oejs.ServerConnector:main: Started ServerConnector@660221ad{SSL-http/1.1}{0.0.0.0:8443}
2015-01-05 09:02:25.649:INFO:oejs.Server:main: Started @2887ms

/ Geef
localhost:8080
/ OK

/ 7	.

[eric@localhost mybase]$ pwd
/tmp/mybase
[eric@localhost mybase]$ java -jar ~/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/start.jar 
WARNING: Nothing to start, exiting ...

Usage: java -jar start.jar [options] [properties] [configs]
       java -jar start.jar --help  # for more information

[eric@localhost mybase]$ java -jar ~/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/start.jar --add-to-startd=http,deploy
INFO: http            initialised in ${jetty.base}/start.d/http.ini (created)
INFO: http            enabled in     ${jetty.base}/${jetty.base}/start.d/http.ini
INFO: server          initialised transitively
INFO: server          initialised in ${jetty.base}/start.d/server.ini (created)
INFO: server          enabled in     ${jetty.base}/${jetty.base}/start.d/server.ini
INFO: deploy          initialised in ${jetty.base}/start.d/deploy.ini (created)
INFO: deploy          enabled in     ${jetty.base}/${jetty.base}/start.d/deploy.ini
MKDIR: ${jetty.base}/webapps
INFO: webapp          enabled in     <transitive>
INFO: servlet         enabled in     <transitive>
INFO: security        enabled in     <transitive>
INFO: server          initialised in ${jetty.base}/${jetty.base}/start.d/server.ini
INFO: server          enabled in     <transitive>
INFO: server          enabled in     ${jetty.base}/${jetty.base}/start.d/server.ini

[eric@localhost mybase]$ find
.
./webapps
./start.d
./start.d/deploy.ini
./start.d/server.ini
./start.d/http.ini

[eric@localhost mybase]$ java -jar ~/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/start.jar 
2015-01-05 09:32:38.883:INFO::main: Logging initialized @311ms
2015-01-05 09:32:39.051:INFO:oejs.Server:main: jetty-9.2.6.v20141205
2015-01-05 09:32:39.070:INFO:oejdp.ScanningAppProvider:main: Deployment monitor [file:/tmp/mybase/webapps/] at interval 1
2015-01-05 09:32:39.084:INFO:oejs.ServerConnector:main: Started ServerConnector@2e0dc005{HTTP/1.1}{0.0.0.0:8080}
2015-01-05 09:32:39.085:INFO:oejs.Server:main: Started @514ms

http://localhost:8080/
/ we zien hetzelfde als we het in de jetty root  doen	,

/ 7	.

[eric@localhost mybase]$ java -jar ~/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/start.jar --add-to-startd=https
INFO: https           initialised in ${jetty.base}/start.d/https.ini (created)
INFO: https           enabled in     ${jetty.base}/${jetty.base}/start.d/https.ini
INFO: ssl             initialised transitively
INFO: ssl             initialised in ${jetty.base}/start.d/ssl.ini (created)
INFO: ssl             enabled in     ${jetty.base}/${jetty.base}/start.d/ssl.ini
DOWNLOAD: http://git.eclipse.org/c/jetty/org.eclipse.jetty.project.git/plain/jetty-server/src/main/config/etc/keystore to etc/keystore
INFO: server          initialised in ${jetty.base}/start.d/server.ini
INFO: server          enabled in     <transitive>
INFO: server          enabled in     ${jetty.base}/start.d/server.ini

[eric@localhost mybase]$ find 
.
./etc
./etc/keystore
./webapps
./start.d
./start.d/ssl.ini
./start.d/https.ini
./start.d/deploy.ini
./start.d/server.ini
./start.d/http.ini

[eric@localhost mybase]$ java -jar ~/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/start.jar 
/ TODO

/ 7	. 

/ in demo-base	,
$ java -jar ../start.jar

[eric@localhost demo-base]$ ls webapps/
async-rest.war     README.TXT  test.d         test-jaas.xml  test-jndi.xml  test-spec.xml  test.xml
example-moved.xml  ROOT        test-jaas.war  test-jndi.war  test-spec.war  test.war       xref-proxy.war

/ geef 
localhost:8080
/ we zien de ROOT webapp	, 
[eric@localhost demo-base]$ ls webapps/ROOT/
images  index.html  jetty.css
/ Alleen een .html, .css, images/	, 

/ in webapp zien we ook de test webapp	,




/ Einde JETTY

/ SPRING MAVEN BOOK HIBERNATE APPL 

/ 7	. 

/ simple-parent: clean install
/ simple-webapp: jetty:run

/ Geef	,
http://localhost:8080/simple-webapp/weather.x?zip=60202
http://localhost:8080/simple-webapp/history.x?zip=60202

/ 7	.

/ Uit maven boek	, 
[eric@localhost ch-multi-spring-postgres]$ pwd
/home/eric/Devel/Java/Spring/ch-multi-spring-postgres
[eric@localhost ch-multi-spring-postgres]$ ls
pom.xml  simple-parent
[eric@localhost ch-multi-spring-postgres]$ ls simple-parent/
pom.xml  simple-command  simple-model  simple-persist  simple-weather  simple-webapp

/ als we import in eclipse	,
/home/eric/Devel/Java/Spring/ch-multi-spring-postgres
/ dan zien we de projects	,
simple-parent simple-command  simple-model  simple-persist  simple-weather  simple-webapp

/ we doen aanpassingen	,

$ vi simple-persist/pom.xml	,

 <dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <version>2.3.2</version>
 </dependency>

$ vi applicationContext-persist.xml

        <property name="hibernateProperties">
            <props>
		...
            	<prop key="hibernate.hbm2ddl.auto">create</prop>
            </props>
        </property>


/ Dus simple-parent is er ook, en deze moeten we hebben	, we doen in eclipse : clean install op simple-parent	, 
[eric@localhost repository]$ ls org/sonatype/mavenbook/multispring/
parent          simple-model   simple-persist  simple-webapp
simple-command  simple-parent  simple-weather

/ Dan op de pom.xml in simple-webapp/	, 
jetty:run 

/ Geef	,
http://localhost:8080/simple-webapp/weather.x?zip=60202
/ OK


/ 7	. 

/ we willen postgresql	,


$ vi applicationContext-persist.xml

	<property name="hibernateProperties">
            <props>
                <prop key="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect</prop>
        	<prop key="hibernate.connection.driver_class">org.postgresql.Driver</prop>
        	<prop key="hibernate.connection.url">jdbc:postgresql://localhost/foo</prop>
        	<prop key="hibernate.connection.username">foo</prop>
        	<prop key="hibernate.connection.password">foo</prop>
	...
            </props>
        </property>

$ vi simple-persist/pom.xml

<dependency>
	<groupId>org.postgresql</groupId>
	<artifactId>postgresql</artifactId>
	<version>9.3-1102-jdbc41</version>
</dependency>

/ run clean install in simple-parent	,
/ run jetty:run in simple-webapp	,

/ Geef	,
http://localhost:8080/simple-webapp/weather.x?zip=60202
/ OK
 
/ we zien	,

foo=> \d+ atmosphere
                                                       Table "public.atmosphere"
   Column   |          Type          |                        Modifiers                        | Storage  | Stats target | Description 
------------+------------------------+---------------------------------------------------------+----------+--------------+-------------
 id         | integer                | not null default nextval('atmosphere_id_seq'::regclass) | plain    |              | 
 humidity   | character varying(255) |                                                         | extended |              | 
 pressure   | character varying(255) |                                                         | extended |              | 
 rising     | character varying(255) |                                                         | extended |              | 
 visibility | character varying(255) |                                                         | extended |              | 
 weather_id | integer                | not null                                                | plain    |              | 
Indexes:
    "atmosphere_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
    "fk2af43942e377ee06" FOREIGN KEY (weather_id) REFERENCES weather(id)
Has OIDs: no



=> \d+ condition
                                                       Table "public.condition"
   Column   |          Type          |                       Modifiers                        | Storage  | Stats target | Description 
------------+------------------------+--------------------------------------------------------+----------+--------------+-------------
 id         | integer                | not null default nextval('condition_id_seq'::regclass) | plain    |              | 
 code       | character varying(255) |                                                        | extended |              | 
 date       | character varying(255) |                                                        | extended |              | 
 temp       | character varying(255) |                                                        | extended |              | 
 text       | character varying(255) |                                                        | extended |              | 
 weather_id | integer                | not null                                               | plain    |              | 
Indexes:
    "condition_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
    "fk441b8cfbe377ee06" FOREIGN KEY (weather_id) REFERENCES weather(id)
Has OIDs: no


foo=> \d+ location;
                               Table "public.location"
 Column  |          Type          | Modifiers | Storage  | Stats target | Description 
---------+------------------------+-----------+----------+--------------+-------------
 zip     | character varying(255) | not null  | extended |              | 
 city    | character varying(255) |           | extended |              | 
 country | character varying(255) |           | extended |              | 
 region  | character varying(255) |           | extended |              | 
Indexes:
    "location_pkey" PRIMARY KEY, btree (zip)
Referenced by:
    TABLE "weather" CONSTRAINT "fkac24cfd41d328c00" FOREIGN KEY (location_zip) REFERENCES location(zip)
Has OIDs: no


foo=> \d+ weather
                                                          Table "public.weather"
    Column    |            Type             |                      Modifiers                       | Storage  | Stats target | Description 
--------------+-----------------------------+------------------------------------------------------+----------+--------------+-------------
 id           | integer                     | not null default nextval('weather_id_seq'::regclass) | plain    |              | 
 date         | timestamp without time zone |                                                      | plain    |              | 
 location_zip | character varying(255)      |                                                      | extended |              | 
Indexes:
    "weather_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
    "fkac24cfd41d328c00" FOREIGN KEY (location_zip) REFERENCES location(zip)
Referenced by:
    TABLE "wind" CONSTRAINT "fk292428e377ee06" FOREIGN KEY (weather_id) REFERENCES weather(id)
    TABLE "atmosphere" CONSTRAINT "fk2af43942e377ee06" FOREIGN KEY (weather_id) REFERENCES weather(id)
    TABLE "condition" CONSTRAINT "fk441b8cfbe377ee06" FOREIGN KEY (weather_id) REFERENCES weather(id)
Has OIDs: no


foo=> \d+ wind
                                                       Table "public.wind"
   Column   |          Type          |                     Modifiers                     | Storage  | Stats target | Description 
------------+------------------------+---------------------------------------------------+----------+--------------+-------------
 id         | integer                | not null default nextval('wind_id_seq'::regclass) | plain    |              | 
 chill      | character varying(255) |                                                   | extended |              | 
 direction  | character varying(255) |                                                   | extended |              | 
 speed      | character varying(255) |                                                   | extended |              | 
 weather_id | integer                | not null                                          | plain    |              | 
Indexes:
    "wind_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
    "fk292428e377ee06" FOREIGN KEY (weather_id) REFERENCES weather(id)
Has OIDs: no

foo=> select*from atmosphere
foo-> ;
 id | humidity | pressure | rising | visibility | weather_id 
----+----------+----------+--------+------------+------------
  1 | 74       | 30.22    | 1      | 7          |          1
(1 row)

foo=> select*from condition;
 id | code |             date             | temp |  text  | weather_id 
----+------+------------------------------+------+--------+------------
  1 | 26   | Thu, 27 Nov 2014 1:26 am CST | 25   | Cloudy |          1
(1 row)

foo=> select*from location;
  zip  |   city   | country | region 
-------+----------+---------+--------
 60202 | Evanston | US      | IL
(1 row)

foo=> select*from weather;
 id |          date           | location_zip 
----+-------------------------+--------------
  1 | 2014-11-27 09:08:20.574 | 60202
(1 row)

foo=> select*from wind;
 id | chill | direction | speed | weather_id 
----+-------+-----------+-------+------------
  1 | 14    | 310       | 13    |          1
(1 row)



/ 7	.

/ debug jetty	,

http://stackoverflow.com/questions/9066733/how-do-i-debug-a-web-application-running-on-jetty-in-eclipse/ 

/ Lees	,
Create Maven Eclipse Runtime for your project:
right-click on project -> maven build -> goals: jetty:run
go to JRE tab of your Maven Eclipse Runtime, and in the VM arguments section add:
-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n

When you execute this runtime, the first thing the Eclipse console outputs (in blue) is:

Listening for transport dt_socket at address: 8000

Now you can create a Remote Java application Debug Runtime and connect to the debug port (8000 in this example)

/ we create a run configuration in eclipse (Not a debug configuration)	, op project simple-webapp	, met Maven, 
/ right click simple-webapp	, Run as, Maven build	, 
Base dir:/home/eric/Devel/Java/Spring/ch-multi-spring-postgres/simple-parent/simple-webapp
Goals: jetty:run
/ onder JRE tab	, 
VM arguments: -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n

/ we create debug configuration	, onder Remote Java application	,
Name: Jetty
project: simple-webapp
Host: localhost
Port: 8000

/ Geef	,
http://localhost:8080/simple-webapp/weather.x?zip=60202

/ Eclipse vind source code niet	in simple-persist	, wel in simple-webapp	, 
/ click op source code not found	,  kies Java project: simple-perist	, de souce code wordt gevonden	,

/ als we niet Java project, maar File system  kiezen, en kiezen dir (/home/eric/Devel/Java/Spring/ch-multi-spring-postgres	, or sub dir TODO), dan krijgen we in eclipse files dubbel	, en mist hij bp's	,
/ TODO

/ Hij valt in WeatherDOA.save	,

/ Geef	,
http://localhost:8080/simple-webapp/history.x?zip=60202

/ Hij valt in 	,
public class LocationDAO extends HibernateDaoSupport {
    public Location findByZip(final String zip) {
    	return (Location) getHibernateTemplate().execute(new HibernateCallback() {
/s
LocationDAO$1.doInHibernate(Session) line: 20	

public class LocationDAO extends HibernateDaoSupport {
    public Location findByZip(final String zip) {
    	return (Location) getHibernateTemplate().execute(new HibernateCallback() {
			public Object doInHibernate(Session session) {
->				Query query = getSession().getNamedQuery("Location.uniqueByZip");

/ 7	.

/ Welke Spring beans zijn er	?

./simple-parent/simple-persist/src/main/resources/applicationContext-persist.xml
    <bean 
	id="sessionFactory"
       	class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
    <bean 
	id="locationDAO" 
	class="org.sonatype.mavenbook.weather.persist.LocationDAO">
       	<property name="sessionFactory" ref="sessionFactory"/>

    <bean 
	id="weatherDAO" 
	class="org.sonatype.mavenbook.weather.persist.WeatherDAO">
       	<property name="sessionFactory" ref="sessionFactory"/>
    </bean>


./simple-parent/simple-webapp/src/main/webapp/WEB-INF/weather-servlet.xml
     <bean 
	id="weatherController" 
	class="org.sonatype.mavenbook.web.WeatherController">
       	<property name="weatherService" ref="weatherService"/>
       	<property name="weatherDAO" ref="weatherDAO"/>
     </bean>

     <bean 
	id="historyController"
        class="org.sonatype.mavenbook.web.HistoryController">
       	<property name="weatherDAO" ref="weatherDAO"/>
       	<property name="locationDAO" ref="locationDAO"/>
     </bean>

     <bean 
	id="urlMapping"
        class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
         <property name="urlMap">
               <map>
                    <entry key="/weather.x">
                         <ref bean="weatherController" />
                    </entry>
                    <entry key="/history.x">
                         <ref bean="historyController" />
                    </entry>
               </map>
          </property>


    <bean 
	id="velocityConfig" 
	class="org.springframework.web.servlet.view.velocity.VelocityConfigurer">
       	<property name="resourceLoaderPath" value="/WEB-INF/vm/"/>
     </bean>

     <bean id="viewResolver" class="org.springframework.web.servlet.view.velocity.VelocityViewResolver">
       <property name="cache" value="true"/>
       <property name="prefix" value=""/>
       <property name="suffix" value=".vm"/>
       <property name="exposeSpringMacroHelpers" value="true"/>
     </bean>

./simple-parent/simple-weather/src/main/resources/applicationContext-weather.xml
   <bean 
	id="weatherService" 
	class="org.sonatype.mavenbook.weather.WeatherService">
      	<property name="yahooRetriever" ref="yahooRetriever"/>
      	<property name="yahooParser" ref="yahooParser"/>
    </bean>

    <bean 
	id="yahooRetriever" 
	class="org.sonatype.mavenbook.weather.YahooRetriever"/>

    <bean 
	id="yahooParser" 
	class="org.sonatype.mavenbook.weather.YahooParser"/>

./simple-parent/simple-command/src/test/resources/ny-weather.xml
./simple-parent/simple-model/src/test/resources/ny-weather.xml

/ Lees	over AnnotationSessionFactoryBean	,
http://stackoverflow.com/questions/8565051/spring-3-1-hibernate-4-sessionfactory


 
/ Einde SPRING MAVEN BOOK HIBERNATE APPL 

/ SPRING MVC SPRING BOOK

/ we lezen spring book, en proberen mvc in maven book hibernate appl te begrijpen, ch-multi-spring-postgres	, 

/ we kijken in simple-webapp/	,

/ 7	. 

/ (493) 

$ vi WEB-INF/web.xml
 <servlet>
    <servlet-name>weather</servlet-name>
    <servlet-class>
      org.springframework.web.servlet.DispatcherServlet
    </servlet-class>

/ Dus hij automatisch loads Spring config file   WEB-INF/weather-servlet.xml	, omdat de dispatcher servlet zo heet	, weather	,
/ Deze is er inderdaad	, hierin zijn de controllers en urlmapping als Spring beans def	, dus de mvc spring beans staan config in WEB-INF/ , logisch	,

/ Deze inj andere beans, die dao's of service's zijn	, deze staan in andere Spring config files, 
/ deze geef je ook op in WEB-INF/web.xml	,

$ vi WEB-INF/web.xml
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
 <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>
      classpath:applicationContext-weather.xml
      classpath:applicationContext-persist.xml

/ bij ons	,
$ vi WEB-INF/web.xml
 <servlet-mapping>
    <servlet-name>weather</servlet-name>
    <url-pattern>*.x</url-pattern>
/ ipv	 in Spring book,
    <url-pattern>*.htm</url-pattern>
/ TODO (Als je weglaat)	,

/ de page controller geef je  in url mappings	,

$ vi WEB-INF/weather-servlet.xml

<beans>  
    <bean id="urlMapping" 
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
          <property name="urlMap">
               <map>
                    <entry key="/weather.x">
                         <ref bean="weatherController" />
                    </entry>
                    <entry key="/history.x">
                         <ref bean="historyController" />

/ De dispatcher servlet stuurt de request naar de juiste controller, afh welke url je geeft 	,
  
$ vi WEB-INF/weather-servlet.xml

<beans>  
     <bean id="weatherController" 
           class="org.sonatype.mavenbook.web.WeatherController">
       <property name="weatherService" ref="weatherService"/>
       <property name="weatherDAO" ref="weatherDAO"/>
     </bean>



/ 7	. 

/ Geef	,
http://localhost:8080/simple-webapp/weather.x?zip=60203

/ we zien in de db	,
foo=> select*from location;
  zip  |   city   | country | region 
-------+----------+---------+--------
 60202 | Evanston | US      | IL
 60203 | Evanston | US      | IL
(2 rows)

/ history.x?zip=... kun je alleen geven als je voor deze zip weather.x?zip=... al hebt gegeven	,

/ Evanston ligt bij Chicago	,

/ Kijk op	,
http://www.unitedstateszipcodes.org/

/ Geef	,
http://localhost:8080/simple-webapp/weather.x?zip=10007

/ we zien	,
Current Weather Conditions for: New York, NY, US
Temperature: 40
Condition: Partly Cloudy
Humidity: 51
Wind Chill: 34
Date: Tue Dec 02 08:57:43 CET 2014

/ we zien	,

foo=> select*from location;
  zip  |   city   | country | region 
-------+----------+---------+--------
 60202 | Evanston | US      | IL
 60203 | Evanston | US      | IL
 10007 | New York | US      | NY
(3 rows)

/ 7	. 

$ vi WeatherController.java

	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
...
		return new ModelAndView("weather", "weather", weather);
/ 1ste "weather" is voor view resolver (TODO)
/ 2de ("weather", weather) , key="weather" is used in view	, en value=weather (TODO)




/ 7	.






/ Einde SPRING MVC SPRING BOOK

/ SPRING HIBERNATE 

/ we zien merge proj, z'n parent is hibernate-book proj	, die is er ook	, daar zien we de pom.xml	,

/ Lees Chapter 15. Criteria Queries	, 15.8 Detached queries and subqueries in Hibernate docs	,

DetachedCriteria query = DetachedCriteria.forClass(Cat.class).add( Property.forName("sex").eq('F') );
Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();






/ Einde SPRING HIBERNATE 

/ MPO

/ nieuw LDAP password	,
eric123@MPO

/ Einde MPO

/ HIBERNATE JMX

/ Geef in google, 
spring jmx hibernate
/ Lees	,
http://stackoverflow.com/questions/5930803/exposing-hibernate-cache-statistics-through-jmx-with-spring-in-tomcat

/ Geef in google	,
jboss jmx hibernate
/ Lees	,
https://access.redhat.com/documentation/en-US/JBoss_Operations_Network/2.4/html/Resource_Monitoring_and_Operations_Reference/Hibernate_Statistics_Service.html







/ Einde HIBERNATE JMX

/ WICKET SPRING

/ we zien	,

public abstract class Application
extends Object
implements ISessionStore.UnboundListener, IEventSink
public final ComponentInstantiationListenerCollection getComponentInstantiationListeners()


public class ComponentInstantiationListenerCollection
extends ListenerCollection<IComponentInstantiationListener>
implements IComponentInstantiationListener

/ TODO



/ Einde WICKET SPRING

/ SPRING XML

/ we hebben projects spring_knight	, spring_intro (annots)	,

/ we maken spring_book	, in eclipse	,
/ new maven project	, 
/ location: /home/eric/Devel/Java/Spring	,

/ org.apache.maven.archetypes:maven-archetype-quickstart	,

/ my.test.own:spring-book	,

/ we moeten wel	,
/ right click spring-book proj	, new , source folder	,
src/main/resources
src/test/resources


/ lees	,
http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/index.html

/ 7	.

/ AUTOWIRED BY NAME

/ we inject in HomeImpl bean een andere bean en een string,

$ vi spring-book.xml

   <bean 
    	id="home" 
    	class="my.test.own.spring_book.HomeImpl"
    	autowire="byName"
    >
        <constructor-arg name="name" value="Foo Bar" />
        <property name="age" value="52"/>
    </bean>	

    <bean
    	id="my"
    	class="my.test.own.spring_book.MyImpl"
    >
    </bean> 
    
    <bean
    	id="my2"
    	class="my.test.own.spring_book.MyImpl2"
    >
    </bean>

$ vi App.java

       	ApplicationContext applicationContext=new ClassPathXmlApplicationContext("spring-book.xml");
        {
        Home home=(Home)applicationContext.getBean("home");
        String string=home.say();
        }

$ vi Home.java

public interface Home {
	String say();

}

$ vi HomeImpl.java

	private My my;
	private My my2;

	public My getMy() {
		return my;
	}
	public void setMy(My my) {
		this.my = my;
	}
	
	public My getMy2() {
		return my2;
	}
	public void setMy2(My my2) {
		this.my2 = my2;
	}

$ vi My.java

public interface My {
	String say(String s,int i);
}

$ vi MyImpl.java

public class MyImpl implements My {

	public String say(String s,int i) {
		return "MyImpl "+s+","+i;
	}

}

$ vi MyImpl2.java

public class MyImpl2 implements My {

	public String say(String s,int i) {
		return "MyImpl2 "+s+","+i;
	}

////////////////////////////////////////////////////////// 
   <bean 
 		class="my.test.own.spring_book.HomeImpl"
    	autowire="byName"
/ is als
   <bean 
     	<property name="my" ref="my"/>	
     	<property name="my2" ref="my2"/>	

/ name="my"  is de naam van de property in de bean van type HomeImpl	, en die zien we in setMy en setMy2, dus  my en my2	,
/ ref is de id van de bean die wordt inject , zien we in <bean id="my" class=...> en <bean id="my2" class=...>

/ Dus de property name in de bean type = id van de bean in de config file	,
///////////////////////////////////////////////////////////

/ 13	. 

/ als we in dit voorbeeld autowired="byType", dan ERR, 
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'home' defined in class path resource [spring-book.xml]: Unsatisfied dependency expressed through bean property 'my': : No qualifying bean of type [my.test.own.spring_book.My] is defined: expected single matching bean but found 2: my,my2; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [my.test.own.spring_book.My] is defined: expected single matching bean but found 2: my,my2

aused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [my.test.own.spring_book.My] is defined: expected single matching bean but found 2: my,my2

$ vi HomeImpl.java

	public void setMy(My my) {
		this.my = my;
	}

$ vi spring-book.xml

  <bean
    	id="my"
    	class="my.test.own.spring_book.MyImpl"
    	
    >
    </bean> 
    
    <bean
    	id="my2"
    	class="my.test.own.spring_book.MyImpl2"
    	
    >

/ HomeImpl heeft properties my en my2 van (interface) type My	, we zien dit aan setMy en setMy2	,
/ Er zijn 2 candidates	, de beans met id my en my2	, 
/ beide beans hebben (interface) type My	,
/////////////////////////////////////////////////////////

/ HomeImpl heeft ook property my2	, en daar geldt hetzelfde probleem, maar daar komt de ERR msg niet eens	,



/ Einde AUTOWIRED BY NAME

/ 13	. 

/ AUTOWIRED BY TYPE

/ we veranderen	,

$ vi spring-book.xml

   	id="home" 
    	class="my.test.own.spring_book.HomeImpl"
    	autowire="byType"
    >

/ we moeten als enige aanpassen	,

$ vi HomeImpl.java

	private My2 my2;
	
	public My2 getMy2() {
		return my2;
	}
	public void setMy2(My2 my2) {
		this.my2 = my2;
	}

$ vi My2.java

public interface My2 {
	String say(String s,int i);
}

$ vi MyImpl2.java

public class MyImpl2 implements My2 {
...

/ Einde AUTOWIRED BY TYPE

/ AUTOWIRE BY CONSTRUCTOR

/ we maken een 2de Home-bean	, HomeImpl2	,

$ vi spring-book.xml

   <bean
    	id="age"
    	class="java.lang.Integer"
    >
    	<constructor-arg value="53"></constructor-arg>
    </bean>
    
       <bean
    	id="name"
    	class="java.lang.String"
    >
    	<constructor-arg value="Bar Baz"></constructor-arg>
    </bean>
    
    <bean 
    	id="home2" 
    	class="my.test.own.spring_book.HomeImpl2"
    	autowire="constructor"
    >
    </bean>	

$ vi HomeImpl2.java

public class HomeImpl2 implements Home {

	private My my;
	private My2 my2;
	private String name;
	private int age;

	public HomeImpl2(String name,My my,My2 my2,int age) {
		this.my=my;
		this.my2=my2;
		this.name=name;
		this.age=age;
	}

/ OK	,
/ we zien	,

337  INFO  App  - 
MyImpl Bar Baz,53



/ Einde AUTOWIRE BY CONSTRUCTOR

/ SPRING SCHEMA

/ Lees	,
http://www.springframework.org/schema/beans/spring-beans-4.1.xsd

<xsd:group name="beanElements">
<xsd:sequence>
<xsd:element ref="description" minOccurs="0"/>
<xsd:choice minOccurs="0" maxOccurs="unbounded">
<xsd:element ref="meta"/>
<xsd:element ref="constructor-arg"/>
<xsd:element ref="property"/>
<xsd:element ref="qualifier"/>
<xsd:element ref="lookup-method"/>
<xsd:element ref="replaced-method"/>
<xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
</xsd:choice>
</xsd:sequence>
</xsd:group>
<xsd:attributeGroup name="beanAttributes">
<xsd:attribute name="name" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="class" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="parent" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="scope" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="abstract" type="xsd:boolean">...</xsd:attribute>
<xsd:attribute name="lazy-init" default="default" type="defaultable-boolean">...</xsd:attribute>
<xsd:attribute name="autowire" default="default">...</xsd:attribute>
<xsd:attribute name="depends-on" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="autowire-candidate" default="default" type="defaultable-boolean">...</xsd:attribute>
<xsd:attribute name="primary" type="xsd:boolean">...</xsd:attribute>
<xsd:attribute name="init-method" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="destroy-method" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="factory-method" type="xsd:string">...</xsd:attribute>
<xsd:attribute name="factory-bean" type="xsd:string">...</xsd:attribute>
<xsd:anyAttribute namespace="##other" processContents="lax"/>
</xsd:attributeGroup>

<xsd:element name="bean">
<xsd:annotation>...</xsd:annotation>
<xsd:complexType>
<xsd:complexContent>
<xsd:extension base="identifiedType">
<xsd:group ref="beanElements"/>
<xsd:attributeGroup ref="beanAttributes"/>
</xsd:extension>
</xsd:complexContent>
</xsd:complexType>
</xsd:element>

<xsd:element name="constructor-arg">
<xsd:annotation>
<xsd:documentation source="java:org.springframework.beans.factory.config.ConstructorArgumentValues">
<![CDATA[
Bean definitions can specify zero or more constructor arguments. This is an alternative to "autowire constructor". Arguments correspond to either a specific index of the constructor argument list or are supposed to be matched generically by type. Note: A single generic argument value will just be used once, rather than potentially matched multiple times (as of Spring 1.1). constructor-arg elements are also used in conjunction with the factory-method element to construct beans using static or instance factory methods.
]]>
</xsd:documentation>
</xsd:annotation>
<xsd:complexType>
<xsd:sequence>
<xsd:element ref="description" minOccurs="0"/>
<xsd:choice minOccurs="0" maxOccurs="1">
<xsd:element ref="bean"/>
<xsd:element ref="ref"/>
<xsd:element ref="idref"/>
<xsd:element ref="value"/>
<xsd:element ref="null"/>
<xsd:element ref="array"/>
<xsd:element ref="list"/>
<xsd:element ref="set"/>
<xsd:element ref="map"/>
<xsd:element ref="props"/>
<xsd:any namespace="##other" processContents="strict"/>
</xsd:choice>
</xsd:sequence>


/ Einde SPRING SCHEMA

/ 13	.

/ we kunnen ook ctor-inject	,

$ vi HouseImpl.java

	public HouseImpl(String name) {
		this.name=name;
	}

$ vi spring-book.xml

  <bean 
    	id="house" 
    	class="my.test.own.spring_book.HouseImpl"
    >
        <property name="my" ref="my"/>
        <constructor-arg name="name" value="Foo Bar" />
        <property name="age" value="52"/>
    
    </bean>

/ We hoeven geen HouseImpl() ctor te def, want die uses Spring niet, 
/ maar als we MyImpl(String string) ctor alleen def, ERR, Spring heeft My() def ctor nodig	, 

/ 7	.


/ by type	,

$ vi spring-book.xml

    <bean 
    	id="house" 
    	class="my.test.own.spring_book.HouseImpl"
    	autowire="byType"
    >
        <constructor-arg name="name" value="Foo Bar" />
        <property name="age" value="52"/>
    
    </bean>

    <bean
    	id="my"
    	class="my.test.own.spring_book.MyImpl"
    	
    >
    </bean>

    <bean
    	id="my2"
    	class="my.test.own.spring_book.MyImpl2"
    >
    </bean>

/ we zien	, omdat er 2 kandidaten zijn	,

Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [my.test.own.spring_book.My] is defined: expected single matching bean but found 2: my,my2

/ 13	.

http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-autowire
/ 5.4.5
/ autowire	,

/ We hebben in spring-book in WorkImpl een autowire="constructor"	,
/ we hebben 2 My impls	, MyImpl, MyImpl2	,
/ dan kijkt hij naar de name van de arg	, 

public class WorkImpl implements Work {

	private You you;

	public WorkImpl(You you2) {
		this.you=you2;

	}

    <bean
    	id="you"
    	class="my.test.own.spring_book_annotations.YouImpl"
    >
    </bean>
    
    <bean
    	id="you2"
    	class="my.test.own.spring_book_annotations.YouImpl2"
    >
    </bean>

/ er zijn 2 kandidaten,  omdat hun type klopt	, dan kijkt hij naar de arg name	, en nu pakt hij dus YouImpl2, dus wordt er new YouImpl2 gedaan, 

/ als we 
    <bean
    	id="you2"
    	class="my.test.own.spring_book_annotations.YouImpl2"
    	autowire-candidate="false"
    >
    </bean>

/ dan pakt Spring YouImpl	, ondanks dat	,
	public WorkImpl(You you2) {
		this.you=you2;
	}

/ ook als er staat	,
	public WorkImpl(You you3) {
		this.you=you3;
	}
/ dan pakt hij YouImpl	,

/ 13	.




/ Einde SPRING XML

/ SPRING ANNOTATIONS 

/ Lees	,
http://www.journaldev.com/2410/spring-dependency-injection-example-with-annotations-and-xml-configuration

/ Lees,
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-autowire
/ 5.2.1 Configuration metadata	,
/ we zien de link 'Java-based configuration'	,
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-java
/ TODO

/ Lees	,
http://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-vs-contextcomponent-scan
/ Lees	,
http://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-annotation-config
/ Lees	,
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-autowire

/ Lees	,
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-annotation-config

/ MORGEN	,
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-annotation-config
http://www.javabeat.net/difference-resource-autowired-inject-spring-injection/
http://blogs.sourceallies.com/2011/08/spring-injection-with-resource-and-autowired/



/ we moeten 	,

$ vi spring-book-annotations.xml

<beans 
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"				/ !
    xsi:schemaLocation="http://www.springframework.org/schema/beans	
    	http://www.springframework.org/schema/beans/spring-beans.xsd
    	http://www.springframework.org/schema/context 						/ !
    	http://www.springframework.org/schema/context/spring-context.xsd"
>

    <context:annotation-config></context:annotation-config>
	
    <bean 
    	id="house" 
    	class="my.test.own.spring_book_annotations.HouseImpl"
    >
        <constructor-arg name="name" value="Foo Bar" />
        <property name="age" value="52"/>
    </bean>
<!--
	autowire="byName"
-->

    <bean
    	id="my"
    	class="my.test.own.spring_book_annotations.MyImpl"
    >
    </bean> 
    
    <bean
    	id="my2"
    	class="my.test.own.spring_book_annotations.MyImpl2"
    >
    </bean>

$ vi HouseImpl.java 

public class HouseImpl implements House {

	private My my;
	public My getMy() {
		return my;
	}
	@Autowired
	public void setMy(My my) {
		this.my = my;
	} 

/ 7	. 

/ We kunnen @Autowired vervangen door @Inject	, 
/ we hoeven in spring config file NIETS te doen, zoals wel voor @Autowired met context, maar we moeten wel een POM dep add	,
	<dependency>
	    <groupId>javax.inject</groupId>
	    <artifactId>javax.inject</artifactId>
	    <version>1</version>
	</dependency>

/ 7	. 

/ @Autowired setMy(...)	, dus op een setter	,

/ Zonder annots	, dus 
<bean 	id="house" 
	class="...HouseImpl"
	autowired="byName"
> 
/ bepaalt de property name welke  bean wordt inject	,

/ Hier wordt <bean id="my2" class="...MyImpl2" inject	,
	public void setMy2(My my) {
		this.my = my;
	}

/ Als er @Autowired op staat, bepaalt de name van het arg welke bean wordt inject,	

/ Hier wordt dus bean <bean id="my" class="...MyImpl>  inject	, 

public class HouseImpl implements House {
	@Autowired
	public void setMy2(My my) {
		this.my = my;
	}

/ Hier wordt dus bean <bean id="my2" class="...MyImpl2>  inject	, 
	@Autowired
	public void setMy2(My my2) {
		this.my = my2;
	}

/ 7	. 

/ op een ctor werkt het wel precies als 	, 
<bean 
	id="work" 
    	class="my.test.own.spring_book_annotations.WorkImpl"
 	autowire="constructor"
>
</bean>

/ nu wordt <bean id="you2" class="...YouImpl2"> inject	,
public class WorkImpl implements Work {
	@Autowired
	public WorkImpl(You you2) {
		this.you=you2;

	}

/ nu wordt <bean id="you" class="...YouImpl"> inject	,
public class WorkImpl implements Work {
	@Autowired
	public WorkImpl(You you) {
		this.you=you;

	}

/ 7	.

$ vi HouseImpl.java
	@Autowired
	private My my2;
	public My getMy() {
		return my2;
	}

	public void setMy(My my) {
		this.my2 = my;
	}

/ Nu wordt <bean id="my2" class="...MyImpl2"> inject	, dus hij kijkt naar de name van de var	,

/ 7	.

/ Dus nogmaals	, 

$ vi HouseImpl.java
	private My my2;
	public My getMy2() {
		return my2;
	}
	@Autowired
	public void setMy2(My my) {
		this.my2 = my;
	}

/ Nu wordt <bean id="my" class="...MyImpl"> inject	,

/ 7	.

/ SAMENVATTING

/ spring-book project

/ 13	. 

/ setter inj	,

$ vi HouseImpl.java

	private My my;
	public void setMy2(My my) {
		this.my = my;
	}


$ vi spring-book.xml

    <bean 
    	id="house" 
    	class="my.test.own.spring_book.HouseImpl"
    	autowire="byName"
    >
...
    </bean>


    <bean
    	id="my"
    	class="my.test.own.spring_book.MyImpl"
    	
    >
    </bean> 
    
    <bean
    	id="my2"
    	class="my.test.own.spring_book.MyImpl2"
    	
    >
    </bean>

/ Als we autowire="byName"	, dan wordt MyImpl2 inject,	 want de property heet my2, omdat de setter zo heet	,

/ Als we autowire="byType", hebben we ERR, want er zijn er 2	,

/ 13	. 

/ ctor inj	,

$ vi WorkImpl.java

	private You you;
	public WorkImpl(You you2) {
		this.you=you2;
	}

$ vi spring-book.xml

   <bean
    	id="you"
    	class="my.test.own.spring_book.YouImpl"
    >
    </bean>
    
    <bean
    	id="you2"
    	class="my.test.own.spring_book.YouImpl2"
    >
    </bean>

/ ctor kijkt eerst naar de type	, als we meer zijn, dan kijkt hij naar de name van ctor arg	, dus hier zal hij YouImpl2 inj	,

/ 13	. 

/ project spring-book-annotations

$ vi HouseImpl.java

	private My my2;
	
	@Autowired
	public void setMy2(My my) {
		this.my2 = my;
	}

$ vi spring-book-annotations.xml

	<context:annotation-config></context:annotation-config>

   <bean 
    	id="house" 
    	class="my.test.own.spring_book_annotations.HouseImpl"
    >
...
    </bean>

   <bean
    	id="my"
    	class="my.test.own.spring_book_annotations.MyImpl"
	autowire-candidate="true/false"
    >
    </bean> 
    
    <bean
    	id="my2"
    	class="my.test.own.spring_book_annotations.MyImpl2"
    >
    </bean>

////////////////////////////////////////////////
/ @Autowired op setter is als ctor inj bij XML	,

/ Dus op een setter kijkt hij NIET naar de property name my2 in dit geval	, hij kijkt naar type van arg, My hier 	, en inj een inst	, als er meerdere zijn kijkt hij naar de name van arg	, 

/ we kunnen ook	,
	@Autowired
	private My my;

/ Hij kijkt naar de type, My dus	, en als er meerdere zijn, kijkt hij naar de name van de var	, 
/ dus als var my heet, en we autowire-candidate="false" de id="my" bean, dan inj hij MyImpl2	, als we autowire-candidate="true" de id="my" bean, dan inj hij de id="my" bean, omdat de var zo heet	,



/ 7	. 

////////////////////////////////////////////
/ @Resource = byName in XML	,

$ vi HouseImpl.java

	private My my;
	
	public My getMy2() {
		return my;
	}
	@Resource
	public void setMy2(My my) {
		this.my = my;
	}

$ vi spring-book-annotations.xml

   <bean
    	id="my"
    	class="my.test.own.spring_book_annotations.MyImpl"
    >
    </bean> 
    

    <bean
    	id="my2"
    	class="my.test.own.spring_book_annotations.MyImpl2"
    >
    </bean>

/ Spring inst een MyImpl2 	, want de prop heet my2	, omdat setMy2	,

/ @Resource is byName	, en kan niet op een ctor	,

/ Einde SAMENVATTING



/ 7	. 

/ spring-book-annotations project	, 

/ qualifier	,

$ vi HouseImpl.java

	private My my;
	
	@Autowired 
	@Qualifier("sub")
	public void setMy2(My my) {
		this.my = my;
	}

$ vi spring-book-annotations.xml

	<context:annotation-config></context:annotation-config>

    
    <bean
    	id="my"
    	class="my.test.own.spring_book_annotations.MyImpl"
    >
    	<qualifier value="main"></qualifier>
    </bean> 
    
    <bean
    	id="my2"
    	class="my.test.own.spring_book_annotations.MyImpl2"
    >
        	<qualifier value="sub"></qualifier>
    
    </bean>

/ Gezien de type My zijn er 2 mog	, maar de qualifier zegt dat hij de MyImpl2 inst moet inj	,

/ 7	. 

/ lees	,
/ geef in google	,
spring @Resource
http://blogs.sourceallies.com/2011/08/spring-injection-with-resource-and-autowired/
http://www.javabeat.net/difference-resource-autowired-inject-spring-injection/

/ @Resource is in Java 7	, 
$ vi pom.xml
...
 <properties>
...
    <compiler.version>3.2</compiler.version>
  </properties>
  <build>
  	<plugins>
  		<plugin>
  			<groupId>org.apache.maven.plugins</groupId>
        		<artifactId>maven-compiler-plugin</artifactId>
        		<version>${compiler.version}</version>
        		<configuration>
          			<source>1.7</source>
          			<target>1.7</target>
        		</configuration>
  		</plugin>
  	</plugins>
  </build>

$ vi HouseImpl.java

	private My my;
	
	public My getMy2() {
		return my;
	}
	@Resource
	public void setMy2(My my) {
		this.my = my;
	}

$ vi spring-book-annotations.xml

   <bean
    	id="my"
    	class="my.test.own.spring_book_annotations.MyImpl"
    >
    </bean> 
    

    <bean
    	id="my2"
    	class="my.test.own.spring_book_annotations.MyImpl2"
    >
    </bean>

/ Spring inst een MyImpl2 	, want de prop heet my2	, omdat setMy2	,

/ @Resouce is byName	, en kan niet op een ctor	,

/ 7	.

/ we kunnen @Component use, ipv in XML <bean id="..." class="...">

/ 13	. 

/ er is 1 impl type voor intf type My	,

$ vi HouseImpl.java

	private My my;
	@Autowired
	public void setMy(My my) {
		this.my = my;
	}

$ vi MyImpl.java

@Component
public class MyImpl implements My {

$ vi MyImpl2.java

@Component
public class MyImpl2 implements My22 {


$ vi spring-book-annotations2.xml

 		<context:component-scan base-package="my.test.own.spring_book_annotations2"></context:component-scan>

/ Deze is overbodig geworden	,
<!-- 	<context:annotation-config></context:annotation-config>
 -->	

/ Deze is overbodig geworden	,
<!--    <bean
    	id="my"
    	class="my.test.own.spring_book_annotations2.MyImpl"
    	
    >
    </bean> 
    
    <bean
    	id="my2"
    	class="my.test.own.spring_book_annotations2.MyImpl2"
    	
    >
    </bean> -->

/ een inst van MyImpl wordt inj	, want alleen MyImpl impl My	,

/ 13	. 

/ Als we meerdere impl types hebben van My	, moeten we @Qualifier use	,

$ vi HouseImpl.java

	private My my;
	@Autowired
	@Qualifier("my2")
	public void setMy(My my) {
		this.my = my;
	}

$ vi MyImpl.java

@Component
@Qualifier("my")
public class MyImpl implements My {

$ vi MyImpl2.java

@Component
@Qualifier("my2")
public class MyImpl2 implements My{

/ Een inst van MyImpl2 wordt inj,  want er zijn nu 2 types, MyImpl en MyImpl2	, en de qualifier zegt dat het MyImpl2 moet zijn	,

/ 7	.

/ @Bean op een producer method	,

/ 13	. 

/ als we een producer method maken, kunnen we de impl type NIET als bean annot met @Component	, als we dat WEL doen, krijgen we not unique exc	,
/ maar als we het inderdaad WEL doen, moeten we met @Qualifier werken 	,


$ vi HouseImpl.java

	private My my;
	@Autowired
	public void setMy(My my) {
		this.my = my;
	}

$ vi MyImpl.java

public class MyImpl implements My {

$ vi MyProducer.java

@Component
public class MyProducer {
	@Bean
	public My getMy(){
		return new MyImpl();
	}
}

/ OK

/ 13	. 

/  We maken MyImpl toch ook tot een bean	,

$ vi HouseImpl.java

	private My my;
	@Autowired
	@Qualifier("myp")
	public void setMy(My my) {
		this.my = my;
	}

$ vi MyImpl.java

@Component
@Qualifier("my")
public class MyImpl implements My {


$ vi MyProducer.java

@Component
public class MyProducer {
	@Bean
	@Qualifier("myp")
	public My getMy(){
		return new MyImpl();
	}
}

/ OK

/ 7	.


 


/ Einde SPRING ANNOTATIONS 

/ AWK

/ 7	. 

/ we hebben log file met stack traces	,
/ we willen alleen de 'at com.mpbojects....' zien, en omdraaien	,


/ count lines	,
calhost LOGS]$ awk  '$0 ~ "\tat "{count++}END{print count}' LOG_MPO_81.txt 
2211
[eric@localhost LOGS]$ awk  'BEGIN{count=0}$0 ~ "\tat com.mpobjects"{count++}END{print count}' LOG_MPO_81.txt 
204

/ rm at org.springframework, at sun.... de rest zo laten	,
[eric@localhost LOGS]$ awk  '$0 ~ "at com.mpobjects"{print}$0 ~ "\tat " && $0 !~ "\tat com.mpobjects"{}$0 !~ "\tat "{print}' LOG_MPO_81.txt 

/ draai een stacktrace om 	, die op bepaalde regels staat	,
[eric@localhost LOGS]$ awk  '810<=NR && NR<=1147 && $0~"at com.mpobjects"' LOG_MPO_81.txt | awk '{l[n++]=$0}END{while(n--)print l[n]}'





/ Einde AWK

/ SELENIUM

/ 7	.

/ lees	,

https://sites.google.com/a/chromium.org/chromedriver/getting-started

http://docs.seleniumhq.org/docs/03_webdriver.jsp
https://code.google.com/p/selenium/wiki/ChromeDriver

/ we doen eerst vb van 03_webdriver.jsp, 
/ op getting-started staan ook voorbeelden (later), en hoe het moet met de chromedriver	 start, doen we nu al	, 

/ 7	.

/ Lees	,
https://code.google.com/p/selenium/issues/detail?id=2960

package org.openqa.selenium.support.ui;

public interface ExpectedCondition<T>  extends com.google.common.base.Function<org.openqa.selenium.WebDriver,T> {
}
The issue was ExpectedCondition interface extends com.google.common.base.Function that is present only in google-collections.jar. 

/ Is nu guava	,

/ 7	.

$ vi Selenium2Example.java

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.WebDriverWait;

public class Selenium2Example  {
    public static void main(String[] args) {
        // Create a new instance of the Firefox driver
        // Notice that the remainder of the code relies on the interface,
        // not the implementation.
        //System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");
        WebDriver driver = new ChromeDriver();

        // And now use this to visit Google
        driver.get("http://www.google.com");
        // Alternatively the same thing can be done like this
        // driver.navigate().to("http://www.google.com");

        // Find the text input element by its name
        WebElement element = driver.findElement(By.name("q"));

        // Enter something to search for
        element.sendKeys("Cheese!");

        // Now submit the form. WebDriver will find the form for us from the element
        element.submit();

        // Check the title of the page
        System.out.println("Page title is: " + driver.getTitle());

        // Google's search is rendered dynamically with JavaScript.
        // Wait for the page to load, timeout after 10 seconds
        (new WebDriverWait(driver, 10)).until(new ExpectedCondition<Boolean>() {
            public Boolean apply(WebDriver d) {
                return d.getTitle().toLowerCase().startsWith("cheese!");
            }
        });
        // Should see: "cheese! - Google Search"
        System.out.println("Page title is: " + driver.getTitle());

        //Close the browser
        driver.quit();
    }
}


[eric@localhost Selenium]$ javac -g -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar  Selenium2Example.java 

/ lees	,
https://sites.google.com/a/chromium.org/chromedriver/getting-started

/ 7	. 

/ via	,
https://sites.google.com/a/chromium.org/chromedriver/getting-started
/ Lees	,
https://code.google.com/p/selenium/wiki/GettingStarted

/ 7	.

[eric@localhost Selenium]$ java -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:.  Selenium2Example
Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/http/protocol/HttpContext


/ Geef in google	,
jar org/apache/http/protocol/HttpContext
/ we zien httpcore	, we geven in google	,
httpcore jar
/ we komen op	,
https://hc.apache.org/downloads.cgi
[eric@localhost Selenium]$  pwd
/home/eric/Devel/Java/Selenium
[eric@localhost Selenium]$ tar xvzf ~/Downloads/httpcomponents-core-4.3.3-bin.tar.gz 

[eric@localhost Selenium]$ java -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:.:./httpcomponents-core-4.3.3/lib/httpcore-4.3.3.jar  Selenium2Example
Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/http/auth/Credentials
/ we moeten httpclient jar hebben,	
/ we komen weer op 	,
https://hc.apache.org/downloads.cgi
/ we doen	,
[eric@localhost Selenium]$  tar xvzf ~/Downloads/httpcomponents-client-4.3.6-bin.tar.gz 

[eric@localhost Selenium]$ java -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:.:./httpcomponents-core-4.3.3/lib/httpcore-4.3.3.jar:./httpcomponents-client-4.3.6/lib/httpclient-4.3.6.jar  Selenium2Example
Exception in thread "main" java.lang.NoClassDefFoundError: com/google/gson/JsonParseException

/ we komen op 	,
https://code.google.com/p/google-gson/
/ we download van search.maven.org	,

[eric@localhost Selenium]$ java -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:.:./httpcomponents-core-4.3.3/lib/httpcore-4.3.3.jar:./httpcomponents-client-4.3.6/lib/httpclient-4.3.6.jar:./gson-2.3.jar  Selenium2Example
Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory

/we geven in google,
jar org/apache/commons/logging/LogFactory
/ we doen	,
[eric@localhost Selenium]$ tar xvzf ~/Downloads/commons-logging-1.2-bin.tar.gz 

[eric@localhost Selenium]$ java -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:.:./httpcomponents-core-4.3.3/lib/httpcore-4.3.3.jar:./httpcomponents-client-4.3.6/lib/httpclient-4.3.6.jar:./gson-2.3.jar:./commons-logging-1.2/commons-logging-1.2.jar  Selenium2Example
Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/commons/exec/Executor

[eric@localhost Selenium]$ tar xvzf ~/Downloads/commons-exec-1.3-bin.tar.gz 

[eric@localhost Selenium]$ getsebool -a
unconfined_chrome_sandbox_transition --> on


/ Uiteindelijk	,

$ sudo setsebool -P unconfined_chrome_sandbox_transition 0
/ Helpt NIET	,

# grep chrome /var/log/audit/audit.log | audit2allow -M mypol
# semodule -i mypol.pp
/ TODO

# grep chronyd /var/log/audit/audit.log | audit2allow -M mypol
# semodule -i mypol.pp


/////////////////////
/ SELENIUM JAVA
[eric@localhost Selenium]$  java -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:.:./httpcomponents-core-4.3.3/lib/httpcore-4.3.3.jar:./httpcomponents-client-4.3.6/lib/httpclient-4.3.6.jar:./gson-2.3.jar:./commons-logging-1.2/commons-logging-1.2.jar:./commons-exec-1.3/commons-exec-1.3.jar  Selenium2Example
Starting ChromeDriver 2.12.301324 (de8ab311bc9374d0ade71f7c167bad61848c7c48) on port 23538
Only local connections are allowed.
[0.617][WARNING]: PAC support disabled because there is no system implementation
Page title is: Google
Page title is: Cheese! - Google zoeken

/ we hoeven chromedriver niet zelf te start	, dat doet deze appl (onder een andere pprt dan 9515)	,



/ Dit hoeft NIET	,
/ we kunnen	,
[eric@localhost Selenium]$ PATH=$PATH:$(pwd)/chromedriver
/ of	, 
      	System.setProperty("webdriver.chrome.driver", "/home/eric/Devel/Java/Selenium/chromedriver");
        WebDriver driver = new ChromeDriver();

/ Wat is deze site	?
https://code.google.com/p/chromedriver/issues/detail?id=539

/ Lees	,
http://blog.varunin.com/2011/10/running-tests-on-google-chrome-using.html

/ Zoek op	,
selenium chrome automation extension has crashed


/ Einde SELENIUM

/ SELENIUM JUNIT

http://stackoverflow.com/questions/16893229/selenium-webdriver-and-junit-class-design
https://code.google.com/p/selenium/wiki/PageObjects

/ 7	. 

/ selenium ide	, 

[eric@localhost Selenium]$ pwd
/home/eric/Devel/Java/Testing/Selenium


/ Ga naar in firefox 	,
http://www.seleniumhq.org/download/
/ In het midden bij Selenium IDE zien we de link 2.8.0	,  click, hij installs ...

/ er verschijnt een icon rechts , click
/ click Options, options
Enable experimental features: check
Start recording immediately on open: check

/ hij is recording	, click wat	,

Options , format	, 
/ kies Java/JUnit4/Webdriver
/ kies daarna	,
File , save test case 
...
/ TODO

/ we cp de MyTestCase.java naar 	,
[eric@localhost Selenium]$ pwd
/home/eric/Devel/Java/Selenium
[eric@localhost Selenium]$ ls
chromedriver         gson-2.3.jar           httpcomponents-client-4.3.6  MyTestCase.class  Selenium2Example$1.class
commons-exec-1.3     guava-18.0.jar         httpcomponents-core-4.3.3    MyTestCase.java   Selenium2Example.class
commons-logging-1.2  hamcrest-core-1.3.jar  junit-4.12.jar               selenium-2.44.0   Selenium2Example.java

/ we hebben ook junit-4.12.jar, hamcrest-core-1.3.jar download	,

[eric@localhost Selenium]$ javac -g -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:./junit-4.12.jar:./hamcrest-core-1.3.jar  MyTestCase.java 
[eric@localhost Selenium]$  java -classpath ./selenium-2.44.0/selenium-java-2.44.0.jar:./guava-18.0.jar:.:./httpcomponents-core-4.3.3/lib/httpcore-4.3.3.jar:./httpcomponents-client-4.3.6/lib/httpclient-4.3.6.jar:./gson-2.3.jar:./commons-logging-1.2/commons-logging-1.2.jar:./commons-exec-1.3/commons-exec-1.3.jar:./junit-4.12.jar:./hamcrest-core-1.3.jar org.junit.runner.JUnitCore MyTestCase
/ OK

/ Ook MyTestCaseSecond	, MyTestCaseThird	,
/ Vergeet niet package in de .java files te rm	,


/ 7	. 

/ we maken in eclipse-interfacing-testing	,
/ workspace-tesing	,

/ maven project vlg maven-archetype-quickstart
my.test.own:testing-first

[eric@localhost Testing]$ ls
my.test.own  Selenium
[eric@localhost Testing]$ pwd
/home/eric/Devel/Java/Testing

/ 7	. 

/ Op	,
http://docs.seleniumhq.org/download/
/ we download	,
Selenium Client & WebDriver Language Bindings
Java	2.45.0	2015-02-26	Download  	Change log  	Ja...
/ click Download	,
selenium-java-2.44.0.zip

[eric@localhost Selenium]$ pwd
/home/eric/Devel/Java/Testing/Selenium
[eric@localhost Selenium]$ unzip ~/Downloads/selenium-java-2.44.0.zip 
[eric@localhost Selenium]$ ls selenium-2.44.0/
CHANGELOG  libs  selenium-java-2.44.0.jar  selenium-java-2.44.0-srcs.jar

/ In de selenium-java-2.44.0.jar zit ook ChromeDriver.class	,
[eric@localhost Selenium]$ jar tvf selenium-2.44.0/selenium-java-2.44.0.jar  | grep Chrome
  3316 Thu Oct 23 13:02:10 CEST 2014 org/openqa/selenium/chrome/ChromeDriver.class

/ Maar in de maven deps dit dat niet zo	, daar zitten ze apart	,

[eric@localhost repository]$ jar tvf org/seleniumhq/selenium/selenium-java/2.45.0/selenium-java-2.45.0.jar | grep -i chrome
[eric@localhost repository]$ jar tvf org/seleniumhq/selenium/selenium-chrome-driver/2.45.0/selenium-chrome-driver-2.45.0.jar | grep -i chrome
  3308 Fri Feb 27 09:11:42 CET 2015 org/openqa/selenium/chrome/ChromeDriver.class

/ 7	. 

/ Op http://docs.seleniumhq.org/download/	, we zien	,
Third Party Drivers, Bindings, and Plugins
Chrome	 2.14	...
/ click op 2.14	,
/ we download van	,
http://chromedriver.storage.googleapis.com/index.html?path=2.14/
-rw-r-----. 1 eric eric   2162844 Nov 13 16:34 chromedriver_linux64.zip
/ we cp chromedriver naar /home/eric/bin	,

/	7	.

/ we maken maven project wicket-testing	,

/ In maven , eclipse (TODO) moet de test class met Test beginnen	,

/ In src/test/java	,
$ vi TestMyCaseSecond.java

	@Before
  	public void setUp() throws Exception {
	  	System.setProperty("webdriver.chrome.driver", "/home/eric/bin/chromedriver");
    	driver = new ChromeDriver();

$ vi pom.xml

	<dependencies>
	
		<dependency>
		    <groupId>org.seleniumhq.selenium</groupId>
		    <artifactId>selenium-java</artifactId>
		    <version>${selenium.version}</version>
		</dependency>

/ de pom van selenium-java heeft selenium-chrome als dep	, dus die hoeven we niet op te nemen hier	,

/ 7	. 

/ firefox is makkelijker	, we hoeven niet een firefoxdriver of zoiets te install	, geen webdriver.firefox.driver property	,

$ vi TestMyCaseSecond.java

	@Before
  	public void setUp() throws Exception {
    	driver = new FirefoxDriver();

$ vi pom.xml

	<dependencies>
	
		<dependency>
		    <groupId>org.seleniumhq.selenium</groupId>
		    <artifactId>selenium-java</artifactId>
		    <version>${selenium.version}</version>
		</dependency>

/ Dit is alles	, 

/ 7	.

/ we zien 	,

$ vi TestMyCaseSecond.java

 @Test
  public void testMyTestCaseSecond() throws Exception {
    driver.get(baseUrl + "/?gfe_rd=cr&ei=kET4VM-ROMuo-wba5IGIDA&gws_rd=ssl");
    driver.findElement(By.id("lst-ib")).clear();
    driver.findElement(By.id("lst-ib")).sendKeys("angular.js");
    driver.findElement(By.linkText("AngularJS — Superheroic JavaScript MVW Framework")).click();
    driver.findElement(By.linkText("View on GitHub")).click();
    driver.findElement(By.xpath("//li[2]/a/span[2]")).click();
 
/ Inderdaad	, By.id	, bij wicket verandert deze steeds	, en bovendien is de wicket:id value er nooit	, als deze "myid" is , dan zien we altijd "myid7" of "myid1a"	,


/ 7	. 

/ we hebben de Misc3 wicket app cp in wicket-testing	, en we hebben deze page record	,

$ vi TestMisc3.java

  @Before
  public void setUp() throws Exception {
//    driver = new FirefoxDriver();
	  System.setProperty("webdriver.chrome.driver", "/home/eric/bin/chromedriver");
	    driver = new ChromeDriver();
    baseUrl = "http://localhost:9090/";
    driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);
  }

  @Test
  public void testMisc3() throws Exception {
    driver.get(baseUrl + "/wicket-testing");
    driver.findElement(By.cssSelector("input[type=\"submit\"]")).click();
    driver.findElement(By.id("b9")).click();
    driver.findElement(By.id("aj8")).click();
    driver.findElement(By.cssSelector("input[type=\"submit\"]")).click();
    driver.findElement(By.id("bc")).click();
    driver.findElement(By.id("ajb")).click();
  }

/ we record:
/ geef www.google.com
/ we doen niets	, dus zien we niets in de recording	, 
/ geef localhost:9090/wicket-testing
/ click de 3 buttons	,
/ geef www.google.com
/ we doen niets	, dus zien we niets in de recording	,
/ geef localhost:9090/wicket-testing
/ click de 3 buttons	,

/ het nut van www.google.com load is om localhost:9090/wicket-testing opnieuw te laten load	, zodat we andere id's krijgen	,

/ 7	. 

/ we hebben in project wicket-testing 2 runs	,
test
tomcat7:undeploy clean tomcat7:deploy	, skip tests: check	,

/ we deploy Misc3 met de 2de	, en test met de 1ste	, 
/ TODO (moet dit anders?)

/ we zien dat de TestMisc3 niet loopt	: element not found	,


/ 7	.

/ Lees	,
http://www.jdev.it/testing-a-wicket-application-with-selenium-ide/
/ en	,
https://cwiki.apache.org/confluence/display/WICKET/Selenium+Tips


[eric@calhost wicketPathLocatorBuilder]$ pwd
/home/eric/testing/wicketPathLocatorBuilder
[eric@localhost wicketPathLocatorBuilder]$ cat user-extensions.js

LocatorBuilders.add('wicketpath', function(e) {
        this.log.debug("wicketpath: e=" + e);
        if (e.attributes && e.hasAttribute("wicketpath")) {
            this.log.info("found attribute " + e.getAttribute("wicketpath"));
            return "//" + this.xpathHtmlElement(e.nodeName.toLowerCase()) +
                "[@wicketpath=" + this.attributeValue(e.getAttribute("wicketpath")) + "]";
        }
        return null;
    });
LocatorBuilders.order.unshift(LocatorBuilders.order.pop());

/ Ga naar Selenium IDE	,
/ click Options, Options...
/ geef in field bij Selenium ore extensions	,
/home/eric/testing/wicketPathLocatorBuilder/user-extensions.js

/ we record	, in project wicket-testing	, src/test/java	,
$ vi TestMisc3.java
...
/ TODO

/ Bij afspelen blijft hangen	,

$ vi TestIDE3.java
    driver.get(baseUrl);
    driver.findElement(By.id("lst-ib")).clear();
    driver.findElement(By.id("lst-ib")).sendKeys("angular.js");
    driver.findElement(By.linkText("AngularJS — Superheroic JavaScript MVW Framework")).click();
    driver.findElement(By.linkText("View on GitHub")).click();

/ Deze gaat OK	, 
/ we moeten wel angular.js geven	, als we angularjs geven	, loopt hij niet door	,
/ TODO

/ De rest	, 
/ TODO




/7	.

/ org.apache.wicket.Application.getDebugSettings() = org.apache.wicket.settings.DebugSettings inst	,
/ DebugSettings.setOutputComponentPath is deprecated	,

	public void init()
	{
		super.init();
		getDebugSettings().setOutputComponentPath(true);
/ deprecated	,
/ of	,
		getDebugSettings().setComponentPathAttributeName("wicketpath");
/ OK	,




$ vi WicketApplication.java

	@Override
	public void init()
	{
		super.init();
		getDebugSettings().setOutputComponentPath(true);
//		getMarkupSettings().setStripWicketTags(true);


/ we hoeven in HTML niets te doen	,  net als getMarkupSettings().setStripWicketTags komt in de uiteindelijke HTML een wicketpath attr	,

/ 7	.

[eric@localhost pnloms]$ env | grep SERVER
TMS_SERVER_TYPE=development







/ Einde SELENIUM JUNIT

/ SELENIUM FITNESSE

/ Geef in firefox: addons.mozilla.org
/ Search for : xebium
/ Op de gewone manier lukt het niet	,




/ Einde SELENIUM FITNESSE

/ MPO

https://test.scs.mp-objects.com/pnloms/core/index_frameset
/ Einde MPO

/ SKYPE INSTALL

/ Lees	,
http://www.if-not-true-then-false.com/2012/install-skype-on-fedora-centos-red-hat-rhel-scientific-linux-sl/

[eric@localhost Ehcache]$   sudo yum install alsa-lib.i686 fontconfig.i686 freetype.i686 \
> glib2.i686 libSM.i686 libXScrnSaver.i686 libXi.i686 \
> libXrandr.i686 libXrender.i686 libXv.i686 libstdc++.i686 \
> pulseaudio-libs.i686 qt.i686 qt-x11.i686 zlib.i686 qtwebkit.i686
Loaded plugins: langpacks, refresh-packagekit
Package fontconfig-2.11.0-2.fc20.i686 already installed and latest version
Package freetype-2.5.0-5.fc20.i686 already installed and latest version
Package glib2-2.38.2-2.fc20.i686 already installed and latest version
Package libSM-1.2.1-6.fc20.i686 already installed and latest version
Package libXi-1.7.4-1.fc20.i686 already installed and latest version
Package libXrandr-1.4.1-2.fc20.i686 already installed and latest version
Package libXrender-0.9.8-2.fc20.i686 already installed and latest version
Package libstdc++-4.8.3-7.fc20.i686 already installed and latest version
Package zlib-1.2.8-3.fc20.i686 already installed and latest version
Resolving Dependencies
--> Running transaction check
---> Package alsa-lib.i686 0:1.0.27.2-2.fc20 will be installed
---> Package libXScrnSaver.i686 0:1.2.2-6.fc20 will be installed
---> Package libXv.i686 0:1.0.9-2.fc20 will be installed
---> Package pulseaudio-libs.i686 0:5.0-7.fc20 will be installed
--> Processing Dependency: libwrap.so.0 for package: pulseaudio-libs-5.0-7.fc20.i686
--> Processing Dependency: libsndfile.so.1(libsndfile.so.1.0) for package: pulseaudio-libs-5.0-7.fc20.i686
--> Processing Dependency: libsndfile.so.1 for package: pulseaudio-libs-5.0-7.fc20.i686
--> Processing Dependency: libjson-c.so.2 for package: pulseaudio-libs-5.0-7.fc20.i686
--> Processing Dependency: libasyncns.so.0 for package: pulseaudio-libs-5.0-7.fc20.i686
--> Processing Dependency: libXtst.so.6 for package: pulseaudio-libs-5.0-7.fc20.i686
---> Package qt.i686 1:4.8.6-10.fc20 will be installed
--> Processing Dependency: libsqlite3.so.0 for package: 1:qt-4.8.6-10.fc20.i686
---> Package qt-x11.i686 1:4.8.6-10.fc20 will be installed
--> Processing Dependency: libmng.so.1 for package: 1:qt-x11-4.8.6-10.fc20.i686
---> Package qtwebkit.i686 0:2.3.3-7.fc20 will be installed
--> Processing Dependency: libxslt.so.1(LIBXML2_1.1.9) for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxslt.so.1(LIBXML2_1.0.24) for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxslt.so.1(LIBXML2_1.0.22) for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxslt.so.1(LIBXML2_1.0.11) for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxslt.so.1 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxml2.so.2(LIBXML2_2.6.6) for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxml2.so.2(LIBXML2_2.6.0) for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxml2.so.2(LIBXML2_2.4.30) for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libxml2.so.2 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libwebp.so.4 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libgstvideo-0.10.so.0 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libgstreamer-0.10.so.0 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libgstpbutils-0.10.so.0 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libgstinterfaces-0.10.so.0 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libgstbase-0.10.so.0 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libgstapp-0.10.so.0 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libQtSensors.so.1 for package: qtwebkit-2.3.3-7.fc20.i686
--> Processing Dependency: libQtLocation.so.1 for package: qtwebkit-2.3.3-7.fc20.i686
--> Running transaction check
---> Package gstreamer.i686 0:0.10.36-6.fc20 will be installed
---> Package gstreamer-plugins-base.i686 0:0.10.36-6.fc20 will be installed
--> Processing Dependency: libvorbisenc.so.2 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libvorbis.so.0 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libvisual-0.4.so.0 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libtheoraenc.so.1(libtheoraenc_1.0) for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libtheoraenc.so.1 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libtheoradec.so.1(libtheoradec_1.0) for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libtheoradec.so.1 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: liborc-test-0.4.so.0 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: liborc-0.4.so.0 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libogg.so.0 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libcdda_paranoia.so.0 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
--> Processing Dependency: libcdda_interface.so.0 for package: gstreamer-plugins-base-0.10.36-6.fc20.i686
---> Package json-c.i686 0:0.11-6.fc20 will be installed
---> Package libXtst.i686 0:1.2.2-2.fc20 will be installed
---> Package libasyncns.i686 0:0.8-6.fc20 will be installed
---> Package libmng.i686 0:1.0.10-12.fc20 will be installed
--> Processing Dependency: liblcms.so.1 for package: libmng-1.0.10-12.fc20.i686
---> Package libsndfile.i686 0:1.0.25-8.fc20 will be installed
--> Processing Dependency: libgsm.so.1 for package: libsndfile-1.0.25-8.fc20.i686
--> Processing Dependency: libFLAC.so.8 for package: libsndfile-1.0.25-8.fc20.i686
---> Package libwebp.i686 0:0.3.1-3.fc20 will be installed
---> Package libxml2.i686 0:2.9.1-2.fc20 will be installed
---> Package libxslt.i686 0:1.1.28-5.fc20 will be installed
---> Package qt-mobility-location.i686 0:1.2.2-0.16.20140317git169da60c.fc20 will be installed
--> Processing Dependency: qt-mobility-common(x86-32) = 1.2.2-0.16.20140317git169da60c.fc20 for package: qt-mobility-location-1.2.2-0.16.20140317git169da60c.fc20.i686
--> Processing Dependency: libproj.so.0 for package: qt-mobility-location-1.2.2-0.16.20140317git169da60c.fc20.i686
---> Package qt-mobility-sensors.i686 0:1.2.2-0.16.20140317git169da60c.fc20 will be installed
---> Package sqlite.i686 0:3.8.6-2.fc20 will be installed
--> Processing Dependency: libtinfo.so.5 for package: sqlite-3.8.6-2.fc20.i686
--> Processing Dependency: libreadline.so.6 for package: sqlite-3.8.6-2.fc20.i686
--> Processing Dependency: libncurses.so.5 for package: sqlite-3.8.6-2.fc20.i686
---> Package tcp_wrappers-libs.i686 0:7.6-76.fc20 will be installed
--> Running transaction check
---> Package cdparanoia-libs.i686 0:10.2-14.fc20 will be installed
---> Package flac-libs.i686 0:1.3.0-3.fc20 will be installed
---> Package gsm.i686 0:1.0.13-10.fc20 will be installed
---> Package lcms-libs.i686 0:1.19-10.fc20 will be installed
---> Package libogg.i686 2:1.3.0-6.fc20 will be installed
---> Package libtheora.i686 1:1.1.1-9.fc20 will be installed
---> Package libvisual.i686 0:0.4.0-14.fc20 will be installed
---> Package libvorbis.i686 1:1.3.4-1.fc20 will be installed
---> Package ncurses-libs.i686 0:5.9-12.20130511.fc20 will be installed
---> Package orc.i686 0:0.4.22-2.fc20 will be installed
---> Package proj.i686 0:4.8.0-5.fc20 will be installed
---> Package qt-mobility-common.i686 0:1.2.2-0.16.20140317git169da60c.fc20 will be installed
---> Package readline.i686 0:6.2-10.fc20 will be installed
--> Finished Dependency Resolution

Dependencies Resolved

==========================================================================================================================================
 Package                              Arch               Version                                              Repository             Size
==========================================================================================================================================
Installing:
 alsa-lib                             i686               1.0.27.2-2.fc20                                      fedora                388 k
 libXScrnSaver                        i686               1.2.2-6.fc20                                         fedora                 24 k
 libXv                                i686               1.0.9-2.fc20                                         fedora                 17 k
 pulseaudio-libs                      i686               5.0-7.fc20                                           updates               498 k
 qt                                   i686               1:4.8.6-10.fc20                                      updates               4.8 M
 qt-x11                               i686               1:4.8.6-10.fc20                                      updates                13 M
 qtwebkit                             i686               2.3.3-7.fc20                                         updates                20 M
Installing for dependencies:
 cdparanoia-libs                      i686               10.2-14.fc20                                         fedora                 52 k
 flac-libs                            i686               1.3.0-3.fc20                                         fedora                172 k
 gsm                                  i686               1.0.13-10.fc20                                       fedora                 30 k
 gstreamer                            i686               0.10.36-6.fc20                                       fedora                961 k
 gstreamer-plugins-base               i686               0.10.36-6.fc20                                       fedora                1.2 M
 json-c                               i686               0.11-6.fc20                                          updates                31 k
 lcms-libs                            i686               1.19-10.fc20                                         fedora                106 k
 libXtst                              i686               1.2.2-2.fc20                                         fedora                 20 k
 libasyncns                           i686               0.8-6.fc20                                           fedora                 26 k
 libmng                               i686               1.0.10-12.fc20                                       fedora                174 k
 libogg                               i686               2:1.3.0-6.fc20                                       fedora                 24 k
 libsndfile                           i686               1.0.25-8.fc20                                        fedora                161 k
 libtheora                            i686               1:1.1.1-9.fc20                                       fedora                140 k
 libvisual                            i686               0.4.0-14.fc20                                        fedora                138 k
 libvorbis                            i686               1:1.3.4-1.fc20                                       updates               179 k
 libwebp                              i686               0.3.1-3.fc20                                         updates               165 k
 libxml2                              i686               2.9.1-2.fc20                                         fedora                651 k
 libxslt                              i686               1.1.28-5.fc20                                        fedora                236 k
 ncurses-libs                         i686               5.9-12.20130511.fc20                                 fedora                305 k
 orc                                  i686               0.4.22-2.fc20                                        updates               169 k
 proj                                 i686               4.8.0-5.fc20                                         fedora                174 k
 qt-mobility-common                   i686               1.2.2-0.16.20140317git169da60c.fc20                  updates                35 k
 qt-mobility-location                 i686               1.2.2-0.16.20140317git169da60c.fc20                  updates               592 k
 qt-mobility-sensors                  i686               1.2.2-0.16.20140317git169da60c.fc20                  updates               122 k
 readline                             i686               6.2-10.fc20                                          updates               186 k
 sqlite                               i686               3.8.6-2.fc20                                         updates               440 k
 tcp_wrappers-libs                    i686               7.6-76.fc20                                          fedora                 66 k

Transaction Summary
==========================================================================================================================================
Install  7 Packages (+27 Dependent packages)

Total download size: 45 M
Installed size: 140 M
Is this ok [y/d/N]: 

[eric@localhost Ehcache]$ cd /tmp
[eric@localhost tmp]$ wget --trust-server-names http://www.skype.com/go/getskype-linux-dynamic
--2014-10-17 17:32:39--  http://www.skype.com/go/getskype-linux-dynamic
Resolving www.skype.com (www.skype.com)... 157.56.114.105
Connecting to www.skype.com (www.skype.com)|157.56.114.105|:80... connected.
HTTP request sent, awaiting response... 302 Found
Location: http://download.skype.com/linux/skype-4.3.0.37.tar.bz2 [following]
--2014-10-17 17:32:39--  http://download.skype.com/linux/skype-4.3.0.37.tar.bz2
Resolving download.skype.com (download.skype.com)... 95.100.97.58, 95.100.97.34
Connecting to download.skype.com (download.skype.com)|95.100.97.58|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 19310701 (18M) [application/octet-stream]
Saving to: ‘skype-4.3.0.37.tar.bz2’

100%[================================================================================================>] 19,310,701  6.69MB/s   in 2.8s   

2014-10-17 17:32:42 (6.69 MB/s) - ‘skype-4.3.0.37.tar.bz2’ saved [19310701/19310701]

[eric@localhost tmp]$ sudo mkdir /opt/skype
[eric@localhost tmp]$ sudo tar xvf skype-4.3* -C /opt/skype --strip-components=1

[eric@localhost tmp]$ sudo ln -s /opt/skype/skype.desktop /usr/share/applications/skype.desktop
[eric@localhost tmp]$ sudo ln -s /opt/skype/icons/SkypeBlue_48x48.png /usr/share/icons/skype.png
[eric@localhost tmp]$ sudo ln -s /opt/skype/icons/SkypeBlue_48x48.png /usr/share/pixmaps/skype.png
[eric@localhost tmp]$ sudo touch /usr/bin/skype
[eric@localhost tmp]$ sudo touch /usr/bin/skype
[eric@localhost tmp]$ ls -l /usr/bin/skype
-rw-r--r--. 1 root root 0 Oct 17 17:35 /usr/bin/skype
[eric@localhost tmp]$ sudo chmod 755 /usr/bin/skype
[eric@localhost tmp]$ ls -l /usr/bin/skype
-rwxr-xr-x. 1 root root 0 Oct 17 17:35 /usr/bin/skype

$ sudo vi /usr/bin/skype
#!/bin/sh
export SKYPE_HOME="/opt/skype"
 
$SKYPE_HOME/skype --resources=$SKYPE_HOME $*

$ skype

/ Account:
ericjvandervelden
vl$Walnoot27




/ Einde SKYPE INSTALL

/ OPEN IN ECLIPSE

https://github.com/apache/wicket
http://tomcat.apache.org/maven-plugin-2.2/tomcat7-maven-plugin/plugin-info.html
http://www.mkyong.com/maven/how-to-deploy-maven-based-war-file-to-tomcat/
http://www.mkyong.com/wicket/how-do-setup-wicket-examples-in-eclipse/
http://www.wicket-library.com/wicket-examples/index.html
http://stackoverflow.com/questions/2059431/get-source-jars-from-maven-repository
http://www.journaldev.com/3481/hibernate-save-vs-saveorupdate-vs-persist-vs-merge-vs-update-explanation-with-examples
http://stackoverflow.com/questions/16047306/how-is-docker-io-different-from-a-normal-virtual-machine/16048358#16048358
http://localhost:9090/simple-webapp/weather.x?zip=60202
http://en.wikibooks.org/wiki/Java_Persistence
http://serverfault.com/questions/554359/postgresql-timezone-does-not-match-system-timezone
http://stackoverflow.com/questions/5459176/difference-between-hibernate-update-by-session-update-and-hibernatetemplate-merg
http://dzone.com/page/research

/ Einde OPEN IN ECLIPSE

/ NETWORKING

[eric@localhost isbscs]$ host www.mp-objects.com
www.mp-objects.com is an alias for www.mp-objects.com.cname.jxshosting.nl.
www.mp-objects.com.cname.jxshosting.nl has address 81.4.97.68
www.mp-objects.com.cname.jxshosting.nl has IPv6 address 2001:828:405:27::5104:6144

/ Lees	,
https://developers.google.com/speed/public-dns/docs/using

; <<>> DiG 9.9.4-P2-RedHat-9.9.4-15.P2.fc20 <<>> @8.8.8.8 www.mp-objects.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 6043
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;www.mp-objects.com.		IN	A

;; ANSWER SECTION:
www.mp-objects.com.	3129	IN	A	208.91.197.132

;; Query time: 14 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Tue Jan 06 15:12:50 CET 2015
;; MSG SIZE  rcvd: 63


/ Einde NETWORKING


/ JSP TLD TAGLIB

[eric@localhost Jsp]$ pwd
/home/eric/Devel/Java/Jsp
[eric@localhost Jsp]$ ls
jsp  jspbook

/ 13	. 

$ vi date.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
	<jsp:useBean id="clock" class="java.util.Date">
		<ul>
			<li>Date: <jsp:getProperty property="date" name="clock"/>
			<li>Month: <jsp:getProperty property="month" name="clock"/>
			<li>${clock.date}</li>
			<li>${clock.month}</li>
		</ul>
	</jsp:useBean>
</body>
</html>

/ 13	.

/ Lees	,
http://stackoverflow.com/questions/20280203/name-was-not-previously-introduced-as-per-jsp-5-3

But, more importantly, you're coding your JSPs as if we were still in 1999. Since then, the JSP EL and the JSTL have been introduced, and scriptlets and jsp:xxx tags shouldn't be used anymore in JSPs. Your JSP should simply be:

<%@ page 
    language="java" 
    contentType="text/html; charset=ISO-8859-1" 
    pageEncoding="ISO-8859-1"
%>
<!DOCTYPE html>
<html>
  <head>
    <title>Result</title>
  </head>
  <body>
    ${user.firstName}
  </body>
</html>
Or, even better, you should be using the JSTL and make sure special characters in the firstName are properly escaped:

/ 13	. 

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
...
<c:out value="${user.firstName}"/>

/////////////////////////////////////////////////////////
/ we use hier jstl en el

$ vi pom.xml

  	<dependency>
		    <groupId>javax.servlet</groupId>
		    <artifactId>jstl</artifactId>
		    <version>1.2</version>
		    <scope>runtime</scope>
		</dependency>
		

			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<version>${tomcat.version}</version>
				<configuration>
	    			<url>http://localhost:9090/manager/text</url>
	    			<server>my_tomcat</server>
 	 			</configuration>
			</plugin>

/////////////////////////////////////////////////////////////////////
/ Let op 	, javax.servlet:jstl is runtime	, alleen bij execution dus	, provided is fout	,

/ we moeten jstl dependency toevoegen	, omdat we hebben	,
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>

/ oef met <c:out>

/ lees	,
http://stackoverflow.com/questions/2276083/include-jstl-dependency-with-maven

/ 13	. 

/ Geef in eclipse	,
jsp tutorial	,
/ we download van 
http://www.javatpoint.com/jstl

[eric@localhost Jsp]$ unzip  ~/Downloads/out.zip 
/ TODO

/ 13	.

/ wat we misten was el	,

/ Lees	,
http://stackoverflow.com/questions/793983/jsp-el-expression-is-not-evaluated

/////////////////////////////////////////
/ el werkt OK als we in web.xml (NIET in de jsp dus) het volgende	,

/////////////////////////////////////////
$ vi web.xml	,

<?xml version="1.0" encoding="ISO-8859-1"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	version="2.5">

	<display-name>jsp</display-name>
</web-app>

/ We HADDEN	, 

///////////////////////////////////////
$ vi web.xml
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
</web-app>
/ ERR

$ vi date.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>

	<jsp:useBean id="clock" class="java.util.Date"></jsp:useBean>
		<ul>
			<li>Date: <jsp:getProperty property="date" name="clock"/>
			<li>Month: <jsp:getProperty property="month" name="clock"/>
			<li>${clock.date}</li>
			<li>${clock.month}</li>
			
		</ul>
		<c:out value="${clock.date}"/>


/ 13	. 

/ we maken 
userinfo.html
userinfo1.jsp
jsp.my.UserInfoBean.java
/ OK

$ vi userinfo.html

<form action="userinfo1.jsp" method="post">
	<span>Name</span>
	<input type="text" name="firstName" id="first">
</form>

/////////////////////////////////////////////////////////////////////
/ JSP werkt via de name attr	, see boek(65, 66)

$ vi userinfo1.jsp

<jsp:useBean id="userInfo" class="jsp.my.UserInfoBean">
	<jsp:setProperty name="userInfo" property="*"/>
</jsp:useBean>


<h1>We see</h1>
<jsp:getProperty property="firstName" name="userInfo"/>

$ vi jsp/my/UserInfoBean.java

	private String firstName;

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

/ 13	.

/ in greeting.jsp	,

	<jsp:useBean id="clock" class="java.util.Date"></jsp:useBean>
	<% if(clock.getHours()<12){ %>
		Good morning!
	<% }else if(clock.getHours()<17){ %>
		Good day!
	<% }else{ %>
		Good evening!
	<% } %>

/ 13.

/ we maken loop.jsp	, 

	<form action="loop.jsp">
		<input type="checkbox" name="fruits" value="apple">Apple<br>
		<input type="checkbox" name="fruits" value="pear">Pear<br>
		<input type="checkbox" name="fruits" value="orange">Orange<br>
		<input type="submit">
	</form>
	<%
		String[] picked=request.getParameterValues("fruits");
		if(picked!=null && picked.length!=0){
	%>
	<ul>
	<% 
			for(int i=0;i<picked.length;i++){
				out.println("<li>"+picked[i]);
			}
	%>
	</ul>
	<%
		}
	%>

/ OK

/////////////////////////////////////////////////////////////////////
/ JSP werkt via de name attr	, see boek(65, 66)

/ 13	. 

/ we passen date.jsp van boven aan, met <%= ...	,

	<jsp:useBean id="clock" class="java.util.Date"></jsp:useBean>
	<ul>
		<li>Date: <jsp:getProperty property="date" name="clock"/></li>
		<li>Date: <%= clock.getDate() %></li>
		<li><c:out value="${clock.date}"/></li>
	</ul>

Date: 24
Date: 24
24

/ we kunnen op 3 manieren print	,

/13	. 

/ Lees	,
http://www.javatpoint.com/jstl

$ vi out.html

<form action="out.jsp" method="post">
FirstName:<input type="text" name="fname"/><br/>
LastName:<input type="text" name="lname"/><br/>
<input type="submit" value="submit"/>
</form>

$ vi out.jsp

<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
First Name:<c:out value="${param.fname}"></c:out><br/>
Last Name:<c:out value="${param.lname}"></c:out>

/ OK



/ 13	. 

/ Lees	,
http://www.java2s.com/Tutorial/Java/0360__JSP/CustomTagSupport.htm

[eric@localhost Jsp]$ pwd
/home/eric/Devel/Java/Jsp
[eric@localhost Jsp]$ unzip  ~/Downloads/CustomTagTagSupport.zip 

/ 13	. 

/ Lees	,
http://www.java2s.com/Tutorial/Java/0360__JSP/CustomTagSupport.htm


/ Lees	,
http://stackoverflow.com/questions/2276083/include-jstl-dependency-with-maven

/ Lees	,
http://stackoverflow.com/questions/20093237/java-lang-classnotfoundexception-javax-servlet-jsp-tagext-tag

/ Voor javax.servlet.jsp.tagext.TagSupport	,

		<dependency>
		    <groupId>javax.servlet.jsp</groupId>
		    <artifactId>jsp-api</artifactId>
		    <version>2.2</version>
		    <scope>provided</scope>
		</dependency>

/ we zien in tomcat	,
./lib/el-api.jar
./lib/jsp-api.jar

///////////////////////////////////////////////////////////////
/ Dus el is er al, en jsp-api ook	, daarom hebben we hier jsp-api provided	,

/ Voor	,
			HttpServletResponse response=(HttpServletResponse)pageContext.getResponse();
 doen we	,
		<dependency>
		    <groupId>javax.servlet</groupId>
		    <artifactId>servlet-api</artifactId>
		    <version>2.5</version>
		    <scope>provided</scope>
		</dependency>

/ 13	. 

/ tld's zitten in WEB-INF	, naast web.xml	,

/ Lees	,
http://docs.oracle.com/javaee/5/tutorial/doc/bnamu.html

<taglib
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee web-jsptaglibrary_2_1.xsd"
    xmlns="http://java.sun.com/xml/ns/javaee"|
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    version="2.1"
> 
/ TODO

/ Lees	,
http://www.tutorialspoint.com/jsp/jsp_custom_tags.htm
http://www.java2s.com/Tutorial/Java/0360__JSP/CustomTagSupport.htm

/ 7	.
//////////////////////////////////////////////////////

/ uiteindelijke custom tag	,

/ Lees	,
http://www.tutorialspoint.com/jsp/jsp_custom_tags.htm

$ vi pom.xml

		
   		<dependency>
		    <groupId>javax.servlet</groupId>
		    <artifactId>jstl</artifactId>
		    <version>1.2</version>
		    <scope>runtime</scope>
		</dependency>
		
		<dependency>
		    <groupId>javax.servlet.jsp</groupId>
		    <artifactId>jsp-api</artifactId>
		    <version>2.2</version>
		    <scope>provided</scope>
		</dependency>
		
    
		<plugin>
			<groupId>org.apache.tomcat.maven</groupId>
			<artifactId>tomcat7-maven-plugin</artifactId>
			<version>${tomcat.version}</version>
			<configuration>
	    		<url>http://localhost:9090/manager/text</url>
	    		<server>my_tomcat</server>
 	 		</configuration>
		</plugin>

$ vi HelloTag.java

public class HelloTag extends SimpleTagSupport{
	@Override
	public void doTag() throws JspException, IOException {
		JspWriter out=getJspContext().getOut();
		out.println("Hello, I am a custom tag");
		
	}
}

$ vi custom.tld

<?xml version="1.0" encoding="UTF-8"?>
<taglib>
	<tlib-version>1.0</tlib-version>  
	<jsp-version>2.1</jsp-version>
	<short-name></short-name>
	 <tag>
    	<name>Hello</name>
    	<tag-class>jsp.my.HelloTag</tag-class>
    	<body-content>empty</body-content>
  	</tag>
</taglib>

$ vi usetld.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="ex" uri="custom.tld" %>
<ex:Hello/>

/ 7	. 

/ Met attributes	,

/ de pom.xml is onveranderd	,

$ vi HelloTag2.java

public class HelloTag2 extends SimpleTagSupport{
	private String message;
	private StringWriter writer;
	
	@Override
	public void doTag() throws JspException, IOException {
		JspWriter out=getJspContext().getOut();
		writer=new StringWriter();
		if(message==null){
			JspFragment fragment=getJspBody();
			fragment.invoke(writer);
			out.println(writer.toString());
		}
		else{
			out.println(message);
		}
		
	}
	...

$ vi custom2.tld

<taglib>
	<tlib-version>1.0</tlib-version>  
	<jsp-version>2.1</jsp-version>
	<short-name></short-name>
	<tag>
    	<name>Hello2</name>
    	<tag-class>jsp.my.HelloTag2</tag-class>
    	<body-content>scriptless</body-content>
    	<attribute>
    		<name>message</name>
    	</attribute>
  	</tag>
</taglib>

$ vi usetld2.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="ex" uri="custom2.tld" %>
<ex:Hello2>Hello, this is message 2</ex:Hello2>


/ we zien dus <name>Hello2</name> in custom2.tld	, en in usetld2.jsp <ex:Hello2>

/ 7	. 

/ we kunnen ook de  uri veranderen	, we geven dan niet de tld file in de webapp	,

$ vi custom.tld

<taglib>
	 <tag>
    		<name>Hello</name>
    		<tag-class>jsp.my.HelloTag</tag-class>
    		<body-content>empty</body-content>
  	</tag>
</taglib>

$ vi web.xml

<web-app>
	<jsp-config>
		<taglib>
    			<taglib-uri>http://localhost/custom</taglib-uri>
    			<taglib-location>/custom.tld</taglib-location>
  		</taglib>
	</jsp-config>
</web-app>

$ vi usetld_a.jsp

<%@ taglib prefix="ex" uri="http://localhost/custom" %>
<ex:Hello/>



/ 13	. 

/ Hoeft NIET	,
	<dependency>
	        <groupId>taglibs</groupId>
	        <artifactId>standard</artifactId>
	        <scope>runtime</scope>
	        <version>1.1.2</version>
    </dependency>
/ Zou moeten voor	,
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

    <dependency>
        <groupId>taglibs</groupId>
        <artifactId>c</artifactId>
        <version>1.1.2</version>
        <scope>runtime</scope>
        <type>tld</type>
    </dependency>
    <dependency>
        <groupId>taglibs</groupId>
        <artifactId>fmt</artifactId>
        <version>1.1.2</version>
        <scope>runtime</scope>
        <type>tld</type>
    </dependency>

/ Einde JSP TLD TAGLIB

/ OPEN IN ECLIPSE

http://beginnersbook.com/jsp-tutorial-for-beginners/


/ Einde OPEN IN ECLIPSE

/ COCOON

/ Lees	,
http://cocoon.apache.org/2.2/1159_1_1.html
http://stackoverflow.com/questions/9142533/plugin-execution-not-covered-by-lifecycle-configuration-jbossas-7-ear-archetype
http://cocoon.apache.org/2.2/maven-plugins/maven-plugin/1.0/1297_1_1.html

/ 7	.

/ op de command line	,

[eric@localhost Cocoon]$ pwd
/home/eric/Devel/Java/Cocoon
[eric@localhost Cocoon]$  mvn archetype:generate -DarchetypeCatalog=http://cocoon.apache.org
[INFO] Generating project in Interactive mode
[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)
Choose archetype:
1: http://cocoon.apache.org -> org.apache.cocoon:cocoon-22-archetype-block-plain (Creates an empty Cocoon block; useful if you want to add another block to a Cocoon application)
2: http://cocoon.apache.org -> org.apache.cocoon:cocoon-22-archetype-block (Creates a Cocoon block containing some small samples)
3: http://cocoon.apache.org -> org.apache.cocoon:cocoon-22-archetype-webapp (Creates a web application configured to host Cocoon blocks. Just add the block dependencies)
Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): : 2			/ Geef	,
Define value for property 'groupId': : my.own.test								/ Geef	,
Define value for property 'artifactId': : myBlock2								/ Geef	,
Define value for property 'version':  1.0-SNAPSHOT: : 
Define value for property 'package':  my.own.test: : 
Confirm properties configuration:
groupId: my.own.test
artifactId: myBlock2
version: 1.0-SNAPSHOT
package: my.own.test
 Y: : 
...

[eric@localhost Cocoon]$ ls
myBlock2 ...
[eric@localhost Cocoon]$ cd myBlock2/
[eric@localhost myBlock2]$ mvn jetty:run

/ Geef in chrome	,
http://localhost:8888/myBlock2/
/ OK

/ 7	. 

/ In eclipse	,

/ we hebben project my.test.own:cocoon-first
/ maak run config : clean jetty:run
/ Geef in chrome	,
http://localhost:8888/cocoon-first
/ OK

/ we zien	,

Apache Cocoon: Welcome

This block my.test.own:cocoon-first was created by the Cocoon block archetype.

Link to the output of a simple Flowscript that accesses a Spring bean.

/ TODO 

/ Einde COCOON

/ JMX

/ Lees
http://docs.oracle.com/javase/tutorial/jmx/

/ Lees 
/ Introducing MBeans

/ 7	.

/ Kies Standard MBeans

/ Lees
http://docs.oracle.com/javase/tutorial/jmx/mbeans/standard.html

/ in eclipse met create Java project moet je de project een name geven, en een location	,
/ bij maven project geef je bij location de dir op waarin proj, met eigen dir, wordt create	,
/ bij java project is location inderdaad de dir van het project zelf	,

/ we maken project jmx-first in Devel/Java/JMX/jmx-first	,

/ De src/ folder in onze source folder	, we hebben dus niet src/main/java	,
/ in deze src folder maken we een interface HelloMBean	, en geven meteen package com.example	,

[eric@localhost jmx-examples]$ pwd
/home/eric/Devel/Java/JMX/jmx-examples
[eric@localhost jmx-examples]$ unzip  ~/Downloads/jmx_examples.zip 

/ we edit HelloMBean, Hello, Main	, 
/ we click op Main	, Run as Java Application	,
/ in de console zien we 
Waiting forever...

$ jconsole
/ Kies com.example.Main
/ kies unsecure

/ als we het attribute cacheSize in jconsole set , zien we inderdaad in eclipse' console
.setCacheSize to 150
/ omdat we hebben	, 


public class Hello implements HelloMBean {
	@Override
	public void sayHello() {
		System.out.println("Hello World!");
	}
	@Override
	public void setCacheSize(int size) {
		cacheSize=size;
		System.out.println(".setCacheSize to "+size);

	}

/ click bij operations sayHello	, 
/ we zien in eclipse's console	,
Hello World!

/ 7	. 

/ Kies MXBeans	,

/ we maken ook QueueSample	,


/ 7	.

/ we maken Hello2	, 

/ Let op dat we dan ook Hello2MBean maken	, en Hello2 extends Hello2MBean	,

/ 7	. 

/ op de command line kan ook 	,


[eric@localhost jmx-examples]$ pwd
/home/eric/Devel/Java/JMX/jmx-examples
[eric@localhost jmx-examples]$ javac $(find -name *.java)

/ Voor jconsole kunnen we 
[eric@localhost jmx-examples]$ java com.example.Main
/ In ander window	,
[eric@localhost ]$ jconsole
/ kies com.example.Main, Connect	,
/ SSL issues
/ TODO
/ Kies MBeans, open com.example.Hello	,
/ we zien Attributes, Notifications	,
/ we kunnen de attr CacheSize wel veranderen, maar als we ons niet als listener hebben reg , krijgen we geen not.	,
/ click eerst Notification, en click Subscribe	,
/ ga dan terug naar attributes, en verander CacheSize	,
/ ga terug naar notifications	, we zien dat we een not. hebben gekregen	,



/ Maar voor com.example.Client 	,
[eric@localhost jmx-examples]$ java -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.authenticate=false  -Dcom.sun.management.jmxremote.ssl=false com.example.Main
...
/ In ander window	,
eric@localhost jmx-examples]$   java com.example.Client
...

/ 7	. 

/ Lees	,
http://docs.oracle.com/javase/tutorial/jmx/remote/jconsole.html

[eric@localhost jmx-examples]$ java -Dcom.sun.management.jmxremote.port=9999 \
>      -Dcom.sun.management.jmxremote.authenticate=false \
>      -Dcom.sun.management.jmxremote.ssl=false \
>      com.example.Main

$ jconsole
/ we zien new Connection	,
/ we kozen altijd com.example.Main uit het rijtje	, maar nu kiezen we 	,
Remote process	: localhost:9999
/ OK





/ Einde JMX

/ ECLIPSE

[eric@localhost eclipse-interfacing]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-interfacing
[eric@localhost eclipse-interfacing]$ tar xvzf ~/Downloads/eclipse-jee-luna-SR2-linux-gtk-x86_64.tar.gz 
[eric@localhost eclipse-interfacing]$ ls
eclipse  workspace
/ we maken de workspace hier	,

[eric@localhost eclipse-interfacing]$ tar xvzf ~/Downloads/eclipse-jee-luna-SR2-linux-gtk-x86_64.tar.gz 
[eric@localhost eclipse-interfacing]$ ls
eclipse  workspace

/ Geef in Work with:
http://download.jboss.org/jbosstools/updates/stable/luna/
/ Click add
name: JBoss Tools
/ we zien in Work with:
JBoss Tools - http://download.jboss.org/jbosstools/updates/stable/luna/


/ Einde ECLIPSE


/ FTP

/ 7	. 

/ bij mpo	,

[eric@localhost apache-activemq-5.10.1]$ ftp ftp-test
username: test01		/ of test02, ... , test05
password: test01@mpo
ftp> pwd
257 "/" is the current directory
ftp> ls
227 Entering Passive Mode (192,168,3,105,141,235).
150 Opening ASCII mode data connection for file list
drwxr-xr-x   4 test01   ftpuser      4096 Oct 14  2010 dsvcts
...


/ 7	.

[eric@localhost pnloms]$ sudo yum install vsftpd
[eric@localhost pnloms]$ sudo systemctl restart vsftpd
[eric@localhost pnloms]$ sudo systemctl enable vsftpd

[eric@localhost eclipse-interfacing]$ repoquery -l vsftpd
...
/var/ftp/pub

[eric@localhost tmp]$ ftp localhost
Connected to localhost (::1).
Name (localhost:eric): anonymous
Password:							/ Lege string , geef Enter	,
ftp> pwd
257 "/"
ftp> ls
/=
ftp> dir 
drwxr-xr-x    2 0        0            4096 Sep 10  2013 pub

/ local commands met ! ervoor	, 
/ maar niet !cd	, use lcd	,

ftp> !ls
anonymous4550147228924059539webdriver-profile  entity_generator-2982464165801481516.xml
...
ftp> lcd /home/eric/tmp
Local directory now /home/eric/tmp
ftp> !ls
dsvcts.fdb.bak	hibernate-core-3.3.0.GA  hibernate-core-3.6.7.Final-sources
ftp> quit
221 Goodbye.
[eric@localhost tmp]$ pwd
/tmp

/ als we lcd hebben use, en we quit ftp client, dan terug in de dir waar we begonnen, /tmp	,

[eric@localhost tmp]$ echo "Foo Bar
> Gee Hee">foo.txt

[eric@localhost tmp]$ ftp localhost
Name (localhost:eric): anonymous
Password:
ftp> cd pub
250 Directory successfully changed.
ftp> put foo.txt
local: foo.txt remote: foo.txt
229 Entering Extended Passive Mode (|||42629|).
550 Permission denied.

[eric@localhost tmp]$ sudo vi /etc/vsftpd/vsftpd.conf 
anon_upload_enable=YES
anon_mkdir_write_enable=YES

[eric@localhost tmp]$ sudo systemctl restart vsftpd

[eric@localhost tmp]$ ftp localhost
Name (localhost:eric): anonymous
Password:
ftp> cd pub
ftp> put foo.txt
553 Could not create file.

/ 7	. 

/ voor ftp's put moeten we eerst lcd  doen, dan put <filename>	, 
/ we kunnen bijv niet in /home/eric $ ftp	, en put /tmp/foo.txt	, we moeten eerst lcd /tmp en dan put foo.txt	,

[eric@localhost ~]$ ftp localhost
Name (localhost:eric): 
331 Please specify the password.
ftp> !pwd
/home/eric
ftp> pwd
257 "/home/eric"
ftp> cd tmp
ftp> pwd
257 "/home/eric/tmp"
ftp> put /tmp/foo.txt 
/ We zien niets in /home/eric/tmp	,
ftp> lcd /tmp
Local directory now /tmp
ftp> !pwd
/tmp
ftp> put foo.txt 
/ OK, we zien foo.txt in /home/eric/tmp

/ 7	.

[eric@localhost tmp]$ sudo mkdir /var/ftp/pub/anon
[eric@localhost tmp]$  sudo chmod a+w /var/ftp/pub/anon/

[eric@localhost tmp]$ ftp localhost
Name (localhost:eric): anonymous
Password:
ftp> pwd
257 "/"
ftp> cd pub/anon
ftp> lcd /tmp/src
ftp> put foo.txt 
ftp> ls
-rw-------    1 14       50              0 Mar 10 08:44 foo.txt
ftp> quit

[eric@localhost tmp]$  sudo ls -l  /var/ftp/pub/anon/
total 0
-rw-------. 1 ftp ftp 0 Mar 10 09:44 foo.txt

/ 7	. 

[eric@localhost trunk]$ sudo vi /etc/vsftpd/vsftpd.conf 

#chroot_local_user=YES
#user_sub_token=$USER
#local_root=/var/ftp/$USER

/ Lees	,
http://howto.gumph.org/content/setup-virtual-users-and-directories-in-vsftpd/

/ Lees	,
$ man vsftpd.conf

/ 7	.

/ eric komt weer in /hom/eric	,

/ in /home/eric/tmp/orders/ staan first.txt en second.txt

[eric@localhost file-copy]$ ftp localhost
Name (localhost:eric): 
331 Please specify the password.
ftp> cd tmp
ftp> cd orders
ftp> ls
-rw-rw-r--    1 1000     1000           37 Mar 11 07:17 first.txt
-rw-rw-r--    1 1000     1000           38 Mar 11 07:17 second.txt
ftp> lcd /tmp
ftp> get first.txt

/ Nu zijn in in /tmp first.txt	,

/ we kunnen ook andersom doen, 
ftp> put <filename> 
/ maar deze moet er dan zijn in /tmp en komt dan in ~eric/tmp/orders/	,






/ Einde FTP

/ CAMEL


/ 7	.

[eric@localhost Camel]$ pwd
/home/eric/Devel/Java/Camel
[eric@localhost Camel]$ git clone https://github.com/camelinaction/camelinaction.git

/ 7	.

/ we use eclipse luna	,

[eric@localhost Camel]$ pwd
/home/eric/Devel/Java/Camel
[eric@localhost Camel]$ vi camelinaction/pom.xml 
    <camel-version>2.14.1</camel-version>

/ er stond 2.14.2	, en die bestaat niet in repo1	,

/ we import een bestaand maven project	, chapter1	, 

/ we import ook chapter2 	,

/ 7	. 

/ Chapter 1	,

/ In eclipse kunnen we gewoon op FileCopierWithCamel Run as , Java application	; op de cmd line moeten we moeite doen	,

/ 13	, 
/ als we NIET noop=true 	, zien we inderdaad dat message1.xml rm is in inbox/	, en staat in outbox/	,
/ als we outbox/ rm, en FileCopierWithCamel run	, dan onstaat er weer een outbox/	, als we outbox/ laten staan (als er is)	, dan ook OK	, 

/ 7	. 

/ multiple routes

/ we maken	,

data/
	inbox/
		message1.xml
	inbox2/
		message2.xml

/ 13	. 

/ als we 	,

      context.addRoutes(new RouteBuilder() {
            public void configure() {
                from("file:data/inbox?noop=true").to("file:data/outbox")
                .from("file:data/inbox2?noop=true").to("file:data/outbox2");
			}
	})

/ dan krijgen we	,

data/
	outbox/
		message1.xml
		message2.xml
	inbox2/
		message1.xml
		message2.xml

/ 13	. 

/ als we	,

       context.addRoutes(new RouteBuilder() {
            public void configure() {
                from("file:data/inbox?noop=true").to("file:data/outbox");
                
            }
        });
        context.addRoutes(new RouteBuilder() {
			
			@Override
			public void configure() throws Exception {
				from("file:data/inbox2?noop=true").to("file:data/outbox2");
			}
		});

/ dan krijgen we	,

data/
	outbox/
		message1.xml
	inbox2/
		message2.xml

/ 13	. 
/ we kunnen  ook	,

       context.addRoutes(new RouteBuilder() {
            public void configure() {
                from("file:data/inbox?noop=true").to("file:data/outbox");
                from("file:data/inbox2?noop=true").to("file:data/outbox2");
                
            }
        });

/ let op ; 	,

/ dan krijgen we	,

data/
	outbox/
		message1.xml
	inbox2/
		message2.xml




'/ 7	

$ pwd
/home/eric
$ mkdir tmp/orders
$ cd ~/tmp/orders
[eric@localhost orders]$ ls
first.txt  second.txt

/ in project chapter1-file-copy	,
$ vi MyFileCopierWithCamel.java

                from("ftp://localhost/tmp/orders?username=eric&password=rtdMpo45")
                .to("file:data/outbox");

$ vi pom.xml
    <dependency>
      <groupId>org.apache.camel</groupId>
      <artifactId>camel-ftp</artifactId>
    </dependency>

/ OK
/ we zien in 	,
[eric@localhost data]$ pwd
/home/eric/Devel/Java/Camel/camelinaction/chapter1/file-copy/data
[eric@localhost data]$ ls outbox/
first.txt  second.txt


/ 7	.

/ we draaien from, to om	,

$ vi MyFileCopierWithCamel2.java

            	from("file:data/inbox?noop=true")
            	.to("ftp://localhost/tmp/orders?username=eric&password=rtdMpo45");

/ we zien dat	,
[eric@localhost data]$ pwd
/home/eric/Devel/Java/Camel/camelinaction/chapter1/file-copy/data
[eric@localhost data]$ ls inbox/
message1.xml

/ terecht komt in 	,
[eric@localhost orders]$ pwd
/home/eric/tmp/orders
[eric@localhost orders]$ ls
first.txt  message1.xml  second.txt

/ 7	. 

/ we doen , 

$ vi MyFileFtpCopierWithCamel.java

               from("ftp://localhost/tmp/orders?username=eric&password=rtdMpo45")
                .to("file:data/outbox");
               	from("file:data/inbox?noop=true")
            	.to("ftp://localhost/tmp/orders?username=eric&password=rtdMpo45");

/ we kunnen deze 2 routes ook verwisselen van volgorde	, maakt niet uit	,

/ we beginnen met	,
[eric@localhost data]$ ls
inbox
[eric@localhost data]$ ls inbox
message1.xml
[eric@localhost data]$ ls ~/tmp/orders/
first.txt second.txt

/ Na run	,
[eric@localhost data]$ ls 
inbox outbox
[eric@localhost data]$ ls outbox/
first.txt  message1.xml  second.txt
[eric@localhost data]$ ls ~/tmp/orders/
first.txt  message1.xml  second.txt

/ Dus orders/ na dat message1 daarin is set, komt in outbox/
/ Is er geen volgorde van de routes aan te geven?
/ TODO

/ 7	. 

/ we doen	,
$ vi MyFileCopierWithCamel.java

        // add our route to the CamelContext
        context.addRoutes(new RouteBuilder() {
            public void configure() {
            	Processor p=new Processor() {
					
					@Override
					public void process(Exchange arg0) throws Exception {
						System.out.println(
								"\n**********\n"+
								"we just downloaded : "+arg0.getIn().getHeader("CamelFileName")+
								"\n**********\n"
						);		
					}
				};
                from("file:data/inbox?noop=true").
                process(p).
                to("file:data/outbox");
                from("file:data/inbox2?noop=true").to("file:data/outbox2");
                
            }
        });

/ we zien	,


**********
we just downloaded : message1.xml
**********

/ 7	.

$ project chapter2-my	,

$ vi MyFileJmsWithCamel.java

       	ConnectionFactory factory=new ActiveMQConnectionFactory("vm://localhost");
        Component component=JmsComponent.jmsComponentAutoAcknowledge(factory);
        context.addComponent("jms", component);

        // add our route to the CamelContext
        context.addRoutes(new RouteBuilder() {
            public void configure() {
            
             	Processor processor=new Processor() {
					@Override
					public void process(Exchange arg0) throws Exception {
						System.out.println(
								"\n**********\n"+
								arg0.getIn().getHeader("CamelFileName")+
								"\n**********\n"
						);		
					}
				};

            	
                from("file:data/inbox?noop=true")
                .process(processor)
                .to("jms:incomingOrders");
                
                from("jms:incomingOrders")
                .process(processor)
                .to("file:data/outbox");
	
               

                
            }
        });

/ component is een JmsComponent 	,


$ vi pom.xml

    <dependency>
      <groupId>org.apache.camel</groupId>
      <artifactId>camel-core</artifactId>
    </dependency>

    <dependency>
      <groupId>org.apache.camel</groupId>
      <artifactId>camel-jms</artifactId>
    </dependency>
    
    <dependency>
      <groupId>org.apache.camel</groupId>
      <artifactId>camel-ftp</artifactId>
    </dependency>

    <dependency>
      <groupId>org.apache.activemq</groupId>
      <artifactId>activemq-all</artifactId>
    </dependency>

/ We hebben		,
data
	inbox
		message1.xml

/ Na run	,
data
	inbox
		message1.xml
	outbox
		message1.xml

/ als we hebben run, verschijnt er een dir activemq-data/	,
[eric@localhost my]$ pwd
/home/eric/Devel/Java/Camel/camelinaction/chapter2/my
[eric@localhost my]$ ls activemq-data/localhost/KahaDB
db-1.log  db.data  db.redo

/ we zien bij de run in de console van eclipse	,

SLF4J: Class path contains multiple SLF4J bindings.
SLF4J: Found binding in [jar:file:/home/eric/.m2/repository/org/apache/activemq/activemq-all/5.10.1/activemq-all-5.10.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/home/eric/.m2/repository/org/slf4j/slf4j-log4j12/1.7.5/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]
[                          main] DefaultCamelContext            INFO  Apache Camel 2.14.1 (CamelContext: camel-1) is starting
[                          main] ManagedManagementStrategy      INFO  JMX is enabled
[                          main] DefaultTypeConverter           INFO  Loaded 182 type converters
[                          main] DefaultCamelContext            INFO  AllowUseOriginalMessage is enabled. If access to the original message is not needed, then its recommended to turn this option off as it may improve performance.
[                          main] DefaultCamelContext            INFO  StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html
[                          main] FileEndpoint                   INFO  Endpoint is configured with noop=true so forcing endpoint to be idempotent as well
[                          main] FileEndpoint                   INFO  Using default memory based idempotent repository with cache max size: 1000
[                          main] DefaultCamelContext            INFO  Route: route1 started and consuming from: Endpoint[file://data/inbox?noop=true]
[                 JMX connector] ManagementContext              INFO  JMX consoles can connect to service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi
[                          main] PListStoreImpl                 INFO  PListStore:[/home/eric/Devel/Java/Camel/camelinaction/chapter2/my/activemq-data/localhost/tmp_storage] started
[                          main] BrokerService                  INFO  Using Persistence Adapter: KahaDBPersistenceAdapter[/home/eric/Devel/Java/Camel/camelinaction/chapter2/my/activemq-data/localhost/KahaDB]
[                          main] MessageDatabase                INFO  KahaDB is version 5
[                          main] MessageDatabase                INFO  Recovering from the journal ...
[                          main] MessageDatabase                INFO  Recovery replayed 1 operations from the journal in 0.02 seconds.
[                          main] BrokerService                  INFO  Apache ActiveMQ 5.10.1 (localhost, ID:localhost.localdomain-49895-1426488827598-0:1) is starting
[                          main] BrokerService                  INFO  Apache ActiveMQ 5.10.1 (localhost, ID:localhost.localdomain-49895-1426488827598-0:1) started
[                          main] BrokerService                  INFO  For help or more information please see: http://activemq.apache.org
[                          main] TransportConnector             INFO  Connector vm://localhost started
[                          main] DefaultCamelContext            INFO  Route: route2 started and consuming from: Endpoint[jms://incomingOrders]
[                          main] DefaultCamelContext            INFO  Total 2 routes, of which 2 is started.
[                          main] DefaultCamelContext            INFO  Apache Camel 2.14.1 (CamelContext: camel-1) started in 1.641 seconds

**********
message1.xml
**********


**********
message1.xml
**********

[                          main] DefaultCamelContext            INFO  Apache Camel 2.14.1 (CamelContext: camel-1) is shutting down
[                          main] DefaultShutdownStrategy        INFO  Starting to graceful shutdown 2 routes (timeout 300 seconds)
[el-1) thread #2 - ShutdownTask] TransportConnector             INFO  Connector vm://localhost stopped
[el-1) thread #2 - ShutdownTask] BrokerService                  INFO  Apache ActiveMQ 5.10.1 (localhost, ID:localhost.localdomain-49895-1426488827598-0:1) is shutting down
[el-1) thread #2 - ShutdownTask] PListStoreImpl                 INFO  PListStore:[/home/eric/Devel/Java/Camel/camelinaction/chapter2/my/activemq-data/localhost/tmp_storage] stopped
[el-1) thread #2 - ShutdownTask] KahaDBStore                    INFO  Stopping async queue tasks
[el-1) thread #2 - ShutdownTask] KahaDBStore                    INFO  Stopping async topic tasks
[el-1) thread #2 - ShutdownTask] KahaDBStore                    INFO  Stopped KahaDB
[el-1) thread #2 - ShutdownTask] BrokerService                  INFO  Apache ActiveMQ 5.10.1 (localhost, ID:localhost.localdomain-49895-1426488827598-0:1) uptime 4.117 seconds
[el-1) thread #2 - ShutdownTask] BrokerService                  INFO  Apache ActiveMQ 5.10.1 (localhost, ID:localhost.localdomain-49895-1426488827598-0:1) is shutdown
[el-1) thread #2 - ShutdownTask] DefaultShutdownStrategy        INFO  Route: route2 shutdown complete, was consuming from: Endpoint[jms://incomingOrders]
[el-1) thread #2 - ShutdownTask] DefaultShutdownStrategy        INFO  Route: route1 shutdown complete, was consuming from: Endpoint[file://data/inbox?noop=true]
[                          main] DefaultShutdownStrategy        INFO  Graceful shutdown of 2 routes completed in 0 seconds
[                          main] DefaultCamelContext            INFO  Apache Camel 2.14.1 (CamelContext: camel-1) uptime 4.866 seconds
[                          main] DefaultCamelContext            INFO  Apache Camel 2.14.1 (CamelContext: camel-1) is shutdown in 0.218 seconds

[eric@localhost my]$ find data
data
data/inbox
data/inbox/message1.xml
data/inbox/.camel
data/inbox/.camel/message1.xml
data/outbox
data/outbox/message1.xml

/ Lees	,
http://camel.apache.org/ftp2.html
http://camel.apache.org/routes.html



/ 7	.

 

                










/ Einde CAMEL

/ ACTIVEMQ

/ Ga naar	,
http://localhost:8161/admin/queues.jsp



/ Einde ACTIVEMQ

/ WICKET

/ Hoe zien we de model in het object?

/ 7	. 

/ proj wicket-book	,

$ vi Misc2.java

public class Misc2 extends WebPage{
	public Misc2() {
		Data d=new Data();
		d.setS("Foo");
		d.setI(13);
		IModel<Data>model=new Model<>(d);
		setDefaultModel(model);
		boolean b=false;
		
	}
	private class Data implements Serializable{
		String s;
		int i;
		public String getS() {
			return s;
		}
		public void setS(String s) {
			this.s = s;
		}
		public int getI() {
			return i;
		}
		public void setI(int i) {
			this.i = i;
		}
	}
}

$ vi Misc2.html
/ Leeg	,

/ Debug	,
       setDefaultModel(model);
/d
this	Misc2  (id=4700)	
	data	Model<T>  (id=4699)	
		object	Misc2$Data  (id=4704)	

/ 7	.

		IModel<Data>model=new CompoundPropertyModel<>(d);
		setDefaultModel(model);

this	Misc2  (id=5076)	
	data	CompoundPropertyModel<T>  (id=5183)	
		target	Misc2$Data  (id=5182)	

/ 7	.

		IModel<Data>model=new PropertyModel<>(d, "s");
		setDefaultModel(model);

this	Misc2  (id=5756)	
	data	PropertyModel<T>  (id=5766)	
		expression	"s" (id=5776)	
		target	Misc2$Data  (id=5764)	




/ Einde WICKET

/ OPEN IN BASH

[eric@localhost mpo]$ PGPASSWORD=mpopostgres@mpo psql -U mpopostgres -h  interstream-a.intermax.mp-objects.com isbscs
[eric@localhost mpo]$ interstream-acceptance.bash 

[eric@localhost mpo]$ carcon-p.bash -i dsv_2015_01_15-query-2.sql
[eric@localhost forticlientsslvpn]$ forticlientsslvpn.bash 

[eric@localhost trunk]$ cp ./base-framework/core/conf/language_en.properties /home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/pnloms/conf
[eric@localhost ActiveMQ]$ gedit ~/Downloads/SHIPMENT_ORDER_MSG.TransientObjectException\ \(1\).xml

[eric@localhost dsvcts]$ pwd
/home/eric/Devel/Firebird/scripts/dsvcts
[eric@localhost dsvcts]$ ls
anti-patch-0000-create-tables.sql                             patch-0002-cil_shipment_order_fk.sql
anti-patch-0001.sql                                           patch-0003-businessobjects.sql
...

[eric@localhost Firebird]$ isql-fb dsvcts.fdb -u sysdba -p masterkey
[eric@localhost repository]$ PGPASSWORD=mpopostgres@mpo psql -U mpopostgres pnloms

[eric@localhost eclipse-jee]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee
[eric@localhost eclipse-jee-test]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee-test
[eric@localhost pnloms]$ pwd
/home/eric/Devel/Java/JBoss/jboss-4.0.5.GA/server/pnloms
[eric@localhost jmx-examples]$ pwd
/home/eric/Devel/Java/JMX/jmx-examples
[eric@localhost trunk]$ pwd
/home/eric/Devel/Java/Eclipse/eclipse-jee/workspace/trunk
[eric@localhost apache-activemq-5.10.1]$  pwd
/home/eric/Devel/Java/ActiveMQ/apache-activemq-5.10.1
[eric@localhost apache-activemq-5.10.1]$ bin/activemq console
[eric@localhost apache-tomcat-7.0.57]$ pwd
/home/eric/Devel/Java/Tomcat/apache-tomcat-7.0.57
[eric@localhost Ehcache]$ pwd
/home/eric/Devel/Java/Ehcache
[eric@localhost demo-base]$ pwd
/home/eric/Devel/Java/Jetty/jetty-distribution-9.2.6.v20141205/demo-base
[eric@localhost ehcache-core-2.6.10-sources]$ pwd
/home/eric/Devel/Java/Ehcache/ehcache-core-2.6.10-sources



/ Einde OPEN IN BASH


