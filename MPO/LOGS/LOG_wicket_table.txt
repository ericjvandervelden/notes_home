/ See THEORY TYPES
/ See REPEATERS
/ 	See WORKING REPEATINGVIEW
/ 	See WORKING REFRESHINGVIEW
/ 	See WORKING DATAVIEW
/ 	See WORKING DATATABLE
/ 	See WORKING DATAGRIDVIEW
/ 		See WORKING FILTER
/ 	See WORKING LISTVIEW 
/ 	See CONTENT FILTERFORM IN DEBUG VIEW FILTERTOOLBAR DATAGRIDVIEW	
/ See USE OF MODELS
/ See DEBUG DATATABLE
/ See DEBUG REFRESHINGVIEW
/ See DEBUG LISTVIEW
/ See RENDERING RENDERALL RENDERNEXT
/ 	See RENDERALL MARKUP GLOBALLY NOT IN RENDERING
/ 	See RENDERNEXT FINDS MARKUP HEADER
/ See WEBMARKUPCONTAINER AND TAG
/ See WEBMARKUPCONTAINER IN OWN FILE AND TAG
/ See PANEL AND TAG
/ 	See VERSCHIL MET WEBMARKUPCONTAINER

/ DEBUG DATATABLE

/ See FILTERFORM
	/ See DESERIALIZE PAGE 
	/ See FILTER
/ See MODEL RUNTIME SET

/ See WEBMARKUPCONTAINER
/ See PANELS

/ 7	. 

		columns.add(new PropertyColumn<Contact, String>(new Model<>("Home Phone"), "homePhone"));
/ homePhone 	, property waarin	?
/ TODO

/ 7	. 

/ 13	. 

/ TextFilterPropertyColumn: er verschijnt een TextField boven de column	, 

$ vi TextFilter.html
<wicket:panel xmlns:wicket="http://wicket.apache.org"><input type="text" wicket:id="filter"/></wicket:panel>

/ 13	. 

$ vi ChoiceFilter.html
<wicket:panel xmlns:wicket="http://wicket.apache.org"><select wicket:id="filter"></select></wicket:panel>

$ vi FilterToolbar.html

<html xmlns:wicket="http://wicket.apache.org/">
<wicket:panel>
	<tr class="filters-tr">
		<wicket:container wicket:id="filters">
			<td wicket:id="filter" class="filter-td">[filter]</td>
		</wicket:container>
	</tr>
</wicket:panel>
</html>
/ In HTML zien we de panel tag NIET	, 
/ TODO

$ vi GoAndClearFilter.html
<wicket:panel xmlns:wicket="http://wicket.apache.org">
	<input type="submit" value="go" wicket:id="go" class="go"/> 
	<input type="submit" value="clear" wicket:id="clear" class="clear"/>
</wicket:panel>

$ vi GoFilter.html
<wicket:panel xmlns:wicket="http://wicket.apache.org"><input type="submit" value="go" wicket:id="go"/></wicket:panel>

/ 13	. 


/ Vrijwel alle components zijn WebMarkupContainer	, 
/ (Web)Page, is een MarkupContainer	,

public class TextField<T> extends AbstractTextComponent<T>
public abstract class AbstractTextComponent<T> extends FormComponent<T>
public abstract class FormComponent<T> extends LabeledWebMarkupContainer implements
public abstract class LabeledWebMarkupContainer extends WebMarkupContainer

public class Form<T> extends WebMarkupContainer

public abstract class Panel extends WebMarkupContainer implements IQueueRegion

public class WebPage extends Page
public abstract class Page extends MarkupContainer

/ 7	. 

/c
DataTableFilterToolbarMy3aPage.<init>() line: 125	
		SortableContactDataProvider_my dataProvider = new SortableContactDataProvider_my();
/d
this	DataTableFilterToolbarMy3aPage  (id=10134)	
columns	ArrayList<E>  (id=10168)	
	[0]	DataTableFilterToolbarMy3aPage$1  (id=10148)	
	[1]	DataTableFilterToolbarMy3aPage$2  (id=10153)	
	[2]	TextFilteredPropertyColumn<T,F,S>  (id=10158)	
		displayModel	Model<T>  (id=10156)	
		propertyExpression	"firstName" (id=10159)	
		sortProperty	"firstName" (id=10159)	
	[3]	DataTableFilterToolbarMy3aPage$3  (id=10161)	
	[4]	PropertyColumn<T,S>  (id=10164)	
	[5]	PropertyColumn<T,S>  (id=10176)	
	[6]	PropertyColumn<T,S>  (id=10177)	
dataProvider	SortableContactDataProvider_my  (id=10169)	
	contactFilter	ContactFilter_my  (id=10173)	
		dateFrom	null	
		dateTo	null	
		firstName	null	
		lastName	null	
	state	SingleSortState<T>  (id=10170)	
		param	SortParam<T>  (id=10174)	
			ascending	true	
			property	"firstName" (id=10159)	

		DataTable<Contact, String> table = new DataTable<>("tableWithFilterForm", columns,dataProvider, 8);
/s
DataTable<T,S>.<init>(String, List<IColumn<T,S>>, IDataProvider<T>, long) line: 135	

		body = newBodyContainer("body");
/ 'n WebMarkupContainer
		datagrid = newDataGridView("rows", columns, dataProvider);
/s
DataTable<T,S>.newDataGridView(String, List<IColumn<T,S>>, IDataProvider<T>) line: 168	
		return new DefaultDataGridView(id, columns, dataProvider);


/ Einde DEBUG DATATABLE

/ THEORY TYPES

/ 7	. 

/ Bij 'n Repeating view moet je zelf de components add	, 
/ bij een ListView geef je een list van elements mee	,  

/ Java
		RepeatingView repeating = new RepeatingView("view");

		repeating.add(new AjaxLink<Void>("1"){
			@Override
			public void onClick(AjaxRequestTarget target) {
			}
		});
		repeating.add(new Label("3",new Model<String>("foo")));

/ html
	<div wicket:id="view">
	</div>

/ Java
		final List<Contact> contacts = new ArrayList<>(10); 
		... / fill contacts in some way (via 'n ContactDataProvider eg)	,

		ListView<Contact> view = new ListView<Contact>("view",contacts)
		{
			@Override
			protected void populateItem(final ListItem<Contact> item)
			{
				Contact contact = item.getModelObject();
				item.add(new Label("itemid", item.getId()));
				item.add(new ActionPanel("actions", item.getModel()));
				item.add(new Label("contactid", String.valueOf(contact.getId())));
				...
/ html
	<tr wicket:id="view">
		<td><span wicket:id="itemid">[item id]</span></td>
		<td><span wicket:id="actions">[actions]</span></td>
		<td><span wicket:id="contactid">[contactid]</span> </td>
		<td><span wicket:id="firstname">[firstname]</span></td>
		<td><span wicket:id="lastname">[lastname]</span></td>
		<td><span wicket:id="homephone">[homephone]</span></td>
		<td><span wicket:id="cellphone">[cellphone]</span></td>
	</tr>

/ 7	. 

/ op DataTableFilterToolbarMy3aPage	, 

public class DataTable<T, S> extends Panel implements IPageableItems
/ het is een panel	,

$ vi DataTable.html

<wicket:panel xmlns:wicket="http://wicket.apache.org">
<caption wicket:id="caption"></caption>
<colgroup wicket:id="colGroup"></colgroup>
<thead wicket:id="topToolbars">
	<wicket:container wicket:id="toolbars"></wicket:container>
</thead>
<tfoot wicket:id="bottomToolbars">
	<wicket:container wicket:id="toolbars"></wicket:container>
</tfoot>
<tbody wicket:id="body">
	<tr wicket:id="rows">
		<td wicket:id="cells">
			<div wicket:id="cell">[cell]</div>
		</td>
	</tr>
</tbody>
</wicket:panel>
/ In HTML zien we het de panel tag NIET	, 
/ In HTML zien we het de caption NIET	, 

/ 13	. 



/ WORKING ABSTRACTDATAGRIDVIEW

/we hadden eerder in RefreshingPage een RefreshingView create	, waarvan we zelf getItemModels() en populateItem(final Item<Contact> item) moesten implement	, populateItem doet:
	item.add(new Label("contactid", String.valueOf(contact.getId()))); 
/
/ een AbstractDataGridView implements populateItem zelf, en z'n parent, DataViewBase implements getItemModels	, maar het is in feite verplaatst naar de IDataProvider	, 
/
/ We moeten zelf de markup geven van de repeater	, maar DataTable heeft al deze markup	, 

$ vi DataGridPage_my2.java
		List<ICellPopulator<Contact>> columns = new ArrayList<>();
		...
		ICellPopulator<Contact>homePhone=new PropertyPopulator<Contact>("homePhone");
		columns.add(homePhone);
		add(new DataGridView<>("rows", columns, new SortableContactDataProvider()));

$ vi DataGridPage_my2.html

<table cellspacing="0" cellpadding="2" border="1">
	<tr wicket:id="rows">											/ markup van de row Item	, want row Item is child van de  repeater DataGridView	, 
		<td wicket:id="cells">										/ markup van de cell Item	,	 want cell Item is child van de row Item	, 
			<span wicket:id="cell">cell content goes here</span>		/ markup van de Label	, want Label is child van cell Item	, 
		</td>
	</tr>
</table>


$ vi SortableContactDataProvider.java

	@Override
	public Iterator<Contact> iterator(long first, long count)
	{
		List<Contact> contactsFound = getContactsDB().getIndex(getSort());
		
		return filterContacts(contactsFound).
			subList((int)first, (int)(first + count)).
			iterator();
	}
	@Override
	public IModel<Contact> model(Contact object)
	{
		return new DetachableContactModel(object);
	}


public abstract class AbstractDataGridView<T> extends DataViewBase<T>
	@Override
	protected final void populateItem(final Item<T> item)
	{
		RepeatingView cells = new RepeatingView(CELL_REPEATER_ID);		/ 'cells"
		item.add(cells);

		int populatorsNumber = populators.size();
		for (int i = 0; i < populatorsNumber; i++)
		{
			ICellPopulator<T> populator = populators.get(i);
			IModel<ICellPopulator<T>> populatorModel = new Model<>(populator);								/ TODO Waar used	?
			Item<ICellPopulator<T>> cellItem = newCellItem(cells.newChildId(), i, populatorModel);
			cells.add(cellItem);

			populator.populateItem(cellItem, CELL_ITEM_ID, item.getModel());	/ "cell"

public class PropertyPopulator<T> implements ICellPopulator<T>
	@Override
	public void populateItem(final Item<ICellPopulator<T>> cellItem, final String componentId,
		final IModel<T> rowModel)
	{
		cellItem.add(new Label(componentId, new PropertyModel<>(rowModel, property)));
	}

public abstract class DataViewBase<T> extends AbstractPageableView<T>
	@Override
	protected final Iterator<IModel<T>> getItemModels(long offset, long count)
	{
		return new ModelIterator<T>(internalGetDataProvider(), offset, count);	/ iterator over Models	,
	}
	private static final class ModelIterator<T> implements Iterator<IModel<T>>
	{
		private final Iterator<? extends T> items;
		private final IDataProvider<T> dataProvider;
		public ModelIterator(IDataProvider<T> dataProvider, long offset, long count)
		{
			items = count > 0 ? dataProvider.iterator(offset, count) : null;		/ iterator over Object, NIET Models
		}
		@Override
		public IModel<T> next()
		{
			index++;
			return dataProvider.model(items.next());
		}

/ 13	. 

/ WORKING DATATABLE

/ We hoeven alleen een IDataProvider te geven	, die de row models geeft	, 
/ en de column met hun properties	,

/ Dus RefreshingView.populateItem en .getItemModels zijn implemented	, 
/ door AbstractDataGridView.populateItem (item is row item, and is populated met cell items),  en AbstractPageableView.getItemModels	(row models), 


public class DataTable<T, S> extends Panel implements IPageableItems
	protected Item<T> newRowItem(final String id, final int index, final IModel<T> model)
	{
		return new Item<>(id, index, model);
	}
	protected Item<IColumn<T, S>> newCellItem(final String id, final int index,
		final IModel<IColumn<T, S>> model)
	{
		return new Item<>(id, index, model);
	}
	private class DefaultDataGridView extends DataGridView<T>
	{
		protected Item newCellItem(final String id, final int index, final IModel model)
		{
			Item item = DataTable.this.newCellItem(id, index, model);
			final IColumn<T, S> column = DataTable.this.columns.get(index);
			return item;
		}
		protected Item<T> newRowItem(final String id, final int index, final IModel<T> model)
		{
			return DataTable.this.newRowItem(id, index, model);
		}
	}
/e
public abstract class AbstractDataGridView<T> extends DataViewBase<T>
	protected Item<ICellPopulator<T>> newCellItem(final String id, final int index, final IModel<ICellPopulator<T>> model)	/ overridden door DataTable$DefaultDataGridView.newCellItem
	{
		return new Item<>(id, index, model);
	}
	@Override
	protected Item<T> newRowItem(final String id, final int index, final IModel<T> model)	/ wordt overridden door DataTable$DefaultDataGridView.newRowItem	,
	{
		return new Item<>(id, index, model);
	}
	protected final Item<T> newItem(final String id, final int index, final IModel<T> model)
	{
		return newRowItem(id, index, model);		/ calls DataTable$DefaultDataGridView.newRowItem 
	}
	protected final void populateItem(final Item<T> item) 			/ row item	,
		RepeatingView cells = new RepeatingView(CELL_REPEATER_ID);
		item.add(cells);

		int populatorsNumber = populators.size();
		for (int i = 0; i < populatorsNumber; i++)
		{
			ICellPopulator<T> populator = populators.get(i);
			IModel<ICellPopulator<T>> populatorModel = new Model<>(populator);
			Item<ICellPopulator<T>> cellItem = newCellItem(cells.newChildId(), i, populatorModel); / calls DataTable$DefaultDataGridView.newCellItem	,
			cells.add(cellItem);

			populator.populateItem(cellItem, CELL_ITEM_ID, item.getModel());	 / calls PropertyColumn.populateItem	, die cell item .add Label met een property model	,  de property zit in de populator	, en is op de row model	,
/e
public abstract class DataViewBase<T> extends AbstractPageableView<T>
	protected final Iterator<IModel<T>> getItemModels(long offset, long count)	{	/ calls IDataProvider	
		return new ModelIterator<T>(internalGetDataProvider(), offset, count);
/e
public abstract class AbstractPageableView<T> extends RefreshingView<T> implements IPageableItems
	protected Iterator<IModel<T>> getItemModels() {
		...
		Iterator<IModel<T>> models = getItemModels(offset, size); / calls DataViewBase.getItemModels	, 
/e
public abstract class RefreshingView<T> extends RepeatingView
	protected Item<T> newItem(final String id, int index, final IModel<T> model)
	{
		return new Item<>(id, index, model);
	}
	protected final void onPopulate()
	{
		Iterator<IModel<T>> models = getItemModels();		/ calls AbstractPageableView.getItemModels	,
		Iterator<Item<T>> items = getItemReuseStrategy().getItems(newItemFactory(), models,
		removeAll();
		addItems(items);
	}
	protected IItemFactory<T> newItemFactory()
	{
		return new IItemFactory<T>()
		{
			@Override
			public Item<T> newItem(int index, IModel<T> model)		/ row item	,
			{
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);	/ calls AbstractDataGridView.newItem 	, die calls DataTable$DefaultDataGridView.newRowItem 
				RefreshingView.this.populateItem(item);							/ calls AbstractDataGridView.populateItem, die calls calls DataTable$DefaultDataGridView.newCellItem 
				return item;
			}
		};
	}
	protected void addItems(Iterator<Item<T>> items)
	{
		int index = 0;
		while (items.hasNext())
		{
			Item<T> item = items.next();
			item.setIndex(index);
			add(item);
			++index;
		}
	}

public class DefaultItemReuseStrategy implements IItemReuseStrategy
	public <T> Iterator<Item<T>> getItems(final IItemFactory<T> factory, final Iterator<IModel<T>> newModels, Iterator<Item<T>> existingItems)
	{
		return new Iterator<Item<T>>()
		{
			@Override
			public Item<T> next()
			{
				IModel<T> model = newModels.next();
				Item<T> item = factory.newItem(index, model);
				index++;
				return item;
			}

		};
	}

public class PropertyColumn<T, S> extends AbstractColumn<T, S> implements IExportableColumn<T, S>
	@Override
	public void populateItem(final Item<ICellPopulator<T>> item, final String componentId,	/ item is cell item	,
		final IModel<T> rowModel)
	{
		item.add(new Label(componentId, getDataModel(rowModel)));
	}
	@Override
	public IModel<?> getDataModel(IModel<T> rowModel)
	{
		PropertyModel<?> propertyModel = new PropertyModel<>(rowModel, propertyExpression);
		return propertyModel;
	}

/ 13	. 

/ WORKING DATAGRIDVIEW

/ render TextFilteredPropertyColumn doet 2 dingen: render Label in cell	, en render TextField op een TextFilter (is een Panel)	, in de FilterToolbar	,
/ de label in de cell heeft als model de (column) property in de Contact	, 
/ de textfield in de filter toolbar heeft als model dezelfde (column) property in de ContactFilter	,

public class TextFilteredPropertyColumn<T, F, S> extends FilteredPropertyColumn<T, S>
	public Component getFilter(final String componentId, final FilterForm<?> form)	 / (*)
	{
		return new TextFilter<>(componentId, getFilterModel(form), form);	/ model is in feite 1 van de properties uit het ContactFilter	, 	 
	}
	protected IModel<F> getFilterModel(final FilterForm<?> form)
	{
		return new PropertyModel<>(form.getDefaultModel(), getPropertyExpression());	/ In form's Model zit de IDataProvider	, die een ContactFilter als filterState property	, en een SingleSortState als state property		, 
	}

/e
public class PropertyColumn<T, S> extends AbstractColumn<T, S> implements IExportableColumn<T, S>
	@Override
	public void populateItem(final Item<ICellPopulator<T>> item, final String componentId, final IModel<T> rowModel) 	/ populate cell item	, (**)
	{
	 	item.add(new Label(componentId, getDataModel(rowModel)));	/ model is in feite een property uit de Contact	, 
	}
	@Override
	public IModel<?> getDataModel(IModel<T> rowModel)
	{
		PropertyModel<?> propertyModel = new PropertyModel<>(rowModel, propertyExpression);
		return propertyModel;



/ (**) called door	,
public abstract class AbstractDataGridView<T> extends DataViewBase<T>
	@Override
	protected final void populateItem(final Item<T> item)	 		/ populate row item	,
	{
		RepeatingView cells = new RepeatingView(CELL_REPEATER_ID);
		item.add(cells);

		int populatorsNumber = populators.size();
		for (int i = 0; i < populatorsNumber; i++)
		{
			ICellPopulator<T> populator = populators.get(i);
			IModel<ICellPopulator<T>> populatorModel = new Model<>(populator);
			Item<ICellPopulator<T>> cellItem = newCellItem(cells.newChildId(), i, populatorModel);
			cells.add(cellItem);

			populator.populateItem(cellItem, CELL_ITEM_ID, item.getModel());	 / calls PropertyColumn.populateItem	, 	populate cell item	
	}

	protected Item<T> newRowItem(final String id, final int index, final IModel<T> model)
	{
		return new Item<>(id, index, model);
	}
	protected Item<ICellPopulator<T>> newCellItem(final String id, final int index, final IModel<ICellPopulator<T>> model)
	{
		return new Item<>(id, index, model);
	}

public abstract class RefreshingView<T> extends RepeatingView
	protected IItemFactory<T> newItemFactory()
	{
		return new IItemFactory<T>()
		{
			@Override
			public Item<T> newItem(int index, IModel<T> model)
			{
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);	/ calls AbstractDataGridView.newRowItem	,
				RefreshingView.this.populateItem(item);		/ calls AbstractDataGridView.populateItem	,
				return item;

/ (*) called door	, 
public class FilterToolbar extends AbstractToolbar
		ListView<IColumn<T, S>> filters = new ListView<IColumn<T, S>>("filters", model)
			@Override
			protected void populateItem(ListItem<IColumn<T, S>> item)
			{
				final IColumn<T, S> col = item.getModelObject();	/ IColumn,	 
				item.setRenderBodyOnly(true);

				Component filter = null;

				if (col instanceof IFilteredColumn)					/ hier wordt ListItem's Model used!
				{
					IFilteredColumn<T, S> filteredCol = (IFilteredColumn<T, S>)col;
					filter = filteredCol.getFilter(FILTER_ID, form);
				}
				if (filter == null)
				{
					filter = new NoFilter(FILTER_ID);
				}

/ 13	. 

/ WICKET LISTVIEW

FilterForm
	Model's object= IDataProvider	 (met FilterState en SingleSortState)	,

	FilterToolbar
		Model null
		
		ListView
			Model's object=List IColumn
		
			ListItem
				ListItemModel's object=index
				children=TextFilter (is een Panel)	/ als de IColumn een TextFilteredPropertyColumn	,
					Model=null
					children=TextField
						Model=PropertyModel op FilterForm's Model + IColumn's property	,

/ belangrijke method	,

public class FilterToolbar extends AbstractToolbar
		ListView<IColumn<T, S>> filters = new ListView<IColumn<T, S>>("filters", model)
			protected void populateItem(ListItem<IColumn<T, S>> item)
				final IColumn<T, S> col = item.getModelObject();		/ IColumn	, see (***)		, item.getModel()=ListItemModel heeft index	, 
																				/ maar ListItemModel's getObject is special	, is NIET return index	,
				item.setRenderBodyOnly(true);

				Component filter = null;

				if (col instanceof IFilteredColumn)
				{
					IFilteredColumn<T, S> filteredCol = (IFilteredColumn<T, S>)col;
					filter = filteredCol.getFilter(FILTER_ID, form);
				}

				if (filter == null)
				{
					filter = new NoFilter(FILTER_ID);

/ (***)
/ crucial method
public class ListItemModel<T> implements IModel<T>
	private final ListView<T> listView;
	private final int index;
	public T getObject()
	{
		return listView.getModelObject().get(index);	/ listView.getModelObject()=List IColumns	,
	}





/ 13	. 

/ WORKING FILTER	



public class GoFilter extends Panel
{
	private final Button go;

	public GoFilter(final String id, final IModel<String> goModel)
	{
		super(id);

		go = new Button("go", goModel)
		{
			@Override
			public void onSubmit()
			{
				onGoSubmit(this);
			}
		};

		add(go);
	}

	protected void onGoSubmit(final Button button)
	{
	}
}
/ GoFilter/TextFilter/NoFilter wordt bijvoorbeeld add aan ListItem in de FilterToolbar's ListView (FilterToolbar$2)	's populateItem	, 	
/ de FilterToolbar's ListView heeft als Model het array met de IColums (getObject geeft deze)	, (FilterToolbar heeft model null)

public abstract class SoftDeletableSearchPage<T extends EnumeratedValueObjectInterface> extends BasePage implements SoftDeletableAction<EnumeratedValueObjectInterface> {
        public SoftDeletableSearchPage(ISortableDataProvider<T> sortableDataProvider) {



public class DataTableFilterToolbarMy3aPage extends BaseMy3aPage
	public DataTableFilterToolbarMy3aPage()
	{
		List<IColumn<Contact, String>> columns = new ArrayList<>();
		
		columns.add(new AbstractColumn<Contact, String>(new Model<>("Actions"))
		{
			@Override
			public void populateItem(Item<ICellPopulator<Contact>> cellItem, String componentId, IModel<Contact> m) {
				Panel action=new ActionMy3aPanel(componentId) {
					@Override
					protected void click(AjaxRequestTarget target) {
                        // first setTitle, then show    , because show calls getTitle   ,
						((ModalWindow)getPage().get("modal")).setTitle(new PropertyModel<String>(model, "cellPhone"));
						((ModalWindow)getPage().get("modal")).setContent(confirm).show(target);
						getPage().setDefaultModel(model);
					}
				};
				cellItem.add(action);




	

/ 13	. 

/ WORKING DATATABLE

/ DataTable	,

public class DataTable<T, S> extends Panel implements IPageableItems
	protected Item<T> newRowItem(final String id, final int index, final IModel<T> model)
	{
		return new Item<>(id, index, model);
	}
	private class DefaultDataGridView extends DataGridView<T>
		@Override
		protected Item<T> newRowItem(final String id, final int index, final IModel<T> model)		<- Waar called	?
		{
			return DataTable.this.newRowItem(id, index, model);	
		}
/ cb
public abstract class AbstractDataGridView<T> extends DataViewBase<T>
	@Override
	protected final Item<T> newItem(final String id, final int index, final IModel<T> model)
	{
		return newRowItem(id, index, model);
	}
/cb
public abstract class RefreshingView<T> extends RepeatingView
	protected IItemFactory<T> newItemFactory()
	{
		return new IItemFactory<T>()
		{
			@Override
			public Item<T> newItem(int index, IModel<T> model)
			{
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);		<-		row item	,
				RefreshingView.this.populateItem(item);
				return item;
			}
		};
	}

/ en	, 

public class DataTable<T, S> extends Panel implements IPageableItems
	protected Item<IColumn<T, S>> newCellItem(final String id, final int index, final IModel<IColumn<T, S>> model)
	{
		return new Item<>(id, index, model);
	}
	private class DefaultDataGridView extends DataGridView<T>
		@Override
		protected Item newCellItem(final String id, final int index, final IModel model)				<- Waar called?
		{
			Item item = DataTable.this.newCellItem(id, index, model);
			final IColumn<T, S> column = DataTable.this.columns.get(index);
			return item;
		}
/ cb
public abstract class AbstractDataGridView<T> extends DataViewBase<T>
	@Override
	protected final void populateItem(final Item<T> item)
	{
		RepeatingView cells = new RepeatingView(CELL_REPEATER_ID);	/ "cells"
		item.add(cells);

		int populatorsNumber = populators.size();
		for (int i = 0; i < populatorsNumber; i++)
		{
			ICellPopulator<T> populator = populators.get(i);
			IModel<ICellPopulator<T>> populatorModel = new Model<>(populator);
			Item<ICellPopulator<T>> cellItem = newCellItem(cells.newChildId(), i, populatorModel);		<-
			cells.add(cellItem);

			populator.populateItem(cellItem, CELL_ITEM_ID, item.getModel());	/ "cell"
		}
	}
}
/cb
public abstract class RefreshingView<T> extends RepeatingView
	protected IItemFactory<T> newItemFactory()
	{
		return new IItemFactory<T>()
		{
			@Override
			public Item<T> newItem(int index, IModel<T> model)
			{
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);
				RefreshingView.this.populateItem(item);						<- item = row item	,
				return item;
			}
		};
	}
}

/ 1313	. 

/ PropertyPopulator is impl van ICellPopulator: heeft propertyExpression	, 
/ IColumn extends ICellPopulator, en heeft header, sort	,PropertyColumn heeft ook propertyExpression	,


public class PropertyColumn<T, S> extends AbstractColumn<T, S> implements IExportableColumn<T, S>
	private final ICellPopulatorString propertyExpression;
/e
public abstract class AbstractColumn<T, S> implements IStyledColumn<T, S>
	private final IModel<String> displayModel;
	private final S sortProperty;

public interface IStyledColumn<T, S> extends IColumn<T, S>

/e
public interface IColumn<T, S> extends ICellPopulator<T>
	Component getHeader(String componentId);
	S getSortProperty();
	boolean isSortable();
/e
public interface ICellPopulator<T> extends IClusterable, IDetachable
	void populateItem(final Item<ICellPopulator<T>> cellItem, final String componentId, final IModel<T> rowModel);

/ en	, 

public class PropertyPopulator<T> implements ICellPopulator<T>
	private final String property;
/ impl populateItem()
/e
public interface ICellPopulator<T> extends IClusterable, IDetachable
	void populateItem(final Item<ICellPopulator<T>> cellItem, final String componentId, final IModel<T> rowModel);

/ 1313	. 

public class TextFilteredPropertyColumn<T, F, S> extends FilteredPropertyColumn<T, S>
	@Override
	public Component getFilter(final String componentId, final FilterForm<?> form)
	{
		return new TextFilter<>(componentId, getFilterModel(form), form);
	}
	protected IModel<F> getFilterModel(final FilterForm<?> form)
	{
		return new PropertyModel<>(form.getDefaultModel(), getPropertyExpression());		<- TODO Wat is het form's default model
	}

/ en 	, 

public class TextFilter<T> extends AbstractFilter
	private final TextField<T> filter;
	public TextFilter(final String id, final IModel<T> model, final FilterForm<?> form)
	{
		super(id, form);
		filter = new TextField<>("filter", model);
		...
		add(filter);
	}
/e
public class AbstractFilter extends Panel
	protected IFilterStateLocator<?> getStateLocator()
	{
		return form.getStateLocator();
	}

	protected IModel<?> getStateModel()
	{
		return form.getDefaultModel();
	}

	protected Object getState()
	{
		return form.getDefaultModelObject();
	}

$ vi NavigationToolbar.java

public class NavigationToolbar extends AbstractToolbar
	public NavigationToolbar(final DataTable<?, ?> table)
	{
		super(table);

		WebMarkupContainer span = new WebMarkupContainer("span");
		add(span);
		span.add(AttributeModifier.replace("colspan", new AbstractReadOnlyModel<String>()
		{
			private static final long serialVersionUID = 1L;

			@Override
			public String getObject()
			{
				return String.valueOf(table.getColumns().size()).intern();
			}
		}));

		span.add(newPagingNavigator("navigator", table));
		span.add(newNavigatorLabel("navigatorLabel", table));
	}

public class PagingNavigator extends Panel
/ TODO

public class DataTableFilterToolbarMy3aPage extends BaseMy3aPage
		...
		columns.add(new PropertyColumn<Contact, String>(new Model<>("Cell Phone"), "cellPhone"));
		SortableContactDataProvider_my dataProvider = new SortableContactDataProvider_my();
		DataTable<Contact, String> table = new DataTable<>("tableWithFilterForm", columns,dataProvider, 8);

		FilterForm<ContactFilter_my> filterForm = new FilterForm<>("filterForm", dataProvider);	
		FilterToolbar filterToolbar = new FilterToolbar(table, filterForm);
		table.addTopToolbar(filterToolbar);

		table.addTopToolbar(new NavigationToolbar(table));
		table.addTopToolbar(new HeadersToolbar<>(table, dataProvider));
		
		filterForm.add(table);


$ vi ExamplePage.html

<body>

    <span wicket:id = "mainNavigation"/>
    
    <h2>Welcome to Repeater View Examples</h2>

    <p><wicket:link><a href="Index.html">[go back]</a></wicket:link></p>

	<wicket:child/>
</body>

$ vi BaseMy3Page.html

<wicket:extend xmlns:wicket="http://wicket.apache.org">
	<span style="display: block; border: 1px solid black;">
		Selected Contact: <span wicket:id="selectedLabel">[selected contact]</span>
	</span>
	<br/>
	<span wicket:id="feedback">Feedback messages go here</span>
	<wicket:child/>
</wicket:extend>

$ vi DataTableFilterToolbarMy3aPage.html

<wicket:extend>

This table has a toolbar filter. We can specify a valid range for contact's born date.<br/>
	<br/>
   
    <form wicket:id="filterForm">
    	<table class="dataview" wicket:id="tableWithFilterForm"></table>			/ DataTable
    </form>
    
    <div wicket:id="modal"></div>
    
</wicket:extend>


$ vi DataTable.html

<wicket:panel xmlns:wicket="http://wicket.apache.org">		/ zien we niet	, 
<caption wicket:id="caption"></caption>			/ zien we niet	, 
<colgroup wicket:id="colGroup"></colgroup>		/ zien we niet	,
<thead wicket:id="topToolbars">
	<wicket:container wicket:id="toolbars"></wicket:container>
</thead>
<tfoot wicket:id="bottomToolbars">
	<wicket:container wicket:id="toolbars"></wicket:container>
</tfoot>
<tbody wicket:id="body">		/ zien we	, WebMarkupContainer	,
	<tr wicket:id="rows">		/ zien we , DefaultDataGridView 	, 'n repeater	,
		<td wicket:id="cells">	/ zien we , RepeatingView	, een repeater	, 
			<div wicket:id="cell">[cell]</div>
		</td>
	</tr>
</tbody>
</wicket:panel>

/ MORGENOCHTEND 8 mei Oef met templates en children	,


/ de Items die children zijn van de DefaultDataGridView "rows" krijgen markup van deze repeater	,
    <tr wicket:id="rows">     
        <td wicket:id="cells"> 
            <div wicket:id="cell">[cell]</div>
        </td>
    </tr>
/ de RepeatingView "cells" die een child is van dit Item, krijgt markup	, 
    <td wicket:id="cells"> 
    	<div wicket:id="cell">[cell]</div>
	</td>

/ de Items die chilren zijn van de RepeatingView "cells" krijgen markup van deze repeater	, 
		<td wicket:id="cells">	
			<div wicket:id="cell">[cell]</div>
		</td>
/ de Label "cell" die child is van de Item krijgt markup
			<div wicket:id="cell">[cell]</div>
/ en dat klopt, see PropertyColumn.populateItem hierboven	, 


$ vi FilterToolbar.html

<wicket:panel>
	<tr class="filters-tr">						/ zien we niet	,
		<wicket:container wicket:id="filters">		/ zien we niet	, 
			<td wicket:id="filter" class="filter-td">[filter]</td>	/ repeater	, 
		</wicket:container>
	</tr>
</wicket:panel>


$ vi TextFilter.html

<wicket:panel xmlns:wicket="http://wicket.apache.org">	/ zien we wel	,
	<input type="text" wicket:id="filter"/>
</wicket:panel>

$ vi NavigationToolbar.html

<wicket:panel xmlns:wicket="http://wicket.apache.org">	/ zien we niet	,
	<tr class="navigation">
		<td wicket:id="span">
			<div class="navigatorLabel">
				<div wicket:id="navigatorLabel">[navigator-label]</div>
			</div>
			<div class="navigator">
				<div wicket:id="navigator">[navigator]</div>
			</div>
		</td>
	</tr>
</wicket:panel>

$ vi HeadersToolbar.html

<wicket:panel xmlns:wicket="http://wicket.apache.org">		/ zien we niet	,
	<tr class="headers">
		<wicket:container wicket:id="headers">		/ zien we niet	,
			<th wicket:id="header">
				<span wicket:id="label">[header-label]</span>
			</th>
		</wicket:container>
	</tr>
</wicket:panel>

$ vi GoAndClearFilter.html

<wicket:panel xmlns:wicket="http://wicket.apache.org">
	<input type="submit" value="go" wicket:id="go" class="go"/> 
	<input type="submit" value="clear" wicket:id="clear" class="clear"/>
</wicket:panel>

$ vi GoFilter.html

<wicket:panel xmlns:wicket="http://wicket.apache.org">
	<input type="submit" value="go" wicket:id="go"/>
</wicket:panel>


/ 7	 

/ Zoek in wicket-core naar .java file alleen in path waar src/main/java  in staat	, dus niet in src/test/java
[eric@localhost wicket]$ find wicket-core/ -path "*/src/main/java*.java"




/ 7	. 

/ verschil DataView en AbstractDataGridView (GridView)

/ DataView toont een list uit de db	, AbstractDataGridView een grid, dus een list met attributes	,  

public class DataTable<T, S> extends Panel implements IPageableItems
	private class DefaultDataGridView extends DataGridView<T>

public class DataGridView<T> extends AbstractDataGridView<T>
/**
 * Acts as a base for data-grid views. Unlike a data view a data-grid view populates both rows and
 * columns. The columns are populated by an array of provided ICellPopulator objects.
 * 
public abstract class AbstractDataGridView<T> extends DataViewBase<T>
public abstract class DataViewBase<T> extends AbstractPageableView<T>						/ IDataProvider + Iterator
public abstract class AbstractPageableView<T> extends RefreshingView<T> implements IPageableItems
public abstract class RefreshingView<T> extends RepeatingView
public class RepeatingView extends AbstractRepeater
public abstract class AbstractRepeater extends WebMarkupContainer

/**
 * DataView is a basic implementation of {@link AbstractPageableView}.
 * 
 * Data views aim to make it very simple to populate your repeating view from a database by
 * utilizing {@link IDataProvider} to act as an interface between the database and the dataview.
 * 
public abstract class DataView<T> extends DataViewBase<T>
public abstract class DataViewBase<T> extends AbstractPageableView<T>						/ IDataProvider + Iterator


/ 7	.  

/ we zien verschil DataView en RefreshingView: we hoeven zelf geen Iterator te maken	, 
/ klopt	, 
public abstract class DataViewBase<T> extends AbstractPageableView<T>
	@Override
	protected final Iterator<IModel<T>> getItemModels(long offset, long count)
	{
		return new ModelIterator<T>(internalGetDataProvider(), offset, count);
	}
	private static final class ModelIterator<T> implements Iterator<IModel<T>>
		private final Iterator<? extends T> items;
		private final IDataProvider<T> dataProvider;
		public ModelIterator(IDataProvider<T> dataProvider, long offset, long count)
		{
			this.dataProvider = dataProvider;
			max = count;

			items = count > 0 ? dataProvider.iterator(offset, count) : null;
		}

/ 13	. 

public class DataGridPage_my2 extends BasePage

/


/ 7	. 

/ RefreshView methods in (Abstract)DataGridView en DataView	,	

/ AbstractDataGridView defs zelf populateItem	, Als je een DataView maakt, moet je het zelf doen	,    

/ 13	

public class DataGridView<T> extends AbstractDataGridView<T>
/e
public abstract class AbstractDataGridView<T> extends DataViewBase<T>
	@Override
	protected final void populateItem(final Item<T> item)
	{
		RepeatingView cells = new RepeatingView(CELL_REPEATER_ID);
		item.add(cells);

		int populatorsNumber = populators.size();
		for (int i = 0; i < populatorsNumber; i++)
		{
			ICellPopulator<T> populator = populators.get(i);
			IModel<ICellPopulator<T>> populatorModel = new Model<>(populator);		/ stateful Model	, maar WH omdat we een RefreshingView op de rows	, vworden deze toch steeds refreshed	, dus OK	,	
			Item<ICellPopulator<T>> cellItem = newCellItem(cells.newChildId(), i, populatorModel);
			cells.add(cellItem);

			populator.populateItem(cellItem, CELL_ITEM_ID, item.getModel());	 (*)

			if (cellItem.get("cell") == null)
			{
				throw new WicketRuntimeException(
					populator.getClass().getName() +
						".populateItem() failed to add a component with id [" +
						CELL_ITEM_ID +
						"] to the provided [cellItem] object. Make sure you call add() on cellItem and make sure you gave the added component passed in 'componentId' id. ( *cellItem*.add(new MyComponent(*componentId*, rowModel) )");
			}
		}

	}

/ 13	. 

/ impl van (*)

public class PropertyColumn<T, S> extends AbstractColumn<T, S> implements IExportableColumn<T, S>
	@Override
	public void populateItem(final Item<ICellPopulator<T>> item, final String componentId,
		final IModel<T> rowModel)
	{
		item.add(new Label(componentId, getDataModel(rowModel)));
	}
	@Override
	public IModel<?> getDataModel(IModel<T> rowModel)
	{
		PropertyModel<?> propertyModel = new PropertyModel<>(rowModel, propertyExpression);
		return propertyModel;
	}

/ 13	. 

/ DataView

/ uit manual	,

<table>
        <tr wicket:id="rows">
           <td wicket:id="dataRow"></td>
        </tr>
</table>

/ en	, 

List<Person> persons = loadPersons();
ListDataProvider<Person> listDataProvider = new ListDataProvider<Person>(persons);

DataView<Person> dataView = new DataView<Person>("rows", listDataProvider) {

  @Override
  protected void populateItem(Item<Person> item) {
    Person person = item.getModelObject();
    RepeatingView repeatingView = new RepeatingView("dataRow");

    repeatingView.add(new Label(repeatingView.newChildId(), person.getName()));
    repeatingView.add(new Label(repeatingView.newChildId(), person.getSurename()));
    repeatingView.add(new Label(repeatingView.newChildId(), person.getAddress()));
    repeatingView.add(new Label(repeatingView.newChildId(), person.getEmail()));
    item.add(repeatingView);
  }
};
add(dataView);

/ WORKING DATAVIEW
/ DataView < DataViewBase implements zelf getItemModels()	, maar in feite moeten we het toch zelf doen, want DataViewBase haalt de iterator uit onze IDataProvider	,

$ vi DataViewBase.java
public abstract class DataViewBase<T> extends AbstractPageableView<T>
	@Override
	protected final Iterator<IModel<T>> getItemModels(long offset, long count)
	{
		return new ModelIterator<T>(internalGetDataProvider(), offset, count);
	}
	private static final class ModelIterator<T> implements Iterator<IModel<T>>
	{
		private final Iterator<? extends T> items; 										/ Iterator over de Objects, NIET de Models	,
		private final IDataProvider<T> dataProvider;
		private final long max;
		private long index;
		public ModelIterator(IDataProvider<T> dataProvider, long offset, long count)
		{
			this.dataProvider = dataProvider;
			max = count;

			items = count > 0 ? dataProvider.iterator(offset, count) : null;
		}
		@Override
		public IModel<T> next()
		{
			index++;
			return dataProvider.model(items.next());
		}

$ vi ContactDataProvider.java

public class ContactDataProvider implements IDataProvider<Contact>
{
	@Override
	public Iterator<Contact> iterator(long first, long count)								/ Iterator over de Objects	, NIET de Models	,
	{
		return getContactsDB().find(first, count, new SortParam<String>("firstName", true))
			.iterator();
	}
	@Override
	public IModel<Contact> model(Contact object)
	{
		return new DetachableContactModel(object);
	}

/ In Refreshing3Page def we zelf een Iterator over Models	, we hadden een soort LoadableDetachableModels create	, 

Refreshing3Page.class
		for(int i=0;i<count;i++){
			integers.add(new Model<Integer>(){		// een soort LoadableDetachableModel	,
				@Override
				public Integer getObject() {
					return (int)(Math.random()*1000);
				}
			});
		}
		final RefreshingView<Integer> view = new RefreshingView<Integer>("view")
			@Override
			protected Iterator<IModel<Integer>> getItemModels()
			{
				return integers.iterator();
			}



/ 13	. 

public abstract class DataView<T> extends DataViewBase<T>

/e
public abstract class DataViewBase<T> extends AbstractPageableView<T>
	@Override
	protected final Iterator<IModel<T>> getItemModels(long offset, long count)
	{
		return new ModelIterator<T>(internalGetDataProvider(), offset, count);
	}
/e
public abstract class AbstractPageableView<T> extends RefreshingView<T> implements IPageableItems
	@Override
	protected Iterator<IModel<T>> getItemModels()														/ method waar we steeds komen	,
	{
		long offset = getFirstItemOffset();
		long size = getViewSize();

		Iterator<IModel<T>> models = getItemModels(offset, size);		/ een iterator over detachable models om de Contacts heen; 
																	/ moet detachable models ,die Contacts opvragen aan db,  ipv Contacts , anders zie je de vorige Contacts nog (die Session scoped zijn)	,  

		models = new CappedIteratorAdapter<T>(models, size);

		return models;
	}
	protected abstract Iterator<IModel<T>> getItemModels(long offset, long size);

/ 7	. 

/ we kijken meer in detail naar de ModelItenerator	,

public abstract class DataViewBase<T> extends AbstractPageableView<T>
	@Override
	protected final Iterator<IModel<T>> getItemModels(long offset, long count)	
	{
		return new ModelIterator<T>(internalGetDataProvider(), offset, count);
	}

	private static final class ModelIterator<T> implements Iterator<IModel<T>>
	{
		private final Iterator<? extends T> items;		/ bijv een Iterator<Contact>	, een Iterator<Contact> op een List<Contact>	,
		private final IDataProvider<T> dataProvider;
		private final long max;
		private long index;

		public ModelIterator(IDataProvider<T> dataProvider, long offset, long count)
		{
			this.dataProvider = dataProvider;
			max = count;

			items = count > 0 ? dataProvider.iterator(offset, count) : null;
		}
		@Override
		public IModel<T> next()
		{
			index++;
			return dataProvider.model(items.next());	/ items.next()=Contact	, en dataProvider.model(deze Contact)= 'n detachable model op deze Contact	, 
					/ return NIET items.next()	, want anders werd de vorige Contact serialized, en bij de deze request weer deser.	, en verschijnt weer, en zien we dus NIET de deze die hier returns wordt 	, je moet altijd de detachable model er in set	, 
/ bij het render moet object uit model gehaald, TODO wanneer gebeurt dat	?
/ TODO
/				/ wat hier eig. staat is dataProvider.model(dataProvider.iterator(offset,count).next())	, dus 2 keer dataProvider	, 
		}
	}
}

public class ContactDataProvider implements IDataProvider<Contact>											/ data provider die we altijd maken	,
	@Override
	public Iterator<Contact> iterator(long first, long count)
	{
		return getContactsDB().find(first, count, new SortParam<String>("firstName", true))
			.iterator();
	}
	@Override
	public IModel<Contact> model(Contact object)
	{
		return new DetachableContactModel(object);
	}

public class ContactsDatabase
	public List<Contact> find(long first, long count, SortParam sort)
	{
		return getIndex(sort).subList((int)first, (int)(first + count));
	}
	public List<Contact> getIndex(SortParam sort)

/ 7	. 

/ Lees	, 
https://ci.apache.org/projects/wicket/guide/7.x/single.html#_always_use_models

If you use raw objects, you cannot replace them later. An example is an entity which gets loaded at each request within a LoadableDetachableModel. The entity manager creates a new object reference, but the page would keep the obsolete instance.
/ Als je geen detachable model use	, is de model of data session scoped	,  use detachable model, deze is request scoped	, en de data wordt wel veranderd met de results van de nieuwe query	,

/ 7	. 

/ Wanneer wordt AbstractDataGridView.populateItem called	?

/ called door	, 

abstract class RefreshingView

	protected abstract Iterator<IModel<T>> getItemModels();		/ een RefreshingView moet deze 2 impl	, (1) /= DataViewBase.getItemModels()
	protected abstract void populateItem(final Item<T> item);	/ (2)

	@Override
	protected final void onPopulate()			/ called door AbstractRepeater.onBeforeRender	,
	{
		Iterator<IModel<T>> models = getItemModels(); 	/ (1)	/ de models voor in de items (die nog moeten worden create) 
																	/= DataViewBase.getItemModels() , (row) models met (request scoped) Contacts er in	,
																		/ die de data provider heeft create	,
		Iterator<Item<T>> items = getItemReuseStrategy().getItems(newItemFactory(), models,		
			getItems());
		removeAll();
		addItems(items);		/ calls de items iterator van 2 regels hierboven's next()	,  die new Item, en populateItem daarop calls	, en addItems adds 												/ dit Item to the view	,
											/ TODO hoe gaat de render()	? WH met render children	,
	}
	protected IItemFactory<T> newItemFactory()
	{
		return new IItemFactory<T>()
		{
			@Override
			public Item<T> newItem(int index, IModel<T> model)
			{
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);		
				RefreshingView.this.populateItem(item);		/ (2)				/= call on AbstractDataGridView.populateItem
				return item;
			}
		};
	}
	protected void addItems(Iterator<Item<T>> items)
	{
		int index = 0;
		while (items.hasNext())
		{
			Item<T> item = items.next();
			item.setIndex(index);
			add(item);										<- RefreshingView is een WebMarkupContainer	,
			++index;
		}
	}

/ called door	, 

public class DefaultItemReuseStrategy implements IItemReuseStrategy
	@Override
	public <T> Iterator<Item<T>> getItems(final IItemFactory<T> factory,
		final Iterator<IModel<T>> newModels, Iterator<Item<T>> existingItems)
	{
		return new Iterator<Item<T>>()
		{
			private int index = 0;

			@Override
			public void remove()
			{
				throw new UnsupportedOperationException();
			}

			@Override
			public boolean hasNext()
			{
				return newModels.hasNext();
			}

			@Override
			public Item<T> next()
			{
				IModel<T> model = newModels.next();
				Item<T> item = factory.newItem(index, model);
				index++;
				return item;
			}

		};
	}

 


/ Einde THEORY TYPES

/ REPEATERS

/ 7	. 

/ Bij RefreshingView krijgt de IItemFactory  de models en maakt de Item	, die dan populate wordt dwz. krijgt een Label als child	,
/ je moet zeggen wat de models zijn, met getItemModels	, en wat de children worden van de Items , met populateItem
/ Bij RepeatingView moeten we het met de hand doen	,  maar we hoeven geen Items te maken	, we add de Labels direct aan de View	,  

/ Daarom zien we ook een verschil in de templates	, 

$ vi Repeating3View.html
	<div wicket:id="view"></div>

$ vi Refreshing3View.html
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>

/ templates zijn leidraad in MarkupContainer.renderAll/renderNext	, hij leest de wicket id, en zoekt de component met deze als id op in tree van components	, vanaf de Page

/ de Views	zijn MarkupContainers	, en wordt children van de Pages	, zelf krijgen ze ook children, Items of direct Labels	, 

Page
View
Label 

Page
View
Item
Label 

/ wat doet de index in een RefreshingView?

/ 7	. 

/ 13	. 

/ bij RefreshingView:
/ Markup van RefreshingView, maar is ook van elk Item	, want een child van een AbstractRepeater krijgt de markup van de AbstractRepeater	,  
/ Dus hieronder is de markup van een Item	, 
	<tr wicket:id="view">													/ wicket id "view" doet er WH niet toe	, 
		<td><span wicket:id="itemid">[item id]</span></td>						/ wicket id "itemid" moet precies zo heten	, 
		<td><span wicket:id="actions">[actions]</span></td>				 	
		<td><span wicket:id="contactid">[contactid]</span> </td>
		<td><span wicket:id="firstname">[firstname]</span></td>
		<td><span wicket:id="lastname">[lastname]</span></td>
		<td><span wicket:id="homephone">[homephone]</span></td>
		<td><span wicket:id="cellphone">[cellphone]</span></td>
	</tr>
/ itemid	, ... , zijn children van de item	 

/ In Refreshing3Page zien we Item niet create	, met een id 	, zoals new Label("item",...)
/ Maar gebeurt wel, in Wicket's code	, 
class RefreshingView
	protected IItemFactory<T> newItemFactory()
	{
		return new IItemFactory<T>()
		{
			@Override
			public Item<T> newItem(int index, IModel<T> model)
			{
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);
				RefreshingView.this.populateItem(item);							/ adds Labels aan de Item, met ids = wicket:ids in de markup	,
				return item;
			}
		};
	}
/ we add een Item ipv alle Labels aan de RefreshingView	, en de Labels aan de View	, want de Item heeft een Model	, en alle Labels krijgen een PropertyModel op dit ene Model	,


/ 13	. 

/ WORKING REPEATINGVIEW

/ we hebben Repeating3Page, Listing3Page, Refreshing3Page	,

/ In Repeating3Page zien we hetzelfde	,  alleen add we Labels aan de RepeatingView	, en geen Items ,	 omdat een Item eem Model heeft (row model)	, die door alle columns zou worden used, nl een column krijgt een PropertyModel met een expression over de row model	,  maar er zijn nu geen columns	,
/ TODO

		RepeatingView repeating = new RepeatingView("view");
		add(repeating);
		repeating.add(new Label("3",new Model<Integer>(){
			@Override
			public Integer getObject() {
				return (int)(Math.random()*1000);
			}
		}));
		repeating.add(new Label("4",new Model<Integer>(){
			@Override
			public Integer getObject() {
				return (int)(Math.random()*1000);
			}
		}));

/ Hier 3, 4 ipv RepeatingView.this.newChildId()

/ 7	. 

$ vi Repeating3Page.java

public class Repeating3Page extends WebPage
{
	public Repeating3Page()
	{
		RepeatingView repeating = new RepeatingView("view");
		add(repeating);

		repeating.add(new Label("3",new Model<Integer>(){
			@Override
			public Integer getObject() {
				return (int)(Math.random()*1000);
			}
		}));
		repeating.add(new Label("4",new Model<Integer>(){
			@Override
			public Integer getObject() {
				return (int)(Math.random()*1000);
			}
		}));
		repeating.add(new Label("5",new LoadableDetachableModel<Integer>() {
			@Override
			protected Integer load() {
				return (int)(Math.random()*1000);
			}
		}));
	}
}

$ vi Repeating3Page.html

	<div wicket:id="view">
	</div>

/ we zien in HTML	, 

<body>
	<div wicket:id="view">619</div><div wicket:id="view">744</div><div wicket:id="view">24</div>
</body>

/ 7	. 

/ WORKING LISTVIEW 

/ we hebben Repeating3Page, Listing3Page, Refreshing3Page	, 

/  we geven een ListView list van models	, 
/ item.getModelObject() is zelf een model	, die we aan label geven	, 
/ TODO Verschil met RefreshingView	, 

/ 13	. 

/ Bij ListView moeten we populateItem impl	, 

/ Je kunt de repeaters een model geven, maar dat gebeurt maar af en toe	, 
/ In FilterToolbar wordt een ListView create met een stateless (readlonly) Model met de IColumns: de getObject() method geeft het array van de IColumns	, 
/ Een ListItem heeft een ListItemModel	, die de index heeft	,
/ In ListingPage:	item.add(new Label("name",new PropertyModel<String>(item.getModel(),"name")));	, item.getModel() heeft de index	,   
/ HIER HIER HIER
 


/ Net zo in de DataTable$DefaultDataGridView
/ Als de IColumn een TextFilteredPropertyColumn is dan  

public abstract class ListView<T> extends AbstractRepeater


	@Override
	protected final void onPopulate()
		// Get number of items to be displayed
		final int size = getViewSize();
			for (int i = 0; i < size; i++)
			{
					// Create item for index
					item = newItem(index, getListItemModel(getModel(), index));	// See hierboven	,  

					// Add list item
					add(item);

					populateItem(item);
	}

	public final IModel<? extends List<T>> getModel() {
		return (IModel<? extends List<T>>)getDefaultModel();	/ Component.getDefaultModel	,
	}


/ voorbeeld	,

public class ListingPage extends WebPage{

	public final static int count=10;
	
	public ListingPage()
	{
		final List<Person>persons=Arrays.asList(new Person("foo","bar"),new Person("me","you"));
		// Er wordt Model.of(persons) gedaan	, 
		// Dit is niet zo illustratief: nuttiger is om een stateless of detachable  model te maken
		// die een db query doet	, als dan de item wordt render, dan wordt de item resolved, en 
		// wordt de query gedaan,
		
		ListView<Person>view=new ListView<Person>("view",persons) {
			@Override
			protected void populateItem(ListItem<Person> item) {
				item.add(new Label("name",new PropertyModel<String>(item.getModel(),"name")));	/ item.getModel()=ListItemModel met de index	,
				item.add(new Label("surname",new PropertyModel<String>(item.getModel(),"surname")));				
			}
		};
		add(view);
	}
	private static class Person implements Serializable {
        private String name;
        private String surname;
		...




/ 13	. 

/ Voorbeeld	, 

$ vi Listing3Page.java

public class Listing3Page extends WebPage{

	public final static int count=10;


	
	public Listing3Page()
	{
		final List<IModel<Integer>> integers = new ArrayList<>(count);
		
		for(int i=0;i<count;i++){
			integers.add(new Model<Integer>(){
				@Override
				public Integer getObject() {
					return (int)(Math.random()*1000);
				}
			});
		}

		ListView<IModel<Integer>>view=new ListView<IModel<Integer>>("view",integers) {
			@Override
			protected void populateItem(ListItem<IModel<Integer>> item) {
				item.add(new Label("item",item.getModelObject()));								<- item.getModelObject() is zelf een model	,
				
			}
		};
		add(view);
	}
}

$ vi Listing3Page.html

<body>
	<div wicket:id="view">
		<div wicket:id="item"></div>
	</div>
</body>

		


/ 7	. 

$ vi Refreshing3Page.java

public class Refreshing3Page extends WebPage
{
	public final static int count=10;

	public Refreshing3Page()
	{
		final List<IModel<Integer>> integers = new ArrayList<>(count);
		
		for(int i=0;i<count;i++){
			integers.add(new Model<Integer>(){
				@Override
				public Integer getObject() {
					return (int)(Math.random()*1000);
				}
			});
		}

		final RefreshingView<Integer> view = new RefreshingView<Integer>("view")
		{
			@Override
			protected Iterator<IModel<Integer>> getItemModels()
			{
				return integers.iterator();
			}

			@Override
			protected void populateItem(final Item<Integer> item) // AbstractDataGridView implements deze , dus hoef
																		// je niet zelf te doen, als je een DataTable use	,
			{
				item.add(new Label("item", item.getModel())); 	// we doen NIET item.getModelObject() ,	 want render doet getObject()	,
				
			}
		};

		add(view);
	}
}
$ vi Refreshing3Page.html


<body>

<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
</body>

/ WORKING REFRESHINGVIEW

/ Onthoud: Wat hier gebeurt is dat er een Item wordt add aan de RefreshingView, die een WebMarkupContainer is	, en dat het Item een Model krijgt, nl een van de getItemModels()	, en dat de Item, die zelf ook een WebMarkupContainer is, hier een Label krijgt die het Model van de Item krijgt	,
/ Onthoud: de markup van de Item is die van de RefreshingView, want Item is een child van de RefreshingView	, en het Label is child van de Item, dus de markup van het Label is:
	<div wicket:id="item"></div>
/ we zien ook dat de wicket:ids kloppen: "item"	, dat moet	, (de id van de Item wordt gen)	,

/ we moeten zelf getItemModels en populateItem  impl (in een (anonymous) extension van RefreshingView)	,  dit alles voor de al impl onPopulate	, 
/ In RepeatingView doen we onPopulate zelf	,  dus daar heb je getItemModels en populateItem niet	, er zijn ook geen Items met Models	, we moeten de Labels zelf een model geven	,


$ vi RefreshingView.java

class RefreshingView
	@Override
	protected final void onPopulate()
	{
		Iterator<IModel<T>> models = getItemModels();											<- zelf	,	
		Iterator<Item<T>> items = getItemReuseStrategy().getItems(newItemFactory(), models,
			getItems());
		removeAll();
		addItems(items);
	}
	protected IItemFactory<T> newItemFactory()
	{
		return new IItemFactory<T>()
		{
			@Override
			public Item<T> newItem(int index, IModel<T> model)
			{
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);
				RefreshingView.this.populateItem(item);											<-	zelf	,
				return item;
			}
		};
	}
	protected void addItems(Iterator<Item<T>> items)
	{
		int index = 0;
		while (items.hasNext())
		{
			Item<T> item = items.next();
			item.setIndex(index);
			add(item);
			++index;
		}
	}

$ vi DefaultItemReuseStrategy.java

public class DefaultItemReuseStrategy implements IItemReuseStrategy
	@Override
	public <T> Iterator<Item<T>> getItems(final IItemFactory<T> factory,
		final Iterator<IModel<T>> newModels, Iterator<Item<T>> existingItems)
	{
		return new Iterator<Item<T>>()
		{
			private int index = 0;

			@Override
			public void remove()
			{
				throw new UnsupportedOperationException();
			}

			@Override
			public boolean hasNext()
			{
				return newModels.hasNext();
			}

			@Override
			public Item<T> next()
			{
				IModel<T> model = newModels.next();
				Item<T> item = factory.newItem(index, model);
				index++;
				return item;
			}

		};
	}
/ je kunt een Iterator create door van een bestaande list .iterator() te call	, maar je kunt hem ook zelf def, zoals hier	,


$ vi Refreshing3Page.html

<body>

<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
</body>

/ we zien in HTML	, 

<body>

<div wicket:id="view">
	<div wicket:id="item">442</div>
</div><div wicket:id="view">
	<div wicket:id="item">774</div>
</div><div wicket:id="view">
	<div wicket:id="item">875</div>
</div><div wicket:id="view">
	<div wicket:id="item">408</div>
</div><div wicket:id="view">
	<div wicket:id="item">667</div>
</div><div wicket:id="view">
	<div wicket:id="item">508</div>
</div><div wicket:id="view">
	<div wicket:id="item">515</div>
</div><div wicket:id="view">
	<div wicket:id="item">611</div>
</div><div wicket:id="view">
	<div wicket:id="item">363</div>
</div><div wicket:id="view">
	<div wicket:id="item">380</div>
</div>
</body>

/ 13	. 

/ we kunnen ook een table, grid maken met een RefreshingView	, 
/ Maar in AbstractDataGridView maken ze ook Items in de cells	, hier niet	, TODO Waarom zou je dat doen?

$ vi RefreshingPage.java

		final RefreshingView<Contact> view = new RefreshingView<Contact>("view")
			@Override
			protected Iterator<IModel<Contact>> getItemModels()
			{
				return contacts.iterator();
			}

			@Override
			protected void populateItem(final Item<Contact> item)
			{
				Contact contact = item.getModelObject();
				item.add(new Label("itemid", item.getId()));
				item.add(new ActionPanel("actions", item.getModel()));
				item.add(new Label("contactid", String.valueOf(contact.getId())));
				item.add(new Label("firstname", contact.getFirstName()));
				item.add(new Label("lastname", contact.getLastName()));
				item.add(new Label("homephone", contact.getHomePhone()));
				item.add(new Label("cellphone", contact.getCellPhone()));
			}
		};

		add(view);

$ vi RefreshingPage.html

<table cellspacing="0" class="dataview">
	<tr wicket:id="view">
		<td><span wicket:id="itemid">[item id]</span></td>
		<td><span wicket:id="actions">[actions]</span></td>
		<td><span wicket:id="contactid">[contactid]</span> </td>
		<td><span wicket:id="firstname">[firstname]</span></td>
		<td><span wicket:id="lastname">[lastname]</span></td>
		<td><span wicket:id="homephone">[homephone]</span></td>
		<td><span wicket:id="cellphone">[cellphone]</span></td>
	</tr>
</table>

/ elk Item is child van de DataView, die een WebMarkupContainer is	,  en heeft dus de markup van de DataView, want dat is altijd zo bij repeaters	, dus dit is de markup van een Item:
    <tr wicket:id="view">
        <td><span wicket:id="itemid">[item id]</span></td>
        <td><span wicket:id="actions">[actions]</span></td>
        <td><span wicket:id="contactid">[contactid]</span> </td>
        <td><span wicket:id="firstname">[firstname]</span></td>
        <td><span wicket:id="lastname">[lastname]</span></td>
        <td><span wicket:id="homephone">[homephone]</span></td>
        <td><span wicket:id="cellphone">[cellphone]</span></td>
    </tr>

/ WORKING REFRESHINGVIEW
/ De Labels en de ActionPanel zijn de children van de Item	, en de wicket:id's kloppen	, dus de markup id van het 2de Label is	:
        <td><span wicket:id="contactid">[contactid]</span> </td>

/ De browser set ze in table vorm door de <table> , <tr>, <td> tags	,

/ we zien in HTML	,

<table cellspacing="0" class="dataview">
	<tbody>
	<tr wicket:id="view" class="odd">															/ Item
		<td><span wicket:id="itemid">1</span></td>												/ Label, 1ste child van Item
		<td><span wicket:id="actions"><wicket:panel xmlns:wicket="http://wicket.apache.org">	/ ActionPanel, 2de child van Item	,
<a href="./refreshing?2-1.ILinkListener-view-1-actions-select" wicket:id="select">select</a>
</wicket:panel></span></td>
		<td><span wicket:id="contactid">28</span> </td>
		<td><span wicket:id="firstname">Abby</span></td>
		<td><span wicket:id="lastname">Davis</span></td>
		<td><span wicket:id="homephone">328-555-4123</span></td>
		<td><span wicket:id="cellphone">853-555-2401</span></td>
	</tr>
	<tr wicket:id="view" class="even">															/ Item
		<td><span wicket:id="itemid">2</span></td>
		<td><span wicket:id="actions"><wicket:panel xmlns:wicket="http://wicket.apache.org">
<a href="./refreshing?2-1.ILinkListener-view-2-actions-select" wicket:id="select">select</a>
</wicket:panel></span></td>
		<td><span wicket:id="contactid">13</span> </td>
		<td><span wicket:id="firstname">Abner</span></td>
		<td><span wicket:id="lastname">Hall</span></td>
		<td><span wicket:id="homephone">445-555-6506</span></td>
		<td><span wicket:id="cellphone">458-555-1760</span></td>
	</tr>
	...
	</tbody>
</table>  





/ Einde REPEATERS

/ USE OF MODELS

/ 7	. 

/ Wat is het nut van een Model	, (LoadableDetachableModel is OK)	,

/ Omdat als de Model stateless is	, hij wel ser & deser wordt	, maar er zit niets in	,

/ Lees	, 
https://ci.apache.org/projects/wicket/guide/7.x/single.html#_what_is_a_model

$ vi TimePage.java

public class TimePage extends WebPage {
	
	public TimePage() {
		IModel<String>model=new Model<String>(){
			@Override
			public String getObject() {
				return new Date().toString();
			}
		};
		Label label = new Label("label",model);
		add(label);
	}

}

$ vi TimePage.html
	<span wicket:id="label"></span>

/ Als we de page reload	, zien we een nieuwe tijd	,
/////////////////////////////////////////////////////////////////////////////
/ WH omdat het model stateless is	: er zit alleen een mth in	, geen data	, 
/ het Model obj wordt WH ser	, maar er zit niets in	, en bij render wordt getObject called	, 

/ 7	. 

/ Ook PropertyModels hebben zo'n eig:
Label label = new Label("name", new PropertyModel(person, "name"));
/ Als de person's name is veranderd, zien we een andere name	,

/ 7	. 

/ Model	,

/ Als we : new Label("label","foo")	, dan wordt er Model create, met object="foo"	, en deze wordt met setModelImpl in data[0] set via Component.<init>
/ bij render wordt getDefaultModel() = getModelImpl() called	,  die daarop getObject() doet	,  

$ vi LabelPage.java

	public LabelPage() {
		Label label = new Label("label","foo");
		add(label);
	}

$ vi Label.class

public class Label extends WebComponent
	public Label(final String id, Serializable label)
	{
		this(id, Model.of(label));	
	}
	@Override
	public void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)
	{
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());
														^^^
	}

$ vi Model.class

public class Model<T extends Serializable> implements IObjectClassAwareModel<T>
	public Model(final T object)
	{
		setObject(object);
	}
	@Override
	public void setObject(final T object)
	{
		this.object = object;
	}

$ vi Component.class

public abstract class Component

	public Component(final String id, final IModel<?> model)
		if (model != null)
		{
			setModelImpl(wrap(model));
		}
	}

	void setModelImpl(IModel<?> model)
	{
				data_set(0, model);
/ of
/ TODO
				data_insert(0, model);
	}

	public final String getDefaultModelObjectAsString()
	{
		return getDefaultModelObjectAsString(getDefaultModelObject());
	}

	public final Object getDefaultModelObject()
	{
		final IModel<?> model = getDefaultModel();
				// Get model value for this component.
				return model.getObject();

	public final IModel<?> getDefaultModel()
	{
		IModel<?> model = getModelImpl();

	IModel<?> getModelImpl()
	{
			return (IModel<?>)data_get(0);

/ 7	. 

/ PropertyModel

/ hierarchies:
/ Model
/ PropertyModel - AbstractPropertyModel - ChainingModel
/ LoadableDetachableModel

/ Een PropertyModel is een ChainingModel	, die heeft de target	,
/ Als we : new PropertyModel(obj, "expression")	, dan wordt target=obj	,

$ vi AbstractPropertyModel.java

public abstract class AbstractPropertyModel<T> extends ChainingModel<T>

	
	@Override
	public T getObject()
	{
		final String expression = propertyExpression();
		final Object target = getInnermostModelOrObject();
		if (target != null)
		{
			return (T)PropertyResolver.getValue(expression, target);
	}

	public final Object getInnermostModelOrObject() 	/ is eig. onderdeel van getObject()	, die de ChainingModel.getObject overrides	,
	{
		Object object = getTarget();			/ uit ChainingModel	,
		while (object instanceof IModel)							/ Deze code had ik in ChainingModel verwacht	,  TODO
		{
			Object tmp = ((IModel<?>)object).getObject();
			if (tmp == object)
			{
				break;
			}
			object = tmp;
		}
		return object;
	}

@Override
$ vi ChainingModel.java			/ wordt override door AbstractPropertyModel

	public T getObject()
	{
		if (target instanceof IModel)
		{
			return ((IModel<T>)target).getObject();
		}
		return (T)target;
	}
}

/ 	7. 

/ LoadableDetachableModel

public abstract class LoadableDetachableModel<T> implements IModel<T>
	/** temporary, transient object. */
	private transient T transientModelObject;


/ Einde USE OF MODELS


/ DEBUG REFRESHINGVIEW

/7	. 

/ BEFORERENDER

/ stack
/s
	Refreshing3Page$2(RefreshingView<T>).onPopulate() line: 93	
	Refreshing3Page$2(AbstractRepeater).onBeforeRender() line: 124	
this [RefreshingView [Component id = view]]
		onPopulate();
/cb

	Refreshing3Page$2(Component).internalBeforeRender() line: 949	
this [RefreshingView [Component id = view]]											/ de refreshingview	,
			onBeforeRender();
/cb

	Refreshing3Page$2(Component).beforeRender() line: 1017	
	Refreshing3Page(MarkupContainer).onBeforeRenderChildren() line: 1866	
			for (final Component child : this)
			{
					child.beforeRender();
/cb

	Refreshing3Page(Component).onBeforeRender() line: 3877	
this Refreshing3Page																/ de page	,
		onBeforeRenderChildren();
/cb

	Refreshing3Page(Page).onBeforeRender() line: 801	

	Refreshing3Page(Component).internalBeforeRender() line: 949	
	Refreshing3Page(Component).beforeRender() line: 1017	
	Refreshing3Page(Component).internalPrepareForRender(boolean) line: 2215	
	Refreshing3Page(Page).internalPrepareForRender(boolean) line: 242	
	Refreshing3Page(Component).render() line: 2304	
this Refreshing3Page
				internalPrepareForRender(true);										<- calls onBeforeRender()s	,
			}

			// Do the render
			internalRender();														<- render 
/cb

	Refreshing3Page(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ debug
/s
Refreshing3Page$2(RefreshingView<T>).onPopulate() line: 93	
this [RefreshingView [Component id = view]]
		Iterator<IModel<T>> models = getItemModels();

/s
							return integers.iterator();	/ integers is Iterator over List<IModel<Integer>>, onze stateless Models	,
/t
		Iterator<Item<T>> items = getItemReuseStrategy().getItems(newItemFactory(), models,

/ DefaultItemReuseStategy.getItems returns een iterator over Item<Integer>s	, die als straks called in addItems, iterates over de Models, de factory een new Item laat maken, met de model er in	, en de item wordt populate, dwz dat een label wordt add, en het label krijgt de model van de item	, 

/ TODO We zitten in onBeforeRender	, maar hoe strakt render met children	?

		removeAll();
		addItems(items);
/s
Refreshing3Page$2(RefreshingView<T>).addItems(Iterator<Item<T>>) line: 189	
		while (items.hasNext())
		{
			Item<T> item = items.next();
/s
DefaultItemReuseStrategy$1.next() line: 75	
				IModel<T> model = newModels.next();						/ 1 van de (stateless) Models	,
				Item<T> item = factory.newItem(index, model);
/s
RefreshingView$1.newItem(int, IModel<T>) line: 114	
				String id = RefreshingView.this.newChildId();
				Item<T> item = RefreshingView.this.newItem(id, index, model);	/ id,model komen in Component.<init> en model wordt met setModelImpl	, en is dan ook het antwoord op Component.getDefaultModel()
item	Item<T>  (id=15024)	
	children	null	
	data	Refreshing3Page$1  (id=15017)	
		object	null	

				RefreshingView.this.populateItem(item);
/s
Item<T>(ListItem<T>).getModel() line: 81	
		return (IModel<T>)getDefaultModel();		/ see vlak hierboven	,
/t
Refreshing3Page$2.populateItem(Item<Integer>) line: 82	
				item.add(new Label("item", item.getModel()));  	// we doen NIET item.getModelObject() ,  want dat doet render   ,
/pd
/ Item is een WebMarkupContainer	, we kunnen MarkupContainer.add	,
/s
Item<T>(MarkupContainer).add(Component...) line: 239	
			// Add the child to my children
			Component previousChild = children_put(child);			<- dit is de add	,
/s
				if (children == null)
				{
					children = child;
/t
			addedComponent(child);
/s
					child.setParent(this);
/t
Refreshing3Page$2(RefreshingView<T>).addItems(Iterator<Item<T>>) line: 191	
		while (items.hasNext())
		{
			Item<T> item = items.next();
/d
item	Item<T>  (id=15024)	
	children	Label  (id=15038)				/ een Label is geen MarkupContainer, dus heeft geen children	,
		data	Refreshing3Page$1  (id=15017)	/ de model van de Label is die van de item	, 
													/ een Item is een WebMarkupContainer	, dus heeft children	,	
	data	Refreshing3Page$1  (id=15017)	
		object	null	

			item.setIndex(index);
			add(item);
/s
Refreshing3Page$2(MarkupContainer).add(Component...) line: 231	
			// Add the child to my children
			Component previousChild = children_put(child);
/s
				if (children == null)
				{
					children = child;
/t
this	Refreshing3Page$2  (id=14990)	
	children	Item<T>  (id=15024)	
		data	Refreshing3Page$1  (id=15017)	
			object	null	
		children	Label  (id=15038)	
			data	Refreshing3Page$1  (id=15017)	
			id	"item" (id=15039)	

/ Dus de View heeft children, de Items	, en die hebben ook children (1) , een Label	,
/ de Items hebben models, die gegeven worden aan hun children, de Label	, (dat deden we zelf, in RefreshingView.populateItem )

/ Einde BEFORE RENDER

/ RENDER

Daemon Thread [http-nio-9090-exec-37] (Suspended (breakpoint at line 728 in Component))	
	owns: NioChannel  (id=15119)	
	Refreshing3Page(Component).getMarkup() line: 728	
	Refreshing3Page(Page).onRender() line: 878	
	Refreshing3Page(WebPage).onRender() line: 141	
	Refreshing3Page(Component).internalRender() line: 2380	
	Refreshing3Page(Component).render() line: 2308	
				internalPrepareForRender(true);												<- onBeforeRender	
			}
			// Do the render
			internalRender();																<- render	,
/cb

	Refreshing3Page(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ debug	, 
/s
Refreshing3Page(Page).onRender() line: 879	
		// Loop through the markup in this container
		MarkupStream markupStream = new MarkupStream(getMarkup());		/ ons template
<head></head><body>													/ <head></head> is er bij gezet	, TODO
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
</body>
		renderAll(markupStream, null);
/s
Refreshing3Page(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1746	
		while (markupStream.hasMore())
		{
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);

/ we slaan tag <head> over	, 
/ deze heeft id __header__
/ TODO

/s
Refreshing3Page(MarkupContainer).renderNext(MarkupStream) line: 1504	
			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id);
/s
Refreshing3Page(MarkupContainer).get(String) line: 400	
		// Get child by id
		Component child = container.children_get(id);
id="view"
child=[RefreshingView [Component id = view]]
/t
Refreshing3Page(MarkupContainer).renderNext(MarkupStream) line: 1508	
			// Get the component for the id from the given container
			Component component = get(id);
/d
component=[RefreshingView [Component id = view]]

				component.render();
/s
Refreshing3Page$2(Component).render() line: 2308	
			// Invoke prepareForRender only if this is the root component to be rendered
			MarkupContainer parent = getParent();
			if ((parent == null) || (parent.getFlag(FLAG_RENDERING) == false) || isAuto())
/n
			{
				internalPrepareForRender(true);			/ GEEN onBeforeRender calls	, is al gedaan	, de tree
														/ van components is al gemaakt,	  
/n
			}

			// Do the render
			internalRender();
/s
Refreshing3Page$2(Component).internalRender() line: 2346	
		// Make sure there is a markup available for the Component
		IMarkupFragment markup = getMarkup();
<div wicket:id="view">								/ we zien een gedeelte van de hele Page markup	, TODO ( hoe ging dat ook alweer)
	<div wicket:id="item"></div>
</div>
				onRender();
/s
Refreshing3Page$2(AbstractRepeater).onRender() line: 92	 		/ AbstractRepeater heeft eigen .onRender	, 

		Iterator<? extends Component> it = renderIterator();	
/s
Refreshing3Page$2(RepeatingView).renderIterator() line: 108	
		return iterator();
/s
Refreshing3Page$2(MarkupContainer).iterator() line: 658	
		return new MarkupChildIterator();
/ TODO
/t
Refreshing3Page$2(AbstractRepeater).onRender() line: 93	
		Iterator<? extends Component> it = renderIterator();
/d
		while (it.hasNext())
		{
			Component child = it.next();
[Item [Component id = 1]]
			renderChild(child);
/s
Refreshing3Page$2(AbstractRepeater).renderChild(Component) line: 115	
		child.render();
/s
Item<T>(Component).render() line: 2296	
			// Invoke prepareForRender only if this is the root component to be rendered
			MarkupContainer parent = getParent();
			if ((parent == null) || (parent.getFlag(FLAG_RENDERING) == false) || isAuto())
/n
			{
				internalPrepareForRender(true);
/n
			}

			// Do the render
			internalRender();
/s
Item<T>(Component).internalRender() line: 2345	
		// Make sure there is a markup available for the Component
		IMarkupFragment markup = getMarkup();
/s
Item<T>(Component).getMarkup() line: 755	
this	Item<T>  (id=15134)	

		// Markup already determined or preset?
		if (markup != null)

		// Ask the parent for find the markup for me
		markup = parent.getMarkup(this);
/s
Refreshing3Page$2(AbstractRepeater).getMarkup(Component) line: 153	
this	Refreshing3Page$2  (id=15133) [RefreshingView [Component id = view]	
		// each direct child gets the markup of this repeater
		return getMarkup();
/s
Refreshing3Page$2(Component).getMarkup() line: 728	
		// Markup already determined or preset?
		if (markup != null)
		{
			return markup;
/t
Item<T>(Component).internalRender() line: 2346	
		// Make sure there is a markup available for the Component
		IMarkupFragment markup = getMarkup();
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
/ De Item als child van een Repeater krijgt de markup van de Repeater zelf	, 

				onRender();
/s
Item<T>(MarkupContainer).onRender() line: 1698					/ AbstractRepeater heeft eigen .onRender	,	die over de children iterates	, en 
																		/ daarop .renderChild calls	,
		internalRenderComponent();
/s
Item<T>(Component).internalRenderComponent() line: 2508	

this	Item<T>  (id=15134)	
markup	MarkupFragment  (id=15209)	
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>

		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();
<div wicket:id="view">

		// Call any tag handler
		onComponentTag(tag);
<div wicket:id="view">

			else
			{
				renderComponentTag(tag);
/s
			// Write the tag
			tag.writeOutput(getResponse(), !needToRenderTag(null),
				getMarkup().getMarkupResourceStream().getWicketNamespace());
/t
Item<T>(Component).internalRenderComponent() line: 2565	
				renderComponentTag(tag);
getResponse()=
<body>

<div wicket:id="view">

				// Render the body. The default strategy will simply call the component's
				// onComponentTagBody() implementation.
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/s
DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
		component.onComponentTagBody(markupStream, openTag);
/s
Item<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
		renderComponentTagBody(markupStream, openTag);
/s
Item<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1713	

markupStream=
[markup = file:/home/eric/Devel/Java/Tomcat/apache-tomcat-8.0.28/webapps/wicket-examples-step-by-step/WEB-INF/classes/org/apache/wicket/examples/repeater/Refreshing3Page.html
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>, index = 1, current = [Raw markup]]

		if (render)
		{
			renderAll(markupStream, openTag);
openTag=<div wicket:id="view">

		while (markupStream.hasMore())
		{
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/s
Item<T>(MarkupContainer).renderNext(MarkupStream) line: 1498	
		// Get the current markup element

		final MarkupElement element = markupStream.get();
			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;
<div wicket:id="item">

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id);

				component.render();
/s
Label(Component).render() line: 2296	
			// Invoke prepareForRender only if this is the root component to be rendered
			MarkupContainer parent = getParent();
			if ((parent == null) || (parent.getFlag(FLAG_RENDERING) == false) || isAuto())
/n
			{
				internalPrepareForRender(true);
			}

			// Do the render
			internalRender();
/s
Label(Component).internalRender() line: 2345	
		// Make sure there is a markup available for the Component
		IMarkupFragment markup = getMarkup();
/s
Label(Component).getMarkup() line: 755	
		// Markup already determined or preset?
		if (markup != null)
/n
		// Ask the parent for find the markup for me
		markup = parent.getMarkup(this);
/s
Item<T>(MarkupContainer).getMarkup(Component) line: 502	
		// Delegate request to attached markup sourcing strategy.
		return getMarkupSourcingStrategy().getMarkup(this, child);		/ child=Label
/s
DefaultMarkupSourcingStrategy.getMarkup(MarkupContainer, Component) line: 81	
		// If the sourcing strategy did not provide one, than ask the component.
		// Get the markup for the container
		IMarkupFragment containerMarkup = container.getMarkup();	 container=Item
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
/ Klopt	, Item is child van Repeater	, en kreeg de markUp van de Repeater	, 
		// Find the child's markup
		IMarkupFragment childMarkup = containerMarkup.find(child.getId());
/s
MarkupFragment.find(String) line: 154	
		return find(id, 1);		
/s
	/**
	 * Find the markup fragment of component with id equal to {@code id}, starting at offset {@code streamOffset}.
	 * 
	 * @param id
	 *		The id of the component tag being searched for.
	 * @param streamOffset
	 *		The offset in the markup stream from which to start searching.
	 */
MarkupFragment(AbstractMarkupFragment).find(String, int) line: 43	
/=
	protected final IMarkupFragment find(final String id, int streamOffset)	/ streamOffset==1	, dus begint WH bij 1ste child	, 

		MarkupStream stream = new MarkupStream(this);
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>, index = 0, current =  '<div wicket:id="view">' (line 0, column 0)]

		stream.setCurrentIndex(streamOffset);
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>, index = 1, current = [Raw markup]]

		while (stream.hasMore())
			stream.next();			/ want nr 1 is Raw markup	, 
/ volgende	, 
		while (stream.hasMore())
		{
			MarkupElement elem = stream.get();
<div wicket:id="item">
				if (tag.isOpen() || tag.isOpenClose())
				{
					if (canFind && tag.getId().equals(id))			"item" == "item"
					{
						return stream.getMarkupFragment();
/t
DefaultMarkupSourcingStrategy.getMarkup(MarkupContainer, Component) line: 94	
		// Find the child's markup
		IMarkupFragment childMarkup = containerMarkup.find(child.getId());
<div wicket:id="item"></div>

			return childMarkup;
/t
Label(Component).internalRender() line: 2346	
		// Make sure there is a markup available for the Component
		IMarkupFragment markup = getMarkup();
/d
<div wicket:id="item"></div>

		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();
<div wicket:id="item">

		// Call any tag handler
		onComponentTag(tag);
<div wicket:id="item">

			else
			{
				renderComponentTag(tag);

				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
tag=<div wicket:id="item">
/s
DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
		component.onComponentTagBody(markupStream, openTag);
/s
Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());
/s
Label(Component).getDefaultModelObjectAsString() line: 1654	
		return getDefaultModelObjectAsString(getDefaultModelObject());
/s
Label(Component).getDefaultModelObject() line: 1620	
/ HIER HIER HIER





/ Intermezzo


/ we zijn in 	,

	Label(Component).internalRenderComponent() line: 2556	

	Label(WebComponent).onRender() line: 60	
	Label(Component).internalRender() line: 2346	
this	Label  (id=15905)	
markup	MarkupFragment  (id=16008)	
<div wicket:id="item"></div>
	Label(Component).render() line: 2308	

	Item<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	Item<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	Item<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	Item<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Item<T>(Component).internalRenderComponent() line: 2565	

	Item<T>(MarkupContainer).onRender() line: 1698	
	Item<T>(Component).internalRender() line: 2380	
this	Item<T>  (id=15904)	
markup	MarkupFragment  (id=15943)	
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
	Item<T>(Component).render() line: 2308	

	Refreshing3Page$2(AbstractRepeater).renderChild(Component) line: 115	

	Refreshing3Page$2(AbstractRepeater).onRender() line: 102	
	Refreshing3Page$2(Component).internalRender() line: 2380	
this	Refreshing3Page$2  (id=15903)	
markup	MarkupFragment  (id=15943)	
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
	Refreshing3Page$2(Component).render() line: 2308	

	Refreshing3Page(MarkupContainer).renderNext(MarkupStream) line: 1524	
	Refreshing3Page(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	Refreshing3Page(Page).onRender() line: 879	

	Refreshing3Page(WebPage).onRender() line: 141	
	Refreshing3Page(Component).internalRender() line: 2380	
this	Refreshing3Page  (id=15899)	
markup	Markup  (id=15161)	
<head></head><body>
<div wicket:id="view">
	<div wicket:id="item"></div>
</div>
</body>
	Refreshing3Page(Component).render() line: 2308	

	Refreshing3Page(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ Einde Intermezzo






















/ Einde RENDER
















/ Einde DEBUG REFRESHINGVIEW

/ FILTERFORM

/ 7	. 

/ Waarom heeft FilterForm dataProvider als arg? Die is toch voor DataGridView	?
/ WH voor sort en filter	, 


		FilterForm<ContactFilter_my> filterForm = new FilterForm<>("filterForm", dataProvider);	
/s
FilterForm<T>.<init>(String, IFilterStateLocator<T>) line: 64	 / het model van dit form is dataProvider.filterState	
		super(id, new FilterStateModel<>(locator));
/s zie (*)
		this.locator = locator;

class FilterStateModel<T> implements IModel<T>	/= in feite dataProvider.filterState	/ filterState = het filter	,  
	private final IFilterStateLocator<T> locator;						/ locator=dataProvider
	public FilterStateModel(final IFilterStateLocator<T> locator)	 
		this.locator = locator;
	public T getObject()									<-
		return locator.getFilterState();
	public void setObject(final T object)
		locator.setFilterState(object);

public interface IFilterStateLocator<T> extends IClusterable
	T getFilterState();
	void setFilterState(T state);

public class ContactFilter_my implements Serializable
    private String firstName;
    private String lastName;
	private Date dateFrom;
    private Date dateTo;

public class SortableContactDataProvider_my extends SortableDataProvider<Contact, String> implements IFilterStateLocator<ContactFilter_my>
	private ContactFilter_my contactFilter = new ContactFilter_my();
	public SortableContactDataProvider_my()
		setSort("firstName", SortOrder.ASCENDING);
	public IModel<Contact> model(Contact object)		/ row item model	,
		return new DetachableContactModel(object);
	public ContactFilter_my getFilterState()
	    return contactFilter;
	public void setFilterState(ContactFilter_my state)
	    contactFilter  = state;
	public long size()
		return filterContacts(getContactsDB().getIndex(getSort())).size();	/ sort en filter staan los van elkaar	,

/ Het filter zit niet in SortableDataProvider	, dus die geven we hier zelf bij in SortableContactDataProvider_my (door te zeggen dat we implements IFilterStateLocator	,


public abstract class SortableDataProvider<T, S> implements ISortableDataProvider<T, S>
	private final SingleSortState<S> state = new SingleSortState<>();									<- sort state
	public void setSort(final SortParam<S> param)
		state.setSort(param);

public class SingleSortState<T> implements ISortState<T>, IClusterable
	SortParam<T> param;
	public SortParam<T> getSort()
		return param;

/ (*)
/s
FilterForm<T>(Form<T>).<init>(String, IModel<T>) line: 320	
/=
	public Form(final String id, final IModel<T> model)
model	FilterStateModel<T>  (id=10154)	
	locator	SortableContactDataProvider_my  (id=10156)	
		contactFilter	ContactFilter_my  (id=10157)	
			dateFrom	null	
			dateTo	null	
			firstName	null	
			lastName	null	
		state	SingleSortState<T>  (id=10158)	
			param	SortParam<T>  (id=10159)	
				ascending	true	
				property	"firstName" (id=10160)	

		super(id, model);

/ 7	. 


/ DESERIALIZE PAGE	

/ we hebben de 1ste filter text filled in	, "Abby" 

/s
Daemon Thread [http-nio-9090-exec-9] (Suspended (breakpoint at line 162 in JavaSerializer))	
	JavaSerializer.newObjectInputStream(InputStream) line: 162	
		return new ClassResolverObjectInputStream(in);
/cb

	JavaSerializer.deserialize(byte[]) line: 112												<-
		final ByteArrayInputStream in = new ByteArrayInputStream(data);
		ObjectInputStream ois = null;
				ois = newObjectInputStream(in);
/cb

	DefaultPageStore(AbstractPageStore).deserializePage(byte[]) line: 152	
		return (IManageablePage) pageSerializer.deserialize(data);
/cb

	DefaultPageStore(AbstractCachingPageStore<P>).getPage(String, int) line: 67	
		byte[] data = getPageData(sessionId, pageId);
		if (data != null)
		{
			return deserializePage(data);
/cb

	PageStoreManager$SessionEntry.getPage(int) line: 203	
			// not found, ask pagestore for the page
			return getPageStore().getPage(sessionId, id);
/cb

	PageStoreManager$PersistentRequestAdapter.getPage(int) line: 357	
			SessionEntry entry = getSessionEntry(false);
				return entry.getPage(id);
entry	PageStoreManager$SessionEntry  (id=10089)	
	afterReadObject	null	
	applicationName	"RepeaterExamplesApplication" (id=10226)	
	sessionCache	ArrayList<E>  (id=10227)	
		[0]	DataTableFilterToolbarMy3aPage  (id=10236)	
	sessionId	"C337FDD567D39AD710BDC0BEFBEF8D38" (id=10228)	
id	4	


/cb

	PageStoreManager(AbstractPageManager).getPage(int) line: 82	
	PageAccessSynchronizer$2(PageManagerDecorator).getPage(int) line: 50	
	PageAccessSynchronizer$2.getPage(int) line: 246	
	DefaultMapperContext.getPageInstance(int) line: 113	
		IManageablePage manageablePage = Session.get().getPageManager().getPage(pageId);
/cb

	PageAndComponentProvider(PageProvider).getStoredPage(int) line: 299	
		IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
/cb

	PageAndComponentProvider(PageProvider).resolvePageInstance(Integer, Class<IRequestablePage>, PageParameters, Integer) line: 264	
		if (pageId != null)
		{
			page = getStoredPage(pageId);
/cb

	PageAndComponentProvider(PageProvider).getPageInstance() line: 169	
	ListenerInterfaceRequestHandler.getPage() line: 96	
	ListenerInterfaceRequestHandler.respond(IRequestCycle) line: 157	
		final IRequestablePage page = getPage();
/cb

	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
			IRequestHandler handler = resolveRequestHandler();
handler	ListenerInterfaceRequestHandler  (id=10207)	
			if (handler != null)
			{
				execute(handler);
/cb

	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ Einde DESERIALIZE PAGE


/ FILTER 

/ 7	 


/ we hebben de 1ste filter text filled in	, "Abby" 	, en Enter gegeven	,

/ we hebben workspace-wicket7_8 create	, 

/ set b's	,
FilterStateModel [line: 52] - FilterStateModel(IFilterStateLocator<T>)	
FilterStateModel [line: 61] - getObject()	
FilterStateModel [line: 70] - setObject(T)	
Form [line: 1829] - updateFormComponentModels()												<-
SortableContactDataProvider_my [line: 46] - SortableContactDataProvider_my()	
SortableContactDataProvider_my [line: 66] - filterContacts(List<Contact>)	
SortableContactDataProvider_my [line: 128] - size()	
SortableContactDataProvider_my [line: 137] - model(Contact)	
SortableContactDataProvider_my [line: 143] - getFilterState()	
SortableContactDataProvider_my [line: 149] - setFilterState(ContactFilter_my)	


/s
FilterForm<T>(Component).beforeRender() line: 1017	

this	FilterForm<T>  (id=10491)	
	children	DataTable<T,S>  (id=10490)	
	data	FilterStateModel<T>  (id=10653)									<-
		locator	SortableContactDataProvider_my  (id=10512)	
			contactFilter	ContactFilter_my  (id=10646)	
				dateFrom	null	
				dateTo	null	
				firstName	"Abby" (id=10662)	
				lastName	"Fisher" (id=10663)	
			state	SingleSortState<T>  (id=10647)	
				param	SortParam<T>  (id=10664)	
					ascending	true	
					property	"firstName" (id=10665)	
	id	"filterForm" (id=10654)	

/ 7	. 

/ we gaven "Abby" in 1ste filter text	, 
/ hij gaat compare de huidige filter state met wat we hebben gegeven	, 
/ nu hier vraag hij de huidige filter state	, 
/ later set hij "Abby" in de filter state	,

/s
	SortableContactDataProvider_my.getFilterState() line: 143	
	    return contactFilter;															/ huidige filter state	,
/cb

	SortableContactDataProvider_my.getFilterState() line: 36	
	FilterStateModel<T>.getObject() line: 61	
		return locator.getFilterState();
/cb

	PropertyModel<T>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 264	
		Object object = getTarget();												/ target waarover je de property moet nemen	,
object	FilterStateModel<T>  (id=117)	

		while (object instanceof IModel)
		{
			Object tmp = ((IModel<?>)object).getObject();
			if (tmp == object)
			{
				break;
			}
			object = tmp;
		}
		return object;
/cb

	PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 83	
		final Object target = getInnermostModelOrObject();
/cb

	TextField<T>(Component).getDefaultModelObject() line: 1626	
		final IModel<?> model = getDefaultModel();
		if (model != null)
		{
			try
			{
				// Get model value for this component.
				return model.getObject();

model	PropertyModel<T>  (id=118)	
	expression	"firstName" (id=269)	
	target	FilterStateModel<T>  (id=117)								<- form's model	,
		locator	SortableContactDataProvider_my  (id=87)	
			contactFilter	ContactFilter_my  (id=284)	
				dateFrom	null	
				dateTo	null	
				firstName	null	
				lastName	null	
			state	SingleSortState<T>  (id=286)	
				param	SortParam<T>  (id=289)	
					ascending	true	
					property	"firstName" (id=269)	

/cb

	Component$3.compare(Component, Object) line: 303	
	TextField<T>(Component).setDefaultModelObject(Object) line: 3079	
		// Check whether this will result in an actual change
		if (!getModelComparator().compare(this, object))					<- 
		{
			modelChanging();
			model.setObject(object);
			modelChanged();
		}
/cb

	TextField<T>(FormComponent<T>).setModelObject(T) line: 1579	
	TextField<T>(FormComponent<T>).updateModel() line: 1097	
		setModelObject(getConvertedInput());
/cb

	Form$FormModelUpdateVisitor.component(Component, IVisit<Void>) line: 229	
								((IFormModelUpdateListener)component).updateModel();
component=[TextField [Component id = filter]]
/cb

	Form$FormModelUpdateVisitor.component(Object, IVisit) line: 199	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 274	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrderHelper(Object, IVisitor<S,R>, IVisitFilter, Visit<R>) line: 262	
	Visits.visitPostOrder(Object, IVisitor<S,R>, IVisitFilter) line: 245	
	FormComponent<T>.visitComponentsPostOrder(Component, IVisitor<Component,R>) line: 423	
	FilterForm<T>(Form<T>).internalUpdateFormComponentModels() line: 1864	
		FormComponent.visitComponentsPostOrder(this, new FormModelUpdateVisitor(this));
/cb

	FilterForm<T>(Form<T>).updateFormComponentModels() line: 1829	
		internalUpdateFormComponentModels();
/cb

	FilterForm<T>(Form<T>).process(IFormSubmitter) line: 963											<- main function	,
		// run validation
		validate();
			// Update model using form data
			updateFormComponentModels();				<- nu	,
			// Form has no error
			delegateSubmit(submittingComponent);
/cb

	FilterForm<T>(Form<T>).onFormSubmitted(IFormSubmitter) line: 795	
					// process the form for this request
					formToProcess.process(submitter);
/cb

	FilterForm<T>(Form<T>).onFormSubmitted() line: 708	
		onFormSubmitted(null);
/cb

	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 57	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	RequestListenerInterface.internalInvoke(Component, Object) line: 258	
			method.invoke(target);	/ method=public abstract void org.apache.wicket.markup.html.form.IFormSubmitListener.onFormSubmitted()
										/ target=[FilterForm [Component id = filterForm]]
/cb

	RequestListenerInterface.invoke(IRequestableComponent) line: 216	
		internalInvoke(component, component);
/cb

	ListenerInterfaceRequestHandler.invokeListener() line: 241											<- main method	,
		if (getBehaviorIndex() == null)
		{
			listenerInterface.invoke(getComponent());							/ in de handler zit de RequestListenerInterface	,
/cb

	ListenerInterfaceRequestHandler.respond(IRequestCycle) line: 234	
		invokeListener();
/cb

	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
			IRequestHandler handler = resolveRequestHandler();
handler	ListenerInterfaceRequestHandler  (id=100)	
	behaviorId	null												
	listenerInterface	RequestListenerInterface  (id=99)	
		listenerInterfaceClass	Class<T> (org.apache.wicket.markup.html.form.IFormSubmitListener) (id=136)	
		method	Method  (id=98) / public abstract void org.apache.wicket.markup.html.form.IFormSubmitListener.onFormSubmitted()	
		name	"IFormSubmitListener" (id=165)	

				execute(handler);
/cb

	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ Intermezzo

/ Hierboven zagen we	, 
handler	ListenerInterfaceRequestHandler  (id=100)	
	behaviorId	null	i
	listenerInterface	RequestListenerInterface  (id=99)	
		listenerInterfaceClass	Class<T> (org.apache.wicket.markup.html.form.IFormSubmitListener) (id=136)	
		method	Method  (id=98) / public abstract void org.apache.wicket.markup.html.form.IFormSubmitListener.onFormSubmitted()	
		name	"IFormSubmitListener" (id=165)	

public class RequestListenerInterface
	/** Map from name to request listener interface */
	private static final Map<String, RequestListenerInterface> interfaces = Collections.synchronizedMap(new HashMap<String, RequestListenerInterface>());
/ Een RequestListenerInterface heeft een static list van RequestListenerInterfaces	,


public interface IFormSubmitListener extends IRequestListener
{
	public static final RequestListenerInterface INTERFACE = new RequestListenerInterface( IFormSubmitListener.class);
	void onFormSubmitted();
}
/ Dit is er 1 uit de RequestListenerInterface's static list	,

public class Form<T> extends WebMarkupContainer implements IFormSubmitListener,
/ De Form is in feite de listener	, 																	<-

/ TODO (save method)

/ Einde Intermezzo

/c
/t 
TextField<T>(Component).setDefaultModelObject(Object) line: 3082	
		// Check whether this will result in an actual change
		if (!getModelComparator().compare(this, object))
/j
		{
			modelChanging();
			model.setObject(object);
object	"Abby" (id=304)	
model	PropertyModel<T>  (id=118)	
	expression	"firstName" (id=269)	
	target	FilterStateModel<T>  (id=117)	

/c
TextField<T>(Component).setDefaultModelObject(Object) line: 3082	
		// Check whether this will result in an actual change
		if (!getModelComparator().compare(this, object))			<- zonet	,
/d
		{
			modelChanging();
			model.setObject(object);
/s
PropertyModel<T>(AbstractPropertyModel<T>).setObject(T) line: 131	
		final String expression = propertyExpression();				/ "firstName"
		else
		{
			PropertyResolverConverter prc = new PropertyResolverConverter( Application.get().getConverterLocator(), Session.get().getLocale());
			PropertyResolver.setValue(expression, getInnermostModelOrObject(), object, prc);
/s
PropertyModel<T>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 264	
		Object object = getTarget();		/ FilterStateModel	,
		while (object instanceof IModel)
		{
			Object tmp = ((IModel<?>)object).getObject();	/ ContactFilter_my
/ Hier waren we net ook	,
			object = tmp;
		return object;
/t
PropertyModel<T>(AbstractPropertyModel<T>).setObject(T) line: 131	
			PropertyResolver.setValue(expression, getInnermostModelOrObject(), object, prc);
/pd
/s
PropertyResolver.setValue(String, Object, Object, PropertyResolverConverter) line: 133	
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, CREATE_NEW_VALUE);
expression="firstName"
object=ContactFilter_my
		setter.setValue(value, converter == null ? new PropertyResolverConverter(Application.get()
			.getConverterLocator(), Session.get().getLocale()) : converter);
value="Abby"
object	ContactFilter_my  (id=284)	
	dateFrom	null	
	dateTo	null	
	firstName	"Abby" (id=304)	
	lastName	null	

/ TODO 
/ MORGENOCHTEND 8 mei GoFilter	,





/ 7	. 







/ Einde FILTER 


/ Einde FILTERFORM

/ FILTERS

/ 7	. 

/ In SCS	,

/ Als een class een interface implements	, en hij implements de interface methods niet	, dan moet de class abstract zijn	, 

AbstractColumn	
	FilteredAbstractColumn
	PropertyColumn
		FilteredPropertyColumn
			TextFilteredPropertyColumn

/ Sommige columns hebben geen property	, zoals de column met de filters	,  dus die moeten FilteredAbstractColumn extend	, 
/ Andere wel	, die moeten FilteredPropertyColumn extend	, 

/ 13	. 

/ FilteredAbstractColumn implements IFilteredColumn.getFilter niet	, en ICellPopulator.populateItem niet	,  dus een anonymous extension moet dat doen	, 

public abstract class SoftDeletableSearchPage<T extends EnumeratedValueObjectInterface> extends BasePage implements
		IColumn<T> action = new FilteredAbstractColumn<T>(Model.<String> of("Actions")) {
			@Override
			public Component getFilter(String componentId, FilterForm<?> form) {
				...
			@Override
			public void populateItem(final Item<ICellPopulator<T>> cit, final String cid, final IModel<T> rml) {
				...
/e
public abstract class FilteredAbstractColumn<T> extends AbstractColumn<T> implements IFilteredColumn<T>
/i
public interface IFilteredColumn<T> extends IColumn<T>
	Component getFilter(String componentId, FilterForm<?> form);
/t
/e
public abstract class AbstractColumn<T> implements IStyledColumn<T>
	public String getSortProperty(){
		...
	public boolean isSortable(){
		...
	public Component getHeader(String componentId){
		...
/i
public interface IStyledColumn<T> extends IColumn<T>
/e
public interface IColumn<T> extends ICellPopulator<T>
	Component getHeader(String componentId);
	String getSortProperty();
	boolean isSortable();
/e
public interface ICellPopulator<T> extends IClusterable, IDetachable
	void populateItem(final Item<ICellPopulator<T>> cellItem, final String componentId, final IModel<T> rowModel);

/ AbstractColumn implements IStyledColumn, maar implements ICellPopulator.populateItem niet	, daarom moet AbstractColumn abstract zijn	,  
/ AbstractColumn implements wel IColumn.getHeader, IColumn.getSortProperty, IColumn.isSortable	,

/ 13	. 

/ In DataTableFilterToolbarMy3aPage	, 

/ TextFilteredPropertyColumn implements IFilteredColumn.getFilter , en ICellPopulator.populateItem ,

public class TextFilteredPropertyColumn<T, F> extends FilteredPropertyColumn<T>
	public Component getFilter(String componentId, FilterForm<?> form) {	
		return new TextFilter<F>(componentId, getFilterModel(form), form);			/ ipv GoFilter	,
	}
/e
public class PropertyColumn<T> extends AbstractColumn<T>
	public void populateItem(Item<ICellPopulator<T>> item, String componentId, IModel<T> rowModel) {
		item.add(new Label(componentId, createLabelModel(rowModel)));
	}

/ 7	. 

/ In DataTableFilterToolbarMy3aPage

public class DataTableFilterToolbarMy3aPage extends BaseMy3aPage
		columns.add(new TextFilteredPropertyColumn<Contact, String,String>(new Model<>("First Name"), "firstName", "firstName"));

public class TextFilteredPropertyColumn<T, F, S> extends FilteredPropertyColumn<T, S>
	@Override
	public Component getFilter(final String componentId, final FilterForm<?> form) {
		return new TextFilter<>(componentId, getFilterModel(form), form);
	}
/s
public class FilterToolbar extends AbstractToolbar
	public <T, S, F> FilterToolbar(final DataTable<T, S> table, final FilterForm<F> form)
		// populate the toolbar with components provided by filtered columns
		ListView<IColumn<T, S>> filters = new ListView<IColumn<T, S>>("filters", model)
			@Override
			protected void populateItem(ListItem<IColumn<T, S>> item) {
					filter = filteredCol.getFilter(FILTER_ID, form);







/ Einde FILTERS

/ DEBUG LISTVIEW



/ 7	. 

/ 1ste voorbeeld	, 

public class ListingPage extends WebPage{

	public final static int count=10;
	
	public ListingPage()
	{
		final List<Person>persons=Arrays.asList(new Person("foo","bar"),new Person("me","you"));
		// Er wordt Model.of(persons) gedaan	, 
		// Dit is niet zo illustratief: nuttiger is om een stateless of detachable  model te maken
		// die een db query doet	, als dan de item wordt render, dan wordt de item resolved, en 
		// wordt de query gedaan,
		
		ListView<Person>view=new ListView<Person>("view",persons) {
			@Override
			protected void populateItem(ListItem<Person> item) {
				item.add(new Label("name",new PropertyModel<String>(item.getModel(),"name")));	/ item.getModel()=ListItemModel met de index	,
				item.add(new Label("surname",new PropertyModel<String>(item.getModel(),"surname")));				
			}
		};
		add(view);
	}
	private static class Person implements Serializable {
        private String name;
        private String surname;
		...

/c
/stack
/s
Daemon Thread [http-nio-9090-exec-18] (Suspended (breakpoint at line 516 in ListView))	
	owns: NioChannel  (id=12488)	
	ListingPage$1(ListView<T>).onPopulate() line: 516			/ creates Items	+ Models, and adds them in the component tree	, creates Labels+ Models, 
																		/ and adds them in the component tree	, 
	ListingPage$1(AbstractRepeater).onBeforeRender() line: 124	
	ListingPage$1(Component).internalBeforeRender() line: 949	
	ListingPage$1(Component).beforeRender() line: 1017	
	ListingPage(MarkupContainer).onBeforeRenderChildren() line: 1866	
	ListingPage(Component).onBeforeRender() line: 3877	
	ListingPage(Page).onBeforeRender() line: 801	
	ListingPage(Component).internalBeforeRender() line: 949	
	ListingPage(Component).beforeRender() line: 1017	
	ListingPage(Component).internalPrepareForRender(boolean) line: 2215	
	ListingPage(Page).internalPrepareForRender(boolean) line: 242	
	ListingPage(Component).render() line: 2304	
	ListingPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	


/s
ListingPage$1(AbstractRepeater).onBeforeRender() line: 124	
		onPopulate();
/s
ListingPage$1(ListView<T>).onPopulate() line: 516	
			for (int i = 0; i < size; i++)
					item = newItem(index, getListItemModel(..., index));
/s
ListingPage$1(ListView<T>).getListItemModel(IModel<List<T>>, int) line: 448	
		return new ListItemModel<>(this, index);
/t
/s
ListingPage$1(ListView<T>).newItem(int, IModel<T>) line: 461	
		return new ListItem<>(index, itemModel);
/t
ListingPage$1(ListView<T>).onPopulate() line: 519	
			for (int i = 0; i < size; i++) {
					item = newItem(index, getListItemModel(getModel(), index));
/d
					add(item);
					populateItem(item);
/s
ListingPage$1.populateItem(ListItem<Person>) line: 44	
				item.add(new Label("name",new PropertyModel<String>(item.getModel(),"name")));	/ item.getModel() heeft index	, 
																				/ hoe property modle see getObject beneden
				item.add(new Label("surname",new PropertyModel<String>(item.getModel(),"surname")));				
/t
ListingPage$1(ListView<T>).onPopulate() line: 505	
			for (int i = 0; i < size; i++) {
					item = newItem(index, getListItemModel(getModel(), index));
					add(item);
					populateItem(item);
/d
/ volgende
/ we geloven het	, 
/t
ListingPage$1(AbstractRepeater).onBeforeRender() line: 126
		onPopulate();
/d

this	ListingPage$1  (id=12489)	
	data	ListModel<T>  (id=12503)	
		object	Arrays$ArrayList<E>  (id=12498)	
			a	ListingPage$Person[2]  (id=12500)	
				[0]	ListingPage$Person  (id=12519)	
				[1]	ListingPage$Person  (id=12520)	
	children	ArrayList<E>  (id=12517)	
		elementData	Object[12]  (id=12521)	
			[0]	ListItem<T>  (id=12512)	
				data	ListItemModel<T>  (id=12511)	
					index	0	
					listView	ListingPage$1  (id=12489)	
				children	ArrayList<E>  (id=12523)	
					elementData	Object[12]  (id=12524)	
						[0]	Label  (id=12525)	
							data	PropertyModel<T>  (id=12527)		 
								expression	"name" (id=12528)			 
								target	ListItemModel<T>  (id=12511)	/ = Model van de ListItem	, zijn parent	,
							id	"name" (id=12528)	
						[1]	Label  (id=12526)	
							data	PropertyModel<T>  (id=12557)	
								expression	"surname" (id=12558)	
								target	ListItemModel<T>  (id=12511)	/ = Model van de ListItem	, zijn parent	,
							id	"surname" (id=12558)	
				id	"0" (id=10210)	
				index	0	
			[1]	ListItem<T>  (id=12522)	
				data	ListItemModel<T>  (id=12571)	
					index	1	
					listView	ListingPage$1  (id=12489)	
				children	ArrayList<E>  (id=12570)	
					elementData	Object[12]  (id=12574)	
						[0]	Label  (id=12576)	
							data	PropertyModel<T>  (id=12579)	
								expression	"name" (id=12528)	
								target	ListItemModel<T>  (id=12571)	/ = Model van de ListItem	, zijn parent	,
							id	"name" (id=12528)	
						[1]	Label  (id=12577)	
							data	PropertyModel<T>  (id=12617)	
								expression	"name" (id=12528)	
								target	ListItemModel<T>  (id=12571)	/ = Model van de ListItem	, zijn parent	,
							id	"surname" (id=12528)	
					modCount	2	
					size	2	
				id	"1" (id=10287)	
				index	1	

/c
/ stack	,
																				/ render de Items , Labels	, resolve the Models die we met onBefore	
																					/ hebben add 	,
	PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 71	
	Label(Component).getDefaultModelObject() line: 1626	
		final IModel<?> model = getDefaultModel();		/ PropertyModel , target=Model met index	, expression ="name"	,
				return model.getObject();

	Label(Component).getDefaultModelObjectAsString() line: 1654	
		return getDefaultModelObjectAsString(getDefaultModelObject());
/cb
	Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Label(Component).internalRenderComponent() line: 2565	
	Label(WebComponent).onRender() line: 60	
	Label(Component).internalRender() line: 2380	
	Label(Component).render() line: 2308	
	ListItem<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	ListItem<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	ListItem<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	ListItem<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	ListItem<T>(Component).internalRenderComponent() line: 2565	
	ListItem<T>(MarkupContainer).onRender() line: 1698	
	ListItem<T>(Component).internalRender() line: 2380	
	ListItem<T>(Component).render() line: 2308	
	ListingPage$1(ListView<T>).renderItem(ListItem<?>) line: 584	
	ListingPage$1(ListView<T>).renderChild(Component) line: 573	
	ListingPage$1(AbstractRepeater).onRender() line: 102	
	ListingPage$1(Component).internalRender() line: 2380	
	ListingPage$1(Component).render() line: 2308	
	ListingPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
	ListingPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	ListingPage(Page).onRender() line: 879	
	ListingPage(WebPage).onRender() line: 141	
	ListingPage(Component).internalRender() line: 2380	
	ListingPage(Component).render() line: 2308	
	ListingPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/ debug	,
/s
PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 71	
		final String expression = propertyExpression();
"name"
		final Object target = getInnermostModelOrObject();	/ Model = PropertyModel heeft index + property "name"	,
/ antwoord	,	
target ListingPage$Person  (id=12519)	
	name	"foo" (id=12646)	
	surname	"bar" (id=12647)	
/ want	,
/s
PropertyModel<T>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 261	
		Object object = getTarget();			/ ListItemModel met index	,
		while (object instanceof IModel)
		{
			Object tmp = ((IModel<?>)object).getObject();
/s
ListItemModel<T>.getObject() line: 61	
		return listView.getModelObject().get(index); 	/ listView.getModelObject()=array met data	, 
															/ dit had ook een db query kunnen zijn	, daarom Models	,
/s
ListingPage$1(ListView<T>).getModelObject() line: 643	
		return (List<T>)getDefaultModelObject();
/s
ListingPage$1(Component).getDefaultModelObject() line: 1620	
		final IModel<?> model = getDefaultModel();
		if (model != null)
		{
			try
			{
				// Get model value for this component.
				return model.getObject();
/t
ListItemModel<T>.getObject() line: 61	
		return listView.getModelObject().get(index);
/pd
/d
/t
PropertyModel<T>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 265	
			Object tmp = ((IModel<?>)object).getObject();
/d
tmp	ListingPage$Person  (id=12519)	
	name	"foo" (id=12646)	
	surname	"bar" (id=12647)	

			object = tmp;
		while (object instanceof IModel)
/ volgende	,
/ NEE
		return object;
/t
PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 84	
		final Object target = getInnermostModelOrObject();
/d
target ListingPage$Person  (id=12519)	
	name	"foo" (id=12646)	
	surname	"bar" (id=12647)	

		if (target != null)
		{
			return (T)PropertyResolver.getValue(expression, target);


/ 7	. 

/ 2de  voorbeeld

public class Listing3Page extends WebPage{

	public final static int count=10;
	
	public Listing3Page()
	{
		final List<IModel<Integer>> integers = new ArrayList<>(count);
		for(int i=0;i<count;i++){
			integers.add(new Model<Integer>(){
				@Override
				public Integer getObject() {
					return (int)(Math.random()*1000);
				}
			});
		}

		ListView<IModel<Integer>>view=new ListView<IModel<Integer>>("view",integers) {
			@Override
			protected void populateItem(ListItem<IModel<Integer>> item) {
				item.add(new Label("item",item.getModelObject()));	/ Item's Model is ListItemModel met index	, 
														Label's Model =  (resolved) en is corresponding  stateless Model uit integers	,
				
			}
		};
		add(view);
	}
}

/ We geven een List aan de ListView	, het is een List van IModels	,

/ stack	,
/s
	Listing3Page$2(ListView<T>).<init>(String, List<T>) line: 161	
	Listing3Page$2.<init>(Listing3Page, String, List) line: 49	
	Listing3Page.<init>() line: 49	
		ListView<IModel<Integer>>view=new ListView<IModel<Integer>>("view",integers) {
/cb
	NativeConstructorAccessorImpl.newInstance0(Constructor, Object[]) line: not available [native method]	
	NativeConstructorAccessorImpl.newInstance(Object[]) line: 57	
	DelegatingConstructorAccessorImpl.newInstance(Object[]) line: 45	
	Constructor<T>.newInstance(Object...) line: 526	
	DefaultPageFactory.newPage(Constructor<C>, PageParameters) line: 175	
	DefaultPageFactory.newPage(Class<C>) line: 67	
	DefaultMapperContext.newPageInstance(Class<IRequestablePage>, PageParameters) line: 102	
	PageProvider.resolvePageInstance(Integer, Class<IRequestablePage>, PageParameters, Integer) line: 271	
	PageProvider.getPageInstance() line: 169	
	WebPageRenderer(PageRenderer).getPage() line: 78	
	WebPageRenderer.isPageStateless() line: 287	
	WebPageRenderer.shouldRenderPageAndWriteResponse(RequestCycle, Url, Url) line: 329	
	WebPageRenderer.respond(RequestCycle) line: 193	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ debug	, 
/s
Listing3Page$2(ListView<T>).<init>(String, List<T>) line: 161	
/=
	public ListView(final String id, final List<T> list)
	{
		this(id, Model.ofList(list));
/s
Model<T>.ofList(List<C>) line: 83	
		return new ListModel<>(list);
/s
ListModel<T>.<init>(List<T>) line: 47	
		setObject(list);
/t
Listing3Page.<init>() line: 56	
		ListView<IModel<Integer>>view=new ListView<IModel<Integer>>("view",integers) {
/d
view	Listing3Page$2  (id=10142)	
	children	null	
	data	ListModel<T>  (id=10177)	
		object	ArrayList<E>  (id=10148)	

/c
/stack
/s
	Listing3Page$2(ListView<T>).onPopulate() line: 516	
	Listing3Page$2(AbstractRepeater).onBeforeRender() line: 124	
	Listing3Page$2(Component).internalBeforeRender() line: 949	
	Listing3Page$2(Component).beforeRender() line: 1017	
	Listing3Page(MarkupContainer).onBeforeRenderChildren() line: 1866	
	Listing3Page(Component).onBeforeRender() line: 3877	
	Listing3Page(Page).onBeforeRender() line: 801	
	Listing3Page(Component).internalBeforeRender() line: 949	
	Listing3Page(Component).beforeRender() line: 1017	
	Listing3Page(Component).internalPrepareForRender(boolean) line: 2215	
	Listing3Page(Page).internalPrepareForRender(boolean) line: 242	
	Listing3Page(Component).render() line: 2304	
	Listing3Page(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/debug	, 
/s
Listing3Page$2(ListView<T>).onPopulate() line: 516	
			for (int i = 0; i < size; i++) {
				if (item == null)
				{
					// Create item for index
					item = newItem(index, getListItemModel(getModel(), index) ); / getModel()=ListView's Model, die de ArrayList van de (stateless) 
														   ^^^^^^^					/ Models bevat	, wordt NIET used	, alleen de index wordt used	,
															not used	,

/ Dus de Model van de Item bevat alleen de index	, de Model van de ListView bevat de List van data	, 
														
/s
Listing3Page$2(ListView<T>).getListItemModel(IModel<List<T>>, int) line: 448	
/=
	/**
	 * Subclasses may provide their own ListItemModel with extended functionality. The default
	 * ListItemModel works fine with mostly static lists where index remains valid. In cases where
	 * the underlying list changes a lot (many users using the application), it may not longer be
	 * appropriate. In that case your own ListItemModel implementation should use an id (e.g. the
	 * database' record id) to identify and load the list item model object.
	 * 
	 * @param listViewModel
	 *            The ListView's model
	 * @param index
	 *            The list item index
	 * @return The ListItemModel created
	 */
	protected IModel<T> getListItemModel(final IModel<? extends List<T>> listViewModel,		/ listViewModel wordt NIET used	 	, alleen de index,		
		final int index)
	{
		return new ListItemModel<>(this, index);
/t
/s
Listing3Page$2(ListView<T>).newItem(int, IModel<T>) line: 461	
		return new ListItem<>(index, itemModel);
/t
Listing3Page$2(ListView<T>).onPopulate() line: 519	
			for (int i = 0; i < size; i++)
					item = newItem(index, getListItemModel(..., index));
/d
item	ListItem<T>  (id=10208)	
	children	null	
	data	ListItemModel<T>  (id=10204)	
		index	0	
		listView	Listing3Page$2  (id=10142)			/ ListView	, 

/ we hadden al	,
view	Listing3Page$2  (id=10142)	
	children	null	
	data	ListModel<T>  (id=10177)	
		object	ArrayList<E>  (id=10148)	

					add(item);
					populateItem(item);
/s
Listing3Page$2.populateItem(ListItem<IModel<Integer>>) line: 52	
				item.add(new Label("item",item.getModelObject()));
/s
ListItem<T>.getModelObject() line: 94	
		return (T)getDefaultModelObject();
/s
ListItem<T>(Component).getDefaultModelObject() line: 1626	
		final IModel<?> model = getDefaultModel();
				return model.getObject();
/s
ListItemModel<T>.getObject() line: 61								/ hier is ListItemModel speciaal	, 
		return listView.getModelObject().get(index);
/s
Listing3Page$2(ListView<T>).getModelObject() line: 643	
		return (List<T>)getDefaultModelObject();
/s
Listing3Page$2(Component).getDefaultModelObject() line: 1620	
		final IModel<?> model = getDefaultModel();
				return model.getObject();
/s
ListModel<T>(GenericBaseModel<T>).getObject() line: 47	
		return object;													/ List with data	,
/t
ListItemModel<T>.getObject() line: 61	
		return listView.getModelObject().get(index);
/pd
/d
/t
Listing3Page$2.populateItem(ListItem<IModel<Integer>>) line: 54	
				item.add(new Label("item",item.getModelObject()));
/pd
/d
/t
Listing3Page$2(ListView<T>).onPopulate() line: 505	
			for (int i = 0; i < size; i++)
			{
					// Create item for index
					item = newItem(index, getListItemModel(getModel(), index));

					// Add list item
					add(item);

					populateItem(item);
/d
/ volgende	, 
/ we geloven het	, 

/t
Listing3Page$2(AbstractRepeater).onBeforeRender() line: 126	
		onPopulate();
/d

this	Listing3Page$2  (id=12673)	
	data	ListModel<T>  (id=12683)	
		object	ArrayList<E>  (id=12697)	
			elementData	Object[10]  (id=12698)	
				[0]	Listing3Page$1  (id=12699)		/ stateless Model	,
				[1]	Listing3Page$1  (id=12700)		/ stateless Model	,
				[2]	Listing3Page$1  (id=12701)	
				[3]	Listing3Page$1  (id=12702)	
				[4]	Listing3Page$1  (id=12703)	
				[5]	Listing3Page$1  (id=12704)	
				[6]	Listing3Page$1  (id=12705)	
				[7]	Listing3Page$1  (id=12706)	
				[8]	Listing3Page$1  (id=12707)	
				[9]	Listing3Page$1  (id=12708)	
	children	ArrayList<E>  (id=12684)	
		elementData	Object[12]  (id=12686)	
			[0]	ListItem<T>  (id=12687)	
			[1]	ListItem<T>  (id=12688)	
			[2]	ListItem<T>  (id=12689)	
				children	Label  (id=12719)	
					data	Listing3Page$1  (id=12701)		/ corresponding stateless Model	,	 resolved met index uit ListItem's model	,
					id	"item" (id=10231)	
				data	ListItemModel<T>  (id=12720)		/ ListItem's Model heeft index	,
					index	2	
					listView	Listing3Page$2  (id=12673)	
				id	"2" (id=10331)	
				index	2	
			[3]	ListItem<T>  (id=12690)	
			[4]	ListItem<T>  (id=12691)	
			[5]	ListItem<T>  (id=12692)	
			[6]	ListItem<T>  (id=12693)	
			[7]	ListItem<T>  (id=12694)	
			[8]	ListItem<T>  (id=12695)	
			[9]	ListItem<T>  (id=12696)	
	id	"view" (id=10187)	

/ 7	. 

/ 3de voorbeeld	, 

/ FilterToolbar in DataTableFilterToolbarMy3aPage	, 	aan de FilterToolbar ('n Panel) wordt add de ListView FilterToolbar$2 	, 
																/ de ListView heeft 

public class DataTableFilterToolbarMy3aPage extends BaseMy3aPage

	public DataTableFilterToolbarMy3aPage()
		List<IColumn<Contact, String>> columns = new ArrayList<>();
		columns.add(new AbstractColumn<Contact, String>(new Model<>("Actions"))
			...
		columns.add(new PropertyColumn<Contact, String>(new Model<>("ID"), "id")
			...
		columns.add(new TextFilteredPropertyColumn<Contact, String,String>(new Model<>("First Name"), "firstName", "firstName"));
		...

		DataTable<Contact, String> table = new DataTable<>("tableWithFilterForm", columns,dataProvider, 8);	/ hier zien we columns	,
		FilterToolbar filterToolbar = new FilterToolbar(table, filterForm);






/ 13	. 

/ onBeforeRender	, die de Items, Labels en hun Models creates and adds	, de component tree + models wordt create	,

/c
/ stack
/s
	FilterToolbar$2.populateItem(ListItem<IColumn<T,S>>) line: 94		/ FilterToolbar$2 is de ListView	,
	FilterToolbar$2(ListView<T>).onPopulate() line: 523	
			for (int i = 0; i < size; i++)
					item = newItem(index, getListItemModel(getModel(), index));	/ ListItem's model = ListItemModel met index	,
					add(item);
					populateItem(item);
/cb
	FilterToolbar$2(AbstractRepeater).onBeforeRender() line: 124	
		onPopulate();
/cb
	FilterToolbar$2(Component).internalBeforeRender() line: 949	
	FilterToolbar$2(Component).beforeRender() line: 1017	
	FilterToolbar(MarkupContainer).onBeforeRenderChildren() line: 1866	
	FilterToolbar(Component).onBeforeRender() line: 3877	
	FilterToolbar.onBeforeRender() line: 158	
	FilterToolbar(Component).internalBeforeRender() line: 949	
	FilterToolbar(Component).beforeRender() line: 1017	
	RepeatingView(MarkupContainer).onBeforeRenderChildren() line: 1866	
	RepeatingView(Component).onBeforeRender() line: 3877	
	RepeatingView(AbstractRepeater).onBeforeRender() line: 143	
	RepeatingView(Component).internalBeforeRender() line: 949	
	RepeatingView(Component).beforeRender() line: 1017	
	DataTable$ToolbarsContainer(MarkupContainer).onBeforeRenderChildren() line: 1866	
	DataTable$ToolbarsContainer(Component).onBeforeRender() line: 3877	
	DataTable$ToolbarsContainer(Component).internalBeforeRender() line: 949	
	DataTable$ToolbarsContainer(Component).beforeRender() line: 1017	
	DataTable<T,S>(MarkupContainer).onBeforeRenderChildren() line: 1866	
	DataTable<T,S>(Component).onBeforeRender() line: 3877	
	DataTable<T,S>(Component).internalBeforeRender() line: 949	
	DataTable<T,S>(Component).beforeRender() line: 1017	
	FilterForm<T>(MarkupContainer).onBeforeRenderChildren() line: 1866	
	FilterForm<T>(Component).onBeforeRender() line: 3877	
	FilterForm<T>(Form<T>).onBeforeRender() line: 1807	
	FilterForm<T>(Component).internalBeforeRender() line: 949	
	FilterForm<T>(Component).beforeRender() line: 1017	
	DataTableFilterToolbarMy3aPage(MarkupContainer).onBeforeRenderChildren() line: 1866	
	DataTableFilterToolbarMy3aPage(Component).onBeforeRender() line: 3877	
	DataTableFilterToolbarMy3aPage(Page).onBeforeRender() line: 801	
	DataTableFilterToolbarMy3aPage(Component).internalBeforeRender() line: 949	
	DataTableFilterToolbarMy3aPage(Component).beforeRender() line: 1017	
	DataTableFilterToolbarMy3aPage(Component).internalPrepareForRender(boolean) line: 2215	
	DataTableFilterToolbarMy3aPage(Page).internalPrepareForRender(boolean) line: 242	
	DataTableFilterToolbarMy3aPage(Component).render() line: 2304	
	DataTableFilterToolbarMy3aPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/ debug	, 
/s
FilterToolbar$2.populateItem(ListItem<IColumn<T,S>>) line: 94	
				final IColumn<T, S> col = item.getModelObject();
col	DataTableFilterToolbarMy3aPage$1  (id=12816)					/ een van de IColumns	,	de index in de ListItem's model is used to resolve	,
																		/ de ListView's model heeft alle columns	, 
				item.setRenderBodyOnly(true);
/ TODO
				if (col instanceof IFilteredColumn)
/n
				if (filter == null)
/j
				{
					filter = new NoFilter(FILTER_ID);

				if (col instanceof IStyledColumn)
				{
					filter.add(new Behavior()
					{
						private static final long serialVersionUID = 1L;

						/**
						 * @see Behavior#onComponentTag(Component, ComponentTag)
						 */
						@Override
						public void onComponentTag(final Component component, final ComponentTag tag)
						{
							String className = ((IStyledColumn<?, S>)col).getCssClass();
							if (!Strings.isEmpty(className))
							{
								tag.append("class", className, " ");
							}
						}
					});
				}
				item.add(filter); / een NoFilter is een Panel (met niets erop)	, 
/t
/ volgende net zo	, 
/ volgende	,

/ Intermezzo

	public DataTableFilterToolbarMy3aPage()
		FilterForm<ContactFilter_my> filterForm = new FilterForm<>("filterForm", dataProvider);	
		add(filterForm);
		FilterToolbar filterToolbar = new FilterToolbar(table, filterForm);
 		table.addTopToolbar(filterToolbar);

/ Einde Intermezzo

/ we zijn in	,
	public <T, S, F> FilterToolbar(final DataTable<T, S> table, final FilterForm<F> form)	 / form is arg van call	,	acts als in closure	,

			for (int i = 0; i < size; i++)
					item = newItem(index, getListItemModel(getModel(), index));
item	ListItem<T>  (id=12951)	
	data	ListItemModel<T>  (id=12952)	
		index	1	
		listView	FilterToolbar$2  (id=12784)	

					add(item);
					populateItem(item);
/s
FilterToolbar$2.populateItem(ListItem<IColumn<T,S>>) line: 94	
				final IColumn<T, S> col = item.getModelObject();
col	TextFilteredPropertyColumn<T,F,S>  (id=12969)	

				item.setRenderBodyOnly(true);

				Component filter = null;
				if (col instanceof IFilteredColumn)
				{
					IFilteredColumn<T, S> filteredCol = (IFilteredColumn<T, S>)col;
					filter = filteredCol.getFilter(FILTER_ID, form);
/s
TextFilteredPropertyColumn<T,F,S>.getFilter(String, FilterForm<?>) line: 70	
		return new TextFilter<>(componentId, getFilterModel(form), form);
/s
TextFilteredPropertyColumn<T,F,S>.getFilterModel(FilterForm<?>) line: 83	
		return new PropertyModel<>(form.getDefaultModel(), getPropertyExpression());	/ dit wordt het model van de TextField	, 
/ MODEL RUNTIME SET
				/ we zien hier ook weer de use van een model	, de object in de FilterStateModel wordt runtime set	, of misschien get TODO	, omdat 
						/ het er aan ligt welke column door de user wordt gekozen	,

form	FilterForm<T>  (id=12780)	
	data	FilterStateModel<T>  (id=12779)	
		locator	SortableContactDataProvider_my  (id=12766)	
			contactFilter	ContactFilter_my  (id=12980)	
				dateFrom	null	
				dateTo	null	
				firstName	null	
				lastName	null	
			state	SingleSortState<T>  (id=12981)	
				param	SortParam<T>  (id=12982)	
					ascending	true	
					property	"firstName" (id=13020)	

getPropertyExpression()="firstName"

/t
TextFilteredPropertyColumn<T,F,S>.getFilter(String, FilterForm<?>) line: 70	
		return new TextFilter<>(componentId, getFilterModel(form), form);
/pd
/s
TextFilter<T>.<init>(String, IModel<T>, FilterForm<?>) line: 48	
/=
	public TextFilter(final String id, final IModel<T> model, final FilterForm<?> form)
		super(id, form);	
/s
TextFilter<T>(AbstractFilter).<init>(String, FilterForm<?>) line: 43	
/=
public class AbstractFilter extends Panel
	public AbstractFilter(final String id, final FilterForm<?> form)
		super(id);														/ Panel ctor	,
		this.form = form;

/ Intermezzo

<wicket:panel xmlns:wicket="http://wicket.apache.org"><input type="text" wicket:id="filter"/></wicket:panel>

/ Einde Intermezzo

/t
TextFilter<T>.<init>(String, IModel<T>, FilterForm<?>) line: 49	
		super(id, form);
		filter = new TextField<>("filter", model);
model	PropertyModel<T>  (id=13042)	
	expression	"firstName" (id=13020)	
	target	FilterStateModel<T>  (id=12779)	
		enableFocusTracking(filter);
		add(filter);				/ this==TextFilter is een Panel
/t
FilterToolbar$2.populateItem(ListItem<IColumn<T,S>>) line: 124	
					filter = filteredCol.getFilter(FILTER_ID, form);
/d
				if (col instanceof IStyledColumn)
				{
					filter.add(new Behavior()
/ css behavior	,
				item.add(filter);

/ 13	. 

/ ListView.onBeforeRender calls onPopulate	, en die maakt de tree van Components: Items, Labels, en hun Models. Zo staat het ook in de manual	,

The most important hook method of this stage is probably onBeforeRender(). This method is called before a component starts its rendering phase and it is our last chance to change its children hierarchy.

/ Dan calls ListView.onBeforeRender  onBeforeRender on the children	, de Items	. Maar die call ook onBeforeRender op hun children, etc	,

/c
/stack
/s
	PropertyModel<T>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 264	
		Object object = getTarget();			(runtime) filter = FilterStateModel	,	 (toestand van het filter)
		while (object instanceof IModel)
		{
			Object tmp = ((IModel<?>)object).getObject();	/ calls: return locator.getFilterState();
tmp	ContactFilter_my  (id=9579)	
	dateFrom	null	
	dateTo	null	
	firstName	null	
	lastName	null	
			object = tmp;
		return object;
/cb
	PropertyModel<T>(AbstractPropertyModel<T>).getObjectClass() line: 143	
		final Object target = getInnermostModelOrObject();
/cb
	TextField<T>(AbstractTextComponent<T>).getModelType(IModel<?>) line: 167	
			Class<?> objectClass = ((IObjectClassAwareModel<?>)model).getObjectClass();	/ model=property model= (runtime)filter+expression	,
/cb
	TextField<T>(AbstractTextComponent<T>).resolveType() line: 152	
			Class<?> type = getModelType(getDefaultModel());
/cb
	TextField<T>(AbstractTextComponent<T>).onBeforeRender() line: 142	
		super.onBeforeRender();
		resolveType();
/cb
	TextField<T>(Component).internalBeforeRender() line: 949	
	TextField<T>(Component).beforeRender() line: 1017	
	TextFilter<T>(MarkupContainer).onBeforeRenderChildren() line: 1866	
	TextFilter<T>(Component).onBeforeRender() line: 3877	
	TextFilter<T>(Component).internalBeforeRender() line: 949	
	TextFilter<T>(Component).beforeRender() line: 1017	
	ListItem<T>(MarkupContainer).onBeforeRenderChildren() line: 1866	
	ListItem<T>(Component).onBeforeRender() line: 3877	
	ListItem<T>(Component).internalBeforeRender() line: 949	
	ListItem<T>(Component).beforeRender() line: 1017	
	FilterToolbar$2(MarkupContainer).onBeforeRenderChildren() line: 1866	
	FilterToolbar$2(Component).onBeforeRender() line: 3877	
	FilterToolbar$2(AbstractRepeater).onBeforeRender() line: 143	
		onPopulate();												/ zonet	,	tree van components (Items, Labels) create	, and models	,
/d
		super.onBeforeRender();													/ calls onBeforeRender on children= Items	,
/cb
	FilterToolbar$2(Component).internalBeforeRender() line: 949	
	FilterToolbar$2(Component).beforeRender() line: 1017	
	FilterToolbar(MarkupContainer).onBeforeRenderChildren() line: 1866	
	FilterToolbar(Component).onBeforeRender() line: 3877	
	FilterToolbar.onBeforeRender() line: 158	
	FilterToolbar(Component).internalBeforeRender() line: 949	
	FilterToolbar(Component).beforeRender() line: 1017	
	RepeatingView(MarkupContainer).onBeforeRenderChildren() line: 1866	
	RepeatingView(Component).onBeforeRender() line: 3877	
	RepeatingView(AbstractRepeater).onBeforeRender() line: 143	
	RepeatingView(Component).internalBeforeRender() line: 949	
	RepeatingView(Component).beforeRender() line: 1017	
	DataTable$ToolbarsContainer(MarkupContainer).onBeforeRenderChildren() line: 1866	
	DataTable$ToolbarsContainer(Component).onBeforeRender() line: 3877	
	DataTable$ToolbarsContainer(Component).internalBeforeRender() line: 949	
	DataTable$ToolbarsContainer(Component).beforeRender() line: 1017	
	DataTable<T,S>(MarkupContainer).onBeforeRenderChildren() line: 1866	
	DataTable<T,S>(Component).onBeforeRender() line: 3877	
	DataTable<T,S>(Component).internalBeforeRender() line: 949	
	DataTable<T,S>(Component).beforeRender() line: 1017	
	FilterForm<T>(MarkupContainer).onBeforeRenderChildren() line: 1866	
	FilterForm<T>(Component).onBeforeRender() line: 3877	
	FilterForm<T>(Form<T>).onBeforeRender() line: 1807	
	FilterForm<T>(Component).internalBeforeRender() line: 949	
	FilterForm<T>(Component).beforeRender() line: 1017	
	DataTableFilterToolbarMy3aPage(MarkupContainer).onBeforeRenderChildren() line: 1866	
	DataTableFilterToolbarMy3aPage(Component).onBeforeRender() line: 3877	
	DataTableFilterToolbarMy3aPage(Page).onBeforeRender() line: 801	
	DataTableFilterToolbarMy3aPage(Component).internalBeforeRender() line: 949	
	DataTableFilterToolbarMy3aPage(Component).beforeRender() line: 1017	
	DataTableFilterToolbarMy3aPage(Component).internalPrepareForRender(boolean) line: 2215	
	DataTableFilterToolbarMy3aPage(Page).internalPrepareForRender(boolean) line: 242	
	DataTableFilterToolbarMy3aPage(Component).render() line: 2304	
	DataTableFilterToolbarMy3aPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/ debug	,
/t
PropertyModel<T>(AbstractPropertyModel<T>).getObjectClass() line: 155	
		final String expression = propertyExpression();	/ "firstName"
		final Object target = getInnermostModelOrObject();	/ Contact_my
				return (Class<T>)PropertyResolver.getPropertyClass(expression, target);
/s
PropertyResolver.getPropertyClass(String, Object) line: 163	
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, RESOLVE_CLASS);
setter	PropertyResolver$ObjectAndGetSetter  (id=9593)	
	getAndSetter	PropertyResolver$MethodGetAndSet  (id=9595)	
		field	Field  (id=9599)	
		getMethod	Method  (id=9600)	/ public java.lang.String org.apache.wicket.examples.repeater.ContactFilter_my.getFirstName()
		setMethod	Method  (id=9601)	

		return setter.getTargetClass();	/ = getMethod.getReturnType()
/t
TextField<T>(AbstractTextComponent<T>).getModelType(IModel<?>) line: 168	
		if (model instanceof IObjectClassAwareModel)
		{
			Class<?> objectClass = ((IObjectClassAwareModel<?>)model).getObjectClass();
/d
objectClass	Class<T> (java.lang.String) (id=8004)	
			return objectClass;
/t
TextField<T>(AbstractTextComponent<T>).resolveType() line: 153	
			Class<?> type = getModelType(getDefaultModel());
/d
			setType(type);	/ sets: 	typeName = type == null ? null : type.getName();
			setFlag(TYPE_RESOLVED, true);


/ 13	. 


/ Zonet onBeforeRender: determines children	, tree van Components (Items, Labels) en Models	,
/ Nu render	,

/ Event tussendoor: niets met Toolbar	, ListView	,

/ renders Label die weergeeft welke selected is	, 

$ vi BaseMy3aPage.java
	public BaseMy3aPage() {
		add(new Label("selected", new PropertyModel<>(this, "defaultModelObject.lastName")).setOutputMarkupId(true));


/ stack
/s
	PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 71	
	Label(Component).getDefaultModelObject() line: 1626	
		final IModel<?> model = getDefaultModel();	  
model	PropertyModel<T>  (id=9637)	
	expression	"defaultModelObject.lastName" (id=9658)	
	target	DataTableFilterToolbarMy3aPage  (id=9509)	

				return model.getObject();
/cb
	Label(Component).getDefaultModelObjectAsString() line: 1654	
	Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());
/cb
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Label(Component).internalRenderComponent() line: 2565	
				renderComponentTag(tag);
			markupStream.next();
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/cb
	Label(WebComponent).onRender() line: 60	
	Label(Component).internalRender() line: 2380	
	Label(Component).render() line: 2308	
	DataTableFilterToolbarMy3aPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
			final ComponentTag tag = (ComponentTag)element;
			final String id = tag.getId();
			Component component = get(id);
				component.render();
/cb
	DataTableFilterToolbarMy3aPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
		while (markupStream.hasMore()) {																/ render is markup based	,
			boolean rawMarkup = renderNext(markupStream);
/cb
	DataTableFilterToolbarMy3aPage(Page).onRender() line: 879	
	DataTableFilterToolbarMy3aPage(WebPage).onRender() line: 141	
	DataTableFilterToolbarMy3aPage(Component).internalRender() line: 2380	
	DataTableFilterToolbarMy3aPage(Component).render() line: 2308	
	DataTableFilterToolbarMy3aPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/ debug	, 
/s
	PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 71			 / resolve	,
		final String expression = propertyExpression();
defaultModelObject.lastName
		final Object target = getInnermostModelOrObject();	/ de page	,
			return (T)PropertyResolver.getValue(expression, target);
/s
PropertyResolver.getValue(String, Object) line: 99	
		ObjectAndGetSetter getter = getObjectAndGetSetter(expression, object, RETURN_NULL);
null
		return null;
/ TODO
/t
Label(Component).getDefaultModelObjectAsString() line: 1654	
		return getDefaultModelObjectAsString(getDefaultModelObject());
/pd
/s
Label(Component).getDefaultModelObjectAsString(Object) line: 1695	
		if (modelObject != null)
/n
	return "";

/ 13	. 

/ Render de TextFilter, NoFilter	, 
/ Hier wordt css behavior called	, 

/ Intermezzo

$ vi FilterToolbar.java
		// populate the toolbar with components provided by filtered columns
		ListView<IColumn<T, S>> filters = new ListView<IColumn<T, S>>("filters", model) {
			@Override
			protected void populateItem(ListItem<IColumn<T, S>> item) {
				if (col instanceof IFilteredColumn)
				{
					IFilteredColumn<T, S> filteredCol = (IFilteredColumn<T, S>)col;
					filter = filteredCol.getFilter(FILTER_ID, form);
				}

				if (filter == null)
				{
					filter = new NoFilter(FILTER_ID);
/ Dus er komt een list van filters (TODO type) net zoveel als er columns zijn	, de default is NoFilter	, anders TextFilter, GoFilter	,...


$ vi FilterToolbar.html
<wicket:panel>
	<tr class="filters-tr">
		<wicket:container wicket:id="filters">								/ ListView	,
			<td wicket:id="filter" class="filter-td">[filter]</td>		/ NoFilter, TextFilter, GoFilter (het zijn Panels)	, 
		</wicket:container>
	</tr>
</wicket:panel>

/ Einde Intermezzo

/c
/ stack
/s
	FilterToolbar$2$1.onComponentTag(Component, ComponentTag) line: 134	
				for (Behavior behavior : behaviors)
				{
					// Components may reject some behavior components
					if (isBehaviorAccepted(behavior))
					{
						behavior.onComponentTag(this, tag);								<- nu	,
			// Write the tag
			tag.writeOutput(getResponse(), !needToRenderTag(null),				<- straks	,
				getMarkup().getMarkupResourceStream().getWicketNamespace());
/cb
	NoFilter(Component).renderComponentTag(ComponentTag) line: 4010	
tag=<td wicket:id="filter" class="filter-td">
/cb
	NoFilter(Component).internalRenderComponent() line: 2556	
				renderComponentTag(tag);								<- nu hier	,
			markupStream.next();
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag); 	<- straks	,
/cb
	NoFilter(MarkupContainer).onRender() line: 1698	
	NoFilter(Component).internalRender() line: 2380	
	NoFilter(Component).render() line: 2308	

	ListItem<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	ListItem<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
		while (markupStream.hasMore())													/ markup based	,
			boolean rawMarkup = renderNext(markupStream);
/cb
	ListItem<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	ListItem<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	ListItem<T>(Component).internalRenderComponent() line: 2565	
				renderComponentTag(tag);
			markupStream.next();
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/cb
	ListItem<T>(MarkupContainer).onRender() line: 1698	
		internalRenderComponent();
/cb
	ListItem<T>(Component).internalRender() line: 2380	
	ListItem<T>(Component).render() line: 2308	

	FilterToolbar$2(ListView<T>).renderItem(ListItem<?>) line: 584	
	FilterToolbar$2(ListView<T>).renderChild(Component) line: 573	

	FilterToolbar$2(AbstractRepeater).onRender() line: 102	
		Iterator<? extends Component> it = renderIterator();
		while (it.hasNext()){
			Component child = it.next();
			renderChild(child);
/cb
	FilterToolbar$2(Component).internalRender() line: 2380	
	FilterToolbar$2(Component).render() line: 2308	

	FilterToolbar(MarkupContainer).renderNext(MarkupStream) line: 1524	
	FilterToolbar(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	FilterToolbar(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	FilterToolbar(MarkupContainer).renderAssociatedMarkup(String, String) line: 797	
			renderComponentTagBody(associatedMarkupStream, associatedMarkupOpenTag);	 / associatedMarkupOpenTag=<wicket:panel>
/cb
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
		((MarkupContainer)component).renderAssociatedMarkup(tagName,...);								/ component=FilterToolbar, tagName="panel"
	PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 112	
		renderAssociatedMarkup(component);
/cb
	FilterToolbar(Component).internalRenderComponent() line: 2565	
				renderComponentTag(tag);
			markupStream.next();
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/cb
	FilterToolbar(MarkupContainer).onRender() line: 1698	
		internalRenderComponent();
/cb
	FilterToolbar(Component).internalRender() line: 2380	
	FilterToolbar(Component).render() line: 2308	

	RepeatingView(AbstractRepeater).renderChild(Component) line: 115	
	RepeatingView(AbstractRepeater).onRender() line: 102	
	RepeatingView(Component).internalRender() line: 2380	
	RepeatingView(Component).render() line: 2308	
	DataTable$ToolbarsContainer(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTable$ToolbarsContainer(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTable$ToolbarsContainer(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	DataTable$ToolbarsContainer(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	DataTable$ToolbarsContainer(Component).internalRenderComponent() line: 2565	
	DataTable$ToolbarsContainer(MarkupContainer).onRender() line: 1698	
	DataTable$ToolbarsContainer(Component).internalRender() line: 2380	
	DataTable$ToolbarsContainer(Component).render() line: 2308	
	DataTable<T,S>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTable<T,S>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTable<T,S>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	DataTable<T,S>(MarkupContainer).renderAssociatedMarkup(String, String) line: 797	
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
	PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 112	
	DataTable<T,S>(Component).internalRenderComponent() line: 2565	

	DataTable<T,S>(MarkupContainer).onRender() line: 1698	
	DataTable<T,S>(Component).internalRender() line: 2380	
	DataTable<T,S>(Component).render() line: 2308	

	FilterForm<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	FilterForm<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	FilterForm<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	FilterForm<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	FilterForm<T>(Form<T>).onComponentTagBody(MarkupStream, ComponentTag) line: 1705	
	FilterForm<T>.onComponentTagBody(MarkupStream, ComponentTag) line: 86	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	FilterForm<T>(Component).internalRenderComponent() line: 2565	
				renderComponentTag(tag);
			markupStream.next();
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/cb
	FilterForm<T>(MarkupContainer).onRender() line: 1698	
	FilterForm<T>(Component).internalRender() line: 2380	
	FilterForm<T>(Component).render() line: 2308	

	DataTableFilterToolbarMy3aPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTableFilterToolbarMy3aPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTableFilterToolbarMy3aPage(Page).onRender() line: 879	
		MarkupStream markupStream = new MarkupStream(getMarkup());
		renderAll(markupStream, null);
/cb
	DataTableFilterToolbarMy3aPage(WebPage).onRender() line: 141	
	DataTableFilterToolbarMy3aPage(Component).internalRender() line: 2380	
	DataTableFilterToolbarMy3aPage(Component).render() line: 2308	

	DataTableFilterToolbarMy3aPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ 13	. 


/ c

/ Renders de TextFilter (bij FilteredPropertyColumn)	, met property value in de ContactFilter_my	, 
/ Zonet deden we render NoFilter	,
/ Render de value in de TextField	,
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);	 

/ stack
/s
	FilterStateModel<T>.getObject() line: 61	
	PropertyModel<T>(AbstractPropertyModel<T>).getInnermostModelOrObject() line: 264	
	PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 83	
	TextField<T>(Component).getDefaultModelObject() line: 1626	
	TextField<T>(Component).getDefaultModelObjectAsString() line: 1654	
	TextField<T>(FormComponent<T>).getModelValue() line: 1287	
	TextField<T>(FormComponent<T>).getValue() line: 871	
	TextField<T>.onComponentTag(ComponentTag) line: 108	
	TextField<T>(Component).internalRenderComponent() line: 2521	
	TextField<T>(MarkupContainer).onRender() line: 1698	
	TextField<T>(Component).internalRender() line: 2380	
	TextField<T>(Component).render() line: 2308	
	TextFilter<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	TextFilter<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	TextFilter<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	TextFilter<T>(MarkupContainer).renderAssociatedMarkup(String, String) line: 797	
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
	PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 112	
	TextFilter<T>(Component).internalRenderComponent() line: 2565	
				renderComponentTag(tag);							/ zonet	, 
			markupStream.next();
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);	 / nu	,
/cb
	TextFilter<T>(MarkupContainer).onRender() line: 1698	
	TextFilter<T>(Component).internalRender() line: 2380	
	TextFilter<T>(Component).render() line: 2308	
	ListItem<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	ListItem<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	ListItem<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	ListItem<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	ListItem<T>(Component).internalRenderComponent() line: 2565	
	ListItem<T>(MarkupContainer).onRender() line: 1698	
	ListItem<T>(Component).internalRender() line: 2380	
	ListItem<T>(Component).render() line: 2308	
	FilterToolbar$2(ListView<T>).renderItem(ListItem<?>) line: 584	
	FilterToolbar$2(ListView<T>).renderChild(Component) line: 573	
	FilterToolbar$2(AbstractRepeater).onRender() line: 102	
	FilterToolbar$2(Component).internalRender() line: 2380	
	FilterToolbar$2(Component).render() line: 2308	
	FilterToolbar(MarkupContainer).renderNext(MarkupStream) line: 1524	
	FilterToolbar(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	FilterToolbar(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	FilterToolbar(MarkupContainer).renderAssociatedMarkup(String, String) line: 797	
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
	PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 112	
	FilterToolbar(Component).internalRenderComponent() line: 2565	
	FilterToolbar(MarkupContainer).onRender() line: 1698	
	FilterToolbar(Component).internalRender() line: 2380	
	FilterToolbar(Component).render() line: 2308	
	RepeatingView(AbstractRepeater).renderChild(Component) line: 115	
	RepeatingView(AbstractRepeater).onRender() line: 102	
	RepeatingView(Component).internalRender() line: 2380	
	RepeatingView(Component).render() line: 2308	
	DataTable$ToolbarsContainer(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTable$ToolbarsContainer(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTable$ToolbarsContainer(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	DataTable$ToolbarsContainer(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	DataTable$ToolbarsContainer(Component).internalRenderComponent() line: 2565	
	DataTable$ToolbarsContainer(MarkupContainer).onRender() line: 1698	
	DataTable$ToolbarsContainer(Component).internalRender() line: 2380	
	DataTable$ToolbarsContainer(Component).render() line: 2308	
	DataTable<T,S>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTable<T,S>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTable<T,S>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	DataTable<T,S>(MarkupContainer).renderAssociatedMarkup(String, String) line: 797	
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
	PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 112	
	DataTable<T,S>(Component).internalRenderComponent() line: 2565	
	DataTable<T,S>(MarkupContainer).onRender() line: 1698	
	DataTable<T,S>(Component).internalRender() line: 2380	
	DataTable<T,S>(Component).render() line: 2308						/ (*)
	FilterForm<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	FilterForm<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	FilterForm<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	FilterForm<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	FilterForm<T>(Form<T>).onComponentTagBody(MarkupStream, ComponentTag) line: 1705	
	FilterForm<T>.onComponentTagBody(MarkupStream, ComponentTag) line: 86	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	FilterForm<T>(Component).internalRenderComponent() line: 2565	
	FilterForm<T>(MarkupContainer).onRender() line: 1698	
	FilterForm<T>(Component).internalRender() line: 2380	
	FilterForm<T>(Component).render() line: 2308	
	DataTableFilterToolbarMy3aPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTableFilterToolbarMy3aPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTableFilterToolbarMy3aPage(Page).onRender() line: 879	
	DataTableFilterToolbarMy3aPage(WebPage).onRender() line: 141	
	DataTableFilterToolbarMy3aPage(Component).internalRender() line: 2380	
	DataTableFilterToolbarMy3aPage(Component).render() line: 2308	
	DataTableFilterToolbarMy3aPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/ HIER HIER HIER




/c

/ 13	. 

/ Render Label in cell
/ dus NIETS met filter	, 

/ Intermezzo

public abstract class AbstractDataGridView<T> extends DataViewBase<T>
	@Override
	protected final void populateItem(final Item<T> item)
	{
		RepeatingView cells = new RepeatingView(CELL_REPEATER_ID);
		item.add(cells);

		int populatorsNumber = populators.size();
		for (int i = 0; i < populatorsNumber; i++)
		{
			ICellPopulator<T> populator = populators.get(i);
			IModel<ICellPopulator<T>> populatorModel = new Model<>(populator);
			Item<ICellPopulator<T>> cellItem = newCellItem(cells.newChildId(), i, populatorModel);	/ cell item krijgt Model met ICellPopulator 
																		/ (IColumn is a ICellPopulator)	,  
																	/ See RefreshingView$IItemFactory.newItem , 
			cells.add(cellItem);

			populator.populateItem(cellItem, CELL_ITEM_ID, item.getModel());
}

public class PropertyColumn<T, S> extends AbstractColumn<T, S> implements IExportableColumn<T, S>
	@Override
	public void populateItem(final Item<ICellPopulator<T>> item, final String componentId,
		final IModel<T> rowModel)
	{
		item.add(new Label(componentId, getDataModel(rowModel)));
	}
	@Override
	public IModel<?> getDataModel(IModel<T> rowModel)
	{
		PropertyModel<?> propertyModel = new PropertyModel<>(rowModel, propertyExpression);
		return propertyModel;
	}

public class DataTableFilterToolbarMy3aPage extends BaseMy3aPage
		columns.add(new AbstractColumn<Contact, String>(new Model<>("Actions"))
		{
			@Override
			public void populateItem(Item<ICellPopulator<Contact>> cellItem, String componentId, IModel<Contact> m) {
				Panel action=new ActionMy3aPanel(componentId) {
					@Override
					protected void click(AjaxRequestTarget target) {
                        // first setTitle, then show    , because show calls getTitle   ,
						((ModalWindow)getPage().get("modal")).setTitle(new PropertyModel<String>(model, "cellPhone"));
						((ModalWindow)getPage().get("modal")).setContent(confirm).show(target);
						getPage().setDefaultModel(model);
					}
				};
				cellItem.add(action);

/ Einde Intermezzo

/ stack	,
/s
	PropertyModel<T>(AbstractPropertyModel<T>).getObject() line: 71	
	Label(Component).getDefaultModelObject() line: 1626	
	Label(Component).getDefaultModelObjectAsString() line: 1654	
	Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Label(Component).internalRenderComponent() line: 2565	
	Label(WebComponent).onRender() line: 60	
	Label(Component).internalRender() line: 2380	
	Label(Component).render() line: 2308	
	Item<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	Item<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	Item<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	Item<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Item<T>(Component).internalRenderComponent() line: 2565	
	Item<T>(MarkupContainer).onRender() line: 1698	
	Item<T>(Component).internalRender() line: 2380	
	Item<T>(Component).render() line: 2308										/ column item	, 
	RepeatingView(AbstractRepeater).renderChild(Component) line: 115	
	RepeatingView(AbstractRepeater).onRender() line: 102	
	RepeatingView(Component).internalRender() line: 2380	
	RepeatingView(Component).render() line: 2308	
	Item<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	Item<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	Item<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	Item<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Item<T>(Component).internalRenderComponent() line: 2565	
	Item<T>(MarkupContainer).onRender() line: 1698	
	Item<T>(Component).internalRender() line: 2380	
	Item<T>(Component).render() line: 2308													/ row item	
	DataTable$DefaultDataGridView(AbstractRepeater).renderChild(Component) line: 115	
	DataTable$DefaultDataGridView(AbstractRepeater).onRender() line: 102	
	DataTable$DefaultDataGridView(Component).internalRender() line: 2380	
	DataTable$DefaultDataGridView(Component).render() line: 2308	
	WebMarkupContainer(MarkupContainer).renderNext(MarkupStream) line: 1524	
	WebMarkupContainer(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	WebMarkupContainer(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	WebMarkupContainer(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	WebMarkupContainer(Component).internalRenderComponent() line: 2565	
	WebMarkupContainer(MarkupContainer).onRender() line: 1698	
	WebMarkupContainer(Component).internalRender() line: 2380	
	WebMarkupContainer(Component).render() line: 2308	
	DataTable<T,S>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTable<T,S>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTable<T,S>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	DataTable<T,S>(MarkupContainer).renderAssociatedMarkup(String, String) line: 797
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
	PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 112	
	DataTable<T,S>(Component).internalRenderComponent() line: 2565	
	DataTable<T,S>(MarkupContainer).onRender() line: 1698	
	DataTable<T,S>(Component).internalRender() line: 2380	
	DataTable<T,S>(Component).render() line: 2308									/ (**)
	FilterForm<T>(MarkupContainer).renderNext(MarkupStream) line: 1524	
	FilterForm<T>(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	FilterForm<T>(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	FilterForm<T>(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	FilterForm<T>(Form<T>).onComponentTagBody(MarkupStream, ComponentTag) line: 1705	
	FilterForm<T>.onComponentTagBody(MarkupStream, ComponentTag) line: 86	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	FilterForm<T>(Component).internalRenderComponent() line: 2565	
	FilterForm<T>(MarkupContainer).onRender() line: 1698	
	FilterForm<T>(Component).internalRender() line: 2380	
	FilterForm<T>(Component).render() line: 2308											/ (*)
	DataTableFilterToolbarMy3aPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
	DataTableFilterToolbarMy3aPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	DataTableFilterToolbarMy3aPage(Page).onRender() line: 879	
	DataTableFilterToolbarMy3aPage(WebPage).onRender() line: 141	
	DataTableFilterToolbarMy3aPage(Component).internalRender() line: 2380	
	DataTableFilterToolbarMy3aPage(Component).render() line: 2308	
	DataTableFilterToolbarMy3aPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/ debug	, 

/ (*)

/ CONTENT FILTERFORM IN DEBUG VIEW FILTERTOOLBAR DATAGRIDVIEW	

this	FilterForm<T>  (id=9521)	
	id	"filterForm" (id=10593)	
	data	FilterStateModel<T>  (id=9520)	
		locator	SortableContactDataProvider_my  (id=11645)	
			contactFilter	ContactFilter_my  (id=11720)	
				dateFrom	null	
				dateTo	null	
				firstName	null	
				lastName	null	
			state	SingleSortState<T>  (id=11721)	
				param	SortParam<T>  (id=11730)	
					ascending	true	
					property	"firstName" (id=11207)	
	children	DataTable<T,S>  (id=9526)	
		id	"tableWithFilterForm" (id=10601)	
		data	null												<-
		bottomToolbars	DataTable$ToolbarsContainer  (id=10595)	
		caption	DataTable$Caption  (id=10596)	
		children	ArrayList<E>  (id=10597)	
			elementData	Object[12]  (id=11791)	
				[0]	DataTable$Caption  (id=11700)	
				[1]	ColGroup  (id=11702)	
				[2]	WebMarkupContainer  (id=11659)	
				[3]	DataTable$ToolbarsContainer  (id=11664)		/= topToolbars
				[4]	DataTable$ToolbarsContainer  (id=11699)		/= bottomToolbars
		colGroup	ColGroup  (id=10598)	
		columns	ArrayList<E>  (id=9816)	
			elementData	Object[9]  (id=11848)	
				[0]	DataTableFilterToolbarMy3aPage$1  (id=11665)	
				[1]	DataTableFilterToolbarMy3aPage$2  (id=11849)	
				[2]	TextFilteredPropertyColumn<T,F,S>  (id=11673)	
				[3]	DataTableFilterToolbarMy3aPage$3  (id=11680)	
				[4]	PropertyColumn<T,S>  (id=11850)	
				[5]	PropertyColumn<T,S>  (id=11851)	
				[6]	PropertyColumn<T,S>  (id=11852)	
		topToolbars	DataTable$ToolbarsContainer  (id=9534)	
			id	"topToolbars" (id=10611)	
			data	null																			<-	
			children	RepeatingView  (id=9533)	
				data	null																		<-
				id	"toolbars" (id=10617)	
				children	ArrayList<E>  (id=10616)	
					elementData	Object[12]  (id=10619)	
						[0]	FilterToolbar  (id=9523)	
							data	null															<-
							id	"1" (id=10382)	
							children	FilterToolbar$2  (id=9522)								/ ListView
								data	FilterToolbar$1  (id=10633)									/ Model met alle IColumn	,
								id	"filters" (id=10634)	
								children	ArrayList<E>  (id=10632)	
									elementData	Object[12]  (id=10639)	
										[0]	ListItem<T>  (id=9693)	
											children	NoFilter  (id=9692)	
											data	ListItemModel<T>  (id=10642)	
												index	0	
												listView	FilterToolbar$2  (id=9522)	
											id	"0" (id=10643)	
										[1]	ListItem<T>  (id=9721)	
										[2]	ListItem<T>  (id=9544)	
											id	"2" (id=10371)	
											data	ListItemModel<T>  (id=9557)	
												index	2	
												listView	FilterToolbar$2  (id=9522)	
											children	TextFilter<T>  (id=9539)	
												data	FilterToolbar$2$1  (id=11940)		/ css behavior	,
												children	TextField<T>  (id=11683)	
													data	Object[2]  (id=11941)	
													[0]	PropertyModel<T>  (id=11682)	/ 	
														expression	"firstName" (id=11207)	
														target	FilterStateModel<T>  (id=11650)	
													[1]	FilterForm$1  (id=11942)			/ behavior	,
										[3]	ListItem<T>  (id=9632)	
										[4]	ListItem<T>  (id=9733)	
										[5]	ListItem<T>  (id=9736)	
										[6]	ListItem<T>  (id=9739)	
									modCount	7	
									size	7	
								markup	MarkupFragment  (id=10635)	
								markupSourcingStrategy	DefaultMarkupSourcingStrategy  (id=9639)	
								modCounter	7	
								parent	FilterToolbar  (id=9523)	
								queue	null	
								requestFlags	51	
								reuseItems	true	
								this$0	FilterToolbar  (id=9523)	
								val$form	FilterForm<T>  (id=9521)	
								viewSize	2147483647	
							markup	MarkupFragment  (id=10626)	
							markupSourcingStrategy	PanelMarkupSourcingStrategy  (id=9694)	
							modCounter	1	
							parent	RepeatingView  (id=9533)	
							queue	null	
							requestFlags	51	
							table	DataTable<T,S>  (id=9526)	
						[1]	NavigationToolbar  (id=10621)	
						[2]	HeadersToolbar<S>  (id=10622)	
		datagrid	DataTable$DefaultDataGridView  (id=11658)				/ RefreshingView
			data	null	
			id	"rows" (id=9783)	
			children	ArrayList<E>  (id=9782)	
				elementData	Object[12]  (id=9791)	
					[0]	Item<T>  (id=9779)	
					[1]	Item<T>  (id=9793)	
					[2]	Item<T>  (id=9794)													/ row item	
						data	DetachableContactModel  (id=9802)	
							id	46	
							state	LoadableDetachableModel$InternalState  (id=9806)	
							transientModelObject	null	 								/ straks Contact	,
						id	"3" (id=9803)	
						children	RepeatingView  (id=9801)	
							id	"cells" (id=9810)	
							data 	null
							children	ArrayList<E>  (id=9809)	
								elementData	Object[12]  (id=9822)	
									[0]	Item<T>  (id=9824)									/ column item	,	
										data	Object[2]  (id=10381)	
											[0]	Model<T>  (id=10384)						/ model met ICellPopulator new AbstractColumn	,	
												object	DataTableFilterToolbarMy3aPage$1  (id=9717)	
											[1]	DataTable$DefaultDataGridView$1  (id=10385)	/ new CssAttributeBehavior()
										id	"1" (id=10382)	
										children	DataTableFilterToolbarMy3aPage$1$2  (id=10380)	
											data	null	
											children	ActionMy3aPanel$1  (id=10447)	
												data	Object[2]  (id=10452)	
													[0]	AjaxLink$1  (id=10461)	
													[1]	Behaviors$BehaviorIdList  (id=10462)	
												id	"select" (id=10453)	
											flags	1107501210	
											generatedMarkupId	-1	
											id	"cell" (id=10363)	
											markup	null	
											markupSourcingStrategy	PanelMarkupSourcingStrategy  (id=10448)	
											modCounter	1	
											parent	Item<T>  (id=9824)	
											queue	null	
											requestFlags	51	
											this$1	DataTableFilterToolbarMy3aPage$1  (id=9717)	
											val$confirm	DataTableFilterToolbarMy3aPage$1$1  (id=10449)	
											val$model	DetachableContactModel  (id=9802)	
										index	0	
										markup	MarkupFragment  (id=9811)	
										markupSourcingStrategy	DefaultMarkupSourcingStrategy  (id=9639)	
										modCounter	1	
										parent	RepeatingView  (id=9801)	
										queue	null	
										requestFlags	51	
									[1]	Item<T>  (id=9825)	
										id	"2" (id=10371)	
										data	Object[2]  (id=10370)	
											[0]	Model<T>  (id=10375)									/ Model met ICellPopulator new PropertyColumn	, 
												object	DataTableFilterToolbarMy3aPage$2  (id=10378)		
											[1]	DataTable$DefaultDataGridView$1  (id=10376)	
										children	Label  (id=10369)	
											data	PropertyModel<T>  (id=10456)	
												expression	"id" (id=10457)	
												target	DetachableContactModel  (id=9802)	/ row item model	,	
											id	"cell" (id=10363)	
									[2]	Item<T>  (id=9826)	
										id	"3" (id=9803)	
										data	Object[2]  (id=10365)	
											[0]	Model<T>  (id=10366)						/ Model met ICellPopulator new TextFilteredPropertyColumn	
												object	TextFilteredPropertyColumn<T,F,S>  (id=9538)		 
											[1]	DataTable$DefaultDataGridView$1  (id=10367)	
										children	Label  (id=10364)	
											id	"cell" (id=12046)	
											data	PropertyModel<T>  (id=12045)	
												expression	"firstName" (id=11207)	
												target	DetachableContactModel  (id=12016)	
									[3]	Item<T>  (id=9827)	
										id	"4" (id=9835)	
										data	Object[2]  (id=9834)	
											[0]	Model<T>  (id=9840)	
												object	DataTableFilterToolbarMy3aPage$3  (id=9549)	
											[1]	DataTable$DefaultDataGridView$1  (id=9841)	
										children	Label  (id=9833)	
											data	PropertyModel<T>  (id=12045)	
												expression	"lastName" (id=11207)	
												target	DetachableContactModel  (id=12016)	
									[4]	Item<T>  (id=9828)	
										id	"5" (id=10392)	
										data	Object[2]  (id=10391)	
											[0]	Model<T>  (id=10394)	
												object	PropertyColumn<T,S>  (id=10397)	
											[1]	DataTable$DefaultDataGridView$1  (id=10395)	
										children	Label  (id=10390)	
									[5]	Item<T>  (id=9829)	
										id	"6" (id=10403)	
										data	Object[2]  (id=10402)	
											[0]	Model<T>  (id=10405)	
												object	PropertyColumn<T,S>  (id=10408)	
											[1]	DataTable$DefaultDataGridView$1  (id=10406)	
										children	Label  (id=10401)	
									[6]	Item<T>  (id=9831)	
										id	"7" (id=10413)	
										data	Object[2]  (id=10412)	
											[0]	Model<T>  (id=10415)	
												object	PropertyColumn<T,S>  (id=10418)	
											[1]	DataTable$DefaultDataGridView$1  (id=10416)	
										children	Label  (id=10411)	
							markup	MarkupFragment  (id=9811)	
							markupSourcingStrategy	DefaultMarkupSourcingStrategy  (id=9639)	
							modCounter	7	
							parent	Item<T>  (id=9794)	
							queue	null	
							requestFlags	51	
					[3]	Item<T>  (id=9795)	
					[4]	Item<T>  (id=9796)	
					[5]	Item<T>  (id=9797)	
					[6]	Item<T>  (id=9798)	
					[7]	Item<T>  (id=9799)	


/ MORGENOCHTEND


/ (**)

/ we zien hieronder dat de repeaters geen IModel hebben, 	
/ de rowItems hebben als model de Contacts
/ de cellItems hebben als model de ICellPopulators	,

this	DataTable$DefaultDataGridView  (id=9524)									/ RefreshingView	,
	data	null	
	id	"rows" (id=9783)	
	children	ArrayList<E>  (id=9782)	
		elementData	Object[12]  (id=9791)	
			[0]	Item<T>  (id=9779)	
			[1]	Item<T>  (id=9793)	
			[2]	Item<T>  (id=9794)													/ row item	
				data	DetachableContactModel  (id=9802)	
					id	46	
					state	LoadableDetachableModel$InternalState  (id=9806)	
					transientModelObject	null	 								/ straks Contact	,
				id	"3" (id=9803)	
				children	RepeatingView  (id=9801)	
					id	"cells" (id=9810)	
					data 	null
					children	ArrayList<E>  (id=9809)	
						elementData	Object[12]  (id=9822)	
							[0]	Item<T>  (id=9824)									/ column item	,	
								data	Object[2]  (id=10381)	
									[0]	Model<T>  (id=10384)						/ model met ICellPopulator new AbstractColumn	,	
										object	DataTableFilterToolbarMy3aPage$1  (id=9717)	
									[1]	DataTable$DefaultDataGridView$1  (id=10385)	/ new CssAttributeBehavior()
								id	"1" (id=10382)	
								children	DataTableFilterToolbarMy3aPage$1$2  (id=10380)	
									data	null	
									children	ActionMy3aPanel$1  (id=10447)	
										data	Object[2]  (id=10452)	
											[0]	AjaxLink$1  (id=10461)	
											[1]	Behaviors$BehaviorIdList  (id=10462)	
										id	"select" (id=10453)	
									flags	1107501210	
									generatedMarkupId	-1	
									id	"cell" (id=10363)	
									markup	null	
									markupSourcingStrategy	PanelMarkupSourcingStrategy  (id=10448)	
									modCounter	1	
									parent	Item<T>  (id=9824)	
									queue	null	
									requestFlags	51	
									this$1	DataTableFilterToolbarMy3aPage$1  (id=9717)	
									val$confirm	DataTableFilterToolbarMy3aPage$1$1  (id=10449)	
									val$model	DetachableContactModel  (id=9802)	
								index	0	
								markup	MarkupFragment  (id=9811)	
								markupSourcingStrategy	DefaultMarkupSourcingStrategy  (id=9639)	
								modCounter	1	
								parent	RepeatingView  (id=9801)	
								queue	null	
								requestFlags	51	
							[1]	Item<T>  (id=9825)	
								id	"2" (id=10371)	
								data	Object[2]  (id=10370)	
									[0]	Model<T>  (id=10375)									/ Model met ICellPopulator new PropertyColumn	, 
										object	DataTableFilterToolbarMy3aPage$2  (id=10378)		
									[1]	DataTable$DefaultDataGridView$1  (id=10376)	
								children	Label  (id=10369)	
									data	PropertyModel<T>  (id=10456)	
										expression	"id" (id=10457)	
										target	DetachableContactModel  (id=9802)	/ row item model	,	
									id	"cell" (id=10363)	
							[2]	Item<T>  (id=9826)	
								id	"3" (id=9803)	
								data	Object[2]  (id=10365)	
									[0]	Model<T>  (id=10366)									/ Model met ICellPopulator new TextFilteredPropertyColum	
										object	TextFilteredPropertyColumn<T,F,S>  (id=9538)		 
									[1]	DataTable$DefaultDataGridView$1  (id=10367)	
								children	Label  (id=10364)	
							[3]	Item<T>  (id=9827)	
								id	"4" (id=9835)	
								data	Object[2]  (id=9834)	
									[0]	Model<T>  (id=9840)	
										object	DataTableFilterToolbarMy3aPage$3  (id=9549)	
									[1]	DataTable$DefaultDataGridView$1  (id=9841)	
								children	Label  (id=9833)	
							[4]	Item<T>  (id=9828)	
								id	"5" (id=10392)	
								data	Object[2]  (id=10391)	
									[0]	Model<T>  (id=10394)	
										object	PropertyColumn<T,S>  (id=10397)	
									[1]	DataTable$DefaultDataGridView$1  (id=10395)	
								children	Label  (id=10390)	
							[5]	Item<T>  (id=9829)	
								id	"6" (id=10403)	
								data	Object[2]  (id=10402)	
									[0]	Model<T>  (id=10405)	
										object	PropertyColumn<T,S>  (id=10408)	
									[1]	DataTable$DefaultDataGridView$1  (id=10406)	
								children	Label  (id=10401)	
							[6]	Item<T>  (id=9831)	
								id	"7" (id=10413)	
								data	Object[2]  (id=10412)	
									[0]	Model<T>  (id=10415)	
										object	PropertyColumn<T,S>  (id=10418)	
									[1]	DataTable$DefaultDataGridView$1  (id=10416)	
								children	Label  (id=10411)	
					markup	MarkupFragment  (id=9811)	
					markupSourcingStrategy	DefaultMarkupSourcingStrategy  (id=9639)	
					modCounter	7	
					parent	Item<T>  (id=9794)	
					queue	null	
					requestFlags	51	
			[3]	Item<T>  (id=9795)	
			[4]	Item<T>  (id=9796)	
			[5]	Item<T>  (id=9797)	
			[6]	Item<T>  (id=9798)	
			[7]	Item<T>  (id=9799)	

/ Einde (*)
























/ Einde DEBUG LISTVIEW

/ WICKET WEBSOCKETS


://github.com/martin-g/wicket-native-websocket-example WICKET WEBSOCKETS
/ Einde WICKET WEBSOCKETS

/ WEBMARKUPCONTAINER

/ 7	. 

/ we kunnen een WebMarkupContainer in eigen .java file	, maar de HTML NIET	, 
/ Dus als je dat doet	, en je hebt 2 pages waarin je deze webmarkupcontainer use	, dan moet je de container HTML in de HTML van beide pages zetten	,
en niet zoals het kan bij een Panel	,
/  Daarom zien we van From, RefreshingPage, DataViewPage GEEN HTML files	, de markup moeten we zelf in onze pages maken	,

/ Form is ook een WebMarkupContainer	, 
/ AbstractRepeater is een WebMarkupContainer	, dus alle repeaters	, ook DataGridView 	, zijn WebMarkupContainers	, 
/ public abstract class Panel extends WebMarkupContainer implements ...	, een Panel is ook een WebMarkupContainer	, 
/ een AjaxLink is ook een WebMarkupContainer	, via AbstractLink	,
/ public class WebPage extends Page ,  public abstract class Page extends MarkupContainer


/ boek (175) WebMarkupContainers worden ook used om section of a page te repaint using ajax	,
/ TODO
/ boek (175) WebMarkupContainer it only attaches it to the  markup	, and does not modify them, unless you use behaviors or  override onComponentTag of onComponentTagBody	,

/ DataTable is een Panel
$ vi DataTable.html
<wicket:panel ...>
...
<tbody wicket:id="body">
	<tr wicket:id="rows">
		<td wicket:id="cells">
			<div wicket:id="cell">[cell]</div>
		</td>
	</tr>
</tbody>
</wicket:panel>

$ vi DataTable.java

	private final DataGridView<T> datagrid;
	private final WebMarkupContainer body;
	public DataTable(final String id, final List<? extends IColumn<T, S>> columns, final IDataProvider<T> dataProvider, final long rowsPerPage) {
		body = newBodyContainer("body");
		datagrid = newDataGridView("rows", columns, dataProvider);
	}
	protected WebMarkupContainer newBodyContainer(final String id)
	{
		return new WebMarkupContainer(id);
	}
	protected DataGridView<T> newDataGridView(String id, List<? extends IColumn<T, S>> columns, IDataProvider<T> dataProvider)
	{
		return new DefaultDataGridView(id, columns, dataProvider);
	}
/ dit is ook een WebMarkupContainer	,

/ 7	. 




/ Einde WEBMARKUPCONTAINER

/ DEBUG WEBMARKUPCONTAINER

/ 7	. 

$ vi file:///home/eric/Devel/Java/Wicket/wicket-examples-step-by-step/src/main/java/org/apache/wicket/examples/repeater/ChildInWebMarkupContainerPage.java 

public class ChildInWebMarkupContainerPage extends WebPage{
	
	public ChildInWebMarkupContainerPage() {
		WebMarkupContainer container=new WebMarkupContainer("container");
		add(container);
		
		IModel<String>model=new Model<String>(){
			public String getObject() {
				return new Date().toString();
			}
		};
		Label label=new Label("labelincontainer", model);
		container.add(label);
	}

}

<body>
	<div wicket:id="container">
		<span wicket:id="labelincontainer">
		</span>
	</div>
</body>

/ Wat is de markup van "container"	, en wat is markup van "labelincontainer"	?

/ we set b in Component.internalRender	,

/ Geef	, 
http://localhost:9090/wicket-examples-step-by-step/repeater/childinwebmarkupcontainer

/c
/ stack
/s
	Label(Component).internalRender() line: 2346	
		IMarkupFragment markup = getMarkup();
this	Label  (id=548)	
markup	MarkupFragment  (id=549)	
<span wicket:id="labelincontainer">
</span>
/cb
	Label(Component).render() line: 2308	
	WebMarkupContainer(MarkupContainer).renderNext(MarkupStream) line: 1524	
	WebMarkupContainer(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	WebMarkupContainer(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	WebMarkupContainer(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	WebMarkupContainer(Component).internalRenderComponent() line: 2565	
	WebMarkupContainer(MarkupContainer).onRender() line: 1698	
this	WebMarkupContainer  (id=505)	
markup	MarkupFragment  (id=506)	
<div wicket:id="container">
		<span wicket:id="labelincontainer">
		</span>
</div>
/cb
	WebMarkupContainer(Component).internalRender() line: 2380	
	WebMarkupContainer(Component).render() line: 2308	
	ChildInWebMarkupContainerPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
	ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	ChildInWebMarkupContainerPage(Page).onRender() line: 879	
	ChildInWebMarkupContainerPage(WebPage).onRender() line: 141	
	ChildInWebMarkupContainerPage(Component).internalRender() line: 2380	
		IMarkupFragment markup = getMarkup();
/cb
	ChildInWebMarkupContainerPage(Component).render() line: 2308	
	ChildInWebMarkupContainerPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	

/ we debug	, 
/ Eerst Page's markup	, 
/s
ChildInWebMarkupContainerPage(Component).internalRender() line: 2345		/ this	ChildInWebMarkupContainerPage  (id=573)	
		IMarkupFragment markup = getMarkup();
/s
ChildInWebMarkupContainerPage(Component).getMarkup() line: 740	
				MarkupContainer container = (MarkupContainer)this;
				Markup associatedMarkup = container.getAssociatedMarkup();
/s
ChildInWebMarkupContainerPage(MarkupContainer).getAssociatedMarkup() line: 456	
			Markup markup = MarkupFactory.get().getMarkup(this, false);
/s
MarkupFactory.getMarkup(MarkupContainer, boolean) line: 194	
		return getMarkup(container, container.getClass(), enforceReload);
/s
MarkupFactory.getMarkup(MarkupContainer, Class<?>, boolean) line: 240	
		MarkupResourceStream markupResourceStream = getMarkupResourceStream(container, containerClass);
/s
MarkupFactory.getMarkupResourceStream(MarkupContainer, Class<?>) line: 320	
		// Who is going to provide the markup resource stream?
		// And ask the provider to locate the markup resource stream
		final IResourceStream resourceStream = getMarkupResourceStreamProvider(container).getMarkupResourceStream(
			container, containerClass);
/s
DefaultMarkupResourceStreamProvider.getMarkupResourceStream(MarkupContainer, Class<?>) line: 70	
		// Get locator to search for the resource
		final IResourceStreamLocator locator = Application.get() .getResourceSettings() .getResourceStreamLocator();
locator	CachingResourceStreamLocator  (id=695)	

		String style = container.getStyle();
		String variation = container.getVariation();
		Locale locale = container.getLocale();
en_US
		MarkupType markupType = container.getMarkupType();
MarkupType [extension=html, mimeType=text/html]
		String ext = (markupType != null ? markupType.getExtension() : null);
html
		// Markup is associated with the containers class. Walk up the class
		// hierarchy up to MarkupContainer to find the containers markup
		// resource.
		while (containerClass != MarkupContainer.class)
		{
			String path = containerClass.getName().replace('.', '/'); 
/ org/apache/wicket/examples/repeater/ChildInWebMarkupContainerPage
			IResourceStream resourceStream = locator.locate(containerClass, path, style, variation, locale, ext, false);
/s
CachingResourceStreamLocator.locate(Class<?>, String, String, String, Locale, String, boolean) line: 128	
		CacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation, strict);
		IResourceStreamReference resourceStreamReference = cache.get(key);
null
		final IResourceStream result;
		if (resourceStreamReference == null)
		{
			result = delegate.locate(scope, path, style, variation, locale, extension, strict);
/s
ResourceStreamLocator.locate(Class<?>, String, String, String, Locale, String, boolean) line: 149	
		// If path contains a locale, then it'll replace the locale provided to this method
		PathLocale data = ResourceUtils.getLocaleFromFilename(path);
		if ((data != null) && (data.locale != null))
/n
		// Try the various combinations of style, locale and extension to find the resource.
		IResourceNameIterator iter = newResourceNameIterator(path, locale, style, variation,
			extension, strict);
		while (iter.hasNext())
		{
			String newPath = iter.next();
org/apache/wicket/examples/repeater/ChildInWebMarkupContainerPage_en_US.html
			IResourceStream stream = locate(clazz, newPath);
/s
ResourceStreamLocator.locate(Class<?>, String) line: 126	
		if (finders == null)
		{
			finders = Application.get().getResourceSettings().getResourceFinders();
this	ResourceStreamLocator  (id=717)	
	finders	ArrayList<E>  (id=722)	
		elementData	Object[10]  (id=820)	
			[0]	ClassPathResourceFinder  (id=823)	
				prefix	"" (id=854)	
			[1]	WebApplicationPath  (id=824)	
				path	"/" (id=861)	
				servletContext	ApplicationContextFacade  (id=862)	
			[2]	ClassPathResourceFinder  (id=825)	
				prefix	"META-INF/resources/" (id=882)	
		size	3	
/=
[[classpath], [webapppath: /], [classpath: META-INF/resources/]]

		IResourceStream result;
		for (IResourceFinder finder : finders)
		{
			result = finder.find(clazz, path);
/t
ResourceStreamLocator.locate(Class<?>, String, String, String, Locale, String, boolean) line: 163	
		while (iter.hasNext())
		{
			String newPath = iter.next();
org/apache/wicket/examples/repeater/ChildInWebMarkupContainerPage_en_US.html
			IResourceStream stream = locate(clazz, newPath);
/d
null
/ volgend	,
		while (iter.hasNext())
		{
			String newPath = iter.next();
org/apache/wicket/examples/repeater/ChildInWebMarkupContainerPage_en.html
			IResourceStream stream = locate(clazz, newPath);
null
/ volgende	, 
		while (iter.hasNext())
		{
			String newPath = iter.next();
org/apache/wicket/examples/repeater/ChildInWebMarkupContainerPage.html
			IResourceStream stream = locate(clazz, newPath);
stream	UrlResourceStream  (id=2563)	
	url	URL  (id=744)	
file:/home/eric/Devel/Java/Tomcat/apache-tomcat-8.0.28/webapps/wicket-examples-step-by-step/WEB-INF/classes/org/apache/wicket/examples/repeater/ChildInWebMarkupContainerPage.html

				return stream;
...
/t
ChildInWebMarkupContainerPage(Component).internalRender() line: 2380	
		IMarkupFragment markup = getMarkup();
/d
markup	Markup  (id=408)	
	markupResourceStream	MarkupResourceStream  (id=429)	
	markupElements	Collections$UnmodifiableRandomAccessList<E>  (id=427)	
		c	ArrayList<E>  (id=2618)	
		list	ArrayList<E>  (id=2618)	
			elementData	Object[15]  (id=2619)	
				[0]	RawMarkup  (id=2617)	
					string	"<!doctype html>\n<html>\n" (id=2633)	
				[1]	ComponentTag  (id=2620)	
					behaviors	null	
					id	"_header_" (id=2635)	
					xmlTag	XmlTag  (id=2636)	<head>
				[2]	RawMarkup  (id=2621)	
					string	"\n\n" (id=2647)	
				[3]	ComponentTag  (id=2622)	
					behaviors	null	
					id	null	
					xmlTag	XmlTag  (id=2646) 	</head>			/ closing tags hebben id null	,
				[4]	RawMarkup  (id=2623)	
					string	"\n<body>\n\t" (id=2645)	
				[5]	ComponentTag  (id=562)	
					behaviors	null	
					id	"container" (id=2643)	
					xmlTag	XmlTag  (id=2644)	<div wicket:id="container">	
				[6]	RawMarkup  (id=525)	
					string	"\n\t\t" (id=2642)	
				[7]	ComponentTag  (id=2627)	
					behaviors	null	
					id	"labelincontainer" (id=545)	
					xmlTag	XmlTag  (id=2641) 	<span wicket:id="labelincontainer">	
				[8]	RawMarkup  (id=2628)	
					string	"\n\t\t" (id=2640)	
				[9]	ComponentTag  (id=2629)	
					behaviors	null	
					id	null	
					xmlTag	XmlTag  (id=2639)	</span>	
				[10]	RawMarkup  (id=2630)	
					string	"\n\t" (id=2638)	
				[11]	ComponentTag  (id=2631)	
					behaviors	null	
					id	null	
					xmlTag	XmlTag  (id=2652)	</div>	
				[12]	RawMarkup  (id=2632)	
					string	"\n\n\n</body>\n</html>" (id=2637)	
			size	13	

		// MarkupStream is an Iterator for the markup
		MarkupStream markupStream = new MarkupStream(markup);
markupStream	MarkupStream  (id=2626) 									/ iterator over de markup	, houdt ook currentIndex bij	,	
	current	RawMarkup  (id=2617)	
	currentIndex	0	
	markup	Markup  (id=408)		/ see hierboven	,
...
/s
ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
		while (markupStream.hasMore())
		{
			// Remember where we are
			final int index = markupStream.getCurrentIndex();	

			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);

			if (rawMarkup)
			{
				markupStream.next();	/ raises markupStream.currentIndex	, = 1 nu	, en sets current	,
/s
public class MarkupStream
	public MarkupElement next()
	{
		if (++currentIndex < markup.size())
		{
			return current = get(currentIndex);
		}
/t
ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
/ volgende	,
		while (markupStream.hasMore())
			// Remember where we are
			final int index = markupStream.getCurrentIndex();	/ 1

			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/s
ChildInWebMarkupContainerPage(MarkupContainer).renderNext(MarkupStream) line: 1498	
		// Get the current markup element
		final MarkupElement element = markupStream.get();
<head>
/t
ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
		while (markupStream.hasMore())
		{
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
1
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/d
			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);

			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
/ volgende	,
		while (markupStream.hasMore())
			// Remember where we are
			final int index = markupStream.getCurrentIndex();	
4																		/ dit is na </head>
			if (rawMarkup)
/j
			{
				markupStream.next();
/ volgende	,
		while (markupStream.hasMore())
		{
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
5
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/s
ChildInWebMarkupContainerPage(MarkupContainer).renderNext(MarkupStream) line: 1495	
		final MarkupElement element = markupStream.get();
<div wicket:id="container">

			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id);
[WebMarkupContainer [Component id = container]]

				component.render();
/s
			internalRender();
/s
WebMarkupContainer(Component).internalRender() line: 2345	
markup	MarkupFragment  (id=2778)	
	markup	Markup  (id=408)	
	size	7	
	startIndex	5	
/ want	, 
/s
WebMarkupContainer(Component).getMarkup() line: 755	
		// Ask the parent for find the markup for me
		markup = parent.getMarkup(this);								/ dit gebeurt dus altijd	, maar als parent='n repeater, 
																	
/ Intermezzo 

public abstract class AbstractRepeater extends WebMarkupContainer
	@Override
	public IMarkupFragment getMarkup(final Component child)
	{
		// each direct child gets the markup of this repeater
		return getMarkup();
	}

/ Dus een repeater geeft z'n eigen markup aan de child	, 																		

/ Einde Intermezzo 
/s
ChildInWebMarkupContainerPage(MarkupContainer).getMarkup(Component) line: 502	
		// Delegate request to attached markup sourcing strategy.
		return getMarkupSourcingStrategy().getMarkup(this, child);
/s
DefaultMarkupSourcingStrategy.getMarkup(MarkupContainer, Component) line: 81	
		// If the sourcing strategy did not provide one, than ask the component.
		// Get the markup for the container
		IMarkupFragment containerMarkup = container.getMarkup();	 / containerMarkup= de page	,
containerMarkup	Markup  (id=408)		/ de markup, NIET de iterator	 (met currentIndex)	,

		IMarkupFragment childMarkup = containerMarkup.find(child.getId());	/ child [WebMarkupContainer [Component id = container]]	, container= de page	,
/s
Markup.find(String) line: 210	
		return find(id, 0);	/ zoek vanaf begin	,	 TODO we waren toch gebleven bij index 5	?
/s
Markup(AbstractMarkupFragment).find(String, int) line: 55 	/ gaat zoeken in de 
/=
	protected final IMarkupFragment find(final String id, int streamOffset)
/ id="container"
		MarkupStream stream = new MarkupStream(this);	 / een nieuwe iterator	, this is Markup	,  
		stream.setCurrentIndex(streamOffset);
		while (stream.hasMore())
		{
			MarkupElement elem = stream.get();
			if (elem instanceof ComponentTag)
			{
				ComponentTag tag = stream.getTag();
				if (tag.isOpen() || tag.isOpenClose())
				{
					if (canFind && tag.getId().equals(id))		/ zoek op id	,
/j
stream	MarkupStream  (id=2806)	
	current	ComponentTag  (id=562)	<div wicket:id="container">
	currentIndex	5	
	markup	Markup  (id=408)	

						return stream.getMarkupFragment();
/s
MarkupFragment.<init>(IMarkupFragment, int) line: 61	
/=
	public MarkupFragment(final IMarkupFragment markup, final int startIndex)
		this.markup = markup;
		this.startIndex = startIndex;
5
		MarkupElement startElem = markup.get(startIndex);
<div wicket:id="container">
		else
		{
			for (endIndex = startIndex + 1; endIndex < markupSize; endIndex++)
			{
				MarkupElement elem = markup.get(endIndex);
endIndex=6
/ elem=raw markup	, 
/ volgende,	
			for (endIndex = startIndex + 1; endIndex < markupSize; endIndex++)
			{
				MarkupElement elem = markup.get(endIndex);
endIndex=7
elem=<span wicket:id="labelincontainer">
				if (elem instanceof ComponentTag)
				{
					ComponentTag tag = (ComponentTag)elem;
					if (tag.closes(startTag))
/n
/ volgende	,
			for (endIndex = startIndex + 1; endIndex < markupSize; endIndex++)
			{
				MarkupElement elem = markup.get(endIndex);
/n
/ elem=raw markup	,
/ volgende,	
			for (endIndex = startIndex + 1; endIndex < markupSize; endIndex++)
			{
				MarkupElement elem = markup.get(endIndex);
endIndex=9
elem=</span>
				if (elem instanceof ComponentTag)
				{
					ComponentTag tag = (ComponentTag)elem;
					if (tag.closes(startTag))
/n
/ elem=raw markup	,
/ volgende,	
			for (endIndex = startIndex + 1; endIndex < markupSize; endIndex++)
			{
				MarkupElement elem = markup.get(endIndex);
endIndex=9
elem=</span>
				if (elem instanceof ComponentTag)
				{
					ComponentTag tag = (ComponentTag)elem;
</div>
					if (tag.closes(startTag))	/ startTag=<div wicket:id="container">
/j
						break;
		size = endIndex - startIndex + 1;
7
/t
WebMarkupContainer(Component).getMarkup() line: 756	
		// Ask the parent for find the markup for me
		markup = parent.getMarkup(this);
/d
this	WebMarkupContainer  (id=2772)	
	markup	MarkupFragment  (id=2832)	
		markup	Markup  (id=408)	
		size	7	
		startIndex	5	

		return markup;
/t
WebMarkupContainer(Component).internalRender() line: 2346	
		IMarkupFragment markup = getMarkup();
/d
markup	MarkupFragment  (id=2832)	
	markup	Markup  (id=408)	
	size	7	
	startIndex	5	

		// MarkupStream is an Iterator for the markup
		MarkupStream markupStream = new MarkupStream(markup);	/ iterator op deze markup fragment	, 
				onRender();
/s
WebMarkupContainer(MarkupContainer).onRender() line: 1698	
		internalRenderComponent();
/s
WebMarkupContainer(Component).internalRenderComponent() line: 2508	
		final IMarkupFragment markup = getMarkup();	/ hebben we al	,

		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();

		// Call any tag handler
		onComponentTag(tag);
				renderComponentTag(tag);

			markupStream.next();
markupStream	MarkupStream  (id=2927)	
	current	RawMarkup  (id=525)	
	currentIndex	1	
	markup	MarkupFragment  (id=2832)	

			// Render the body only if open-body-close. Do not render if open-close.
			if (tag.isOpen())
			{
				// Render the body. The default strategy will simply call the component's
				// onComponentTagBody() implementation.
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/s
DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
		component.onComponentTagBody(markupStream, openTag);
/ component=WebMarkupContainer	, 
/ markupStream.currentIndex=1	, want de tag zelf (index 0) is al rendered	,
/s
WebMarkupContainer(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
		renderComponentTagBody(markupStream, openTag);
/s
WebMarkupContainer(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
			renderAll(markupStream, openTag);
/s
WebMarkupContainer(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1750	
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
1
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
true
			if (rawMarkup)
			{
				markupStream.next();
markupStream	MarkupStream  (id=2927)	
	current	ComponentTag  (id=2627)		<span wicket:id="labelincontainer">
	currentIndex	2	
	markup	MarkupFragment  (id=2832)	

/ volgende,	
		while (markupStream.hasMore())
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
2
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/s
WebMarkupContainer(MarkupContainer).renderNext(MarkupStream) line: 1495	
		final MarkupElement element = markupStream.get();

this	WebMarkupContainer  (id=2772)	
element	ComponentTag  (id=2627)		<span wicket:id="labelincontainer">

		// If it's a tag like <wicket..> or <span wicket:id="..." >
		if ((element instanceof ComponentTag) && !markupStream.atCloseTag())
		{
			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id); 										/ component	Label  (id=2775)	

				component.render();
/s
Label(Component).internalRender() line: 2345	
		IMarkupFragment markup = getMarkup();
/s
Label(Component).getMarkup() line: 734	
		if (markup != null)
/n
		// Ask the parent for find the markup for me
		markup = parent.getMarkup(this);
/s
WebMarkupContainer(MarkupContainer).getMarkup(Component) line: 502	
		return getMarkupSourcingStrategy().getMarkup(this, child);
/s
DefaultMarkupSourcingStrategy.getMarkup(MarkupContainer, Component) line: 81	
		IMarkupFragment containerMarkup = container.getMarkup();
containerMarkup	MarkupFragment  (id=2832)	
	markup	Markup  (id=408)	
	size	7	
	startIndex	5	
/=
<div wicket:id="container">
		<span wicket:id="labelincontainer">
		</span>
</div>

		// Find the child's markup
		IMarkupFragment childMarkup = containerMarkup.find(child.getId());
/s
MarkupFragment.find(String) line: 154		/ Dit is dus NIET zoals net Markup.find	,	die op index 0 begon	,
		return find(id, 1);
id="labelincontainer"
/s
MarkupFragment(AbstractMarkupFragment).find(String, int) line: 43	

		MarkupStream stream = new MarkupStream(this);
		stream.setCurrentIndex(streamOffset);
1
		while (stream.hasMore())
		{
			MarkupElement elem = stream.get();

			if (elem instanceof ComponentTag)
			{
				ComponentTag tag = stream.getTag();

				if (tag.isOpen() || tag.isOpenClose())
				{
					if (canFind && tag.getId().equals(id))
					{
						return stream.getMarkupFragment();
/t
Label(Component).getMarkup() line: 756	
		markup = parent.getMarkup(this);
/d
this	Label  (id=2775)	
	markup	MarkupFragment  (id=2999)	
		markup	MarkupFragment  (id=2832)	
			markup	Markup  (id=408)	
			size	7	
			startIndex	5	
		size	3	
		startIndex	2	


		return markup;
/t
Label(Component).internalRender() line: 2346	
		IMarkupFragment markup = getMarkup();
/d
		MarkupStream markupStream = new MarkupStream(markup);
markupStream	MarkupStream  (id=3043)	
	current	ComponentTag  (id=2627)	
	currentIndex	0	
	markup	MarkupFragment  (id=2999)	
		markup	MarkupFragment  (id=2832)	
		size	3	
		startIndex	2	
/=
<span wicket:id="labelincontainer">
		</span>, index = 0, current =  '<span wicket:id="labelincontainer">' (line 0, column 0)]

				onRender();
/s
Label(WebComponent).onRender() line: 60	
		internalRenderComponent();
/s
Label(Component).internalRenderComponent() line: 2508	
		final IMarkupFragment markup = getMarkup();
/ is er al	,
		final MarkupStream markupStream = new MarkupStream(markup);
		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();
		// Call any tag handler
		onComponentTag(tag);
				renderComponentTag(tag);

			markupStream.next();
markupStream	MarkupStream  (id=3033)	
	current	RawMarkup  (id=2628)	
	currentIndex	1	
	markup	MarkupFragment  (id=2999)	
/=
/ raw markup ONDER <span wicket:id="labelincontainer">	, 

				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/s
DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
		component.onComponentTagBody(markupStream, openTag);
/s
Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
		replaceComponentTagBody(markupStream, openTag, getDefaultModelObjectAsString());
/s
Label(Component).replaceComponentTagBody(MarkupStream, ComponentTag, CharSequence) line: 4054	


/ MORGENOCHTEND
Daemon Thread [http-nio-9090-exec-123] (Suspended)	
	owns: NioChannel  (id=244)	
	Label(Component).replaceComponentTagBody(MarkupStream, ComponentTag, CharSequence) line: 4061	
	Label.onComponentTagBody(MarkupStream, ComponentTag) line: 115	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	Label(Component).internalRenderComponent() line: 2565	
	Label(WebComponent).onRender() line: 60	
	Label(Component).internalRender() line: 2380	
	Label(Component).render() line: 2308	
	WebMarkupContainer(MarkupContainer).renderNext(MarkupStream) line: 1524	
	WebMarkupContainer(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	WebMarkupContainer(MarkupContainer).renderComponentTagBody(MarkupStream, ComponentTag) line: 1734	
	WebMarkupContainer(MarkupContainer).onComponentTagBody(MarkupStream, ComponentTag) line: 1657	
	DefaultMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 70	
	WebMarkupContainer(Component).internalRenderComponent() line: 2565	
	WebMarkupContainer(MarkupContainer).onRender() line: 1698	
	WebMarkupContainer(Component).internalRender() line: 2380	
	WebMarkupContainer(Component).render() line: 2308	
	ChildInWebMarkupContainerPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
	ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	ChildInWebMarkupContainerPage(Page).onRender() line: 879	
	ChildInWebMarkupContainerPage(WebPage).onRender() line: 141	
	ChildInWebMarkupContainerPage(Component).internalRender() line: 2380	
	ChildInWebMarkupContainerPage(Component).render() line: 2308	
	ChildInWebMarkupContainerPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	


/ Einde DEBUG WEBMARKUPCONTAINER

/ RENDERING RENDERALL RENDERNEXT

/ 7	.

/ MarkupContainer.renderAll: loops over markup: markupStream heeft currentIndex, current (tag)
/ MarkupContainer.renderNext : finds Component opg wicket:id in de tag	, en calls Component.internalRender	, deze maakt eigen markupStream op de markup van de Component	,

/ In MarkupContainer.renderAll wordt currentIndex bijgehouden, na renderNext wordt markupStream.next() of markupStream.skipComponent() gedaan	, 
/ Component.internalRender heeft EIGEN markupStream op de markup van de Component waarmee wordt rendered	,  

/ HtmlHeaderContainer heeft eigen getMarkup()	,


/ 7	. 

/ RENDERALL MARKUP GLOBALLY NOT IN RENDERING

/ we kunnen zien wat rendered is in Expressions	,
/ bijv na de 1ste raw markup	,
"getRequestCycle()"	 (pending)	
	activeResponse	BufferedWebResponse  (id=220)	
		charSequenceAction	BufferedWebResponse$WriteCharSequenceAction  (id=346)	
			builder	StringBuilder  (id=349)	
<!doctype html>
<html>

$ vi Component.java
Component.class
	public final RequestCycle getRequestCycle()
	{
		return RequestCycle.get();
	}

package org.apache.wicket.request.cycle;
public class RequestCycle implements IRequestCycle, IEventSink
	public static RequestCycle get()
	{
		return ThreadContext.getRequestCycle();
	}

/ In Expressions kunnen we , 
getRequestCycle()
ThreadContext.getRequestCycle()
org.apache.wicket.request.cycle.RequestCycle.get()

/ 7	. 

/c
/ stack
/s
	ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	ChildInWebMarkupContainerPage(Page).onRender() line: 879	
	ChildInWebMarkupContainerPage(WebPage).onRender() line: 141	
	ChildInWebMarkupContainerPage(Component).internalRender() line: 2380	
	ChildInWebMarkupContainerPage(Component).render() line: 2308	
	ChildInWebMarkupContainerPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	
/ debug	,
ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	

markupStream	MarkupStream  (id=218)	
	current 	RawMarkup	
	currentIndex	0	
	markup	Markup  (id=122)	

		while (markupStream.hasMore())
		{
			// Remember where we are
			final int index = markupStream.getCurrentIndex();	
0
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);

"ThreadContext.g...tRequestCycle()"	 (pending)	
	activeResponse	BufferedWebResponse  (id=220)	
		charSequenceAction	BufferedWebResponse$WriteCharSequenceAction  (id=346)	
			builder	StringBuilder  (id=349)	
<!doctype html>
<html>

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);

			if (rawMarkup)
			{
				markupStream.next();

markupStream	MarkupStream  (id=218)	
	current	ComponentTag  (id=154)		<head>
	currentIndex	1	
	markup	Markup  (id=122)	

			}
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
			}

/ volgende,	

		while (markupStream.hasMore())
		{
			// In case of Page we need to render the whole file. For all other components just what
			// is in between the open and the close tag.
			if ((openTag != null) && markupStream.get().closes(openTag))
			{
				break;
			}

markupStream	MarkupStream  (id=218)	
	current	ComponentTag  (id=154)			<head>
	currentIndex	1	
	markup	Markup  (id=122)	

			// Remember where we are
			final int index = markupStream.getCurrentIndex();

			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);

"ThreadContext.g...tRequestCycle()"	 (pending)	
	activeResponse	BufferedWebResponse  (id=220)	
		charSequenceAction	BufferedWebResponse$WriteCharSequenceAction  (id=346)	
			builder	StringBuilder  (id=349)	
<!doctype html>
<html>
<head>
</head>

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);

			if (rawMarkup)
/n
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
/s
MarkupStream.skipComponent() line: 346	

/ Intermezzo

public class MarkupStream
	public ComponentTag getTag()
	{
		if (current instanceof ComponentTag)
		{
			return (ComponentTag)current;
		}
	}
	public boolean hasMore()
	{
		return currentIndex < markup.size();
	}
	public MarkupElement next()
	{
		if (++currentIndex < markup.size())
		{
			return current = get(currentIndex);
		}
	}

/ Einde Intermezzo

		// Get start tag
		final ComponentTag startTag = getTag();
/= current = <head>
				// Skip <tag>
				next();

this	MarkupStream  (id=218)	
	current	RawMarkup  (id=155)	
	currentIndex	2	
	markup	Markup  (id=122)	

				// Skip nested components
				skipToMatchingCloseTag(startTag);
/s
MarkupStream.skipToMatchingCloseTag(ComponentTag) line: 465	
		// Loop through the markup in this container
		while (hasMore())
		{
			// If the current markup tag closes the openTag
			if (get().closes(openTag))
/n
			next();

this	MarkupStream  (id=218)	
	currentIndex	3	

/ volgende,	
		// Loop through the markup in this container
		while (hasMore())
		{
			// If the current markup tag closes the openTag
			if (get().closes(openTag))
/j
				return;
/t
MarkupStream.skipComponent() line: 362	
				// Skip nested components
				skipToMatchingCloseTag(startTag);
			}

			// Skip </tag>
			next();
this	MarkupStream  (id=218)	
	current	RawMarkup  (id=157)	
	currentIndex	4	
/t
ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1771	
		while (markupStream.hasMore())
		{
			// Remember where we are
			final int index = markupStream.getCurrentIndex();

			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);

			if (rawMarkup)
			{
				markupStream.next();
			}
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
/d
markupStream	MarkupStream  (id=218)	
	current	RawMarkup  (id=157)	
	currentIndex	4	
	markup	Markup  (id=122)	

/ 7	. 

/ RENDERNEXT FINDS MARKUP HEADER

/ finds markup	,

ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
		while (markupStream.hasMore())
		{
			// In case of Page we need to render the whole file. For all other components just what
			// is in between the open and the close tag.
			if ((openTag != null) && markupStream.get().closes(openTag))
			{
				break;
			}

			// Remember where we are
			final int index = markupStream.getCurrentIndex();
1

			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);
/s
ChildInWebMarkupContainerPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
		// Get the current markup element
		final MarkupElement element = markupStream.get();
CompnentTag <head>
			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id);
component	HtmlHeaderContainer  (id=543)	

				component.render();
/s
HtmlHeaderContainer(Component).render() line: 2308	
			internalRender();
/s
HtmlHeaderContainer(Component).internalRender() line: 2345	
		IMarkupFragment markup = getMarkup();
/s
HtmlHeaderContainer.getMarkup() line: 390	
		// Get the page markup
		IMarkupFragment markup = getPage().getMarkup();

		// Find the markup fragment
		MarkupStream stream = new MarkupStream(markup);	/ zet er een stream op	,

		IMarkupFragment headerMarkup = null;
		while (stream.skipUntil(ComponentTag.class))	/ de 1ste ComponentTag is <head>
1
			ComponentTag tag = stream.getTag();
			if (tag.isOpen() || tag.isOpenClose()) {
				if (tag instanceof WicketTag)			/ <head> is geen WicketTag	, bijv <wicket:panel>
/n
				else if (tag.getName().equalsIgnoreCase("head") && tag.isAutoComponentTag())
/j
				{
					headerMarkup = stream.getMarkupFragment();
/s
MarkupStream.getMarkupFragment() line: 485	
		return new MarkupFragment(markup, currentIndex);
/ markup= page markup	, 
/ currentIndex=1
/s
MarkupFragment.<init>(IMarkupFragment, int) line: 61	
		this.markup = markup;
		this.startIndex = startIndex;
		else
		{
			for (endIndex = startIndex + 1; endIndex < markupSize; endIndex++)
			{
				MarkupElement elem = markup.get(endIndex);
				if (elem instanceof ComponentTag)
				{
					ComponentTag tag = (ComponentTag)elem;
					if (tag.closes(startTag))
					{
						break;	
endIndex=3
		size = endIndex - startIndex + 1;
/t
HtmlHeaderContainer.getMarkup() line: 391	
					headerMarkup = stream.getMarkupFragment();
headerMarkup	MarkupFragment  (id=574)	
	markup	Markup  (id=122)	
	size	3	
	startIndex	1	

					break;
		setMarkup(headerMarkup);



/ Einde RENDERING RENDERALL RENDERNEXT

/ WEBMARKUPCONTAINER AND TAG

/ workspace-wicket7_8
/ proj wicket-examples-step-by-step
/ package org.apache.wicket.examples.repeater;
public class ChildInWebMarkupContainerPage extends WebPage{

/ debug	,
/s

ChildInWebMarkupContainerPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
/=
	protected final void renderAll(final MarkupStream markupStream, final ComponentTag openTag)
	{
		while (markupStream.hasMore())
		{
			// Remember where we are
			final int index = markupStream.getCurrentIndex();
0,1,4,nu = 5
			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);

			if (rawMarkup)
			{
				markupStream.next();
			}
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
			}
			else
			{
				throw new WicketRuntimeException("Ups. This should never happen. " +
					markupStream.toString());
			}

/ we step hier eerst een paar keer door heen	,
/ eerst RawMarkup , dan <head>, dan RawMarkup	,
/ indez=0,1,4, nu=5	,

/s
ChildInWebMarkupContainerPage(MarkupContainer).renderNext(MarkupStream) line: 1498	
		final MarkupElement element = markupStream.get();
<div wicket:id="container">												/ Als hier <span ...> had gestaan, ook OK	,
			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();		/ "container"

			// Get the component for the id from the given container
			Component component = get(id);
[WebMarkupContainer [Component id = container]]

				component.render();
/s
WebMarkupContainer(Component).internalRender() line: 2345	

/ de Component heeft markup=null	, z'n parent, de page heeft markup	, de hele page	, 
/ In renderAll is er een markupStream met currentIndex=5 , en die wordt ook aan renderNext gegeven om de Component te bepalen opg wicket:id	, 

		IMarkupFragment markup = getMarkup();
/s
WebMarkupContainer(Component).getMarkup() line: 755	
		if (markup != null)
/n
		// Ask the parent for find the markup for me
		markup = parent.getMarkup(this);
/s
ChildInWebMarkupContainerPage(MarkupContainer).getMarkup(Component) line: 502	
		return getMarkupSourcingStrategy().getMarkup(this, child);
/s
DefaultMarkupSourcingStrategy.getMarkup(MarkupContainer, Component) line: 81	
		IMarkupFragment containerMarkup = container.getMarkup();			/ container=page	,
		// Find the child's markup
		IMarkupFragment childMarkup = containerMarkup.find(child.getId());	/ sets een stream op de markup, en returns a MarkupFragment	,
/s
Markup(AbstractMarkupFragment).find(String, int) line: 43	
/=
	protected final IMarkupFragment find(final String id, int streamOffset)
id	"container" (id=632)	
streamOffset	0	

		MarkupStream stream = new MarkupStream(this);
		stream.setCurrentIndex(streamOffset);
		while (stream.hasMore())
			MarkupElement elem = stream.get();
RawMarkup
			if (elem instanceof ComponentTag)
/n
			stream.next();
/ volgende	,
			MarkupElement elem = stream.get();
			if (elem instanceof ComponentTag)
			{
				ComponentTag tag = stream.getTag();
<head>
				if (tag.isOpen() || tag.isOpenClose())
				{
					if (canFind && tag.getId().equals(id))
/n
			stream.next();
/ volgende	,
			MarkupElement elem = stream.get();
RawMarkup
			if (elem instanceof ComponentTag)
/n
			stream.next();
/ volgende	,
			MarkupElement elem = stream.get();
			if (elem instanceof ComponentTag)
			{
				ComponentTag tag = stream.getTag();
</head>
				if (tag.isOpen() || tag.isOpenClose())
/n
/ TODO
			stream.next();
/ volgende	,
			MarkupElement elem = stream.get();
RawMarkup
			if (elem instanceof ComponentTag)
/n
			stream.next();
/ volgende	,
			MarkupElement elem = stream.get();
			if (elem instanceof ComponentTag)
			{
				ComponentTag tag = stream.getTag();
<div wicket:id="container">
				if (tag.isOpen() || tag.isOpenClose())
					if (canFind && tag.getId().equals(id))
					{
						return stream.getMarkupFragment();
stream	MarkupStream  (id=687)	
	current	ComponentTag  (id=158)	
	currentIndex	5	
	markup	Markup  (id=122)	
/s
MarkupStream.getMarkupFragment() line: 485	
		return new MarkupFragment(markup, currentIndex);
/s
MarkupFragment.<init>(IMarkupFragment, int) line: 61	
/=
	public MarkupFragment(final IMarkupFragment markup, final int startIndex)
/ markup= page markup	,
		this.markup = markup;
		this.startIndex = startIndex;
5
		MarkupElement startElem = markup.get(startIndex);
<div wicket:id="container">
		else
		{
			for (endIndex = startIndex + 1; endIndex < markupSize; endIndex++)
			{
				MarkupElement elem = markup.get(endIndex);
				if (elem instanceof ComponentTag)
				{
					ComponentTag tag = (ComponentTag)elem;
					if (tag.closes(startTag))
					{
						break;
/ endIndex=11
		size = endIndex - startIndex + 1;
/t
WebMarkupContainer(Component).getMarkup() line: 756	
		markup = parent.getMarkup(this);
/d
this	WebMarkupContainer  (id=621)	
	markup	MarkupFragment  (id=697)	
		markup	Markup  (id=122)	
		size	7	
		startIndex	5	

		return markup;
/t
WebMarkupContainer(Component).internalRender() line: 2346	
		IMarkupFragment markup = getMarkup();
/d
				onRender();
/s
WebMarkupContainer(MarkupContainer).onRender() line: 1698	
		internalRenderComponent();
/s
WebMarkupContainer(Component).internalRenderComponent() line: 2508	
		final IMarkupFragment markup = getMarkup();
/ is er al	,
		final MarkupStream markupStream = new MarkupStream(markup);
/ set er een stream op deze markup fragment van container

		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();

		// Call any tag handler
		onComponentTag(tag);
				renderComponentTag(tag);
/s
			// Write the tag
			tag.writeOutput(getResponse(), !needToRenderTag(null),
				getMarkup().getMarkupResourceStream().getWicketNamespace());
/t
WebMarkupContainer(Component).internalRenderComponent() line: 2508	
				renderComponentTag(tag);
/d
"ThreadContext.g...tRequestCycle()"	 (pending)	
	activeResponse	BufferedWebResponse  (id=723)	
		charSequenceAction	BufferedWebResponse$WriteCharSequenceAction  (id=731)	
			builder	StringBuilder  (id=732)	
<!doctype html>
<html>
<head>

</head>
<body>
	<div wicket:id="container">	 / de tag staat er	, had ook een <span ...> kunnen zijn	,

			markupStream.next();
				// Render the body. The default strategy will simply call the component's
				// onComponentTagBody() implementation.
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);

markupStream	MarkupStream  (id=720)	
	current	RawMarkup  (id=159)	
	currentIndex	1	
	markup	MarkupFragment  (id=697)	
/ de stream op de markup fragment van de container wordt doorgegeven	,


/ Einde WEBMARKUPCONTAINER AND TAG

/ WEBMARKUPCONTAINER IN OWN FILE AND TAG

/ In ChildInWebMarkupContainerPage doen we 
			WebMarkupContainer container=new WebMarkupContainer("container");
/ In ChildInWebMarkupContainer1Page maken we een nested class ChildContainingContainerNested extends WebMarkupContainer ,
/ In ChildInWebMarkupContainer1aPage maken we een inner class ChildContainingContainerInner extends WebMarkupContainer	,
/ In ChildInWebMarkupContainer2Page doen we 	,
		WebMarkupContainer container=new ChildContainingContainer("container");
/ en we hebben een 	 ChildContainingContainer.java	

 



/ Einde WEBMARKUPCONTAINER IN OWN FILE AND TAG

/ PANEL AND TAG

/ workspace-wicket7_8
/ proj wicket-examples-step-by-step
/ package org.apache.wicket.examples.repeater;
public class ChildInPanelPage extends WebPage{

/ er zijn ChildInPanelPage	,   ChildContainingPanel.java	,

/ geef	,
http://localhost:9090/wicket-examples-step-by-step/repeater/childinpanel

/ Onthoud: loop eerst een aantal keer MarkupContainer.renderAll door (this=page) , totdat bij Panel (of zonet WebMarkupContainer)	,

/s
ChildInPanelPage(Component).internalRender() line: 2380		/ this=page
		IMarkupFragment markup = getMarkup();
this	ChildInPanelPage  (id=781)	
	markup	Markup  (id=790)	

				onRender();
/s
ChildInPanelPage(Page).onRender() line: 879	
		// Loop through the markup in this container
		MarkupStream markupStream = new MarkupStream(getMarkup());
		renderAll(markupStream, null);
/s
ChildInPanelPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1746	
		while (markupStream.hasMore())
		{
			// In case of Page we need to render the whole file. For all other components just what
			// is in between the open and the close tag.
			if ((openTag != null) && markupStream.get().closes(openTag))
			{
				break;
			}

			// Remember where we are
			final int index = markupStream.getCurrentIndex();

			// Render the markup element
			boolean rawMarkup = renderNext(markupStream);

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);

			if (rawMarkup)
			{
				markupStream.next();
			}
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
			}
/ loop er een paar keer doorheen	,
/ todat index=5	, 
/s
ChildInPanelPage(MarkupContainer).renderNext(MarkupStream) line: 1495	
this	ChildInPanelPage  (id=781)	

		final MarkupElement element = markupStream.get();
<div wicket:id="panel">

markupStream	MarkupStream  (id=787)	
	current	ComponentTag  (id=807)	
	currentIndex	5	
	markup	Markup  (id=790)	/ page markup	,

			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id);
[ChildContainingPanel [Component id = panel]]

				component.render();
component	ChildContainingPanel  (id=819)	
/s
ChildContainingPanel(Component).internalRender() line: 2345	
		IMarkupFragment markup = getMarkup();					/= <div wicket:id="panel"></div> uit de page markup	, NIET de markup in de panel's HTML	,
/s
ChildContainingPanel(Component).getMarkup() line: 755	/ als we getMarkup(null), dan ChildContainingPanel(MarkupContainer).getMarkup(Component) 
						/ getMarkup() geeft markup in page HTML	, dus <div wicket:id="panel"></div>	, en getMarkup(null) geeft de panel's HTML	,
	
		if (markup != null)
/n
		markup = parent.getMarkup(this);
/s
ChildInPanelPage(MarkupContainer).getMarkup(Component) line: 502	
		return getMarkupSourcingStrategy().getMarkup(this, child);	/ this = page	, child = panel
/s
DefaultMarkupSourcingStrategy.getMarkup(MarkupContainer, Component) line: 81	
		IMarkupFragment containerMarkup = container.getMarkup();	/ markup van de page	,
		// Find the child's markup
		IMarkupFragment childMarkup = containerMarkup.find(child.getId());
/s
Markup.find(String) line: 210	
		return find(id, 0);									/ id="panel"
/s
Markup(AbstractMarkupFragment).find(String, int) line: 63	

		MarkupStream stream = new MarkupStream(this);
		stream.setCurrentIndex(streamOffset);		0
		while (stream.hasMore())
		{
			MarkupElement elem = stream.get();

			if (elem instanceof ComponentTag)
			{
				ComponentTag tag = stream.getTag();

				if (tag.isOpen() || tag.isOpenClose())
				{
					if (canFind && tag.getId().equals(id))
					{
						return stream.getMarkupFragment();
				else if (tag.isClose())
					...
			stream.next();									/ deze verhoogt de stream's currentIndex	,
/ aantal while loops: raw input, <head>, </head>
/ totdat <div wicket:id="panel">	,  
/s
MarkupStream.getMarkupFragment() line: 485	
		return new MarkupFragment(markup, currentIndex);
/t
ChildContainingPanel(Component).internalRender() line: 2346	
		IMarkupFragment markup = getMarkup();
/d
markup	MarkupFragment  (id=857)	
	markup	Markup  (id=790)	
	size	3	
	startIndex	5	
/=
<div wicket:id="panel"></div>					/ is dus de markup in de page's HTML, is NIET de panel's markup in de 

				onRender();
/s
ChildContainingPanel(Component).internalRenderComponent() line: 2508	
		final IMarkupFragment markup = getMarkup();
/ is er al	,
		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();
		// Call any tag handler
		onComponentTag(tag);
<div wicket:id="panel">

				renderComponentTag(tag);

"ThreadContext.g...tRequestCycle()"	 (pending)	
	activeResponse	BufferedWebResponse  (id=891)	
		charSequenceAction	BufferedWebResponse$WriteCharSequenceAction  (id=899)	
			builder	StringBuilder  (id=900)	
<!doctype html>
<html>
<head>

</head>
<body>
	<div wicket:id="panel">

			markupStream.next();	/ current= raw markup onder <div wicket:id="panel">

				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);
/ VERSCHIL MET WEBMARKUPCONTAINER
this	ChildContainingPanel  (id=819)	
/s
PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 83	

		else
		{
			// Skip the components body. Like with Panels or Fragments, it'll be replaced with the
			// associated markup
			if (markupStream.getPreviousTag().isOpen())	/ <div wicket:id="panel">
			{
				markupStream.skipRawMarkup();
/s
		while (true)
		{
			if (current instanceof RawMarkup)
			{
				if (next() != null)
				{
					continue;
				}
			}
/t
				if (markupStream.get().closes(openTag) == false)
/n 
markupStream.get()=</div>
/ want het is true	,
/ er mag buiten raw markup niets staan tussen <div ...> en </div>	,

		renderAssociatedMarkup(component);
/s
PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
		((MarkupContainer)component).renderAssociatedMarkup(tagName, "Markup for a " + tagName +	/	tagName="panel"
/s
ChildContainingPanel(MarkupContainer).renderAssociatedMarkup(String, String) line: 762	
this	ChildContainingPanel  (id=819)	
		final MarkupStream associatedMarkupStream = new MarkupStream(getMarkup(null));

/ we doen getMarkup(null)	, NIET getMarkup()	, Component.getMarkup() geeft markup in page's markup	, dus <div wicket:id="panel"></div>	, 
		/ en MarkupContainer.getMarkup(Component child) geeft panel's HTML 


/s
ChildContainingPanel(MarkupContainer).getMarkup(Component) line: 502	
/=
	public IMarkupFragment getMarkup(final Component child)
this is de panel	,
child=null	, hierdoor wordt de hele container's markup returned	, anders alleen die van de child	,
		return getMarkupSourcingStrategy().getMarkup(this, child);
/s
PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).getMarkup(MarkupContainer, Component) line: 93	
/=
	public IMarkupFragment getMarkup(final MarkupContainer parent, final Component child)
parent=panel
child=null
		IMarkupFragment associatedMarkup = parent.getAssociatedMarkup();
/s
ChildContainingPanel(MarkupContainer).getAssociatedMarkup() line: 456	
			Markup markup = MarkupFactory.get().getMarkup(this, false);
/s
MarkupFactory.getMarkup(MarkupContainer, boolean) line: 194	
		return getMarkup(container, container.getClass(), enforceReload);
/s
MarkupFactory.getMarkup(MarkupContainer, Class<?>, boolean) line: 219	

/ MORGENOCHTEND
Daemon Thread [http-nio-9090-exec-6] (Suspended)	
	owns: NioChannel  (id=604)	
	MarkupFactory.getMarkup(MarkupContainer, Class<?>, boolean) line: 221	
	MarkupFactory.getMarkup(MarkupContainer, boolean) line: 194	
	ChildContainingPanel(MarkupContainer).getAssociatedMarkup() line: 456	
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).getMarkup(MarkupContainer, Component) line: 95	
	ChildContainingPanel(MarkupContainer).getMarkup(Component) line: 502	
	ChildContainingPanel(MarkupContainer).renderAssociatedMarkup(String, String) line: 762	
	PanelMarkupSourcingStrategy(AssociatedMarkupSourcingStrategy).renderAssociatedMarkup(Component) line: 77	
	PanelMarkupSourcingStrategy.onComponentTagBody(Component, MarkupStream, ComponentTag) line: 112	
	ChildContainingPanel(Component).internalRenderComponent() line: 2565	
	ChildContainingPanel(MarkupContainer).onRender() line: 1698	
	ChildContainingPanel(Component).internalRender() line: 2380	
	ChildContainingPanel(Component).render() line: 2308	
	ChildInPanelPage(MarkupContainer).renderNext(MarkupStream) line: 1524	
	ChildInPanelPage(MarkupContainer).renderAll(MarkupStream, ComponentTag) line: 1759	
	ChildInPanelPage(Page).onRender() line: 879	
	ChildInPanelPage(WebPage).onRender() line: 141	
	ChildInPanelPage(Component).internalRender() line: 2380	
	ChildInPanelPage(Component).render() line: 2308	
	ChildInPanelPage(Page).renderPage() line: 1018	
	WebPageRenderer.renderPage(Url, RequestCycle) line: 124	
	WebPageRenderer.respond(RequestCycle) line: 236	
	RenderPageRequestHandler.respond(IRequestCycle) line: 175	
	RequestCycle$HandlerExecutor.respond(IRequestHandler) line: 895	
	RequestCycle$HandlerExecutor(RequestHandlerStack).execute(IRequestHandler) line: 64	
	RequestCycle.execute(IRequestHandler) line: 265	
	RequestCycle.processRequest() line: 222	
	RequestCycle.processRequestAndDetach() line: 293	
	WicketFilter.processRequestCycle(RequestCycle, WebResponse, HttpServletRequest, HttpServletResponse, FilterChain) line: 261	
	WicketFilter.processRequest(ServletRequest, ServletResponse, FilterChain) line: 203	
	WicketFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 284	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	NonLoginAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 502	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	















 








/ Einde PANEL AND TAG

/ PANELS

/ 7	. 

/ page met WebMarkupContainer OK	, 

public class ChildInWebMarkupContainerPage extends WebPage{
	
	public ChildInWebMarkupContainerPage() {
		WebMarkupContainer container=new WebMarkupContainer("container");
		IModel<String>model=new Model<String>(){
			public String getObject() {
				return new Date().toString();
			}
		};
		add(container);
		Label label=new Label("childincontainer", model);
		container.add(label);
	}
}
<head>
</head>
<body>
	<div wicket:id="container">
		<span wicket:id="childincontainer">
		</span>
	</div>
</body>

/ 7	. 

/ page met Panel ERR	,




/ ERR	,
public class PanelMarkupSourcingStrategy extends AssociatedMarkupSourcingStrategy
	@Override
	public void onComponentTagBody(final Component component, final MarkupStream markupStream, final ComponentTag openTag) {
		if (allowWicketComponentsInBodyMarkup) {
/n
		else
		{
			// Skip the components body. Like with Panels or Fragments, it'll be replaced with the
			// associated markup
			if (markupStream.getPreviousTag().isOpen())
			{
				markupStream.skipRawMarkup();
				if (markupStream.get().closes(openTag) == false)
				{
					StringBuilder msg = new StringBuilder();

					msg.append("Close tag not found for tag: ")
						.append(openTag.toString())
						.append(". For ")
						.append(component.getClass().getSimpleName())
						.append(" Components only raw markup is allow in between the tags but not ")
						.append("other Wicket Component. Component: ")
						.append(component.toString());

					throw new MarkupException(markupStream, msg.toString());
				}
			}
		}

/ 7	. 

/ straks use in page	,
	private static class Parent extends WebMarkupContainer{
		public Parent(String id) {
			super(id)	;
		}
	}

/ 7	. 



/ Einde PANELS

