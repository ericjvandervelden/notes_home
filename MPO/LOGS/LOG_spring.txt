/ See VERSION GRADLE
/ See DEBUG SPRING
/ 	GROVE ROUNDTRIP
/ 	SPEL
/ 	SPRING XML
	SPRING AUTOCONFIG
/ 		RESULT BEAN REGISTRY

/ See AUTOCONFIG JAVACONFIG
/ See SPRING FULL LITE CONFIGURATION 

/ See SPRING AUTOCONFIG
/ 	See GENERICS STUDY 
	See WHERE @CONFIGURATION IS USED
	See WHERE @COMPONENTSCAN IS USED
/ See TO MERGE

/ SPITTR wicket7_5, my-Spittr	,


/ 7	.

/ AOP

/ ws wicket7_5 
/ proj spring-framework

/ spring heeft geen dep op cglib	, maar toch OK
/ TODO
/ we doen toch een dep op cglib	, als we dan Enhancer geven zien we 2 mog	,
org.springframework.cglib.proxy
net.sf.cglib.proxy

$ less pom.xml

  <groupId>my.own</groupId>
  <artifactId>spring-framework</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <properties>
  
  </properties>
  <dependencies>
	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-context</artifactId>
	    <version>4.3.4.RELEASE</version>
	</dependency>
	<dependency>
	    <groupId>junit</groupId>
	    <artifactId>junit</artifactId>
	    <version>4.12</version>
	</dependency>
	<dependency>
	    <groupId>cglib</groupId>
	    <artifactId>cglib</artifactId>
	    <version>3.2.4</version>
	</dependency>
	
  </dependencies>

/ Lees	,
https://www.codota.com/java/spring/scenarios/549bbb39da0a3be0ebda1717/org.springframework.aop.framework.ProxyFactory?tag=spring1b&fullSource=1#

	@Test
	public void testAopCglibProxy() throws Exception {
		ModelMap map = new ModelMap();
		ProxyFactory factory = new ProxyFactory();
		SomeInnerClass val = new SomeInnerClass();
		factory.setTarget(val);
		factory.setProxyTargetClass(true);
		map.addAttribute(factory.getProxy());
		assertTrue(map.containsKey("someInnerClass"));
		assertEquals(val, map.get("someInnerClass"));
	} 

	public static class SomeInnerClass { 
 
		@Override 
		public boolean equals(Object obj) {
			return (obj instanceof SomeInnerClass);
		} 
 
		@Override 
		public int hashCode() { 
			return SomeInnerClass.class.hashCode();
		} 
	} 

/ 7	 

/ Gradle

/ ws wicket7_5 
/ proj 

/ lees	,
http://stackoverflow.com/questions/4871656/using-gradle-to-build-a-jar-with-dependencies
/->
https://issues.gradle.org/browse/GRADLE-1361
Fat jar cookbook example leads to error

/ lees	, 
https://www.mkyong.com/gradle/gradle-create-a-jar-file-with-dependencies/
http://logback.qos.ch/

/ kijk hoe Walls aan 
import org.junit.contrib.java.lang.system.StandardOutputStreamLog;
/ komt	, 
/ bij maven dep is deze class deprecated	,
		<dependency>
		    <groupId>com.github.stefanbirkner</groupId>
		    <artifactId>system-rules</artifactId>
		    <version>1.16.1</version>
		</dependency>
/ TODO

/ 7	.

/ Maven	,

/ ws wicket7_5 
/ proj  my-stereo-autoconfig	,


/ 13	. 

/ we maken het maven proj my-stereo-autoconfig	,
/ we kunnen CDPlayerConfig.java in src/main/java of src/test/java	, beide gevallen komen in target/classes, 
/ we kunnen soundconfig.xml in src/main/resources of in src/test/resources	,  beide gevallen komen in target/test-classes 
/ surefire heeft en classes/ en test-classes in zijn classpath	, dus voor de test maakt het niet uit waar de config class of xml staat	,



/ 1313	. 

/ ws wicket7_5 
/ proj  my-stereo-autoconfig	,

/ Als we src/test/java/CDPlayerConfig.java	, dan zien we	,
./target/test-classes/soundsystem/CDPlayerConfig.class

$ mvn compile
[DEBUG] Classpath:
[DEBUG]  /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/classes
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-context/4.3.4.RELEASE/spring-context-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-aop/4.3.4.RELEASE/spring-aop-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-beans/4.3.4.RELEASE/spring-beans-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-core/4.3.4.RELEASE/spring-core-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-expression/4.3.4.RELEASE/spring-expression-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar
[DEBUG]  /home/eric/.m2/repository/com/github/stefanbirkner/system-rules/1.16.1/system-rules-1.16.1.jar
[DEBUG] Source roots:
[DEBUG]  /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/src/main/java
[DEBUG] Command line options:
...
[INFO] Compiling 5 source files to /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/classes

/ Als we src/test/java/CDPlayerConfig.java	, dan zien we	,
./target/test-classes/soundsystem/CDPlayerConfig.class

$ mvn test-compile

[DEBUG] Classpath:
[DEBUG]  /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/test-classes
[DEBUG]  /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/classes
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-context/4.3.4.RELEASE/spring-context-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-aop/4.3.4.RELEASE/spring-aop-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-beans/4.3.4.RELEASE/spring-beans-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-core/4.3.4.RELEASE/spring-core-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-expression/4.3.4.RELEASE/spring-expression-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar
[DEBUG]  /home/eric/.m2/repository/com/github/stefanbirkner/system-rules/1.16.1/system-rules-1.16.1.jar
[DEBUG]  /home/eric/.m2/repository/org/springframework/spring-test/4.3.4.RELEASE/spring-test-4.3.4.RELEASE.jar
[DEBUG]  /home/eric/.m2/repository/junit/junit/4.12/junit-4.12.jar
[DEBUG]  /home/eric/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar
[DEBUG]  /home/eric/.m2/repository/org/mockito/mockito-core/2.2.19/mockito-core-2.2.19.jar
[DEBUG]  /home/eric/.m2/repository/net/bytebuddy/byte-buddy/1.5.5/byte-buddy-1.5.5.jar
[DEBUG]  /home/eric/.m2/repository/net/bytebuddy/byte-buddy-agent/1.5.5/byte-buddy-agent-1.5.5.jar
[DEBUG]  /home/eric/.m2/repository/org/objenesis/objenesis/2.4/objenesis-2.4.jar
[DEBUG] Source roots:
[DEBUG]  /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/src/test/java
[DEBUG] Command line options:
...
[INFO] Compiling 3 source files to /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/test-classes

/ 1313

/ ws wicket7_5 
/ proj  my-stereo-autoconfig	,

/ als we de jar willen, moeten we mvn package doen	,

/ lees	,
https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html 

/ hij kijkt naar 

./target/classes
./target/classes/soundsystem
./target/classes/soundsystem/CompactDisc.class
./target/classes/soundsystem/CDPlayer.class
./target/classes/soundsystem/SgtPeppers.class
./target/classes/soundsystem/MediaPlayer.class
./target/classes/META-INF
./target/classes/META-INF/spring
./target/classes/META-INF/spring/soundsystem.xml


$ mvn package

[INFO] Building jar: /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/my-stereo-autoconfig-0.0.1-SNAPSHOT.jar
[DEBUG] adding directory META-INF/
[DEBUG] adding entry META-INF/MANIFEST.MF
[DEBUG] adding directory soundsystem/
[DEBUG] adding directory META-INF/spring/
[DEBUG] adding entry soundsystem/CompactDisc.class
[DEBUG] adding entry soundsystem/CDPlayer.class
[DEBUG] adding entry soundsystem/SgtPeppers.class
[DEBUG] adding entry soundsystem/MediaPlayer.class
[DEBUG] adding entry META-INF/spring/soundsystem.xml
[DEBUG] adding directory META-INF/maven/
[DEBUG] adding directory META-INF/maven/my.own/
[DEBUG] adding directory META-INF/maven/my.own/my-stereo-autoconfig/
[DEBUG] adding entry META-INF/maven/my.own/my-stereo-autoconfig/pom.xml
[DEBUG] adding entry META-INF/maven/my.own/my-stereo-autoconfig/pom.properties

/ Dus dat is alles in classes/ , manifest en pom dingen	,
/ Dus NIET test-classes	, en dat is logisch	,

/ 13	. 

/ ws wicket7_5 
/ proj  my-stereo-autoconfig	,

/ we hebben nu steeds	, 

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:soundsystem.xml")
public class CDPlayerXMLConfigTest {


/ we kunnen ook soundsystem.xml de naam CDPlayerXMLConfigTest-context.xml geven	, en hem in src/test/resources/soundsystem set	, 
/ Let op dat we hem in dezelfde package plaatsten als de test	, soundconfig dus	,

/ dan kunnen we 

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class CDPlayerXMLConfigTest {

/ we zien	, 
$ mvn test-resources

[INFO] Copying 1 resource
[DEBUG] file CDPlayerXMLConfigTest-context.xml has a filtered file extension
[DEBUG] copy /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/src/test/resources/soundsystem/CDPlayerXMLConfigTest-context.xml to /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/test-classes/soundsystem/CDPlayerXMLConfigTest-context.xml

/ we zien de test en de config file in dezelfde plaats in test-classes	, in soundsystem 	,  en blijkbaar wordt de naam van de test used	, want de config file moet precies zo heten	,

/ misschien kunnen we in @ContextConfiguration toch een package geven, en de config file in een ander package set	
/ TODO 





/ 13	. 

/ ws wicket7_5 
/ proj  my-stereo-autoconfig	,

/ in wicket's pom.xml moeten we de Page.html ook copy , dus daarom in de pom <resources/>	, 
/ maar nu hebben we genoeg aan de default acties van mvn	,
/ in src/main/resources hebben we META-INF/spring/soundsystem.xml, 
/ in de log van mvn zien we	,
[INFO] Copying 1 resource
[DEBUG] file soundsystem.xml has a filtered file extension
[DEBUG] copy /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/src/main/resources/META-INF/spring/soundsystem.xml to /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/classes/META-INF/spring/soundsystem.xml
/ Dus inderdaad komt META-INF/spring/soundsystem.xml in het classpath	, en daarom werkt	,

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:META-INF/spring/soundsystem.xml")
public class CDPlayerXMLConfigTest {

/ 13	. 

/ Dat META-INF/spring is WH conventie	, 
/ we kunnen ook 	,
/ in src/main/resources hebben we soundsystem.xml, 

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:soundsystem.xml")
public class CDPlayerXMLConfigTest {


/ 13	. 

/ we set de soundsystem.xml in src/test/resources	, 
/ dan komt deze in target's test-classes ipv classes, 	
/ maar lees 
http://maven.apache.org/surefire/maven-surefire-plugin/examples/configuring-classpath.html

/ surefire build it's classpath	,
The test-classes directory
The classes directory
The project dependencies
Additional classpath elements

/ vandaar dat het allebei kan	, in src/main/resources, en src/test/resources,	

/ we zien in de log van mvn test	, 
[DEBUG] file soundsystem.xml has a filtered file extension
[DEBUG] copy /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/src/test/resources/soundsystem.xml to /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-stereo-autoconfig/target/test-classes/soundsystem.xml



/ 7	. 

/ ws wicket7_5 
/ proj  my-stereo-autoconfig	,

/ CH2

/ in stereo-autoconfig zijn er CDPlayerTest en CDPlayerXMLConfigTest	, 
/ CDPlayerTest  uses CDPlayerConfig.java, CDPlayerXMLConfigTest uses soundsystem.xml	,

/ wat betreft via XML	, 

/ 7	. 


/ ws wicket7_5 
/ proj  my-knight

/ 13	. 

/ we hebben maven proj my-knight create	, naast gradle proj knight	, omdat in knight problemen met debug	, 
/ zoek op	,
the jar of this class file belongs to container 'project and external dependencies' which does not allow modifications

/ lees	,
google: eclipse debug how finds source files
http://stackoverflow.com/questions/6174550/eclipse-java-debugging-source-not-found
http://stackoverflow.com/questions/5815013/eclipse-dont-have-java-doc-to-show-information-about-class-and-methods-how-to-a]

/ of geef	,
eclipse debug not attached source but finds source
https://www.youtube.com/watch?v=IGIKPY6q1Qw

/ MORGENOCHTEND
/ in java-eclipse,	 zonder jbosstools	, kijk hoe source files worden gevonden	, 

/ we zien tijdens debug	, 

Source not found	,
The JAR file ~/.m2/repository/org/springframework/spring-beans/4.3.4.RELEASE/spring-beans-4.3.4.RELEASE.jar has no source attachment	, 
Attach Source	,
/ we clicked ergens op	, TODO		, en we zien de source file	, 
/ in ~/.m2/repository zien we spring-beans-4.3.4.RELEASE-sources.jar	, zie zojuist downloaded is	, 
/ in eclipse zien we GEEN attached source TODO	, in build-path, libraries	, 

/ 13	. 

/ Lees	, 
http://www.baeldung.com/spring-expression-language

/ lees	,
http://stackoverflow.com/questions/28809454/trouble-wiring-in-system-in-using-constructor-injection
@Component
public class Logger implements IReporter {

    private PrintStream output;

    @Autowired  
    public Logger(@Value("#{T(System).out}") PrintStream output) {
        this.output = output;
    }


/ 13	. 

/ ws workspace-wicket7_5
/ proj knight	, 

/ gradle loads source by default	, we hoeven NIET zoiets als in mvn dependency:sources	,

/ gradle loads jars and sources jars NIET in .m2	, maar in .gradle	,


/ Kijk in Project Explorer onder 
Project and External Dependencies
	/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context/4.0.7.RELEASE/8a4aa735f3691a1985381b3c6c69d32b835f51b4/spring-context-4.0.7.RELEASE.jar

/ of onder project's build path, libraries	, Project and External Dependencies

/ 13	. 

/ Als dependencies niet worden gevonden	, 
/ right click project	, Gradle,	 Refresh gradle project	, 

/ 13	. 

/ geef in google	, 
buildship 2.0
->
https://projects.eclipse.org/projects/tools.buildship/releases/2.0.0
/-> Getting started
http://www.vogella.com/tutorials/EclipseGradle/article.html


/ 13	. 

/ VERSION GRADLE

/ Hoe version gradle	?

/ stereo-xmlconfig

$ vi build.gradle	
task wrapper(type: Wrapper) {
    gradleVersion = '3.3'
}
/ Nu in Gradle Tasks
stereo-xmlconfig
	wrapper

/ Nu kunnen we,	 
/ right click CNamespaceReferenceTest.java	, 

/ 13	. 

[eric@localhost Spring]$ find  SpringiA4_SourceCode/Chapter_05/Spittr/ -name "*.war" | xargs -I % cp % /home/eric/Devel/Java/Tomcat/apache-tomcat-8.0.28/webapps/

/ Geef in chrome	, 
http://localhost:9090/spittr
/ OK






/ 13	. 

/ DEBUG SPRING

/ GROVE ROUNDTRIP

/ debug KnightMain	,

/ In Debug view right click sia.knights.KnightMain at localhost:34494

/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/bin/java 
	-agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:34494 -Dfile.encoding=UTF-8 
	-classpath /home/eric/Devel/Java/Spring/SpringiA4_SourceCode/Chapter_01/knight/bin:										<-
		/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context/4.0.7.RELEASE/8a4aa735f3691a1985381b3c6c69d32b835f51b4/spring-context-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.7.2/d3b191a99d2c34dfd5311ef3110f096f5bc0a10e/aspectjweaver-1.7.2.jar:/home/eric/.gradle/caches/modules-2/files-2.1/log4j/log4j/1.2.14/3b254c872b95141751f414e353a25c2ac261b51/log4j-1.2.14.jar:/home/eric/.m2/repository/junit/junit/4.11/junit-4.11.jar:/home/eric/.m2/repository/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-test/4.0.7.RELEASE/148c20e5170e6081dfcc5afefa613e27a7b1b814/spring-test-4.0.7.RELEASE.jar:/home/eric/.m2/repository/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/4.0.7.RELEASE/777e9502c4c2de150918a746fa22734d3eff81e0/spring-core-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-beans/4.0.7.RELEASE/fdd041f086972cc16f9b09ee420a98604cd0bc07/spring-beans-4.0.7.RELEASE.jar:/home/eric/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-aop/4.0.7.RELEASE/caadec5dc4ea4899d89004ff46053f8e391e0343/spring-aop-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/4.0.7.RELEASE/46a4cfe181b1f15940b5ea7530fcad1f8b98c561/spring-expression-4.0.7.RELEASE.jar:/home/eric/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/home/eric/.m2/repository/org/objenesis/objenesis/1.0/objenesis-1.0.jar sia.knights.KnightMain

/ Dit vermoedden we al	,
[eric@localhost Spring]$ find  SpringiA4_SourceCode/Chapter_01/knight/
SpringiA4_SourceCode/Chapter_01/knight/bin
SpringiA4_SourceCode/Chapter_01/knight/bin/META-INF
SpringiA4_SourceCode/Chapter_01/knight/bin/META-INF/spring
SpringiA4_SourceCode/Chapter_01/knight/bin/META-INF/spring/minstrel.xml
SpringiA4_SourceCode/Chapter_01/knight/bin/META-INF/spring/knight.xml
SpringiA4_SourceCode/Chapter_01/knight/bin/log4j.properties
SpringiA4_SourceCode/Chapter_01/knight/bin/sia
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/KnightJavaConfigInjectionTest.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/Knight.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/RescueDamselQuest.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/config
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/config/KnightConfig.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/config/SoundSystemConfig.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/DamselRescuingKnight.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/Minstrel.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/SlayDragonQuest.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/KnightXMLInjectionTest-context.xml
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/KnightConfig.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/BraveKnightTest.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/FakePrintStream.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/BraveKnight.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/Quest.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/KnightMain.class
SpringiA4_SourceCode/Chapter_01/knight/bin/sia/knights/KnightXMLInjectionTest.class
SpringiA4_SourceCode/Chapter_01/knight/gradlew.bat
SpringiA4_SourceCode/Chapter_01/knight/gradle
SpringiA4_SourceCode/Chapter_01/knight/gradle/wrapper
SpringiA4_SourceCode/Chapter_01/knight/gradle/wrapper/gradle-wrapper.jar
SpringiA4_SourceCode/Chapter_01/knight/gradle/wrapper/gradle-wrapper.properties

/ Zo vindt ClassPathXmlApplicationContext.<init> SpringiA4_SourceCode/Chapter_01/knight/bin/META-INF/spring/knight.xml in	,
ClassPathXmlApplicationContext.<init>(String) line: 83	
		this(new String[] {configLocation}, true, null);
configLocation	"META-INF/spring/knight.xml" (id=26)	



/ wilt bean knight gaan create	, maar gaat eerst bean quest maken	,

/ Lees SpEL	, spring expression language	, 
https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html
/ bijv	,
<bean id="numberGuess" class="org.spring.samples.NumberGuess">
    <property name="randomNumber" value="#{ T(java.lang.Math).random() * 100.0 }"/>

    <!-- other properties -->
</bean>
<bean id="shapeGuess" class="org.spring.samples.ShapeGuess">
    <property name="initialShapeSeed" value="#{ numberGuess.randomNumber }"/>

    <!-- other properties -->
</bean>


/c

/ stack	,
SlayDragonQuest.<init>(PrintStream) line: 10	
    this.stream = stream;
/cb
BeanUtils.instantiateClass(Constructor<T>, Object...) line: 142	
			return ctor.newInstance(args);
/cb
/s
CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory, Constructor<?>, Object...) line: 122	
			return BeanUtils.instantiateClass(ctor, args);
args	Object[1]  (id=386)	
	[0]	PrintStream  (id=302)	
/s
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 143	
			else {
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
				resolvedValues = new ConstructorArgumentValues();
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues); / beanName="quest" , we zijn ook nog steeds in resolveConstructorArguments	, beanName="knight"	, lager in de stack, ook precies op dit punt	,
/ sets	,
resolvedValues	ConstructorArgumentValues  (id=292)	
	genericArgumentValues	LinkedList<E>  (id=318)	
		first	LinkedList$Node<E>  (id=320)	
			item	ConstructorArgumentValues$ValueHolder  (id=321)	
				value	PrintStream  (id=302)	

/ we zijn ook nog steeds in resolveConstructorArguments, beanName="knight"	, maar hier returns hij nu,
...
			else {
				beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(							<-
						mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
/cb
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1148	
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1050	
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() 
/ JA
mbd	RootBeanDefinition  (id=294)	
	constructorArgumentValues	ConstructorArgumentValues  (id=304)	
		genericArgumentValues	LinkedList<E>  (id=305)	
			first	LinkedList$Node<E>  (id=307)	
				item	ConstructorArgumentValues$ValueHolder  (id=308)	
					value	TypedStringValue  (id=309)	
						value	"#{T(System).out}" (id=311)	
/ want
$ less knight.xml
  <bean id="quest" class="sia.knights.SlayDragonQuest">
    <constructor-arg value="#{T(System).out}" />
  </bean>
				|| !ObjectUtils.isEmpty(args))  {
			return autowireConstructor(beanName, mbd, ctors, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 512	
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 482	
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
/cb
	AbstractBeanFactory$1.getObject() line: 306	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
->
/cb								return createBean(beanName, mbd, args);
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 230	
				try {
					singletonObject = singletonFactory.getObject();
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 302	
				// Create bean instance.
				if (mbd.isSingleton()) {
->					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 197	
		return doGetBean(name, null, null, false);
name="quest"
/ recursive call	, eerder met "knight"	,																		<-
/cb
	BeanDefinitionValueResolver.resolveReference(Object, RuntimeBeanReference) line: 351	
			else {
				Object bean = this.beanFactory.getBean(refName);
refName="quest"
/cb
	BeanDefinitionValueResolver.resolveValueIfNecessary(Object, Object) line: 108	
		if (value instanceof RuntimeBeanReference) {
			RuntimeBeanReference ref = (RuntimeBeanReference) value;
			return resolveReference(argName, ref);
/cb
	ConstructorResolver.resolveConstructorArguments(String, RootBeanDefinition, BeanWrapper, ConstructorArgumentValues, ConstructorArgumentValues) line: 648	
		for (ConstructorArgumentValues.ValueHolder valueHolder : cargs.getGenericArgumentValues()) {
			if (valueHolder.isConverted()) {
				resolvedValues.addGenericArgumentValue(valueHolder);
			}
			else {
				Object resolvedValue =
						valueResolver.resolveValueIfNecessary("constructor argument", valueHolder.getValue());
valueHolder	ConstructorArgumentValues$ValueHolder  (id=172)	
	value	RuntimeBeanReference  (id=176)	
		beanName	"quest" (id=181)	
/cb
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 145	
			else {
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
cargs	ConstructorArgumentValues  (id=159)	
	genericArgumentValues	LinkedList<E>  (id=165)	
		first	LinkedList$Node<E>  (id=169)	
			item	ConstructorArgumentValues$ValueHolder  (id=172)	
				value	RuntimeBeanReference  (id=176)	
					beanName	"quest" (id=181)	

				resolvedValues = new ConstructorArgumentValues();
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);			<- nu
				...
				beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(							<- straks
						mbd, beanName, this.beanFactory, constructorToUse, argsToUse);

/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1148	
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1050	
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() 
mbd	RootBeanDefinition  (id=108)	
	constructorArgumentValues	ConstructorArgumentValues  (id=159)	
		genericArgumentValues	LinkedList<E>  (id=165)	
			first	LinkedList$Node<E>  (id=169)	
				item	ConstructorArgumentValues$ValueHolder  (id=172)	
					value	RuntimeBeanReference  (id=176)	
						beanName	"quest" (id=181)	
/ JA 
				|| !ObjectUtils.isEmpty(args))  {
			return autowireConstructor(beanName, mbd, ctors, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 512	
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 482	
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
/cb
	AbstractBeanFactory$1.getObject() line: 306	
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
this	AbstractBeanFactory$1  (id=31)	
	val$mbd	RootBeanDefinition  (id=48)	
		beanClass	Class<T> (sia.knights.BraveKnight) (id=67)	
		resource	DefaultResourceLoader$ClassPathContextResource  (id=86)			class path resource [META-INF/spring/knight.xml]

				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
->								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 230	
				try {
					singletonObject = singletonFactory.getObject();
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 302	
				// Create bean instance.
				if (mbd.isSingleton()) {
->					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 197	
		return doGetBean(name, null, null, false);
name="knight"
/cb
	DefaultListableBeanFactory.preInstantiateSingletons() line: 754	
				else {
					getBean(beanName);
beanName="knight"
/cb
	ClassPathXmlApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 866	
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/cb
	ClassPathXmlApplicationContext(AbstractApplicationContext).refresh() line: 542							<-
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);									<-

				// Last step: publish corresponding event.
				finishRefresh();
/cb
	ClassPathXmlApplicationContext.<init>(String[], boolean, ApplicationContext) line: 139	
			refresh();
/cb
	ClassPathXmlApplicationContext.<init>(String) line: 83	
	KnightMain.main(String[]) line: 10	

/ debug	,
/s
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 143	
			else {
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
				resolvedValues = new ConstructorArgumentValues();

mdb rootBeanDefinition  (id=129)	
	constructorArgumentValues	ConstructorArgumentValues  (id=142)	
		genericArgumentValues	LinkedList<E>  (id=143)	
			first	LinkedList$Node<E>  (id=145)	
				item	ConstructorArgumentValues$ValueHolder  (id=147)	
					value	TypedStringValue  (id=148)	
						value	"#{T(System).out}" (id=151)	

				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);

resolvedValues	ConstructorArgumentValues  (id=292)	
	genericArgumentValues	LinkedList<E>  (id=318)	
		first	LinkedList$Node<E>  (id=320)	
			item	ConstructorArgumentValues$ValueHolder  (id=321)	
				value	PrintStream  (id=302)	

/c
/stack	,
/s
		DefaultListableBeanFactory(DefaultSingletonBeanRegistry).registerDependentBean(String, String) line: 410	

		String canonicalName = canonicalName(beanName);
		synchronized (this.dependentBeanMap) {
			Set<String> dependentBeans = this.dependentBeanMap.get(canonicalName);
			if (dependentBeans == null) {
				dependentBeans = new LinkedHashSet<String>(8);
				this.dependentBeanMap.put(canonicalName, dependentBeans);	/ dependentBeans={}
			}
			dependentBeans.add(dependentBeanName);		/ er komt "knight" bij	,
		}
		synchronized (this.dependenciesForBeanMap) {
			Set<String> dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);
			if (dependenciesForBean == null) {
				dependenciesForBean = new LinkedHashSet<String>(8);
				this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);	/ dependenciesForBean={}
			}
			dependenciesForBean.add(canonicalName);	/ er komt 'quest" bij	,

this	DefaultListableBeanFactory  (id=30)	
	dependenciesForBeanMap	ConcurrentHashMap<K,V>  (id=127)	
{knight=[quest]}
	dependentBeanMap	ConcurrentHashMap<K,V>  (id=128)	
{quest=[knight]}
/cb
		BeanDefinitionValueResolver.resolveReference(Object, RuntimeBeanReference) line: 329	
				this.beanFactory.registerDependentBean(refName, this.beanName);
/cb
		BeanDefinitionValueResolver.resolveValueIfNecessary(Object, Object) line: 108	
argName	"constructor argument" (id=283)	
value	RuntimeBeanReference  (id=279)	
	beanName	"quest" (id=282)	
	source	null	
	toParent	false	

			return resolveReference(argName, ref);
/cb
		ConstructorResolver.resolveConstructorArguments(String, RootBeanDefinition, BeanWrapper, ConstructorArgumentValues, ConstructorArgumentValues) line: 646	
				Object resolvedValue =
						valueResolver.resolveValueIfNecessary("constructor argument", valueHolder.getValue());
valueHolder	ConstructorArgumentValues$ValueHolder  (id=277)	
	value	RuntimeBeanReference  (id=279)	
		beanName	"quest" (id=282)	
		source	null	
		toParent	false	
/cb
		ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 140	
			else {
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
				resolvedValues = new ConstructorArgumentValues();
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
cargs	ConstructorArgumentValues  (id=265)	
	genericArgumentValues	LinkedList<E>  (id=2046)	
		[0]	ConstructorArgumentValues$ValueHolder  (id=277)	
			value	RuntimeBeanReference  (id=279)	
				beanName	"quest" (id=282)	
				source	null	
				toParent	false	
/cb
		DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1115	
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
/cb
		DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1018	
		DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
		DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
		AbstractBeanFactory$1.getObject() line: 302	
		DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
		DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
		DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
		DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
		ClassPathXmlApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
		ClassPathXmlApplicationContext(AbstractApplicationContext).refresh() line: 482	
		ClassPathXmlApplicationContext.<init>(String[], boolean, ApplicationContext) line: 139	
		ClassPathXmlApplicationContext.<init>(String) line: 83	
		KnightMain.main(String[]) line: 10	
/debug verder	, 
/s
ConstructorResolver.resolveConstructorArguments(String, RootBeanDefinition, BeanWrapper, ConstructorArgumentValues, ConstructorArgumentValues) line: 647	
				Object resolvedValue =
						valueResolver.resolveValueIfNecessary("constructor argument", valueHolder.getValue());
/d
resolvedValue	SlayDragonQuest  (id=43)	
				ConstructorArgumentValues.ValueHolder resolvedValueHolder =
						new ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());
resolvedValueHolder	ConstructorArgumentValues$ValueHolder  (id=2110)	
	converted	false	
	convertedValue	null	
	name	null	
	source	null	
	type	null	
	value	SlayDragonQuest  (id=43)	
				resolvedValueHolder.setSource(valueHolder);
				resolvedValues.addGenericArgumentValue(resolvedValueHolder);
resolvedValues	ConstructorArgumentValues  (id=266)	
	genericArgumentValues	LinkedList<E>  (id=2042)	
		[0]	ConstructorArgumentValues$ValueHolder  (id=2110)	
			converted	false	
			convertedValue	null	
			name	null	
			source	ConstructorArgumentValues$ValueHolder  (id=277)	
				converted	false	
				convertedValue	null	
				name	null	
				source	null	
				type	null	
				value	RuntimeBeanReference  (id=279)	
					beanName	"quest" (id=282)	
					source	null	
					toParent	false	
			type	null	
			value	SlayDragonQuest  (id=43)	
/t
	/**
	 * "autowire constructor" (with constructor arguments by type) behavior.
	 * Also applied if explicit constructor argument values are specified,
	 * matching all remaining arguments with beans from the bean factory.
	 * <p>This corresponds to constructor injection: In this mode, a Spring
	 * bean factory is able to host components that expect constructor-based
	 * dependency resolution.
	 */
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 144	
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
/d
1
resolvedValues	ConstructorArgumentValues  (id=85)	
	genericArgumentValues	LinkedList<E>  (id=86)	
		[0]	ConstructorArgumentValues$ValueHolder  (id=103)	
			converted	false	
			convertedValue	null	
			name	null	
			source	ConstructorArgumentValues$ValueHolder  (id=105)	
			type	null	
			value	SlayDragonQuest  (id=106)	

					candidates = (mbd.isNonPublicAccessAllowed() ?
							beanClass.getDeclaredConstructors() : beanClass.getConstructors());
[public sia.knights.BraveKnight(sia.knights.Quest)]

						String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
						if (paramNames == null) {
/j
							ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
							if (pnd != null) {
								paramNames = pnd.getParameterNames(candidate);
							}
						}
						argsHolder = createArgumentArray(
								beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);
argsHolder	ConstructorResolver$ArgumentsHolder  (id=2274)	
	arguments	Object[1]  (id=2275)	
		[0]	SlayDragonQuest  (id=43)	
	preparedArguments	Object[1]  (id=2276)	
		[0]	RuntimeBeanReference  (id=279)	
			beanName	"quest" (id=282)	
			source	null	
			toParent	false	
	rawArguments	Object[1]  (id=2277)	
		[0]	SlayDragonQuest  (id=43)	
	resolveNecessary	true	

			if (explicitArgs == null) {
				argsHolderToUse.storeCache(mbd, constructorToUse);

			else {
				beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(				/ injects arg	, de SlayDragonQuest	,
						mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
argsToUse	Object[1]  (id=1850)	
	[0]	SlayDragonQuest  (id=106)													/ to inject	,
													/ injects door call ctor.newInstance(args)	, 
/s
CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory, Constructor<?>, Object[]) line: 125	
this	CglibSubclassingInstantiationStrategy  (id=47)	
			return BeanUtils.instantiateClass(ctor, args);
ctor	Constructor<T>  (id=2258)	
args	Object[1]  (id=2275)	
	[0]	SlayDragonQuest  (id=43)	
/s
BeanUtils.instantiateClass(Constructor<T>, Object...) line: 148	
			return ctor.newInstance(args);
/s
BraveKnight.<init>(Quest) line: 7	
    this.quest = quest;
/t
	/**
	 * "autowire constructor" (with constructor arguments by type) behavior.
	 * Also applied if explicit constructor argument values are specified,
	 * matching all remaining arguments with beans from the bean factory.
	 * <p>This corresponds to constructor injection: In this mode, a Spring
	 * bean factory is able to host components that expect constructor-based
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 274	
			else {
				beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(
						mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
			}
/d
beanInstance	BraveKnight  (id=2372)	
			bw.setWrappedInstance(beanInstance);
			return bw;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1115	
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
/d
/t
		DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1018	
			return autowireConstructor(beanName, mbd, ctors, args);
/d
/t
		DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	

this	DefaultListableBeanFactory  (id=30)	
	beanPostProcessors	ArrayList<E>  (id=123)	
		[0]	ApplicationContextAwareProcessor  (id=401)	
			applicationContext	ClassPathXmlApplicationContext  (id=18)	
		[1]	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=404)	
			beanFactory	DefaultListableBeanFactory  (id=30)	
			beanPostProcessorTargetCount	2	
		[2]	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=406)	
			applicationContext	ClassPathXmlApplicationContext  (id=18)	
			singletonNames	ConcurrentHashMap<K,V>  (id=412)	
	registeredSingletons	LinkedHashSet<E>  (id=159)	
		[0]	"environment" (id=187)	
		[1]	"systemProperties" (id=202)	
		[2]	"systemEnvironment" (id=207)	
		[3]	"messageSource" (id=182)	
		[4]	"applicationEventMulticaster" (id=195)	
		[5]	"quest" (id=282)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=27)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=2386)	
			key	"messageSource" (id=182)	
			value	DelegatingMessageSource  (id=183)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=2387)	
			key	"environment" (id=187)	
			value	StandardEnvironment  (id=188)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=2388)	
			key	"applicationEventMulticaster" (id=195)	
			value	SimpleApplicationEventMulticaster  (id=196)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=2389)	
			key	"quest" (id=282)	
			value	SlayDragonQuest  (id=43)	
		[4]	ConcurrentHashMap$WriteThroughEntry  (id=2390)	
			key	"systemProperties" (id=202)	
			value	Properties  (id=203)	
		[5]	ConcurrentHashMap$WriteThroughEntry  (id=2391)	
			key	"systemEnvironment" (id=207)	
			value	Collections$UnmodifiableMap<K,V>  (id=208)	

		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/d
		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 911	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
PostProcessorRegistrationDelegate$ApplicationListenerDetector.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 337	
			if (beanDefinition.isSingleton()) {
				this.singletonNames.put(beanName, Boolean.TRUE);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 515	
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/d
				mbd.postProcessed = true;

			populateBean(beanName, mbd, instanceWrapper);
beanName	"knight" (id=222)	
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1128	
		PropertyValues pvs = mbd.getPropertyValues();
pvs	MutablePropertyValues  (id=2100)	
	converted	false	
	processedProperties	null	
	propertyValueList	ArrayList<E>  (id=2621)	
[]
		if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
/n
mbd.getResolvedAutowireMode()=NO_AUTOWIRE
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
false
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);
false
		applyPropertyValues(beanName, mbd, bw, pvs);
/ niets	,
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 539	
			populateBean(beanName, mbd, instanceWrapper);
/d
/ niets	,
			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1541	
		else {
			invokeAwareMethods(beanName, bean);
beanName	"knight" (id=222)	
bean	BraveKnight  (id=2372)	
/niets	, bean !instanceof Aware

		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);

/ Einde GROVE ROUNDTRIP

/ SPEL

/ Lees	,
https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html
/ of	,
https://docs.spring.io/spring/docs/current/spring-framework-reference/html/index.html
ยง 10
/ ยง = U00a7

/s
/ stack
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 140	
			else {
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
cargs	ConstructorArgumentValues  (id=98)	
	genericArgumentValues	LinkedList<E>  (id=100)	
		[0]	ConstructorArgumentValues$ValueHolder  (id=117)	
			value	TypedStringValue  (id=119)	
				value	"#{T(System).out}" (id=125)	

				resolvedValues = new ConstructorArgumentValues();
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1115	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1018	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
	AbstractBeanFactory$1.getObject() line: 302	
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
	BeanDefinitionValueResolver.resolveReference(Object, RuntimeBeanReference) line: 328	
	BeanDefinitionValueResolver.resolveValueIfNecessary(Object, Object) line: 108	
	ConstructorResolver.resolveConstructorArguments(String, RootBeanDefinition, BeanWrapper, ConstructorArgumentValues, ConstructorArgumentValues) line: 646	
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 140	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1115	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1018	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
	AbstractBeanFactory$1.getObject() line: 302	
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
	DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
	ClassPathXmlApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
	ClassPathXmlApplicationContext(AbstractApplicationContext).refresh() line: 482	
	ClassPathXmlApplicationContext.<init>(String[], boolean, ApplicationContext) line: 139	
	ClassPathXmlApplicationContext.<init>(String) line: 83	
	KnightMain.main(String[]) line: 10	
/ debug
/s
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 140	
			else {
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
				resolvedValues = new ConstructorArgumentValues();
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
/s
ConstructorResolver.resolveConstructorArguments(String, RootBeanDefinition, BeanWrapper, ConstructorArgumentValues, ConstructorArgumentValues) line: 645	
			else {
				Object resolvedValue =
						valueResolver.resolveValueIfNecessary("constructor argument", valueHolder.getValue());
PrintStream
/ want,
/s
BeanDefinitionValueResolver.resolveValueIfNecessary(Object, Object) line: 106	
/=
	public Object resolveValueIfNecessary(Object argName, Object value) {
argName	"constructor argument" (id=207)	
value	TypedStringValue  (id=119)	
	value	"#{T(System).out}" (id=125)	

		else if (value instanceof TypedStringValue) {
			// Convert value to target type here.
			TypedStringValue typedStringValue = (TypedStringValue) value;
			Object valueObject = evaluate(typedStringValue);
PrintStream
/ want,	
/s
BeanDefinitionValueResolver.evaluate(TypedStringValue) line: 214	
		Object result = this.beanFactory.evaluateBeanDefinitionString(value.getValue(), this.beanDefinition);
/s
DefaultListableBeanFactory(AbstractBeanFactory).evaluateBeanDefinitionString(String, BeanDefinition) line: 1361	
		Scope scope = (beanDefinition != null ? getRegisteredScope(beanDefinition.getScope()) : null);
null
		return this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));
/s
StandardBeanExpressionResolver.evaluate(String, BeanExpressionContext) line: 117	
			Expression expr = this.expressionCache.get(value);
expr	SpelExpression  (id=239)	
	ast	CompoundExpression  (id=243)	
		children	SpelNodeImpl[2]  (id=251)	
			[0]	TypeReference  (id=254)						/ deze 2 , TypeReference en PropertyOrFieldReference zien we steeds terug	,
			[1]	PropertyOrFieldReference  (id=255)	

			return expr.getValue(sec);
/s
SpelExpression.getValue(EvaluationContext) line: 94	
		return this.ast.getValue(new ExpressionState(context, this.configuration));
/s
CompoundExpression(SpelNodeImpl).getValue(ExpressionState) line: 102	
			return getValueInternal(expressionState).getValue();
/s
CompoundExpression.getValueInternal(ExpressionState) line: 84	
		return getValueRef(state).getValue();
/s
CompoundExpression.getValueRef(ExpressionState) line: 43	
		SpelNodeImpl nextNode = this.children[0];
		try {
			TypedValue result = nextNode.getValueInternal(state);
result	TypedValue  (id=363)	
	typeDescriptor	TypeDescriptor  (id=375)	
	value	Class<T> (java.lang.System) (id=366)	

			try {
				state.pushActiveContextObject(result);
				nextNode = this.children[cc-1];
nextNode	PropertyOrFieldReference  (id=255)	
				return nextNode.getValueRef(state);
/s
PropertyOrFieldReference.getValueRef(ExpressionState) line: 72	
		return new AccessorLValue(this, state.getActiveContextObject(), state.getEvaluationContext(),
				state.getConfiguration().isAutoGrowNullReferences());
/t
CompoundExpression.getValueInternal(ExpressionState) line: 84	
		return getValueRef(state).getValue();
/pd
/s
PropertyOrFieldReference$AccessorLValue.getValue() line: 341	
			return this.ref.getValueInternal(this.contextObject, this.eContext, this.autoGrowNullReferences);
/s
PropertyOrFieldReference.getValueInternal(TypedValue, EvaluationContext, boolean) line: 85	
		TypedValue result = readProperty(contextObject, eContext, this.name);
result	TypedValue  (id=435)	
	typeDescriptor	TypeDescriptor  (id=436)	
	value	PrintStream  (id=200)	
/ want	, 
/s
PropertyOrFieldReference.readProperty(TypedValue, EvaluationContext, String) line: 172	
				return accessorToUse.read(eContext, contextObject.getValue(), name);
contextObject	TypedValue  (id=363)	
	typeDescriptor	TypeDescriptor  (id=375)	
	value	Class<T> (java.lang.System) (id=366)	
name	"out" (id=266)	
/s
ReflectivePropertyAccessor$OptimalPropertyAccessor.read(EvaluationContext, Object, String) line: 614	
			if (this.member instanceof Field) {
				try {
					if (this.needsToBeMadeAccessible) {
						ReflectionUtils.makeAccessible((Field) this.member);
					}
					Object value = ((Field) this.member).get(target);
this	ReflectivePropertyAccessor$OptimalPropertyAccessor  (id=262)	
	member	Field  (id=297)					public static final java.io.PrintStream java.lang.System.out
	needsToBeMadeAccessible	false	
	typeDescriptor	TypeDescriptor  (id=301)	
target	Class<T> (java.lang.System) (id=366)	
value	PrintStream  (id=200)	


/ Einde SPEL

/ SPRING XML

/ stack
/s
	XmlBeanDefinitionReader.<init>(BeanDefinitionRegistry) line: 117	
	private DocumentLoader documentLoader = new DefaultDocumentLoader();
/cb
	ClassPathXmlApplicationContext(AbstractXmlApplicationContext).loadBeanDefinitions(DefaultListableBeanFactory) line: 82	
		// Create a new XmlBeanDefinitionReader for the given BeanFactory.
		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
/cb
	ClassPathXmlApplicationContext(AbstractRefreshableApplicationContext).refreshBeanFactory() line: 129	
			DefaultListableBeanFactory beanFactory = createBeanFactory();
			beanFactory.setSerializationId(getId());
			customizeBeanFactory(beanFactory);
			loadBeanDefinitions(beanFactory);										<-
/cb
	ClassPathXmlApplicationContext(AbstractApplicationContext).obtainFreshBeanFactory() line: 542	
		refreshBeanFactory();
/cb
	ClassPathXmlApplicationContext(AbstractApplicationContext).refresh() line: 454										<-
			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
/cb
	ClassPathXmlApplicationContext.<init>(String[], boolean, ApplicationContext) line: 139	
	ClassPathXmlApplicationContext.<init>(String) line: 83	
	KnightMain.main(String[]) line: 10	
/ debug	,
/s
ClassPathXmlApplicationContext(AbstractXmlApplicationContext).loadBeanDefinitions(DefaultListableBeanFactory) line: 92	
		// Create a new XmlBeanDefinitionReader for the given BeanFactory.
		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
/d
		// resource loading environment.
		beanDefinitionReader.setEnvironment(this.getEnvironment());
		beanDefinitionReader.setResourceLoader(this);
		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

		// Allow a subclass to provide custom initialization of the reader,
		// then proceed with actually loading the bean definitions.
		initBeanDefinitionReader(beanDefinitionReader);
		loadBeanDefinitions(beanDefinitionReader);
/s
ClassPathXmlApplicationContext(AbstractXmlApplicationContext).loadBeanDefinitions(XmlBeanDefinitionReader) line: 121	
		Resource[] configResources = getConfigResources();
null
/ TODO Wat zijn dit?
		String[] configLocations = getConfigLocations();
[META-INF/spring/knight.xml]
		if (configLocations != null) {
			reader.loadBeanDefinitions(configLocations);
/s
XmlBeanDefinitionReader(AbstractBeanDefinitionReader).loadBeanDefinitions(String...) line: 251	
		for (String location : locations) {
			counter += loadBeanDefinitions(location);
/s
XmlBeanDefinitionReader(AbstractBeanDefinitionReader).loadBeanDefinitions(String, Set<Resource>) line: 206	
location	"META-INF/spring/knight.xml" (id=1048)	
actualResources	null	
		ResourceLoader resourceLoader = getResourceLoader();
resourceLoader	ClassPathXmlApplicationContext  (id=20)	

		if (resourceLoader instanceof ResourcePatternResolver) {
			// Resource pattern matching available.
			try {
				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
resources	Resource[1]  (id=1055)	
	[0]	DefaultResourceLoader$ClassPathContextResource  (id=1059)	
		classLoader	Launcher$AppClassLoader  (id=16)	
		clazz	null	
		path	"META-INF/spring/knight.xml" (id=1067)	

				int loadCount = loadBeanDefinitions(resources);
/s
XmlBeanDefinitionReader(AbstractBeanDefinitionReader).loadBeanDefinitions(Resource...) line: 177	
		for (Resource resource : resources) {
			counter += loadBeanDefinitions(resource);
/s
XmlBeanDefinitionReader.loadBeanDefinitions(EncodedResource) line: 314	
		if (!currentResources.add(encodedResource)) {
currentResources	HashSet<E>  (id=1097)	
	[0]	EncodedResource  (id=1094)	
		charset	null	
		encoding	null	
		resource	DefaultResourceLoader$ClassPathContextResource  (id=1059)	
			classLoader	Launcher$AppClassLoader  (id=16)	
			clazz	null	
			path	"META-INF/spring/knight.xml" (id=1067)	

			InputStream inputStream = encodedResource.getResource().getInputStream();
/s
DefaultResourceLoader$ClassPathContextResource(ClassPathResource).getInputStream() line: 166	
this	DefaultResourceLoader$ClassPathContextResource  (id=1059)	
	classLoader	Launcher$AppClassLoader  (id=16)	
	clazz	null	
	path	"META-INF/spring/knight.xml" (id=1067)	

			is = this.classLoader.getResourceAsStream(this.path);
	return is;
/t
XmlBeanDefinitionReader.loadBeanDefinitions(EncodedResource) line: 331	
				InputSource inputSource = new InputSource(inputStream);			/ SAX type	,
				if (encodedResource.getEncoding() != null) {
					inputSource.setEncoding(encodedResource.getEncoding());
				}
				return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
/s
	/**
	 * Actually load bean definitions from the specified XML file.
	 * @param inputSource the SAX InputSource to read from
	 * @param resource the resource descriptor for the XML file
	 * @return the number of bean definitions found
	 * @throws BeanDefinitionStoreException in case of loading or parsing errors
	 * @see #doLoadDocument
	 * @see #registerBeanDefinitions
	 */
XmlBeanDefinitionReader.doLoadBeanDefinitions(InputSource, Resource) line: 390	

			Document doc = doLoadDocument(inputSource, resource);
/s
	/**
	 * Actually load the specified document using the configured DocumentLoader.
	 * @param inputSource the SAX InputSource to read from
	 * @param resource the resource descriptor for the XML file
	 * @return the DOM Document
	 * @throws Exception when thrown from the DocumentLoader
	 * @see #setDocumentLoader
	 * @see DocumentLoader#loadDocument
	 */
XmlBeanDefinitionReader.doLoadDocument(InputSource, Resource) line: 428	

		return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());
/s
	/**
	 * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured
	 * XML parser.
	 */
DefaultDocumentLoader.loadDocument(InputSource, EntityResolver, ErrorHandler, int, boolean) line: 71	
		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);	
																/ com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl@728d4682
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
/s
	/**
	 * Create a JAXP DocumentBuilder that this bean definition reader
	 * will use for parsing XML documents. Can be overridden in subclasses,
	 * adding further initialization of the builder.
	 * @param factory the JAXP DocumentBuilderFactory that the DocumentBuilder
	 * should be created with
	 * @param entityResolver the SAX EntityResolver to use
	 * @param errorHandler the SAX ErrorHandler to use
	 * @return the JAXP DocumentBuilder
	 * @throws ParserConfigurationException if thrown by JAXP methods
	 */
DefaultDocumentLoader.createDocumentBuilder(DocumentBuilderFactory, EntityResolver, ErrorHandler) line: 130	
		DocumentBuilder docBuilder = factory.newDocumentBuilder();	/ com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl@629abc40
		if (entityResolver != null) {
			docBuilder.setEntityResolver(entityResolver);
entityResolver	ResourceEntityResolver  (id=1150)	
	dtdResolver	BeansDtdResolver  (id=1155)	
	resourceLoader	ClassPathXmlApplicationContext  (id=20)	
	schemaResolver	PluggableSchemaResolver  (id=1157)	

		if (errorHandler != null) {
			docBuilder.setErrorHandler(errorHandler);
errorHandler	SimpleSaxErrorHandler  (id=1012)	
		}
		return docBuilder;
/t
DefaultDocumentLoader.loadDocument(InputSource, EntityResolver, ErrorHandler, int, boolean) line: 76	
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
/d
		return builder.parse(inputSource);
/t
XmlBeanDefinitionReader.doLoadBeanDefinitions(InputSource, Resource) line: 391	
			Document doc = doLoadDocument(inputSource, resource);
/d

/ intermezzo

$ less knight.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
      http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="knight" class="sia.knights.BraveKnight">
    <constructor-arg ref="quest" />
  </bean>

  <bean id="quest" class="sia.knights.SlayDragonQuest">
    <constructor-arg value="#{T(System).out}" />
  </bean>

</beans>

/ Einde Intermezzo

doc	DeferredDocumentImpl  (id=1229)			/ [#document: null]
	children	Node[1]  (id=1308)	
		[0]	DeferredElementNSImpl  (id=1247)	/ [beans: null]	
			children	Node[5]  (id=1309)	
				[0]	DeferredTextImpl  (id=1258)	
				[1]	DeferredElementNSImpl  (id=1264)	/ [bean: null]	
					children	Node[3]  (id=1329)	
						[0]	DeferredTextImpl  (id=1290)	
						[1]	DeferredElementNSImpl  (id=1291)	/ [constructor-arg: null]	
							children	Node[0]  (id=1346)	
							attributes	Node[1]  (id=1348)	
								[0]	DeferredAttrNSImpl  (id=1349)		/ ref="quest"
						[2]	DeferredTextImpl  (id=1292)	
					attributes	Node[5]  (id=1330)	
						[0]	DeferredAttrNSImpl  (id=1295)	/ autowire="default"	
						[1]	DeferredAttrNSImpl  (id=1296)	/ autowire-candidate="default"	
						[2]	DeferredAttrNSImpl  (id=1297)	/ class="sia.knights.BraveKnight"	
						[3]	DeferredAttrNSImpl  (id=1298)	/ id="knight"	
						[4]	DeferredAttrNSImpl  (id=1299)	/ lazy-init="default"	
				[2]	DeferredTextImpl  (id=1265)	
				[3]	DeferredElementNSImpl  (id=1266)	/ [bean: null] 
					children	Node[3]  (id=1370)	
						[0]	DeferredTextImpl  (id=1371)	
						[1]	DeferredElementNSImpl  (id=1372)/ [constructor-arg: null]	
							children	Node[0]  (id=1383)	
							attributes	Node[1]  (id=1385)	
								[0]	DeferredAttrNSImpl  (id=1386)	/ value="#{T(System).out}"	
						[2]	DeferredTextImpl  (id=1373)	
					attributes	Node[5]  (id=1375)	
						[0]	DeferredAttrNSImpl  (id=1376)	/ autowire="default"	
						[1]	DeferredAttrNSImpl  (id=1377)	/ autowire-candidate="default"
						[2]	DeferredAttrNSImpl  (id=1378)	/ class="sia.knights.SlayDragonQuest"	
						[3]	DeferredAttrNSImpl  (id=1379)	/ id="quest"	
						[4]	DeferredAttrNSImpl  (id=1380)	/ lazy-init="default"	
				[4]	DeferredTextImpl  (id=1267)	
			attributes	Node[6]  (id=1310)	
				[0]	DeferredAttrNSImpl  (id=1272)	/ default-autowire="default"	
				[1]	DeferredAttrNSImpl  (id=1277)	/ default-lazy-init="default"	
				[2]	DeferredAttrNSImpl  (id=1278)	/ default-merge="default"	
				[3]	DeferredAttrNSImpl  (id=1279)	/ xmlns="http://www.springframework.org/schema/beans"	
				[4]	DeferredAttrNSImpl  (id=1280)	/ xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"	
				[5]	DeferredAttrNSImpl  (id=1281)	/ xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"	
	attributes	null	

			return registerBeanDefinitions(doc, resource);
/s
XmlBeanDefinitionReader.registerBeanDefinitions(Document, Resource) line: 505	
		int countBefore = getRegistry().getBeanDefinitionCount();
0
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
/s
DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(Document, XmlReaderContext) line: 110	
		Element root = doc.getDocumentElement();
[beans: null]
		doRegisterBeanDefinitions(root);
/s
DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(Element) line: 121	
		BeanDefinitionParserDelegate parent = this.delegate;
null
		this.delegate = createDelegate(this.readerContext, root, parent);
		parseBeanDefinitions(root, this.delegate);
/s
DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(Element, BeanDefinitionParserDelegate) line: 184	
		if (delegate.isDefaultNamespace(root)) {
			NodeList nl = root.getChildNodes();
			for (int i = 0; i < nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
[bean: null]
					if (delegate.isDefaultNamespace(ele)) {
						parseDefaultElement(ele, delegate);
/s
DefaultBeanDefinitionDocumentReader.parseDefaultElement(Element, BeanDefinitionParserDelegate) line: 205	
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
/s
DefaultBeanDefinitionDocumentReader.processBeanDefinition(Element, BeanDefinitionParserDelegate) line: 314	
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
/s
BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element, BeanDefinition) line: 452	
		String id = ele.getAttribute(ID_ATTRIBUTE);
"knight"
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
""
		if (containingBean == null) {
			checkNameUniqueness(beanName, aliases, ele);
/ TODO

		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
/s
BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element, String, BeanDefinition) line: 539	
		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
"sia.knights.BraveKnight"

			AbstractBeanDefinition bd = createBeanDefinition(className, parent);
/s
BeanDefinitionParserDelegate.createBeanDefinition(String, String) line: 686	
		return BeanDefinitionReaderUtils.createBeanDefinition(
				parentName, className, this.readerContext.getBeanClassLoader());

this.readerContext.getBeanClassLoader()==null	, want	,
this	BeanDefinitionParserDelegate  (id=111)	
	readerContext	XmlReaderContext  (id=89)	
		reader	XmlBeanDefinitionReader  (id=50)	
			beanClassLoader	null	
/s
BeanDefinitionReaderUtils.createBeanDefinition(String, String, ClassLoader) line: 60	
		GenericBeanDefinition bd = new GenericBeanDefinition();
		bd.setParentName(parentName);
null
		if (className != null) {
			if (classLoader != null) {
/n
			else {
				bd.setBeanClassName(className);
		return bd;
/t
BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element, String, BeanDefinition) line: 553	
			AbstractBeanDefinition bd = createBeanDefinition(className, parent);
/d
bd	GenericBeanDefinition  (id=140)	
	beanClass	"sia.knights.BraveKnight" (id=137)	
	...

			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
/s
BeanDefinitionParserDelegate.parseBeanDefinitionAttributes(Element, String, BeanDefinition, AbstractBeanDefinition) line: 595	
		if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
/n
		if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
/n
		String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
"default"
		if (DEFAULT_VALUE.equals(lazyInit)) {
			lazyInit = this.defaults.getLazyInit();
false

this	BeanDefinitionParserDelegate  (id=111)	
	defaults	DocumentDefaultsDefinition  (id=158)	
		autowire	"no" (id=229)	
		autowireCandidates	null	
		dependencyCheck	"" (id=110)	
		destroyMethod	null	
		initMethod	null	
		lazyInit	"false" (id=230)	
		merge	"false" (id=230)	
		source	null	
	...

		bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
bd	GenericBeanDefinition  (id=140)	
	beanClass	"sia.knights.BraveKnight" (id=137)	
	lazyInit	false	
	...

		String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
"default"
		bd.setAutowireMode(getAutowireMode(autowire));
/s
BeanDefinitionParserDelegate.getAutowireMode(String) line: 707	
		String att = attValue;
'default"
		if (DEFAULT_VALUE.equals(att)) {
			att = this.defaults.getAutowire();
"no"
		int autowire = AbstractBeanDefinition.AUTOWIRE_NO;
0
		// Else leave default value.
		return autowire;
/t
BeanDefinitionParserDelegate.parseBeanDefinitionAttributes(Element, String, BeanDefinition, AbstractBeanDefinition) line: 616	
		bd.setAutowireMode(getAutowireMode(autowire));
0
		String dependencyCheck = ele.getAttribute(DEPENDENCY_CHECK_ATTRIBUTE);
""
		bd.setDependencyCheck(getDependencyCheck(dependencyCheck));
/s
BeanDefinitionParserDelegate.getDependencyCheck(String) line: 729	
		String att = attValue;
""
		if (DEFAULT_VALUE.equals(att)) {
/n
		else {
			return AbstractBeanDefinition.DEPENDENCY_CHECK_NONE;
0
\t
BeanDefinitionParserDelegate.parseBeanDefinitionAttributes(Element, String, BeanDefinition, AbstractBeanDefinition) line: 619	
		bd.setDependencyCheck(getDependencyCheck(dependencyCheck));
/d
0
		if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
/n
		String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
"default"
		if ("".equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {
			String candidatePattern = this.defaults.getAutowireCandidates();
null
			if (candidatePattern != null) {
/n
		if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
/n
		if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
/n
		else {
			if (this.defaults.getInitMethod() != null) {
/n
		if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
/n
		else {
			if (this.defaults.getDestroyMethod() != null) {
/n
		if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
/n
		if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
/n
		return bd;
/t
BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element, String, BeanDefinition) line: 554	
			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
/d
			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
null
			parseMetaElements(ele, bd);
/ geen	,

			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

			parseConstructorArgElements(ele, bd);

  <bean id="knight" class="sia.knights.BraveKnight">
    <constructor-arg ref="quest" />
  </bean>

/s
BeanDefinitionParserDelegate.parseConstructorArgElements(Element, BeanDefinition) line: 751	
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i < nl.getLength(); i++) {
			Node node = nl.item(i);
			if (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {
				parseConstructorArgElement((Element) node, bd);
/s
BeanDefinitionParserDelegate.parseConstructorArgElement(Element, BeanDefinition) line: 835	
/=
	public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
ele [constructor-arg: null]
		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
""
		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
""
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
""
		if (StringUtils.hasLength(indexAttr)) {
/n
		else {
			try {

this	BeanDefinitionParserDelegate  (id=111)	
	parseState	ParseState  (id=131)	
		state	Stack<E>  (id=134)	
			[0]	BeanEntry  (id=398)	
				beanDefinitionName	"knight" (id=120)	
			[1]	ConstructorArgumentEntry  (id=392)	
				index	-1	

				Object value = parsePropertyValue(ele, bd, null);
/s
	/**
	 * Get the value of a property element. May be a list etc.
	 * Also used for constructor arguments, "propertyName" being null in this case.
	 */
BeanDefinitionParserDelegate.parsePropertyValue(Element, BeanDefinition, String) line: 965	
ele [constructor-arg: null]
propertyName null
		String elementName = (propertyName != null) ?
/n
						"<property> element for property '" + propertyName + "'" :
						"<constructor-arg> element";
"<constructor-arg> element"

		// Should only have one child element: ref, value, list, etc.
		NodeList nl = ele.getChildNodes();
		for (int i = 0; i < nl.getLength(); i++) {
/n
		boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
true
		boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
false
		if (hasRefAttribute) {
			String refName = ele.getAttribute(REF_ATTRIBUTE);
"quest"
			RuntimeBeanReference ref = new RuntimeBeanReference(refName);
ref	RuntimeBeanReference  (id=468)	
	beanName	"quest" (id=465)	
	source	null	
	toParent	false	
			return ref;
/t
BeanDefinitionParserDelegate.parseConstructorArgElement(Element, BeanDefinition) line: 876	
				Object value = parsePropertyValue(ele, bd, null);
/d
				ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
				valueHolder.setSource(extractSource(ele));
null
				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);

bd	GenericBeanDefinition  (id=140)	
	constructorArgumentValues	ConstructorArgumentValues  (id=153)	
		genericArgumentValues	LinkedList<E>  (id=517)	
			[0]	ConstructorArgumentValues$ValueHolder  (id=480)	
				converted	false	
				convertedValue	null	
				name	null	
				source	null	
				type	null	
				value	RuntimeBeanReference  (id=468)	
					beanName	"quest" (id=465)	
					source	null	
					toParent	false	
		indexedArgumentValues	LinkedHashMap<K,V>  (id=521)		/ leeg	,

/t
BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element, String, BeanDefinition) line: 561	
			parseConstructorArgElements(ele, bd);
/d
			parsePropertyElements(ele, bd);
/ geen	,
			parseQualifierElements(ele, bd);
/ geen	,
			bd.setResource(this.readerContext.getResource());
class path resource [META-INF/spring/knight.xml]
			bd.setSource(extractSource(ele));
null
/ TODO
			return bd;
/t
BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element, BeanDefinition) line: 475	
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
/d
aliases	ArrayList<E>  (id=121)	
beanName	"knight" (id=120)	
beanDefinition	GenericBeanDefinition  (id=140)	
	abstractFlag	false	
	attributes	LinkedHashMap<K,V>  (id=148)	
	autowireCandidate	true	
	autowireMode	0	
	beanClass	"sia.knights.BraveKnight" (id=137)	
	constructorArgumentValues	ConstructorArgumentValues  (id=153)	
		genericArgumentValues	LinkedList<E>  (id=517)	
			[0]	ConstructorArgumentValues$ValueHolder  (id=480)	
				converted	false	
				convertedValue	null	
				name	null	
				source	null	
				type	null	
				value	RuntimeBeanReference  (id=468)	
					beanName	"quest" (id=465)	
					source	null	
					toParent	false	
		indexedArgumentValues	LinkedHashMap<K,V>  (id=521)	
	dependencyCheck	0	
	dependsOn	null	
	description	null	
	destroyMethodName	null	
	enforceDestroyMethod	true	
	enforceInitMethod	true	
	factoryBeanName	null	
	factoryMethodName	null	
	initMethodName	null	
	lazyInit	false	
	lenientConstructorResolution	true	
	methodOverrides	MethodOverrides  (id=155)	
	nonPublicAccessAllowed	true	
	parentName	null	
	primary	false	
	propertyValues	MutablePropertyValues  (id=216)	
	qualifiers	LinkedHashMap<K,V>  (id=219)	
	resource	DefaultResourceLoader$ClassPathContextResource  (id=56)	
	role	0	
	scope	"" (id=110)	
	source	null	
	synthetic	false	

			String[] aliasesArray = StringUtils.toStringArray(aliases);
[]
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
/t
DefaultBeanDefinitionDocumentReader.processBeanDefinition(Element, BeanDefinitionParserDelegate) line: 315	
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
/d
bdHolder	BeanDefinitionHolder  (id=699)	
	aliases	String[0]  (id=694)	
	beanDefinition	GenericBeanDefinition  (id=140)	
	beanName	"knight" (id=120)	

this	DefaultBeanDefinitionDocumentReader  (id=78)	
	readerContext	XmlReaderContext  (id=1491)	
		reader	XmlBeanDefinitionReader  (id=50)	
			registry	DefaultListableBeanFactory  (id=1502)		<- registry = DefaultListableBeanFactory TODO is singleton? TODO


			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
/ TODO
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
/s
BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) line: 147	
		// Register bean definition under primary name.
		String beanName = definitionHolder.getBeanName();
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
/s
DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition) line: 721	
		synchronized (this.beanDefinitionMap) {
			oldBeanDefinition = this.beanDefinitionMap.get(beanName);
			if (oldBeanDefinition != null) {
/n
			else {
				this.beanDefinitionNames.add(beanName);
				this.frozenBeanDefinitionNames = null;
			}
			this.beanDefinitionMap.put(beanName, beanDefinition);
/t
BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) line: 151	
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
/d
DefaultBeanDefinitionDocumentReader.processBeanDefinition(Element, BeanDefinitionParserDelegate) line: 326	
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
/d
DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(Element, BeanDefinitionParserDelegate) line: 184	
		if (delegate.isDefaultNamespace(root)) {
			NodeList nl = root.getChildNodes();
			for (int i = 0; i < nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
[bean: null]
					if (delegate.isDefaultNamespace(ele)) {
						parseDefaultElement(ele, delegate);
/d
/ Dit was "knight"	,   "quest" gaat net zo	, slaan we over	, 
/t
DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(Element) line: 144	
		parseBeanDefinitions(root, this.delegate);
/d
		this.delegate = parent;
null
/t
XmlBeanDefinitionReader.registerBeanDefinitions(Document, Resource) line: 509	
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
		return getRegistry().getBeanDefinitionCount() - countBefore;
/t
XmlBeanDefinitionReader(AbstractBeanDefinitionReader).loadBeanDefinitions(Resource...) line: 179	
		for (Resource resource : resources) {
			counter += loadBeanDefinitions(resource);
/d
		}
		return counter;
2
/t
XmlBeanDefinitionReader(AbstractBeanDefinitionReader).loadBeanDefinitions(String, Set<Resource>) line: 217	
				int loadCount = loadBeanDefinitions(resources);
/d
				return loadCount;
/t
XmlBeanDefinitionReader(AbstractBeanDefinitionReader).loadBeanDefinitions(String...) line: 251	
		for (String location : locations) {
			counter += loadBeanDefinitions(location);
		}
		return counter;
/t
ClassPathXmlApplicationContext(AbstractXmlApplicationContext).loadBeanDefinitions(DefaultListableBeanFactory) line: 94	
		loadBeanDefinitions(beanDefinitionReader);
/d
/t
ClassPathXmlApplicationContext(AbstractRefreshableApplicationContext).refreshBeanFactory() line: 131	
			loadBeanDefinitions(beanFactory);
/d
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;
/t
ClassPathXmlApplicationContext(AbstractApplicationContext).obtainFreshBeanFactory() line: 543	
		refreshBeanFactory();
/d
/t
ClassPathXmlApplicationContext(AbstractApplicationContext).refresh() line: 454	
			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
/d
			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}



/ Einde SPRING XML



/ XML 

/ Lees	,
https://xerces.apache.org/xerces2-j/features.html

If you have created a DOM document builder or a SAX parser using the JAXP interfaces, the following instructions tell you how to set features on document builders and SAX parsers created from the JAXP interfaces.

The DocumentBuilderFactory interface contains a ...
The SAXParserFactory interface contains a ...

/ lees	, 
https://docs.oracle.com/javase/tutorial/jaxp/intro/index.html

The Java API for XML Processing (JAXP) is for processing XML data using applications written in the Java programming language. JAXP leverages the parser standards Simple API for XML Parsing (SAX) and Document Object Model (DOM) so that you can choose to parse your data as a stream of events or to build an object representation of it. JAXP also supports the Extensible Stylesheet Language Transformations (XSLT) standard, giving you control over the presentation of the data and enabling you to convert the data to other XML documents or to other formats, such as HTML. JAXP also provides namespace support, allowing you to work with DTDs that might otherwise have naming conflicts. Finally, as of version 1.4, JAXP implements the Streaming API for XML (StAX) standard.

Designed to be flexible, JAXP allows you to use any XML-compliant parser from within your application. It does this with what is called a pluggability layer, which lets you plug in an implementation of the SAX or DOM API. The pluggability layer also allows you to plug in an XSL processor, letting you control how your XML data is displayed.


/ WH jaxp is api 	, Xerces is impl	, 
/ Met Xerces kun je SAX of DOM	,


/ Einde XML

/ SPRING AUTOCONFIG

$ vi KnightConfig2.java

@Configuration
@ComponentScan
public class KnightConfig2 {
}

$ vi KnightMain2.java

public class MyKnightMain2 {

  public static void main(String[] args) throws Exception {
    ApplicationContext context=new AnnotationConfigApplicationContext(KnightConfig2.class);
    Knight knight = context.getBean(Knight.class);
    knight.embarkOnQuest();
  }

}

public class DefaultResourceLoader implements ResourceLoader {				/ this.classLoader
	public abstract class AbstractApplicationContext extends DefaultResourceLoader
		public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry { 			/ this.beanFactory
			public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
																						/ this.reader = new AnnotatedBeanDefinitionReader(this);
																						/ this.scanner = new ClassPathBeanDefinitionScanner(this);
			public class GenericWebApplicationContext extends GenericApplicationContext
			public class GenericXmlApplicationContext extends GenericApplicationContext {

public class DefaultResourceLoader implements ResourceLoader {
	public abstract class AbstractApplicationContext extends DefaultResourceLoader
		public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {
			public abstract class AbstractRefreshableConfigApplicationContext extends AbstractRefreshableApplicationContext
				public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {
					public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {


/s
/ stack	,
		StandardEnvironment.customizePropertySources(MutablePropertySources) line: 79	
			propertySources.addLast(new MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));
			propertySources.addLast(new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));
/cb
		StandardEnvironment(AbstractEnvironment).<init>() line: 122	
		StandardEnvironment.<init>() line: 54	
		AnnotationConfigApplicationContext(AbstractApplicationContext).createEnvironment() line: 504	
		AnnotationConfigApplicationContext(AbstractApplicationContext).getEnvironment() line: 291	
		AnnotationConfigApplicationContext(AbstractApplicationContext).getEnvironment() line: 126	
		AnnotatedBeanDefinitionReader.getOrCreateEnvironment(BeanDefinitionRegistry) line: 173	
/**
 * Convenient adapter for programmatic registration of annotated bean classes.
 * This is an alternative to {@link ClassPathBeanDefinitionScanner}, applying
 * the same resolution of annotations but for explicitly registered classes only.
 *
		AnnotatedBeanDefinitionReader.<init>(BeanDefinitionRegistry) line: 66	
			this(registry, getOrCreateEnvironment(registry));
/cb
		AnnotationConfigApplicationContext.<init>() line: 61	
			this.reader = new AnnotatedBeanDefinitionReader(this);			<-		/ WH voor @Bean
			this.scanner = new ClassPathBeanDefinitionScanner(this);				/ WH voor @Configuration , @ComponentScan/ WH voor @Bean
/cb
		AnnotationConfigApplicationContext.<init>(Class<?>...) line: 82	
			this();
/cb
		MyKnightMain2.main(String[]) line: 11	
/debug	,
		StandardEnvironment.customizePropertySources(MutablePropertySources) line: 79	
			propertySources.addLast(new MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));
/s
public abstract class AbstractEnvironment implements ConfigurableEnvironment {
	public Map<String, Object> getSystemProperties() {
		try {
			return (Map) System.getProperties();				/ JVM's properties	,
/t
		StandardEnvironment.customizePropertySources(MutablePropertySources) line: 79	
			propertySources.addLast(new MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));
/d
			propertySources.addLast(new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));
/s
public abstract class AbstractEnvironment implements ConfigurableEnvironment {
	public Map<String, Object> getSystemEnvironment() {
		try {
			return (Map) System.getenv();						/ OS's properties	,
/t
AnnotatedBeanDefinitionReader.<init>(BeanDefinitionRegistry) line: 66	
		this(registry, getOrCreateEnvironment(registry));
/ pd
/s
AnnotatedBeanDefinitionReader.<init>(BeanDefinitionRegistry, Environment) line: 79	
/=
	public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {

registry	AnnotationConfigApplicationContext  (id=20)	
environment	StandardEnvironment  (id=107)	
	activeProfiles	LinkedHashSet<E>  (id=113)	
	defaultProfiles	LinkedHashSet<E>  (id=114)	
	logger	Log4JLogger  (id=115)	
	propertyResolver	PropertySourcesPropertyResolver  (id=134)	
	propertySources	MutablePropertySources  (id=120)	
		logger	Log4JLogger  (id=115)	
		propertySourceList	CopyOnWriteArrayList<E>  (id=130)	
			[0]	MapPropertySource  (id=220)									/ JVM's properties
			[1]	SystemEnvironmentPropertySource  (id=307)					/ OS's properties

		this.registry = registry;
registry	AnnotationConfigApplicationContext  (id=25)	
		this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
/ TODO @Conditional
		AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
/s
AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry) line: 134	
		registerAnnotationConfigProcessors(registry, null);
/s
	/**
	 * Register all relevant annotation post processors in the given registry.
	 *
AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object) line: 148	

		DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
registry	AnnotationConfigApplicationContext  (id=25)	
	beanFactory	DefaultListableBeanFactory  (id=109)	

		if (beanFactory != null) {
			if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
				beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);

			if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
				beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
/=
/**
 * Complete implementation of the
 * {@link org.springframework.beans.factory.support.AutowireCandidateResolver} strategy
 * interface, providing support for qualifier annotations as well as for lazy resolution
 * driven by the {@link Lazy} annotation in the {@code context.annotation} package.
 *
public class ContextAnnotationAutowireCandidateResolver extends QualifierAnnotationAutowireCandidateResolver {

		Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<BeanDefinitionHolder>(4);

		if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) { / "org.springframework.context.annotation.internalConfigurationAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);

/ type hierarchy	,
public abstract class AttributeAccessorSupport implements AttributeAccessor, Serializable {
	public class BeanMetadataAttributeAccessor extends AttributeAccessorSupport implements BeanMetadataElement {
		public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
/s
RootBeanDefinition.<init>(Class<?>) line: 121	
		super();
/s
RootBeanDefinition.<init>(Class<?>) line: 121	
		this(null, null);
/s
RootBeanDefinition(AbstractBeanDefinition).<init>(ConstructorArgumentValues, MutablePropertyValues) line: 141	
	private String scope = SCOPE_DEFAULT;
""
	private boolean abstractFlag = false;
	private boolean lazyInit = false;
	private int autowireMode = AUTOWIRE_NO;
	private int dependencyCheck = DEPENDENCY_CHECK_NONE;
	private String[] dependsOn;
	private boolean autowireCandidate = true;
...
		setConstructorArgumentValues(cargs);
cargs=null
/s
		this.constructorArgumentValues =
				(constructorArgumentValues != null ? constructorArgumentValues : new ConstructorArgumentValues());
/t
		setPropertyValues(pvs);
pvs=null
/s
		this.propertyValues = (propertyValues != null ? propertyValues : new MutablePropertyValues());
/t
RootBeanDefinition.<init>(Class<?>) line: 57	
		super();
/d
		setBeanClass(beanClass);
beanClass	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=178)	MORGENOCHTEND V

this	RootBeanDefinition  (id=176)	
	abstractFlag	false	
	allowCaching	true	
	attributes	LinkedHashMap<K,V>  (id=189)	
	autowireCandidate	true	
	autowireMode	0	
	beanClass	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=178)	
	beforeInstantiationResolved	null	
	constructorArgumentLock	Object  (id=192)	
	constructorArgumentsResolved	false	
	constructorArgumentValues	ConstructorArgumentValues  (id=193)	
	decoratedDefinition	null	
	dependencyCheck	0	
	dependsOn	null	
	description	null	
	destroyMethodName	null	
	enforceDestroyMethod	true	
	enforceInitMethod	true	
	externallyManagedConfigMembers	null	
	externallyManagedDestroyMethods	null	
	externallyManagedInitMethods	null	
	factoryBeanName	null	
	factoryMethodName	null	
	initMethodName	null	
	isFactoryMethodUnique	false	
	lazyInit	false	
	lenientConstructorResolution	true	
	methodOverrides	MethodOverrides  (id=195)	
	nonPublicAccessAllowed	true	
	postProcessed	false	
	postProcessingLock	Object  (id=197)	
	preparedConstructorArguments	null	
	primary	false	
	propertyValues	MutablePropertyValues  (id=198)	
	qualifiedElement	null	
	qualifiers	LinkedHashMap<K,V>  (id=201)	
	resolvedConstructorArguments	null	
	resolvedConstructorOrFactoryMethod	null	
	resolvedFactoryMethodReturnType	null	
	resolvedTargetType	null	
	resource	null	
	role	0	
	scope	"" (id=185)	
	source	null	
	synthetic	false	
	targetType	null	

/ Intermezzo

/ we hadden hierboven bij XML

beanDefinition	GenericBeanDefinition  (id=140)	
	abstractFlag	false	
	attributes	LinkedHashMap<K,V>  (id=148)	
	autowireCandidate	true	
	autowireMode	0	
	beanClass	"sia.knights.BraveKnight" (id=137)	
	constructorArgumentValues	ConstructorArgumentValues  (id=153)	
		genericArgumentValues	LinkedList<E>  (id=517)	
			[0]	ConstructorArgumentValues$ValueHolder  (id=480)	
				converted	false	
				convertedValue	null	
				name	null	
				source	null	
				type	null	
				value	RuntimeBeanReference  (id=468)	
					beanName	"quest" (id=465)	
					source	null	
					toParent	false	
		indexedArgumentValues	LinkedHashMap<K,V>  (id=521)	
	dependencyCheck	0	
	dependsOn	null	
	description	null	
	destroyMethodName	null	
	enforceDestroyMethod	true	
	enforceInitMethod	true	
	factoryBeanName	null	
	factoryMethodName	null	
	initMethodName	null	
	lazyInit	false	
	lenientConstructorResolution	true	
	methodOverrides	MethodOverrides  (id=155)	
	nonPublicAccessAllowed	true	
	parentName	null	
	primary	false	
	propertyValues	MutablePropertyValues  (id=216)	
	qualifiers	LinkedHashMap<K,V>  (id=219)	
	resource	DefaultResourceLoader$ClassPathContextResource  (id=56)	
	role	0	
	scope	"" (id=110)	
	source	null	
	synthetic	false	

/ Einde Intermezzo

/t
AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object) line: 162	
		if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
			RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
/d
			def.setSource(source);
null
			beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
/s
AnnotationConfigUtils.registerPostProcessor(BeanDefinitionRegistry, RootBeanDefinition, String) line: 217	
		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
2
		registry.registerBeanDefinition(beanName, definition);
registry	AnnotationConfigApplicationContext  (id=25)	
/s
DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition) line: 853	
			else {
				// Still in startup registration phase
				this.beanDefinitionMap.put(beanName, beanDefinition);
beanName	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=165)	
				this.beanDefinitionNames.add(beanName);
				this.manualSingletonNames.remove(beanName);
			}
			this.frozenBeanDefinitionNames = null;
/t
AnnotationConfigUtils.registerPostProcessor(BeanDefinitionRegistry, RootBeanDefinition, String) line: 219	
		registry.registerBeanDefinition(beanName, definition);
/d
/ RESULT BEAN REGISTRY
registry	AnnotationConfigApplicationContext  (id=25)	
	beanFactory	DefaultListableBeanFactory  (id=109)	
		beanDefinitionMap	ConcurrentHashMap<K,V>  (id=232)	
			[0]	ConcurrentHashMap$WriteThroughEntry  (id=259)	
				key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=165)	
				value	RootBeanDefinition  (id=176)	
		beanDefinitionNames	ArrayList<E>  (id=246)	
			[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=165)	

		return new BeanDefinitionHolder(definition, beanName);
/t
AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object) line: 163	
		if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
			RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
/d
beanDefs	LinkedHashSet<E>  (id=174)	
	[0]	BeanDefinitionHolder  (id=315)	

		if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) { / "org.springframework.context.annotation.internalAutowiredAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
		}

		if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {	/ "org.springframework.context.annotation.internalRequiredAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
		}

/ intermezzo

public class AnnotationConfigUtils {
	private static final boolean jsr250Present =
			ClassUtils.isPresent("javax.annotation.Resource", AnnotationConfigUtils.class.getClassLoader());
true

	private static final boolean jpaPresent =
			ClassUtils.isPresent("javax.persistence.EntityManagerFactory", AnnotationConfigUtils.class.getClassLoader()) &&
			ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader());
false
/ TODO

/ Einde intermezzo

		// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
		if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {	/ "org.springframework.context.annotation.internalCommonAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
		}

		// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
		if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
/n

		if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) { / "org.springframework.context.event.internalEventListenerProcessor"
			RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
		}

		if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {		/ "org.springframework.context.event.internalEventListenerFactory"
			RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
		}

		return beanDefs;

registry	AnnotationConfigApplicationContext  (id=25)	
	beanFactory	DefaultListableBeanFactory  (id=109)	
		beanDefinitionMap	ConcurrentHashMap<K,V>  (id=232)	
			[0]	ConcurrentHashMap$WriteThroughEntry  (id=349)	
				key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=332)	
				value	RootBeanDefinition  (id=334)	
			[1]	ConcurrentHashMap$WriteThroughEntry  (id=350)	
				key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=329)	
				value	RootBeanDefinition  (id=331)	
			[2]	ConcurrentHashMap$WriteThroughEntry  (id=351)	
				key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=165)	
				value	RootBeanDefinition  (id=176)	
			[3]	ConcurrentHashMap$WriteThroughEntry  (id=352)	
				key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=324)	
				value	RootBeanDefinition  (id=327)	
			[4]	ConcurrentHashMap$WriteThroughEntry  (id=353)	
				key	"org.springframework.context.event.internalEventListenerProcessor" (id=338)	
				value	RootBeanDefinition  (id=340)	
			[5]	ConcurrentHashMap$WriteThroughEntry  (id=354)	
				key	"org.springframework.context.event.internalEventListenerFactory" (id=341)	
				value	RootBeanDefinition  (id=343)	
		beanDefinitionNames	ArrayList<E>  (id=246)	
			[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=165)	
			[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=324)	
			[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=329)	
			[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=332)	
			[4]	"org.springframework.context.event.internalEventListenerProcessor" (id=338)	
			[5]	"org.springframework.context.event.internalEventListenerFactory" (id=341)	

/t
AnnotationConfigApplicationContext.<init>() line: 62	
		this.reader = new AnnotatedBeanDefinitionReader(this);
/d
		this.scanner = new ClassPathBeanDefinitionScanner(this);
/s
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry) line: 83	
		this(registry, true);
/s
	/**
	 * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.
	 * <p>If the passed-in bean factory does not only implement the
	 * {@code BeanDefinitionRegistry} interface but also the {@code ResourceLoader}
	 * interface, it will be used as default {@code ResourceLoader} as well. This will
	 * usually be the case for {@link org.springframework.context.ApplicationContext}
	 * implementations.
	 * <p>If given a plain {@code BeanDefinitionRegistry}, the default {@code ResourceLoader}
	 * will be a {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.
	 * <p>If the passed-in bean factory also implements {@link EnvironmentCapable} its
	 * environment will be used by this reader.  Otherwise, the reader will initialize and
	 * use a {@link org.springframework.core.env.StandardEnvironment}. All
	 * {@code ApplicationContext} implementations are {@code EnvironmentCapable}, while
	 * normal {@code BeanFactory} implementations are not.
	 * @param registry the {@code BeanFactory} to load bean definitions into, in the form
	 * of a {@code BeanDefinitionRegistry}
	 * @param useDefaultFilters whether to include the default filters for the
	 * {@link org.springframework.stereotype.Component @Component},
	 * {@link org.springframework.stereotype.Repository @Repository},
	 * {@link org.springframework.stereotype.Service @Service}, and
	 * {@link org.springframework.stereotype.Controller @Controller} stereotype annotations
	 * @see #setResourceLoader
	 * @see #setEnvironment
	 */
	public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {
		this(registry, useDefaultFilters, getOrCreateEnvironment(registry));
	}
/s
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 136	
		super(useDefaultFilters, environment);
useDefaultFilters	true	
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 114	
		if (useDefaultFilters) {
			registerDefaultFilters();
/s
	/**
	 * Register the default filter for {@link Component @Component}.
	 * <p>This will implicitly register all annotations that have the
	 * {@link Component @Component} meta-annotation including the
	 * {@link Repository @Repository}, {@link Service @Service}, and
	 * {@link Controller @Controller} stereotype annotations.
	 * <p>Also supports Java EE 6's {@link javax.annotation.ManagedBean} and
	 * JSR-330's {@link javax.inject.Named} annotations, if available.
	 *
	 */
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 239	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));

/ intermezzo


/ in eclipse: ctrl+shift+t

/ we hebben ook, maar niet nodig	,
[eric@localhost Spring]$ git clone https://github.com/spring-projects/spring-framework.git

/**
 * Indicates that an annotated class is a "component".
 * Such classes are considered as candidates for auto-detection
 * when using annotation-based configuration and classpath scanning.
 *
 * <p>Other class-level annotations may be considered as identifying
 * a component as well, typically a special kind of component:
 * e.g. the {@link Repository @Repository} annotation or AspectJ's
 * {@link org.aspectj.lang.annotation.Aspect @Aspect} annotation.
 *
 * @author Mark Fisher
 * @since 2.5
 * @see Repository
 * @see Service
 * @see Controller
 * @see org.springframework.context.annotation.ClassPathBeanDefinitionScanner
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Component {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any
	 */
	String value() default "";

}

/**
 * Indicates that an annotated class is a "Controller" (e.g. a web controller).
 *
 * <p>This annotation serves as a specialization of {@link Component @Component},
 * allowing for implementation classes to be autodetected through classpath scanning.
 * It is typically used in combination with annotated handler methods based on the
 * {@link org.springframework.web.bind.annotation.RequestMapping} annotation.
 *
 * @author Arjen Poutsma
 * @author Juergen Hoeller
 * @since 2.5
 * @see Component
 * @see org.springframework.web.bind.annotation.RequestMapping
 * @see org.springframework.context.annotation.ClassPathBeanDefinitionScanner
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any
	 */
	String value() default "";

}

/ Einde intermezzo

/ we waren in,	
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 239	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));											<- Let op Component.class	,
/s
/**
 * A simple filter which matches classes with a given annotation,
 * checking inherited annotations as well.
 *
	/**
	 * Create a new AnnotationTypeFilter for the given annotation type.
	 * This filter will also match meta-annotations. To disable the
	 * meta-annotation matching, use the constructor that accepts a
	 * '{@code considerMetaAnnotations}' argument. The filter will
	 * not match interfaces.
	 * @param annotationType the annotation type to match
	 */
	public AnnotationTypeFilter(Class<? extends Annotation> annotationType) {
		this(annotationType, true, false);				/ annotationType	Class<T> (org.springframework.stereotype.Component) (id=867)	
/s
AnnotationTypeFilter.<init>(Class<Annotation>, boolean, boolean) line: 74	
	/**
	 * Create a new {@link AnnotationTypeFilter} for the given annotation type.
	 * @param annotationType the annotation type to match
	 * @param considerMetaAnnotations whether to also match on meta-annotations
	 * @param considerInterfaces whether to also match interfaces
	 */
	public AnnotationTypeFilter(Class<? extends Annotation> annotationType, boolean considerMetaAnnotations, boolean considerInterfaces) {
annotationType	Class<T> (org.springframework.stereotype.Component) (id=686)	
		super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces); / annotationType    Class<T> (org.springframework.stereotype.Component) (id=867)
/s
Class<T>.isAnnotationPresent(Class<Annotation>) line: 3232	
this	Class<T> (org.springframework.stereotype.Component) (id=686)	
annotationClass	Class<T> (java.lang.annotation.Inherited) (id=690)	

        return getAnnotation(annotationClass) != null;
/s
Class<T>.getAnnotation(Class<A>) line: 3216					/ Java
/=
    public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
        return (A) annotations.get(annotationClass);

this	Class<T> (org.springframework.stereotype.Component) (id=686)	
	annotations	LinkedHashMap<K,V>  (id=705)	
		[0]	LinkedHashMap$Entry<K,V>  (id=712)	
			key	Class<T> (java.lang.annotation.Target) (id=718)	
			value	$Proxy2  (id=719)	
		[1]	LinkedHashMap$Entry<K,V>  (id=713)	
			key	Class<T> (java.lang.annotation.Retention) (id=724)	
			value	$Proxy1  (id=725)	
		[2]	LinkedHashMap$Entry<K,V>  (id=714)	
			key	Class<T> (java.lang.annotation.Documented) (id=728)	
			value	$Proxy3  (id=729)	
/ Klopt	, see @interface Component hierboven	,

/t
AnnotationTypeFilter.<init>(Class<Annotation>, boolean, boolean) line: 74	
		super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces);
/pd
/s
AnnotationTypeFilter(AbstractTypeHierarchyTraversingFilter).<init>(boolean, boolean) line: 49	
		this.considerInherited = considerInherited;
false
		this.considerInterfaces = considerInterfaces;
false
/t
AnnotationTypeFilter.<init>(Class<Annotation>, boolean, boolean) line: 75	
		super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces);
/d
		this.annotationType = annotationType;			/ interface org.springframework.stereotype.Component
		this.considerMetaAnnotations = considerMetaAnnotations;	/ true
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 240	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
/d
this	ClassPathBeanDefinitionScanner  (id=661)	
	includeFilters	LinkedList<E>  (id=792)	
		[0]	AnnotationTypeFilter  (id=683)	
			annotationType	Class<T> (org.springframework.stereotype.Component) (id=686)	
			considerInherited	false	
			considerInterfaces	false	
			considerMetaAnnotations	true	
			logger	Log4JLogger  (id=806)	

		ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
		try {
			this.includeFilters.add(new AnnotationTypeFilter(
					((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));
		catch (ClassNotFoundException ex) {
			// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.
		}

/ Lees	,
http://stackoverflow.com/questions/11986847/java-ee-6-javax-annotation-managedbean-vs-javax-inject-named-vs-javax-faces
http://stackoverflow.com/questions/8887140/jsf-request-scoped-bean-keeps-recreating-new-stateful-session-beans-on-every-req

		try {
			this.includeFilters.add(new AnnotationTypeFilter(
					((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));
		}
		catch (ClassNotFoundException ex) {
			// JSR-330 API not available - simply skip.
		}
/ TODO is er wel	, 

@Inject instead of Springโs @Autowired to inject a bean.
@Named instead of Springโs @Component to declare a bean.

/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 118	
			registerDefaultFilters();
/d
/t
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 66	
		super(useDefaultFilters, environment);
/d
	private BeanDefinitionDefaults beanDefinitionDefaults = new BeanDefinitionDefaults();
this	ClassPathBeanDefinitionScanner  (id=856)	
	beanDefinitionDefaults	BeanDefinitionDefaults  (id=916)	
		autowireMode	0	
		dependencyCheck	0	
		destroyMethodName	null	
		initMethodName	null	
		lazyInit	false	

	private BeanNameGenerator beanNameGenerator = new AnnotationBeanNameGenerator();
this	ClassPathBeanDefinitionScanner  (id=856)	
	scopeMetadataResolver	AnnotationScopeMetadataResolver  (id=1038)	
		defaultProxyMode	ScopedProxyMode  (id=1040)	
			name	"NO" (id=1042)	
			ordinal	1	
		scopeAnnotationType	Class<T> (org.springframework.context.annotation.Scope) (id=1041)	

	private boolean includeAnnotationConfig = true;

		this.registry = registry;

		// Determine ResourceLoader to use.
		if (this.registry instanceof ResourceLoader) {
			setResourceLoader((ResourceLoader) this.registry);
/s
	/**
	 * Set the ResourceLoader to use for resource locations.
	 * This will typically be a ResourcePatternResolver implementation.
	 * <p>Default is PathMatchingResourcePatternResolver, also capable of
	 * resource pattern resolving through the ResourcePatternResolver interface.
	 * @see org.springframework.core.io.support.ResourcePatternResolver
	 * @see org.springframework.core.io.support.PathMatchingResourcePatternResolver
	 */
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);	/ = resourceLoader AnnotationConfigApplicationContext  (id=25)	

		this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);

this	ClassPathBeanDefinitionScanner  (id=856)	
	metadataReaderFactory	CachingMetadataReaderFactory  (id=1073)	
		cacheLimit	256	
		metadataReaderCache	CachingMetadataReaderFactory$1  (id=1076)	
		resourceLoader	AnnotationConfigApplicationContext  (id=25)	
	resourcePatternResolver	AnnotationConfigApplicationContext  (id=25)	

/t
AnnotationConfigApplicationContext.<init>() line: 63	
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
/d
/t
AnnotationConfigApplicationContext.<init>(Class<?>...) line: 83	
		this();
/d
		register(annotatedClasses); / [class sia.knights.config.KnightConfig2]
/s
AnnotationConfigApplicationContext.register(Class<?>...) line: 150	
		this.reader.register(annotatedClasses);
/s
AnnotatedBeanDefinitionReader.register(Class<?>...) line: 122	
		for (Class<?> annotatedClass : annotatedClasses) {
			registerBean(annotatedClass);
/s
AnnotatedBeanDefinitionReader.registerBean(Class<?>) line: 127	
		registerBean(annotatedClass, null, (Class<? extends Annotation>[]) null);
/s
AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 137	
		AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
/s
AnnotatedGenericBeanDefinition.<init>(Class<?>) line: 54	
/s
AnnotatedGenericBeanDefinition(GenericBeanDefinition).<init>() line: 56	
		super();
/s
AnnotatedGenericBeanDefinition(AbstractBeanDefinition).<init>() line: 193	
		this(null, null);
/s
AnnotatedGenericBeanDefinition(AbstractBeanDefinition).<init>(ConstructorArgumentValues, MutablePropertyValues) line: 200	
/s
AnnotatedGenericBeanDefinition(BeanMetadataAttributeAccessor).<init>() line: 30	
/s
AnnotatedGenericBeanDefinition(AttributeAccessorSupport).<init>() line: 39	
/t
AnnotatedGenericBeanDefinition(AbstractBeanDefinition).<init>(ConstructorArgumentValues, MutablePropertyValues) line: 201	
/d
		setConstructorArgumentValues(cargs);		/ cargs=null
/s
AnnotatedGenericBeanDefinition(AbstractBeanDefinition).setConstructorArgumentValues(ConstructorArgumentValues) line: 690	
		this.constructorArgumentValues =
				(constructorArgumentValues != null ? constructorArgumentValues : new ConstructorArgumentValues());
/t
AnnotatedGenericBeanDefinition(AbstractBeanDefinition).<init>(ConstructorArgumentValues, MutablePropertyValues) line: 202	
		setConstructorArgumentValues(cargs);
/d
		setPropertyValues(pvs);	 pvs=null
/s
AnnotatedGenericBeanDefinition(AbstractBeanDefinition).setPropertyValues(MutablePropertyValues) line: 713	
		this.propertyValues = (propertyValues != null ? propertyValues : new MutablePropertyValues());
/t
AnnotatedGenericBeanDefinition.<init>(Class<?>) line: 55	
/d
		setBeanClass(beanClass);	/ beanClass	Class<T> (sia.knights.config.KnightConfig2) (id=1215)	
		this.metadata = new StandardAnnotationMetadata(beanClass, true);
/s
StandardAnnotationMetadata.<init>(Class<?>, boolean) line: 67	

		super(introspectedClass);
this	StandardAnnotationMetadata  (id=1244)	
	introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=1215)	

		this.annotations = introspectedClass.getAnnotations();
		this.nestedAnnotationsAsMap = nestedAnnotationsAsMap;

/ Intermezzo

@Configuration
@ComponentScan
public class KnightConfig2 {
}

/ Einde Intermezzo

this	StandardAnnotationMetadata  (id=1244)	
	annotations	Annotation[2]  (id=1312)	
		[0]	$Proxy4  (id=1299)	
			h	AnnotationInvocationHandler  (id=1303)	
				memberMethods	null	
				memberValues	LinkedHashMap<K,V>  (id=1305)	
				type	Class<T> (org.springframework.context.annotation.Configuration) (id=1266)	
		[1]	$Proxy5  (id=1301)	
			h	AnnotationInvocationHandler  (id=1307)	
				memberMethods	null	
				memberValues	LinkedHashMap<K,V>  (id=1309)	
				type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=1270)	
	introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=1215)	
	nestedAnnotationsAsMap true	

/t
AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 138	
		AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
/d
abd	AnnotatedGenericBeanDefinition  (id=1233)	
	...
	metadata	StandardAnnotationMetadata  (id=1244)	
		annotations	Annotation[2]  (id=1312)	
			[0]	$Proxy4  (id=1299)	
				h	AnnotationInvocationHandler  (id=1303)	
					memberMethods	null	
					memberValues	LinkedHashMap<K,V>  (id=1305)	
					type	Class<T> (org.springframework.context.annotation.Configuration) (id=1266)	
			[1]	$Proxy5  (id=1301)	
				h	AnnotationInvocationHandler  (id=1307)	
					memberMethods	null	
					memberValues	LinkedHashMap<K,V>  (id=1309)	
					type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=1270)	
		introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=1215)	
		nestedAnnotationsAsMap	true	

		ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
/s
AnnotationScopeMetadataResolver.resolveScopeMetadata(BeanDefinition) line: 79	

		ScopeMetadata metadata = new ScopeMetadata();
metadata	ScopeMetadata  (id=1488)	
	scopedProxyMode	ScopedProxyMode  (id=1040)	
		name	"NO" (id=1042)	
		ordinal	1	
	scopeName	"singleton" (id=1489)	

		if (definition instanceof AnnotatedBeanDefinition) {
			AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType);
/s
AnnotationConfigUtils.attributesFor(AnnotatedTypeMetadata, Class<?>) line: 276	
		return attributesFor(metadata, annotationClass.getName()); / annotationClass Class<T> (org.springframework.context.annotation.Scope) (id=1041)	
/s
AnnotationConfigUtils.attributesFor(AnnotatedTypeMetadata, String) line: 280	
		return AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(annotationClassName, false));
/s
StandardAnnotationMetadata.getAnnotationAttributes(String, boolean) line: 117	
		return (this.annotations.length > 0 ? AnnotatedElementUtils.getMergedAnnotationAttributes(
				getIntrospectedClass(), annotationName, classValuesAsString, this.nestedAnnotationsAsMap) : null);
/s
	/**
	 * Get the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element} and
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * <p>Attributes from lower levels in the annotation hierarchy override attributes
	 * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are
	 * fully supported, both within a single annotation and within the annotation hierarchy.
	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by
	 * this method will stop searching the annotation hierarchy once the first annotation
	 * of the specified {@code annotationName} has been found. As a consequence,
	 * additional annotations of the specified {@code annotationName} will be ignored.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @param classValuesAsString whether to convert Class references into Strings or to
	 * preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances
	 * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
AnnotatedElementUtils.getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 394	
/=
	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {
element	Class<T> (sia.knights.config.KnightConfig2) (id=1215)	
annotationName	"org.springframework.context.annotation.Scope" (id=1503)	
classValuesAsString	false	
nestedAnnotationsAsMap	true	

		AnnotationAttributes attributes = searchWithGetSemantics(element, null, annotationName,
				new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap));
/s

/ intermezzo

/ Lees	, 
https://www.intertech.com/Blog/spring-4-meta-annotations/
A meta annotation is an annotation that can be applied to another annotation. 

/ Dus WH is Component een meta-annotation	, 

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component											<-			/ @Component kan ook classes	, maar ook op annotations	,
public @interface Repository {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any
	 */
	String value() default "";

}

/ Einde intermezzo

/s
	/**
	 * Search for annotations of the specified {@code annotationName} or
	 * {@code annotationType} on the specified {@code element}, following
	 * <em>get semantics</em>.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @param annotationName the fully qualified class name of the annotation
	 * type to find (as an alternative to {@code annotationType})
	 * @param processor the processor to delegate to
	 * @return the result of the processor, potentially {@code null}
	 */
AnnotatedElementUtils.searchWithGetSemantics(AnnotatedElement, Class<Annotation>, String, Processor<T>) line: 881	
		return searchWithGetSemantics(element, annotationType, annotationName, null, processor);
/s
	/**
	 * Search for annotations of the specified {@code annotationName} or
	 * {@code annotationType} on the specified {@code element}, following
	 * <em>get semantics</em>.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @param annotationName the fully qualified class name of the annotation
	 * type to find (as an alternative to {@code annotationType})
	 * @param containerType the type of the container that holds repeatable
	 * annotations, or {@code null} if the annotation is not repeatable
	 * @param processor the processor to delegate to
	 * @return the result of the processor, potentially {@code null}
	 * @since 4.3
	 */
AnnotatedElementUtils.searchWithGetSemantics(AnnotatedElement, Class<Annotation>, String, Class<Annotation>, Processor<T>) line: 902	
		try {
			return searchWithGetSemantics(element, annotationType, annotationName, containerType, processor,
					new HashSet<AnnotatedElement>(), 0);
/s
	/**
	 * Perform the search algorithm for the {@link #searchWithGetSemantics}
	 * method, avoiding endless recursion by tracking which annotated elements
	 * have already been <em>visited</em>.
	 * <p>The {@code metaDepth} parameter is explained in the
	 * {@link Processor#process process()} method of the {@link Processor} API.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @param annotationName the fully qualified class name of the annotation
	 * type to find (as an alternative to {@code annotationType})
	 * @param containerType the type of the container that holds repeatable
	 * annotations, or {@code null} if the annotation is not repeatable
	 * @param processor the processor to delegate to
	 * @param visited the set of annotated elements that have already been visited
	 * @param metaDepth the meta-depth of the annotation
	 * @return the result of the processor, potentially {@code null}
	 */
AnnotatedElementUtils.searchWithGetSemantics(AnnotatedElement, Class<Annotation>, String, Class<Annotation>, Processor<T>, Set<AnnotatedElement>, int) line: 938	
	private static <T> T searchWithGetSemantics(AnnotatedElement element, Class<? extends Annotation> annotationType,
			String annotationName, Class<? extends Annotation> containerType, Processor<T> processor,
			Set<AnnotatedElement> visited, int metaDepth) {
element	Class<T> (sia.knights.config.KnightConfig2) (id=64)	
annotationType	null	
annotationName	"org.springframework.context.annotation.Scope" (id=71)	
containerType	null	
processor	AnnotatedElementUtils$MergedAnnotationAttributesProcessor  (id=92)	
visited	HashSet<E>  (id=94)									[class sia.knights.config.KnightConfig2]											
metaDepth	0	
declaredAnnotations	Arrays$ArrayList<E>  (id=105)	
	[0]	$Proxy4  (id=114)	
		h	AnnotationInvocationHandler  (id=123)	
			memberMethods	Method[1]  (id=127)	
			memberValues	LinkedHashMap<K,V>  (id=130)	
			type	Class<T> (org.springframework.context.annotation.Configuration) (id=117)	
	[1]	$Proxy5  (id=115)	
		h	AnnotationInvocationHandler  (id=135)	
			memberMethods	Method[11]  (id=138)	
			memberValues	LinkedHashMap<K,V>  (id=139)	
			type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=121)	

		if (visited.add(element)) {								/ element Class<T> (sia.knights.config.KnightConfig2)	, met 2 annotations	,
			try {
				// Start searching within locally declared annotations
				List<Annotation> declaredAnnotations = Arrays.asList(element.getDeclaredAnnotations()); / @Configuration, @ComponentScan
				T result = searchWithGetSemanticsInAnnotations(element, declaredAnnotations,		
						annotationType, annotationName, containerType, processor, visited, metaDepth);
/s
	/**
	 * This method is invoked by {@link #searchWithGetSemantics} to perform
	 * the actual search within the supplied list of annotations.
	 * <p>This method should be invoked first with locally declared annotations
	 * and then subsequently with inherited annotations, thereby allowing
	 * local annotations to take precedence over inherited annotations.
	 * <p>The {@code metaDepth} parameter is explained in the
	 * {@link Processor#process process()} method of the {@link Processor} API.
	 * @param element the element that is annotated with the supplied
	 * annotations, used for contextual logging; may be {@code null} if unknown
	 * @param annotations the annotations to search in
	 * @param annotationType the annotation type to find
	 * @param annotationName the fully qualified class name of the annotation
	 * type to find (as an alternative to {@code annotationType})
	 * @param containerType the type of the container that holds repeatable
	 * annotations, or {@code null} if the annotation is not repeatable
	 * @param processor the processor to delegate to
	 * @param visited the set of annotated elements that have already been visited
	 * @param metaDepth the meta-depth of the annotation
	 * @return the result of the processor, potentially {@code null}
	 * @since 4.2
	 */
AnnotatedElementUtils.searchWithGetSemanticsInAnnotations(AnnotatedElement, List<Annotation>, Class<Annotation>, String, Class<Annotation>, Processor<T>, Set<AnnotatedElement>, int) line: 996	

		// Search in annotations
		for (Annotation annotation : annotations) {								/ @Configuration, @ComponentScan
			if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation)) {
				if (annotation.annotationType() == annotationType ||	/ interface org.springframework.context.annotation.Configuration == null NEE
						annotation.annotationType().getName().equals(annotationName) ||	/ .equals(org.springframework.context.annotation.Scope) NEE
						processor.alwaysProcesses()) {
/n
				// Repeatable annotations in container?
				else if (annotation.annotationType() == containerType) {		/ containerType==null
/n
		// Recursively search in meta-annotations
		for (Annotation annotation : annotations) {								/ @Configuration, @ComponentScan
			if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation)) {
				T result = searchWithGetSemantics(annotation.annotationType(), annotationType,
						annotationName, containerType, processor, visited, metaDepth + 1);		/ annotationName	"org.springframework.context.annotation.Scope" (id=70)	
null
/ TODO
		return null;
/t
AnnotatedElementUtils.searchWithGetSemantics(AnnotatedElement, Class<Annotation>, String, Class<Annotation>, Processor<T>, Set<AnnotatedElement>, int) line: 940	
		if (visited.add(element)) {
			try {
				// Start searching within locally declared annotations
				List<Annotation> declaredAnnotations = Arrays.asList(element.getDeclaredAnnotations());
				T result = searchWithGetSemanticsInAnnotations(element, declaredAnnotations,	/ element	Class<T> (sia.knights.config.KnightConfig2) (id=64)	
						annotationType, annotationName, containerType, processor, visited, metaDepth);	/ annotationName	"org.springframework.context.annotation.Scope" (id=70)	

/d
null
				if (element instanceof Class) { // otherwise getAnnotations doesn't return anything new
					List<Annotation> inheritedAnnotations = new ArrayList<Annotation>();
					for (Annotation annotation : element.getAnnotations()) {
						if (!declaredAnnotations.contains(annotation)) {
/n
					// Continue searching within inherited annotations
					result = searchWithGetSemanticsInAnnotations(element, inheritedAnnotations,	/ inheritedAnnotations=[]
							annotationType, annotationName, containerType, processor, visited, metaDepth);
null
		return null;
/t
AnnotatedElementUtils.getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 397	
		AnnotationAttributes attributes = searchWithGetSemantics(element, null, annotationName,
				new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap));
/d
null
		AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);
/ niets	, want attributes==null

		return attributes;
/t
AnnotationScopeMetadataResolver.resolveScopeMetadata(BeanDefinition) line: 84	
/=
	public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {
/=
definition	AnnotatedGenericBeanDefinition  (id=187)	
	beanClass	Class<T> (sia.knights.config.KnightConfig2) (id=64)	

		ScopeMetadata metadata = new ScopeMetadata();
		if (definition instanceof AnnotatedBeanDefinition) {
			AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(
					annDef.getMetadata(), this.scopeAnnotationType);
/d
null
			if (attributes != null) {
/n
		return metadata;		/ defaults	,
/t
AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 142	
		ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
/d
abd	AnnotatedGenericBeanDefinition  (id=187)	
	...
	beanClass	Class<T> (sia.knights.config.KnightConfig2) (id=64)					/ KnightConfig2 is ook een bean TODO
	metadata	StandardAnnotationMetadata  (id=71)	
		annotations	Annotation[2]  (id=223)											/ @Configuration, @ComponentScan	,
		introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=64)	
		nestedAnnotationsAsMap	true	

scopeMetadata	ScopeMetadata  (id=193)	
	scopedProxyMode	ScopedProxyMode  (id=200)	
		name	"NO" (id=277)	
		ordinal	1	
	scopeName	"singleton" (id=203)	

/ Intermezzo

/ we zijn nog in register([KnightConfig2.class])
 /stack
	AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 138	
	AnnotatedBeanDefinitionReader.registerBean(Class<?>) line: 127	
	AnnotatedBeanDefinitionReader.register(Class<?>...) line: 122	
	AnnotationConfigApplicationContext.register(Class<?>...) line: 150	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 83	
		this();
/d
		register(annotatedClasses);		<-
		refresh();
	MyKnightMain2.main(String[]) line: 11	
    	ApplicationContext context=new AnnotationConfigApplicationContext(KnightConfig2.class);			<-
    	Knight knight = context.getBean(Knight.class);
    	knight.embarkOnQuest();


/ Einde Intermezzo

		abd.setScope(scopeMetadata.getScopeName());
		String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
name==null
/ Het gaat om de bean KnightConfig2	, 
abd	AnnotatedGenericBeanDefinition  (id=1083)	
	beanClass	Class<T> (sia.knights.config.KnightConfig2) (id=1055)	
	metadata	StandardAnnotationMetadata  (id=1093)	
		annotations	Annotation[2]  (id=1110)	
			[0]	$Proxy5  (id=1112)	
				h	AnnotationInvocationHandler  (id=1165)	
					type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=1115)	
			[1]	$Proxy4  (id=1113)	
				h	AnnotationInvocationHandler  (id=1178)	
					type	Class<T> (org.springframework.context.annotation.Configuration) (id=1117)	
/s
AnnotationBeanNameGenerator.generateBeanName(BeanDefinition, BeanDefinitionRegistry) line: 70	
		if (definition instanceof AnnotatedBeanDefinition) {										/ KnightConfig2
			String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);
/s
AnnotationBeanNameGenerator.determineBeanNameFromAnnotation(AnnotatedBeanDefinition) line: 90	
		AnnotationMetadata amd = annotatedDef.getMetadata();
amd	StandardAnnotationMetadata  (id=1093)	
	annotations	Annotation[2]  (id=1110)	
		[0]	$Proxy5  (id=1112)		@Configuration
		[1]	$Proxy4  (id=1113)		@ComponentScan
	introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=1055)	
	nestedAnnotationsAsMap	true	

		Set<String> types = amd.getAnnotationTypes(); / [org.springframework.context.annotation.ComponentScan, org.springframework.context.annotation.Configuration]
		String beanName = null;
		for (String type : types) {
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);	/ type=ComponentScan
/s
AnnotationConfigUtils.attributesFor(AnnotatedTypeMetadata, String) line: 280	
		return AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(annotationClassName, false));
/s
StandardAnnotationMetadata.getAnnotationAttributes(String, boolean) line: 117	
		return (this.annotations.length > 0 ? AnnotatedElementUtils.getMergedAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, this.nestedAnnotationsAsMap) : null);
/s
AnnotatedElementUtils.getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 394	
element	Class<T> (sia.knights.config.KnightConfig2) (id=64)	
annotationName	"org.springframework.context.annotation.Configuration" (id=287)	
classValuesAsString	false	
nestedAnnotationsAsMap	true	
		AnnotationAttributes attributes = searchWithGetSemantics(element, null, annotationName, new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap));

element	Class<T> (sia.knights.config.KnightConfig2) (id=1055)	
annotationName	"org.springframework.context.annotation.ComponentScan" (id=1280)	
classValuesAsString	false	
nestedAnnotationsAsMap	true	

attributes	AnnotationAttributes  (id=1287)	
	[0]	LinkedHashMap$Entry<K,V>  (id=1290)	
		key	"basePackages" (id=1301)	
		value	AnnotationUtils$DefaultValueHolder  (id=1302)	
			defaultValue	String[0]  (id=1309)	
	[1]	LinkedHashMap$Entry<K,V>  (id=1291)	
		key	"resourcePattern" (id=1304)	
		value	AnnotationUtils$DefaultValueHolder  (id=1305)	
			defaultValue	"**/*.class" (id=1311)	
	[2]	LinkedHashMap$Entry<K,V>  (id=1292)	
		key	"includeFilters" (id=1306)	
		value	AnnotationUtils$DefaultValueHolder  (id=1307)	
			defaultValue	ComponentScan$Filter[0]  (id=1313)	
	[3]	LinkedHashMap$Entry<K,V>  (id=1293)	
		key	"excludeFilters" (id=1315)	
		value	AnnotationUtils$DefaultValueHolder  (id=1316)	
			defaultValue	ComponentScan$Filter[0]  (id=1318)	
	[4]	LinkedHashMap$Entry<K,V>  (id=1294)	
		key	"useDefaultFilters" (id=1320)	
		value	AnnotationUtils$DefaultValueHolder  (id=1321)	
			defaultValue	Boolean  (id=1323)	
				value	true	
	[5]	LinkedHashMap$Entry<K,V>  (id=1295)	
		key	"scopeResolver" (id=1326)	
		value	AnnotationUtils$DefaultValueHolder  (id=1327)	
			defaultValue	Class<T> (org.springframework.context.annotation.AnnotationScopeMetadataResolver) (id=684)	
	[6]	LinkedHashMap$Entry<K,V>  (id=1296)	
		key	"scopedProxy" (id=1330)	
		value	AnnotationUtils$DefaultValueHolder  (id=1331)	
			defaultValue	ScopedProxyMode  (id=1333)	
				name	"DEFAULT" (id=1335)	
				ordinal	0	
	[7]	LinkedHashMap$Entry<K,V>  (id=1297)	
		key	"nameGenerator" (id=1337)	
		value	AnnotationUtils$DefaultValueHolder  (id=1338)	
			defaultValue	Class<T> (org.springframework.beans.factory.support.BeanNameGenerator) (id=568)	
	[8]	LinkedHashMap$Entry<K,V>  (id=1298)	
		key	"basePackageClasses" (id=1341)	
		value	AnnotationUtils$DefaultValueHolder  (id=1342)	
			defaultValue	Class<T>[0]  (id=1344)	
	[9]	LinkedHashMap$Entry<K,V>  (id=1299)	
		key	"lazyInit" (id=1346)	
		value	AnnotationUtils$DefaultValueHolder  (id=1347)	
			defaultValue	Boolean  (id=1350)	
				value	false	
	[10]	LinkedHashMap$Entry<K,V>  (id=1300)	
		key	"value" (id=1353)	
		value	AnnotationUtils$DefaultValueHolder  (id=1354)	
			defaultValue	String[0]  (id=1358)	
/ TODO
		return attributes;

/ Intermezzo

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	/**
	 * Alias for {@link #basePackages}.
	 * <p>Allows for more concise annotation declarations if no other attributes
	 * are needed &mdash; for example, {@code @ComponentScan("org.my.pkg")}
	 * instead of {@code @ComponentScan(basePackages = "org.my.pkg")}.
	 */
	@AliasFor("basePackages")
	String[] value() default {};
	...
}

/ Einde Intermezzo
/t
AnnotationBeanNameGenerator.determineBeanNameFromAnnotation(AnnotatedBeanDefinition) line: 91	
		AnnotationMetadata amd = annotatedDef.getMetadata();
		Set<String> types = amd.getAnnotationTypes();
		String beanName = null;
		for (String type : types) {
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type); / amd=KnightConfig2	, type=ComponentScan	,
/d
			if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {	/ type=ComponentScan
/s
StandardAnnotationMetadata.getMetaAnnotationTypes(String) line: 85	
		return (this.annotations.length > 0 ?
				AnnotatedElementUtils.getMetaAnnotationTypes(getIntrospectedClass(), annotationName) : null);
/s
	/**
	 * Get the fully qualified class names of all meta-annotation
	 * types <em>present</em> on the annotation (of the specified
	 * {@code annotationName}) on the supplied {@link AnnotatedElement}.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 *
AnnotatedElementUtils.getMetaAnnotationTypes(AnnotatedElement, String) line: 177	
		return getMetaAnnotationTypes(element, AnnotationUtils.getAnnotation(element, annotationName));	/ element=KnightConfig2,  annotationName=ComponentScan
AnnotatedElementUtils.getMetaAnnotationTypes(AnnotatedElement, Annotation) line: 187	
		try {
			final Set<String> types = new LinkedHashSet<String>();
			searchWithGetSemantics(composed.annotationType(), null, null, null, new SimpleAnnotationProcessor<Object>(true) {
					@Override
					public Object process(AnnotatedElement annotatedElement, Annotation annotation, int metaDepth) {
						types.add(annotation.annotationType().getName());
						return CONTINUE;
					}
				}, new HashSet<AnnotatedElement>(), 1);
/ TODO
/t
AnnotationBeanNameGenerator.determineBeanNameFromAnnotation(AnnotatedBeanDefinition) line: 104	
		for (String type : types) {
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);
			if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {
/n
/ volgende	,
       for (String type : types) {
            AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);	/ type=Configuration	,

ttributes	AnnotationAttributes  (id=1426)	
	[0]	LinkedHashMap$Entry<K,V>  (id=1429)	
		key	"value" (id=1353)	
		value	"" (id=1430)	

/ Intermezzo

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {

	/**
	 * Explicitly specify the name of the Spring bean definition associated
	 * with this Configuration class.  If left unspecified (the common case),
	 * a bean name will be automatically generated.
	 * <p>The custom name applies only if the Configuration class is picked up via
	 * component scanning or supplied directly to a {@link AnnotationConfigApplicationContext}.
	 * If the Configuration class is registered as a traditional XML bean definition,
	 * the name/id of the bean element will take precedence.
	 * @return the specified bean name, if any
	 * @see org.springframework.beans.factory.support.DefaultBeanNameGenerator
	 */
	String value() default "";

}
/ Einde Intermezzo

		for (String type : types) {
			AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);
			if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {
/j
/ TODO
				Object value = attributes.get("value");
""
				if (value instanceof String) {
					String strVal = (String) value;
					if (StringUtils.hasLength(strVal)) {
/n
		return beanName;
null
/t
AnnotationBeanNameGenerator.generateBeanName(BeanDefinition, BeanDefinitionRegistry) line: 77	
		if (definition instanceof AnnotatedBeanDefinition) {
			String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);
null
			if (StringUtils.hasText(beanName)) {
/n
		// Fallback: generate a unique default bean name.
		return buildDefaultBeanName(definition, registry); / definition	AnnotatedGenericBeanDefinition  (id=1083), 	beanClass	Class<T> (sia.knights.config.KnightConfig2) (id=1055)	
/s
AnnotationBeanNameGenerator.buildDefaultBeanName(BeanDefinition, BeanDefinitionRegistry) line: 135	
		return buildDefaultBeanName(definition);
/s
AnnotationBeanNameGenerator.buildDefaultBeanName(BeanDefinition) line: 149	
		String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());
KnightConfig2
		return Introspector.decapitalize(shortClassName);
/t
AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 145	
		AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);	/ KnightConfig2
		ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
		abd.setScope(scopeMetadata.getScopeName());
		String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
/d
knightConfig2
		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
/s
AnnotationConfigUtils.processCommonDefinitionAnnotations(AnnotatedBeanDefinition) line: 235	
		processCommonDefinitionAnnotations(abd, abd.getMetadata());
/s
AnnotationConfigUtils.processCommonDefinitionAnnotations(AnnotatedBeanDefinition, AnnotatedTypeMetadata) line: 239	
		if (metadata.isAnnotated(Lazy.class.getName())) {								/ is KnightConfig2 annotated with Lazy ?

this	StandardAnnotationMetadata  (id=1093)	
	introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=1055)	
/s
StandardAnnotationMetadata.isAnnotated(String) line: 106	
		return (this.annotations.length > 0 &&
				AnnotatedElementUtils.isAnnotated(getIntrospectedClass(), annotationName));	/ getIntrospectedClass()=KnightConfig2, annotationName=Lazy
/t
AnnotationConfigUtils.processCommonDefinitionAnnotations(AnnotatedBeanDefinition, AnnotatedTypeMetadata) line: 239
        if (metadata.isAnnotated(Lazy.class.getName())) {
/n
		if (metadata.isAnnotated(Primary.class.getName())) {
/n
		if (metadata.isAnnotated(DependsOn.class.getName())) {
/n
		if (abd instanceof AbstractBeanDefinition) {
			AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
			if (metadata.isAnnotated(Role.class.getName())) {
/n
			if (metadata.isAnnotated(Description.class.getName())) {
/n
/t
AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 146	
		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
/d
		if (qualifiers != null) {
/n
		BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
/s
AnnotationConfigUtils.applyScopedProxyMode(ScopeMetadata, BeanDefinitionHolder, BeanDefinitionRegistry) line: 269	
		ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();
		if (scopedProxyMode.equals(ScopedProxyMode.NO)) {
/j
			return definition;
/t
AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 162	
		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
/d
		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
/s
	/**
	 * Register the given bean definition with the given bean factory.
	 */
BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) line: 147	
		// Register bean definition under primary name.
		String beanName = definitionHolder.getBeanName();									/ knightConfig2
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
/s
AnnotationConfigApplicationContext(GenericApplicationContext).registerBeanDefinition(String, BeanDefinition) line: 318	
		this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
/s
DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition) line: 789	

		if (beanDefinition instanceof AbstractBeanDefinition) {
			try {
				((AbstractBeanDefinition) beanDefinition).validate();

		oldBeanDefinition = this.beanDefinitionMap.get(beanName);
null
			else {
				// Still in startup registration phase
				this.beanDefinitionMap.put(beanName, beanDefinition);
				this.beanDefinitionNames.add(beanName);
				this.manualSingletonNames.remove(beanName);

this	DefaultListableBeanFactory  (id=939)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=960)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1488)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1505)	
			value	RootBeanDefinition  (id=1506)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1489)													<-
			key	"knightConfig2" (id=1457)	
			value	AnnotatedGenericBeanDefinition  (id=1083)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1490)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1503)	
			value	RootBeanDefinition  (id=1504)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=1491)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1501)	
			value	RootBeanDefinition  (id=1502)	
		[4]	ConcurrentHashMap$WriteThroughEntry  (id=1492)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1499)	
			value	RootBeanDefinition  (id=1500)	
		[5]	ConcurrentHashMap$WriteThroughEntry  (id=1493)	
			key	"org.springframework.context.event.internalEventListenerProcessor" (id=1497)	
			value	RootBeanDefinition  (id=1498)	
		[6]	ConcurrentHashMap$WriteThroughEntry  (id=1494)	
			key	"org.springframework.context.event.internalEventListenerFactory" (id=1495)	
			value	RootBeanDefinition  (id=1496)	

/ KnightConfig2 is een bean	, 
/ TODO

/t
AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
		this();
		register(annotatedClasses);
/d
		refresh();
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 511	
			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).obtainFreshBeanFactory() line: 613	
		refreshBeanFactory();
/s
	/**
	 * Do nothing: We hold a single internal BeanFactory and rely on callers
	 * to register beans through our public methods (or the BeanFactory's).
	 * @see #registerBeanDefinition
	 */
AnnotationConfigApplicationContext(GenericApplicationContext).refreshBeanFactory() line: 264	
		this.beanFactory.setSerializationId(getId());
this	AnnotationConfigApplicationContext  (id=25)	
	id	"org.springframework.context.annotation.AnnotationConfigApplicationContext@4d31477b" (id=943)	
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 517	
			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
/d
			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);
/s
	/**
	 * Configure the factory's standard context characteristics,
	 * such as the context's ClassLoader and post-processors.
	 * @param beanFactory the BeanFactory to configure
	 */
AnnotationConfigApplicationContext(AbstractApplicationContext).prepareBeanFactory(ConfigurableListableBeanFactory) line: 628	

		// Tell the internal bean factory to use the context's class loader etc.
		beanFactory.setBeanClassLoader(getClassLoader());
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
/s
StandardBeanExpressionResolver.<init>(ClassLoader) line: 97	
	/** Default expression prefix: "#{" */
	public static final String DEFAULT_EXPRESSION_PREFIX = "#{";
	/** Default expression suffix: "}" */
	public static final String DEFAULT_EXPRESSION_SUFFIX = "}";

	private String expressionPrefix = DEFAULT_EXPRESSION_PREFIX;
	private String expressionSuffix = DEFAULT_EXPRESSION_SUFFIX;

		this.expressionParser = new SpelExpressionParser(new SpelParserConfiguration(null, beanClassLoader));
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).prepareBeanFactory(ConfigurableListableBeanFactory) line: 630	
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
/d
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
/s
DefaultListableBeanFactory(AbstractBeanFactory).addPropertyEditorRegistrar(PropertyEditorRegistrar) line: 738	
		this.propertyEditorRegistrars.add(registrar);
registrar	ResourceEditorRegistrar  (id=111)	
	propertyResolver	StandardEnvironment  (id=26)	
	resourceLoader	AnnotationConfigApplicationContext  (id=25)	
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).prepareBeanFactory(ConfigurableListableBeanFactory) line: 633	
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
/d
		// Configure the bean factory with context callbacks.
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
/s
ApplicationContextAwareProcessor.<init>(ConfigurableApplicationContext) line: 71	
		this.applicationContext = applicationContext;
		this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
/s
/**
 * {@link StringValueResolver} adapter for resolving placeholders and
 * expressions against a {@link ConfigurableBeanFactory}.
 *
 * <p>Note that this adapter resolves expressions as well, in contrast
 * to the {@link ConfigurableBeanFactory#resolveEmbeddedValue} method.
 * The {@link BeanExpressionContext} used is for the plain bean factory,
 * with no scope specified for any contextual objects to access.
 *
EmbeddedValueResolver.<init>(ConfigurableBeanFactory) line: 43	
		this.exprContext = new BeanExpressionContext(beanFactory, null);
		this.exprResolver = beanFactory.getBeanExpressionResolver();
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).prepareBeanFactory(ConfigurableListableBeanFactory) line: 630	
		// Configure the bean factory with context callbacks.
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
/d

beanFactory	DefaultListableBeanFactory  (id=89)	
	ignoredDependencyInterfaces	HashSet<E>  (id=189)	
		[0]	Class<T> (org.springframework.beans.factory.BeanNameAware) (id=199)	
		[1]	Class<T> (org.springframework.beans.factory.BeanFactoryAware) (id=161)	
		[2]	Class<T> (org.springframework.beans.factory.BeanClassLoaderAware) (id=200)	

		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

this	AnnotationConfigApplicationContext  (id=25)	
beanFactory	DefaultListableBeanFactory  (id=939)	
	ignoredDependencyInterfaces	HashSet<E>  (id=996)	
		[0]	Class<T> (org.springframework.context.ApplicationEventPublisherAware) (id=1600)	
		[1]	Class<T> (org.springframework.context.ResourceLoaderAware) (id=1028)	
		[2]	Class<T> (org.springframework.beans.factory.BeanFactoryAware) (id=904)	
		[3]	Class<T> (org.springframework.beans.factory.BeanNameAware) (id=1593)	
		[4]	Class<T> (org.springframework.context.MessageSourceAware) (id=1601)	
		[5]	Class<T> (org.springframework.context.ApplicationContextAware) (id=1602)	
		[6]	Class<T> (org.springframework.context.EmbeddedValueResolverAware) (id=1603)	
		[7]	Class<T> (org.springframework.beans.factory.BeanClassLoaderAware) (id=1594)	
		[8]	Class<T> (org.springframework.context.EnvironmentAware) (id=1590)	

		// BeanFactory interface not registered as resolvable type in a plain factory.
		// MessageSource registered (and found for autowiring) as a bean.
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
/s
DefaultListableBeanFactory.registerResolvableDependency(Class<?>, Object) line: 602	
/=
	public void registerResolvableDependency(Class<?> dependencyType, Object autowiredValue) {
dependencyType	Class<T> (org.springframework.beans.factory.BeanFactory) (id=43)	
autowiredValue	DefaultListableBeanFactory  (id=939)	

f (autowiredValue != null) {
			this.resolvableDependencies.put(dependencyType, autowiredValue);
/t
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

this	AnnotationConfigApplicationContext  (id=25)	
beanFactory	DefaultListableBeanFactory  (id=939)	
	resolvableDependencies	ConcurrentHashMap<K,V>  (id=1535)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1650)	
			key	Class<T> (org.springframework.context.ApplicationContext) (id=34)	
			value	AnnotationConfigApplicationContext  (id=25)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1651)	
			key	Class<T> (org.springframework.beans.factory.BeanFactory) (id=43)	
			value	DefaultListableBeanFactory  (id=939)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1652)	
			key	Class<T> (org.springframework.context.ApplicationEventPublisher) (id=41)	
			value	AnnotationConfigApplicationContext  (id=25)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=1653)	
			key	Class<T> (org.springframework.core.io.ResourceLoader) (id=44)	
			value	AnnotationConfigApplicationContext  (id=25)	

		// Register early post-processor for detecting inner beans as ApplicationListeners.
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
/s
/**
 * {@code BeanPostProcessor} that detects beans which implement the {@code ApplicationListener}
 * interface. This catches beans that can't reliably be detected by {@code getBeanNamesForType}		/ TODO
 * and related operations which only work against top-level beans.
 *
 * <p>With standard Java serialization, this post-processor won't get serialized as part of
 * {@code DisposableBeanAdapter} to begin with. However, with alternative serialization
 * mechanisms, {@code DisposableBeanAdapter.writeReplace} might not get used at all, so we
 * defensively mark this post-processor's field state as {@code transient}.
 */
class ApplicationListenerDetector implements DestructionAwareBeanPostProcessor, MergedBeanDefinitionPostProcessor {

	private static final Log logger = LogFactory.getLog(ApplicationListenerDetector.class);

	private transient final AbstractApplicationContext applicationContext;											<- transient

	private transient final Map<String, Boolean> singletonNames = new ConcurrentHashMap<String, Boolean>(256);		<- transient

		this.applicationContext = applicationContext;
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).prepareBeanFactory(ConfigurableListableBeanFactory) line: 652	
		// Register early post-processor for detecting inner beans as ApplicationListeners.
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
/d
		// Detect a LoadTimeWeaver and prepare for weaving, if found.
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {	"loadTimeWeaver"
/n
		// Register default environment beans.
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {	"environment"
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
/s
DefaultListableBeanFactory.registerSingleton(String, Object) line: 929	
		super.registerSingleton(beanName, singletonObject);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).registerSingleton(String, Object) line: 126	
			addSingleton(beanName, singletonObject);
/t
DefaultListableBeanFactory.registerSingleton(String, Object) line: 945	
		super.registerSingleton(beanName, singletonObject);
/d
		else {
			// Still in startup registration phase
			if (!this.beanDefinitionMap.containsKey(beanName)) {
/j
				this.manualSingletonNames.add(beanName);
		clearByTypeCache();
/s
DefaultListableBeanFactory.clearByTypeCache() line: 970	
		this.allBeanNamesByType.clear();
		this.singletonBeanNamesByType.clear();
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).prepareBeanFactory(ConfigurableListableBeanFactory) line: 662	
		// Register default environment beans.
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {					/ "environment"
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {		/ "systemProperties"
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {		/ "systemEnvironment"
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());

this	AnnotationConfigApplicationContext  (id=25)	
beanFactory	DefaultListableBeanFactory  (id=939)	
	manualSingletonNames	LinkedHashSet<E>  (id=1529)	
		[0]	"environment" (id=1692)	
		[1]	"systemProperties" (id=1741)	
		[2]	"systemEnvironment" (id=1747)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=1539)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1755)	
			key	"environment" (id=1692)	
			value	StandardEnvironment  (id=26)	
				activeProfiles	LinkedHashSet<E>  (id=1566)	
				defaultProfiles	LinkedHashSet<E>  (id=1567)	
				logger	Log4JLogger  (id=1568)	
				propertyResolver	PropertySourcesPropertyResolver  (id=1541)	
				propertySources	MutablePropertySources  (id=1809)	
					logger	Log4JLogger  (id=1568)	
					propertySourceList	CopyOnWriteArrayList<E>  (id=1826)	
						[0]	MapPropertySource  (id=1833)	
							logger	Log4JLogger  (id=1840)	
							name	"systemProperties" (id=1741)	
							source	Properties  (id=1806)										<-
						[1]	SystemEnvironmentPropertySource  (id=1834)	
							logger	Log4JLogger  (id=1930)	
							name	"systemEnvironment" (id=1747)								<<-
							source	Collections$UnmodifiableMap<K,V>  (id=1803)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1793)	
			key	"systemProperties" (id=1741)	
			value	Properties  (id=1806)														<-
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1794)	
			key	"systemEnvironment" (id=1747)	
			value	Collections$UnmodifiableMap<K,V>  (id=1803)									<<-	

/ we zien de systemProperties en systemEnvironment terug in de environment bean	,

/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 521	
			// Prepare the bean factory for use in this context.					/ prepare the context of the bean factory	,
			prepareBeanFactory(beanFactory);
/d
			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);
/ leeg	,
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 686	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
getBeanFactoryPostProcessors()={}
/s
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 87	

			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
[org.springframework.context.annotation.internalConfigurationAnnotationProcessor]
/ want
/s
DefaultListableBeanFactory.getBeanNamesForType(Class<?>, boolean, boolean) line: 390	
			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);
/s
DefaultListableBeanFactory.doGetBeanNamesForType(ResolvableType, boolean, boolean) line: 409	
/=
	private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {
type	ResolvableType$1  (id=144) org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor
includeNonSingletons	true	
allowEagerInit	false	

		// Check all bean definitions.
		for (String beanName : this.beanDefinitionNames) {
this	DefaultListableBeanFactory  (id=89)	
	beanDefinitionNames	ArrayList<E>  (id=153)	
		[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=130)	
		[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=156)	
		[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=157)	
		[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=242)	
		[4]	"org.springframework.context.event.internalEventListenerProcessor" (id=243)	
		[5]	"org.springframework.context.event.internalEventListenerFactory" (id=246)	
		[6]	"knightConfig2" (id=247)	

			// Only consider bean as eligible if the bean name
			// is not defined as alias for some other bean.
			if (!isAlias(beanName)) { 	
						/ org.springframework.context.annotation.internalConfigurationAnnotationProcessor
						/ org.springframework.context.annotation.internalAutowiredAnnotationProcessor
						/ org.springframework.context.annotation.internalRequiredAnnotationProcessor
						/ org.springframework.context.annotation.internalCommonAnnotationProcessor
						/ org.springframework.context.event.internalEventListenerProcessor
						/ org.springframework.context.event.internalEventListenerFactory
						/ knightConfig2
				try {
					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
					// Only check bean definition if it is complete.
					if (!mbd.isAbstract() && (allowEagerInit ||
							((mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading())) &&
									!requiresEagerInitForType(mbd.getFactoryBeanName()))) {
						// In case of FactoryBean, match object created by FactoryBean.
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
false
						boolean matchFound = (allowEagerInit || !isFactoryBean ||
								(mbd.getDecoratedDefinition() != null && !mbd.isLazyInit()) ||
								containsSingleton(beanName)) &&
								(includeNonSingletons || isSingleton(beanName)) &&
								isTypeMatch(beanName, type);
true	/ org.springframework.context.annotation.internalConfigurationAnnotationProcessor
false	/ org.springframework.context.annotation.internalAutowiredAnnotationProcessor
		/ org.springframework.context.annotation.internalRequiredAnnotationProcessor
		/ org.springframework.context.annotation.internalCommonAnnotationProcessor
		/ org.springframework.context.event.internalEventListenerProcessor
		/ org.springframework.context.event.internalEventListenerFactory
		/ knightConfig2
						if (!matchFound && isFactoryBean) {
/n
							// In case of FactoryBean, try to match FactoryBean instance itself next.
							beanName = FACTORY_BEAN_PREFIX + beanName;
							matchFound = (includeNonSingletons || mbd.isSingleton()) && isTypeMatch(beanName, type);
						}
						if (matchFound) {
/j	/ org.springframework.context.annotation.internalConfigurationAnnotationProcessor
							result.add(beanName);
		}

		// Check manually registered singletons too.
		for (String beanName : this.manualSingletonNames) {
this	DefaultListableBeanFactory  (id=89)	
	manualSingletonNames	LinkedHashSet<E>  (id=221)	
		[0]	"environment" (id=267)	
		[1]	"systemProperties" (id=268)	
		[2]	"systemEnvironment" (id=269)	
/ niets	,
		return StringUtils.toStringArray(result);
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 84	
			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
/d
[org.springframework.context.annotation.internalConfigurationAnnotationProcessor]

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			List<BeanDefinitionRegistryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
/s
DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class<T>) line: 202	
		return doGetBean(name, requiredType, null, false);
/s
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 302	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {	<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 213	
			Object singletonObject = this.singletonObjects.get(beanName);
null
this	DefaultListableBeanFactory  (id=89)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=319)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1292)	
			key	"environment" (id=267)	
			value	StandardEnvironment  (id=30)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1293)	
			key	"systemProperties" (id=268)	
			value	Properties  (id=1297)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1294)	
			key	"systemEnvironment" (id=269)	
			value	Collections$UnmodifiableMap<K,V>  (id=1298)	

				try {
					singletonObject = singletonFactory.getObject();
/s
AbstractBeanFactory$1.getObject() line: 306	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {	/ we zijn ook nog hier in	,
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);						<-
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 447	

		// Make sure bean class is actually resolved at this point, and
		// clone the bean definition in case of a dynamically resolved Class
		// which cannot be stored in the shared merged bean definition.
		Class<?> resolvedClass = resolveBeanClass(mbd, beanName); / class org.springframework.context.annotation.ConfigurationClassPostProcessor
		// Prepare method overrides.
		try {
			mbdToUse.prepareMethodOverrides();
/ []
		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
null
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 507	
		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
mbd	RootBeanDefinition  (id=392)	
	scope	"singleton" (id=1406)	
/s
			return SCOPE_SINGLETON.equals(scope) || SCOPE_DEFAULT.equals(scope);
/t
		if (mbd.isSingleton()) {
/j
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
null
		Class<?> beanClass = resolveBeanClass(mbd, beanName);	/ uit mdb	,
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1014	
		Class<?> beanClass = resolveBeanClass(mbd, beanName);	/ uit mdb	,	class org.springframework.context.annotation.ConfigurationClassPostProcessor
		if (mbd.getFactoryMethodName() != null)  {
/n
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
/s
	/**
	 * Determine candidate constructors to use for the given bean, checking all registered
	 *
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1069	
		if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {
/n
		return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1047	
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
/d
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
/s
	/**
	 * Return the resolved autowire code,
	 * (resolving AUTOWIRE_AUTODETECT to AUTOWIRE_CONSTRUCTOR or AUTOWIRE_BY_TYPE).
	 * @see #AUTOWIRE_AUTODETECT
	 * @see #AUTOWIRE_CONSTRUCTOR
	 * @see #AUTOWIRE_BY_TYPE
	 */
RootBeanDefinition(AbstractBeanDefinition).getResolvedAutowireMode() line: 513	
		if (this.autowireMode == AUTOWIRE_AUTODETECT) {
/n
			return this.autowireMode;
0
/=
	public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;
/t

/ intermezzo

public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor

	/**
	 * Constant that indicates no autowiring at all.
	 * @see #setAutowireMode
	 */
	public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;

	/**
	 * Constant that indicates autowiring bean properties by name.
	 * @see #setAutowireMode
	 */
	public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;

	/**
	 * Constant that indicates autowiring bean properties by type.
	 * @see #setAutowireMode
	 */
	public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;

	/**
	 * Constant that indicates autowiring a constructor.
	 * @see #setAutowireMode
	 */
	public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;


/ Einde intermezzo

/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1049	
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
/n
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
/n
		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1092	
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/s
CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory) line: 61	
		// Don't override the class with CGLIB if no overrides.
		if (bd.getMethodOverrides().isEmpty()) {
/j
			Constructor<?> constructorToUse;
			synchronized (bd.constructorArgumentLock) {
				constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;
				if (constructorToUse == null) {
					final Class<?> clazz = bd.getBeanClass(); / class org.springframework.context.annotation.ConfigurationClassPostProcessor
						else {
							constructorToUse =	clazz.getDeclaredConstructor((Class[]) null); 
constructorToUse	Constructor<T>  (id=1480)	/ public org.springframework.context.annotation.ConfigurationClassPostProcessor()
						bd.resolvedConstructorOrFactoryMethod = constructorToUse;
			return BeanUtils.instantiateClass(constructorToUse);
/s
BeanUtils.instantiateClass(Constructor<T>, Object...) line: 142	
			return ctor.newInstance(args);
args=[]
/t
CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory) line: 89	
			return BeanUtils.instantiateClass(constructorToUse);
/d
		else {
/n
			// Must generate CGLIB subclass.
			return instantiateWithMethodInjection(bd, beanName, owner);
/n
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1104	
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/d
beanInstance	ConfigurationClassPostProcessor  (id=1489)	

			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
/s
BeanWrapperImpl.<init>(Object) line: 101	
		super(object);
/s
BeanWrapperImpl(AbstractNestablePropertyAccessor).<init>(Object) line: 132	
		registerDefaultEditors();
/s
	/**
	 * Activate the default editors for this registry instance,
	 * allowing for lazily registering default editors when needed.
	 */
	protected void registerDefaultEditors() {
		this.defaultEditorsActive = true;
/t
BeanWrapperImpl(AbstractNestablePropertyAccessor).<init>(Object) line: 133	
		registerDefaultEditors();
/d
		setWrappedInstance(object);
/s
	/**
	 * Switch the target object, replacing the cached introspection results only
	 * if the class of the new object is different to that of the replaced object.
	 *
BeanWrapperImpl(AbstractNestablePropertyAccessor).setWrappedInstance(Object, String, Object) line: 205	
		else {
			this.wrappedObject = object;
		this.nestedPath = (nestedPath != null ? nestedPath : "");
		this.rootObject = (!"".equals(this.nestedPath) ? rootObject : this.wrappedObject);
		this.nestedPropertyAccessors = null;
		this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);
/t
BeanWrapperImpl.setWrappedInstance(Object, String, Object) line: 152	
		super.setWrappedInstance(object, nestedPath, rootObject);
		setIntrospectionClass(getWrappedClass());
/niets	,
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1105	
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
/d
bw	BeanWrapperImpl  (id=1500)	
	acc	null	
	autoGrowCollectionLimit	2147483647	
	autoGrowNestedPaths	false	
	cachedIntrospectionResults	null	
	configValueEditorsActive	false	
	conversionService	null	
	customEditorCache	null	
	customEditors	null	
	customEditorsForPath	null	
	defaultEditors	null	
	defaultEditorsActive	true	
	extractOldValueForEditor	false	
	nestedPath	"" (id=1408)	
	nestedPropertyAccessors	null	
	overriddenDefaultEditors	null	
	rootObject	ConfigurationClassPostProcessor  (id=1489)	
	typeConverterDelegate	TypeConverterDelegate  (id=1518)	
	wrappedObject	ConfigurationClassPostProcessor  (id=1489)	

			initBeanWrapper(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).initBeanWrapper(BeanWrapper) line: 1118	
		bw.setConversionService(getConversionService());
null
		registerCustomEditors(bw);

/ intermezzo

/ stack
	ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 115	
	DefaultListableBeanFactory(AbstractBeanFactory).registerCustomEditors(PropertyEditorRegistry) line: 1139	
			for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) {	/ org.springframework.beans.support.ResourceEditorRegistrar@13b3d787		<-
				try {
					registrar.registerCustomEditors(registry);

	DefaultListableBeanFactory(AbstractBeanFactory).initBeanWrapper(BeanWrapper) line: 1119	
		registerCustomEditors(bw);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1105	
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
			initBeanWrapper(bw);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1054	
		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 512	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 482	
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
/cb
	AbstractBeanFactory$1.getObject() line: 306	
							try {
								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 230	
				try {
					singletonObject = singletonFactory.getObject();
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 302	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {			<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class<T>) line: 202	
		return doGetBean(name, requiredType, null, false);
/cb
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 87	
			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			List<BeanDefinitionRegistryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {	/ ppName=org.springframework.context.annotation.internalConfigurationAnnotationProcessor	<-
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 686	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 524	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	MyKnightMain2.main(String[]) line: 11	


/ Einde intermezzo
/s
	/**
	 * Initialize the given PropertyEditorRegistry with the custom editors
	 * that have been registered with this BeanFactory.
 	 *
DefaultListableBeanFactory(AbstractBeanFactory).registerCustomEditors(PropertyEditorRegistry) line: 1131	
		PropertyEditorRegistrySupport registrySupport =
				(registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);
registrySupport	BeanWrapperImpl  (id=1500)	

		if (registrySupport != null) {
			registrySupport.useConfigValueEditors();
/s
					this.configValueEditorsActive = true;
/t
		if (!this.propertyEditorRegistrars.isEmpty()) {
			for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) {
this	DefaultListableBeanFactory  (id=89)	
	propertyEditorRegistrars	LinkedHashSet<E>  (id=230)	
		[0]	ResourceEditorRegistrar  (id=1540)	
			propertyResolver	StandardEnvironment  (id=30)	
			resourceLoader	AnnotationConfigApplicationContext  (id=25)	

				try {
					registrar.registerCustomEditors(registry);
registry	BeanWrapperImpl  (id=1500)	
/s
	/**
	 * Populate the given {@code registry} with the following resource editors:
	 * ResourceEditor, InputStreamEditor, InputSourceEditor, FileEditor, URLEditor,
	 * URIEditor, ClassEditor, ClassArrayEditor.
	 * <p>If this registrar has been configured with a {@link ResourcePatternResolver},
	 * a ResourceArrayPropertyEditor will be registered as well.
ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 115	
this	ResourceEditorRegistrar  (id=85)	
	propertyResolver	StandardEnvironment  (id=157)	
	resourceLoader	AnnotationConfigApplicationContext  (id=22)	

		ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
		doRegisterEditor(registry, Resource.class, baseEditor);
/s
	/**
	 * Override default editor, if possible (since that's what we really mean to do here);
	 * otherwise register as a custom editor.
	 */
ResourceEditorRegistrar.doRegisterEditor(PropertyEditorRegistry, Class<?>, PropertyEditor) line: 144	
		if (registry instanceof PropertyEditorRegistrySupport) {
			((PropertyEditorRegistrySupport) registry).overrideDefaultEditor(requiredType, editor);
/s
BeanWrapperImpl(PropertyEditorRegistrySupport).overrideDefaultEditor(Class<?>, PropertyEditor) line: 183	
		if (this.overriddenDefaultEditors == null) {
			this.overriddenDefaultEditors = new HashMap<Class<?>, PropertyEditor>();
		}
		this.overriddenDefaultEditors.put(requiredType, propertyEditor);
requiredType	Class<T> (org.springframework.core.io.Resource) (id=187)	
propertyEditor	ResourceEditor  (id=176)	
	ignoreUnresolvablePlaceholders	true	
	listeners	null	
	propertyResolver	StandardEnvironment  (id=157)	
	resourceLoader	AnnotationConfigApplicationContext  (id=22)	
	source	ResourceEditor  (id=176)	
	value	null	
/t
ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 117	
		doRegisterEditor(registry, Resource.class, baseEditor);
/d
		doRegisterEditor(registry, ContextResource.class, baseEditor);
		doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
		doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
		doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
		if (pathClass != null) { 		/ interface java.nio.file.Path
/j
			doRegisterEditor(registry, pathClass, new PathEditor(baseEditor));
		}
		doRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));
		doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

		ClassLoader classLoader = this.resourceLoader.getClassLoader();
		doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
		doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
		doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

		if (this.resourceLoader instanceof ResourcePatternResolver) {
			doRegisterEditor(registry, Resource[].class,
					new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));

registry	BeanWrapperImpl  (id=87)						/ de BeanWrapper
	overriddenDefaultEditors	HashMap<K,V>  (id=227)	
		[0]	HashMap$Entry<K,V>  (id=245)	
			key	Class<T> (org.springframework.core.io.Resource[]) (id=259)	
			value	ResourceArrayPropertyEditor  (id=260)	
		[1]	HashMap$Entry<K,V>  (id=246)	
			key	Class<T> (java.io.InputStream) (id=263)	
			value	InputStreamEditor  (id=264)	
		[2]	HashMap$Entry<K,V>  (id=247)	
			key	Class<T> (java.net.URL) (id=267)	
			value	URLEditor  (id=268)	
		[3]	HashMap$Entry<K,V>  (id=248)	
			key	Class<T> (java.nio.file.Path) (id=233)	
			value	PathEditor  (id=274)	
		[4]	HashMap$Entry<K,V>  (id=249)	
			key	Class<T> (org.springframework.core.io.Resource) (id=187)	
			value	ResourceEditor  (id=176)	
		[5]	HashMap$Entry<K,V>  (id=253)	
			key	Class<T> (java.io.File) (id=278)	
			value	FileEditor  (id=279)	
		[6]	HashMap$Entry<K,V>  (id=254)	
			key	Class<T> (java.io.Reader) (id=285)	
			value	ReaderEditor  (id=286)	
		[7]	HashMap$Entry<K,V>  (id=256)	
			key	Class<T> (java.net.URI) (id=289)	
			value	URIEditor  (id=290)	
		[8]	HashMap$Entry<K,V>  (id=257)	
			key	Class<T> (org.springframework.core.io.ContextResource) (id=225)	
			value	ResourceEditor  (id=176)	
		[9]	HashMap$Entry<K,V>  (id=271)	
			key	Class<T> (java.lang.Class) (id=76)	
			value	ClassEditor  (id=294)	
		[10]	HashMap$Entry<K,V>  (id=272)	
			key	Class<T> (org.xml.sax.InputSource) (id=297)	
			value	InputSourceEditor  (id=298)	
		[11]	HashMap$Entry<K,V>  (id=283)	
			key	Class<T> (java.lang.Class[]) (id=99)	
			value	ClassArrayEditor  (id=301)	
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1106	
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
			initBeanWrapper(bw);
/d
			return bw;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 514	
/=
	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
beanName	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=71)	
mbd	RootBeanDefinition  (id=131)	
	beanClass	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=139)	
	scope	"singleton" (id=550)	
args	null	

			instanceWrapper = createBeanInstance(beanName, mbd, args);
/d
instanceWrapper	BeanWrapperImpl  (id=87)	
	overriddenDefaultEditors	HashMap<K,V>  (id=227)		/ hier vlak boven	,
	rootObject	ConfigurationClassPostProcessor  (id=140)	
	typeConverterDelegate	TypeConverterDelegate  (id=231)	
	wrappedObject	ConfigurationClassPostProcessor  (id=140)	

		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
bean	ConfigurationClassPostProcessor  (id=140)	
beanType	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=139)	

			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 945	
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
this	DefaultListableBeanFactory  (id=61)	
	beanPostProcessors	ArrayList<E>  (id=430)	
		[0]	ApplicationContextAwareProcessor  (id=406)	
		[1]	ApplicationListenerDetector  (id=435)	

			if (bp instanceof MergedBeanDefinitionPostProcessor) {
/j
bp	ApplicationListenerDetector  (id=435)	
				MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;	/ org.springframework.context.support.ApplicationListenerDetector@70ca62f7
				bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
ApplicationListenerDetector.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 62	
		if (this.applicationContext != null) {
			this.singletonNames.put(beanName, beanDefinition.isSingleton());
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 533	
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/d
		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName));
/j
		if (earlySingletonExposure) {
			addSingletonFactory(beanName, new ObjectFactory<Object>() {			<-
				@Override
				public Object getObject() throws BeansException {
					return getEarlyBeanReference(beanName, mbd, bean);
				}
			});
		}
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).addSingletonFactory(String, ObjectFactory<?>) line: 164	
			if (!this.singletonObjects.containsKey(beanName)) {
				this.singletonFactories.put(beanName, singletonFactory);
				this.earlySingletonObjects.remove(beanName);
				this.registeredSingletons.add(beanName);
			}
this	DefaultListableBeanFactory  (id=61)	
	registeredSingletons	LinkedHashSet<E>  (id=1459)	
		[0]	"environment" (id=1502)	
		[1]	"systemProperties" (id=1503)	
		[2]	"systemEnvironment" (id=1504)	
		[3]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=71)	
	singletonFactories	HashMap<K,V>  (id=1464)	
		[0]	HashMap$Entry<K,V>  (id=1485)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=71)	
			value	AbstractAutowireCapableBeanFactory$2  (id=1448)			/ ObjectFactory hierboven	,
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 551	
			addSingletonFactory(beanName, new ObjectFactory<Object>() {
				@Override
				public Object getObject() throws BeansException {
					return getEarlyBeanReference(beanName, mbd, bean);
				}
			});
		}
/d
		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
beanName	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=71)	
/s
	/**
	 * Populate the bean instance in the given BeanWrapper with the property values
	 * from the bean definition.
	 *
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1159	
		PropertyValues pvs = mbd.getPropertyValues();	/ this.propertyValues
PropertyValues: length=0

		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
		// state of the bean before properties are set. This can be used, for example,
		// to support styles of field injection.
		boolean continueWithPropertyPopulation = true;

		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
/n
!false && false

		if (!continueWithPropertyPopulation) {
/n
			return;
/n

		if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
/n
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
false
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);
false
		if (hasInstAwareBpps || needsDepCheck) {
/n
		applyPropertyValues(beanName, mbd, bw, pvs);
/ niets	,
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 552	
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
/d
			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/s
	/**
	 * Initialize the given bean instance, applying factory callbacks
	 * as well as init methods and bean post processors.
	 * <p>Called from {@link #createBean} for traditionally defined beans,
	 * and from {@link #initializeBean} for existing bean instances.
	 *
	protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
		else {
			invokeAwareMethods(beanName, bean);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).invokeAwareMethods(String, Object) line: 1599	
		if (bean instanceof Aware) {
			if (bean instanceof BeanNameAware) {
/n
			if (bean instanceof BeanClassLoaderAware) {
/j
				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());
			}
			if (bean instanceof BeanFactoryAware) {
/n
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1575	
		else {
			invokeAwareMethods(beanName, bean);
/d
		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 406	
		Object result = existingBean;			/ existingBean	ConfigurationClassPostProcessor  (id=140)	

		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
this	DefaultListableBeanFactory  (id=61)	
	beanPostProcessors	ArrayList<E>  (id=430)	
		[0]	ApplicationContextAwareProcessor  (id=406)	
		[1]	ApplicationListenerDetector  (id=435)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
ApplicationContextAwareProcessor.postProcessBeforeInitialization(Object, String) line: 78	
		else {
			invokeAwareInterfaces(bean);
/s
ApplicationContextAwareProcessor.invokeAwareInterfaces(Object) line: 104	
		if (bean instanceof Aware) {
			if (bean instanceof EnvironmentAware) {
				((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
			if (bean instanceof EmbeddedValueResolverAware) {
/n
			if (bean instanceof ResourceLoaderAware) {
				((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);

			if (bean instanceof ApplicationEventPublisherAware) {
/n
			if (bean instanceof MessageSourceAware) {
/n
			if (bean instanceof ApplicationContextAware) {
/n
bean	ConfigurationClassPostProcessor  (id=140)	
	environment	StandardEnvironment  (id=157)	
	resourceLoader	AnnotationConfigApplicationContext  (id=22)	
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 408	
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/ niets	,
		return result;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1579	
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/d
		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
/niets	, want	,
/s
	/**
	 * Give a bean a chance to react now all its properties are set,
	 * and a chance to know about its owning bean factory (this object).
	 * This means checking whether the bean implements InitializingBean or defines
	 * a custom init method, and invoking the necessary callback(s) if it does.
	 *
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).invokeInitMethods(String, Object, RootBeanDefinition) line: 1622	

		boolean isInitializingBean = (bean instanceof InitializingBean);
false
		if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
/n
		if (mbd != null) {
			String initMethodName = mbd.getInitMethodName();
null
			if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
					!mbd.isExternallyManagedInitMethod(initMethodName)) {
/n
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1587	
			invokeInitMethods(beanName, wrappedBean, mbd);
/d
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsAfterInitialization(Object, String) line: 422	
		Object result = existingBean;
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {	/ beanProcessor	ApplicationContextAwareProcessor  (id=406)	
			result = beanProcessor.postProcessAfterInitialization(result, beanName);
/niets	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {	/ beanProcessor	ApplicationListenerDetector  (id=435)	
			result = beanProcessor.postProcessAfterInitialization(result, beanName);
/niets	,
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 566	
			populateBean(beanName, mbd, instanceWrapper);
/d
exposedObject	ConfigurationClassPostProcessor  (id=140)	
	environment	StandardEnvironment  (id=157)	
	resourceLoader	AnnotationConfigApplicationContext  (id=22)	

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
null
/ want	,
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, boolean) line: 185	
this	DefaultListableBeanFactory  (id=43)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=58)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1164)	
			key	"environment" (id=1173)	
			value	StandardEnvironment  (id=1174)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1165)	
			key	"systemProperties" (id=1177)	
			value	Properties  (id=1178)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1166)	
			key	"systemEnvironment" (id=1181)	
			value	Collections$UnmodifiableMap<K,V>  (id=1182)	

		Object singletonObject = this.singletonObjects.get(beanName);
null
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { / beanName	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1098)	
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).isSingletonCurrentlyInCreation(String) line: 336	
		return this.singletonsCurrentlyInCreation.contains(beanName);
/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, boolean) line: 187	
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
/j
				singletonObject = this.earlySingletonObjects.get(beanName);
null				
					if (singletonObject == null && allowEarlyReference) {
false
		return (singletonObject != NULL_OBJECT ? singletonObject : null);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 568	
			Object earlySingletonReference = getSingleton(beanName, false);
null
			if (earlySingletonReference != null) {
/n

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
/ niets	,
		return exposedObject;	/ exposedObject	ConfigurationClassPostProcessor  (id=1100)	
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 483	
		Object beanInstance = doCreateBean(beanName, mbdToUse, args); 
/d
		return beanInstance;	/ beanInstance	ConfigurationClassPostProcessor  (id=140)	
/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 231	
				try {
					singletonObject = singletonFactory.getObject();
/d
singletonObject	ConfigurationClassPostProcessor  (id=140)	
					newSingleton = true;
				finally {
					if (recordSuppressedExceptions) {
						this.suppressedExceptions = null;
					}
					afterSingletonCreation(beanName);
/ niets	,
				if (newSingleton) {
					addSingleton(beanName, singletonObject);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).addSingleton(String, Object) line: 145	
			this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);

this	DefaultListableBeanFactory  (id=61)	
	registeredSingletons	LinkedHashSet<E>  (id=1459)	
		[0]	"environment" (id=1502)	
		[1]	"systemProperties" (id=1503)	
		[2]	"systemEnvironment" (id=1504)	
		[3]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=71)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=81)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1707)	
			key	"environment" (id=1502)	
			value	StandardEnvironment  (id=157)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1708)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=71)	
			value	ConfigurationClassPostProcessor  (id=140)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1709)	
			key	"systemProperties" (id=1503)	
			value	Properties  (id=1639)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=1710)	
			key	"systemEnvironment" (id=1504)	
			value	Collections$UnmodifiableMap<K,V>  (id=1641)	

/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 259	
					addSingleton(beanName, singletonObject);
/d
			return (singletonObject != NULL_OBJECT ? singletonObject : null);
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 317	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {	
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);			<-
/d
sharedInstance	ConfigurationClassPostProcessor  (id=140)	
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
/s
	/**
	 * Get the object for the given bean instance, either the bean
	 * instance itself or its created object in case of a FactoryBean.
	 *
DefaultListableBeanFactory(AbstractBeanFactory).getObjectForBeanInstance(Object, String, String, RootBeanDefinition) line: 1583	
		// Don't let calling code try to dereference the factory if the bean isn't a factory.
		if (BeanFactoryUtils.isFactoryDereference(name) && !(beanInstance instanceof FactoryBean)) {
/s
BeanFactoryUtils.isFactoryDereference(String) line: 61	
		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));	/ &
/t
DefaultListableBeanFactory(AbstractBeanFactory).getObjectForBeanInstance(Object, String, String, RootBeanDefinition) line: 1583	
		if (BeanFactoryUtils.isFactoryDereference(name) && !(beanInstance instanceof FactoryBean)) {
/n
		// Now we have the bean instance, which may be a normal bean or a FactoryBean.
		// If it's a FactoryBean, we use it to create a bean instance, unless the
		// caller actually wants a reference to the factory.
		if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
/j
			return beanInstance;
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 369	
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
/d
bean==sharedInstance
		// Check if required type matches the type of the actual bean instance.
		if (requiredType != null && bean != null && !requiredType.isAssignableFrom(bean.getClass())) {
/n
requiredType	Class<T> (org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor) (id=547)	
bean	ConfigurationClassPostProcessor  (id=1100)	
		return (T) bean;
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 87	
		Set<String> processedBeans = new HashSet<String>();
		...
			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			List<BeanDefinitionRegistryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {
postProcessorNames	String[1]  (id=1282)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1098)	

				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
/d
					processedBeans.add(ppName);
			}
priorityOrderedPostProcessors	ArrayList<E>  (id=1283)	
	[0]	ConfigurationClassPostProcessor  (id=1100)	
processedBeans	HashSet<E>  (id=1285)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1098)	

/ Geen volgende for loop	,

/ intermezzo

/ we zijn in ,	

/stack
/s
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 88	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 686	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 524	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
		refresh();
/cb
	MyKnightMain2.main(String[]) line: 11	
    	ApplicationContext context=new AnnotationConfigApplicationContext(KnightConfig2.class);

/ Einde intermezzo

			sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
			registryPostProcessors.addAll(priorityOrderedPostProcessors);
/s
registryPostProcessors	LinkedList<E>  (id=1281)	
	[0]	ConfigurationClassPostProcessor  (id=1100)	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
registry	DefaultListableBeanFactory  (id=43)	
/s
PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 269	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/s
ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 227	
		RootBeanDefinition iabpp = new RootBeanDefinition(ImportAwareBeanPostProcessor.class);
		iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);
IMPORT_AWARE_PROCESSOR_BEAN_NAME="org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor"
/s
DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition) line: 789	

		oldBeanDefinition = this.beanDefinitionMap.get(beanName);
null
this	DefaultListableBeanFactory  (id=43)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=1114)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1364)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1371)	
			value	RootBeanDefinition  (id=1372)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1365)	
			key	"knightConfig2" (id=1373)	
			value	AnnotatedGenericBeanDefinition  (id=1374)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1366)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1375)	
			value	RootBeanDefinition  (id=1376)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=1367)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1098)	
			value	RootBeanDefinition  (id=1377)	
		[4]	ConcurrentHashMap$WriteThroughEntry  (id=1368)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1378)	
			value	RootBeanDefinition  (id=1379)	
		[5]	ConcurrentHashMap$WriteThroughEntry  (id=1369)	
			key	"org.springframework.context.event.internalEventListenerProcessor" (id=1380)	
			value	RootBeanDefinition  (id=1381)	
		[6]	ConcurrentHashMap$WriteThroughEntry  (id=1370)	
			key	"org.springframework.context.event.internalEventListenerFactory" (id=1382)	
			value	RootBeanDefinition  (id=1383)	

		else {
			if (hasBeanCreationStarted()) {
/j
/ want	,
/s
DefaultListableBeanFactory(AbstractBeanFactory).hasBeanCreationStarted() line: 1567	
		return !this.alreadyCreated.isEmpty();
this	DefaultListableBeanFactory  (id=43)	
	alreadyCreated	Collections$SetFromMap<E>  (id=1112)	
		[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1098)	
/t
DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition) line: 838	
		else {
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				synchronized (this.beanDefinitionMap) {
					this.beanDefinitionMap.put(beanName, beanDefinition);

this	DefaultListableBeanFactory  (id=43)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=1114)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1542)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1371)	
			value	RootBeanDefinition  (id=1372)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1543)	
			key	"knightConfig2" (id=1373)	
			value	AnnotatedGenericBeanDefinition  (id=1374)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1544)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1375)	
			value	RootBeanDefinition  (id=1376)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=1545)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=1357)	
			value	RootBeanDefinition  (id=1354)	
		[4]	ConcurrentHashMap$WriteThroughEntry  (id=1546)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1098)	
			value	RootBeanDefinition  (id=1377)	
		[5]	ConcurrentHashMap$WriteThroughEntry  (id=1547)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1378)	
			value	RootBeanDefinition  (id=1379)	
		[6]	ConcurrentHashMap$WriteThroughEntry  (id=1548)	
			key	"org.springframework.context.event.internalEventListenerProcessor" (id=1380)	
			value	RootBeanDefinition  (id=1381)	
		[7]	ConcurrentHashMap$WriteThroughEntry  (id=1549)	
			key	"org.springframework.context.event.internalEventListenerFactory" (id=1382)	
			value	RootBeanDefinition  (id=1383)	

					List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					if (this.manualSingletonNames.contains(beanName)) { / [environment, systemProperties, systemEnvironment]
/n
/t
ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 231	
		registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);
/d
		RootBeanDefinition ecbpp = new RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);
		ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);

registry	DefaultListableBeanFactory  (id=43)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=1114)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=1774)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1371)	
			value	RootBeanDefinition  (id=1372)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=1775)	
			key	"knightConfig2" (id=1373)	
			value	AnnotatedGenericBeanDefinition  (id=1374)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=1776)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1375)	
			value	RootBeanDefinition  (id=1376)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=1777)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=1357)	
			value	RootBeanDefinition  (id=1354)	
		[4]	ConcurrentHashMap$WriteThroughEntry  (id=1778)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1098)	
			value	RootBeanDefinition  (id=1377)	
		[5]	ConcurrentHashMap$WriteThroughEntry  (id=1779)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1378)	
			value	RootBeanDefinition  (id=1379)	
		[6]	ConcurrentHashMap$WriteThroughEntry  (id=1780)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=1783)	
			value	RootBeanDefinition  (id=1771)	
		[7]	ConcurrentHashMap$WriteThroughEntry  (id=1781)	
			key	"org.springframework.context.event.internalEventListenerProcessor" (id=1380)	
			value	RootBeanDefinition  (id=1381)	
		[8]	ConcurrentHashMap$WriteThroughEntry  (id=1782)	
			key	"org.springframework.context.event.internalEventListenerFactory" (id=1382)	
			value	RootBeanDefinition  (id=1383)	

		int registryId = System.identityHashCode(registry);	/ registry	DefaultListableBeanFactory  (id=43)	
		this.registriesPostProcessed.add(registryId);
		processConfigBeanDefinitions(registry);
/s
	/**
	 * Build and validate a configuration model based on the registry of
	 * {@link Configuration} classes.
	 */
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 274	

		List<BeanDefinitionHolder> configCandidates = new ArrayList<BeanDefinitionHolder>();
		String[] candidateNames = registry.getBeanDefinitionNames();

		for (String beanName : candidateNames) { / org.springframework.context.annotation.internalConfigurationAnnotationProcessor
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
/n
/ want	,
/s
	/**
	 * Determine whether the given bean definition indicates a full {@code @Configuration}
	 * class, through checking {@link #checkConfigurationClassCandidate}'s metadata marker.
	 */
ConfigurationClassUtils.isFullConfigurationClass(BeanDefinition) line: 190	
		return CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));
CONFIGURATION_CLASS_FULL="full"
CONFIGURATION_CLASS_ATTRIBUTE="org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass"
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 280	
		for (String beanName : candidateNames) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
/d
					ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
/s
	/**
	 * Determine whether the given bean definition indicates a lite {@code @Configuration}
	 * class, through checking {@link #checkConfigurationClassCandidate}'s metadata marker.
	 */
ConfigurationClassUtils.isLiteConfigurationClass(BeanDefinition) line: 198	
		return CONFIGURATION_CLASS_LITE.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));
CONFIGURATION_CLASS_LITE="lite"
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 285	
		for (String beanName : candidateNames) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
					ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
/n
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/s
	/**
	 * Check whether the given bean definition is a candidate for a configuration class
	 * (or a nested component class declared within a configuration/component class,
	 * to be auto-registered as well), and mark it accordingly.
	 *
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 81	
		String className = beanDef.getBeanClassName(); 	/ org.springframework.context.annotation.ConfigurationClassPostProcessor

		else if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
			// Check already loaded Class if present...
			// since we possibly can't even load the class file for this Class.
			Class<?> beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
			metadata = new StandardAnnotationMetadata(beanClass, true);
/s
StandardAnnotationMetadata.<init>(Class<?>, boolean) line: 68	
		super(introspectedClass);
		this.annotations = introspectedClass.getAnnotations();
[]
		this.nestedAnnotationsAsMap = nestedAnnotationsAsMap;
true
/t
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 111	
			metadata = new StandardAnnotationMetadata(beanClass, true);
/d
		if (isFullConfigurationCandidate(metadata)) {
/n
		else if (isLiteConfigurationCandidate(metadata)) {
/n
		else {
			return false;
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 277	
		for (String beanName : candidateNames) {
			...
			 if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/n
/ volgende,	
/ al de Spring beans net zo	, maar	,
		for (String beanName : candidateNames) {								/ knightConfig2
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
					ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
/n
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/s
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 87	
		if (beanDef instanceof AnnotatedBeanDefinition &&
				className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) {
			// Can reuse the pre-parsed metadata from the given BeanDefinition...
			metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();

metadata	StandardAnnotationMetadata  (id=33)	
	annotations	Annotation[2]  (id=157)	
		[0]	$Proxy5  (id=160)	
			h	AnnotationInvocationHandler  (id=167)	
				memberMethods	Method[11]  (id=170)	
				memberValues	LinkedHashMap<K,V>  (id=172)	
				type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=163)	
		[1]	$Proxy4  (id=161)	
			h	AnnotationInvocationHandler  (id=174)	
				memberMethods	Method[1]  (id=175)	
				memberValues	LinkedHashMap<K,V>  (id=176)	
				type	Class<T> (org.springframework.context.annotation.Configuration) (id=166)	
	introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=122)	
	nestedAnnotationsAsMap	true	

		if (isFullConfigurationCandidate(metadata)) {	/ 		return metadata.isAnnotated(Configuration.class.getName());
/j
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass:full

		// It's a full or lite configuration candidate... Let's determine the order value, if any.
		Map<String, Object> orderAttributes = metadata.getAnnotationAttributes(Order.class.getName());
null
/ TODO
		return true;
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 286	
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/d
/j
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));

/ Einde 		for (String beanName : candidateNames) {

		// Detect any custom bean name generation strategy supplied through the enclosing application context
		SingletonBeanRegistry singletonRegistry = null;
		if (registry instanceof SingletonBeanRegistry) {
			singletonRegistry = (SingletonBeanRegistry) registry;
			if (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {
/n
singletonRegistry	DefaultListableBeanFactory  (id=43)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=338)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=448)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=449)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=450)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=451)	
		[4]	ConcurrentHashMap$WriteThroughEntry  (id=452)	
		[5]	ConcurrentHashMap$WriteThroughEntry  (id=453)	
		[6]	ConcurrentHashMap$WriteThroughEntry  (id=454)	
		[7]	ConcurrentHashMap$WriteThroughEntry  (id=456)	
		[8]	ConcurrentHashMap$WriteThroughEntry  (id=457)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=48)	
		[0]	ConcurrentHashMap$WriteThroughEntry  (id=417)	
			key	"environment" (id=399)	
			value	StandardEnvironment  (id=400)	
		[1]	ConcurrentHashMap$WriteThroughEntry  (id=418)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=63)	
			value	ConfigurationClassPostProcessor  (id=54)	
		[2]	ConcurrentHashMap$WriteThroughEntry  (id=419)	
			key	"systemProperties" (id=410)	
			value	Properties  (id=411)	
		[3]	ConcurrentHashMap$WriteThroughEntry  (id=420)	
			key	"systemEnvironment" (id=407)	
			value	Collections$UnmodifiableMap<K,V>  (id=408)	
/ TODO

		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);

		Set<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);
		Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());
		do {
			parser.parse(candidates);
/s
ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 160	
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition();
			try {
				if (bd instanceof AnnotatedBeanDefinition) {
					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
/s
ConfigurationClassParser.parse(AnnotationMetadata, String) line: 197	
		processConfigurationClass(new ConfigurationClass(metadata, beanName));
/s
/**
 * Represents a user-defined {@link Configuration @Configuration} class.
 * Includes a set of {@link Bean} methods, including all such methods
 * defined in the ancestry of the class, in a 'flattened-out' manner.
 *
final class ConfigurationClass {
/t
/s
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 202	
		// Recursively process the configuration class and its superclass hierarchy.
		SourceClass sourceClass = asSourceClass(configClass);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
sourceClass	ConfigurationClassParser$SourceClass  (id=1620)	
	metadata	StandardAnnotationMetadata  (id=1622)	
		annotations	Annotation[2]  (id=1623)	
			[0]	$Proxy5  (id=160)	
			[1]	$Proxy4  (id=161)	
		introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=122)	
		nestedAnnotationsAsMap	true	
	source	Class<T> (sia.knights.config.KnightConfig2) (id=122)	
/s
	/**
	 * Apply processing and build a complete {@link ConfigurationClass} by reading the
	 * annotations, members and methods from the source class. This method can be called
	 * multiple times as relevant sources are discovered.
	 *
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 247	

/ intermezzo

/ we zijn in	,
/ stack	,
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 247	
		processMemberClasses(configClass, sourceClass);
/cb
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 230	
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/cb
	ConfigurationClassParser.parse(AnnotationMetadata, String) line: 197	
		processConfigurationClass(new ConfigurationClass(metadata, beanName));
/cb
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 166	
				if (bd instanceof AnnotatedBeanDefinition) {									/ bd=KnightConfig2
					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
/cb
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 324	
			parser.parse(candidates);
/cb
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 246	
		processConfigBeanDefinitions(registry);
/cb
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 270	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/cb
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 93	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
priorityOrderedPostProcessors	ArrayList<E>  (id=162)	
	[0]	ConfigurationClassPostProcessor  (id=127)	
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 686	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 524	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);										<-
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	MyKnightMain2.main(String[]) line: 11	


/ Einde intermezzo

		// Recursively process any member (nested) classes first
		processMemberClasses(configClass, sourceClass);
/s
ConfigurationClassParser.processMemberClasses(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 320	
		for (SourceClass memberClass : sourceClass.getMemberClasses()) {
/s
ConfigurationClassParser$SourceClass.getMemberClasses() line: 760	
			Object sourceToProcess = this.source;			/ class sia.knights.config.KnightConfig2
			if (sourceToProcess instanceof Class) {
				Class<?> sourceClass = (Class<?>) sourceToProcess;
				try {
					Class<?>[] declaredClasses = sourceClass.getDeclaredClasses();	/ declaredClasses	Class<T>[0]  (id=1664)	, nested classes

					List<SourceClass> members = new ArrayList<SourceClass>(declaredClasses.length);
					for (Class<?> declaredClass : declaredClasses) {
/n
						members.add(asSourceClass(declaredClass));
					}
					return members;
[]
/t
ConfigurationClassParser.processMemberClasses(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 337	
		for (SourceClass memberClass : sourceClass.getMemberClasses()) {
/n
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 250	
		// Recursively process any member (nested) classes first
		processMemberClasses(configClass, sourceClass);
/d
/ geen	,

/ intermezzo	

class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
/ Einde intermezzo	

		// Process any @PropertySource annotations
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {
/n
		// Process any @ComponentScan annotations
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
/s
AnnotationConfigUtils.attributesForRepeatable(AnnotationMetadata, Class<?>, Class<?>) line: 286	
		return attributesForRepeatable(metadata, containerClass.getName(), annotationClass.getName());
/s
AnnotationConfigUtils.attributesForRepeatable(AnnotationMetadata, String, String) line: 293	
/=
	static Set<AnnotationAttributes> attributesForRepeatable(AnnotationMetadata metadata,
			String containerClassName, String annotationClassName) {

containerClassName	"org.springframework.context.annotation.ComponentScans" (id=1690)	
annotationClassName	"org.springframework.context.annotation.ComponentScan" (id=1691)	

		Set<AnnotationAttributes> result = new LinkedHashSet<AnnotationAttributes>();
		addAttributesIfNotNull(result, metadata.getAnnotationAttributes(annotationClassName, false));	
/s
StandardAnnotationMetadata.getAnnotationAttributes(String, boolean) line: 117	
/=
	public Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {
annotationName	"org.springframework.context.annotation.ComponentScan" (id=1691)	
classValuesAsString	false	

		return (this.annotations.length > 0 ? AnnotatedElementUtils.getMergedAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, this.nestedAnnotationsAsMap) : null);
/s
	/**
	 * Get the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element} and
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * <p>Attributes from lower levels in the annotation hierarchy override attributes
	 * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are
	 * fully supported, both within a single annotation and within the annotation hierarchy.
	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by
	 * this method will stop searching the annotation hierarchy once the first annotation
	 * of the specified {@code annotationName} has been found. As a consequence,
	 * additional annotations of the specified {@code annotationName} will be ignored.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 *
AnnotatedElementUtils.getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 394	
/=
	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {
element	Class<T> (sia.knights.config.KnightConfig2) (id=122)	
annotationName	"org.springframework.context.annotation.ComponentScan" (id=1691)	
classValuesAsString	false	
nestedAnnotationsAsMap	true	

/ Intermezzo

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	/**
	 * Alias for {@link #basePackages}.
	 * <p>Allows for more concise annotation declarations if no other attributes
	 * are needed &mdash; for example, {@code @ComponentScan("org.my.pkg")}
	 * instead of {@code @ComponentScan(basePackages = "org.my.pkg")}.
	 */
	@AliasFor("basePackages")
	String[] value() default {};

	/**
	 * Base packages to scan for annotated components.
	 * <p>{@link #value} is an alias for (and mutually exclusive with) this
	 * attribute.
	 * <p>Use {@link #basePackageClasses} for a type-safe alternative to
	 * String-based package names.
	 */
	@AliasFor("value")
	String[] basePackages() default {};

	/**
	 * Type-safe alternative to {@link #basePackages} for specifying the packages
	 * to scan for annotated components. The package of each class specified will be scanned.
	 * <p>Consider creating a special no-op marker class or interface in each package
	 * that serves no purpose other than being referenced by this attribute.
	 */
	Class<?>[] basePackageClasses() default {};

	/**
	 * The {@link BeanNameGenerator} class to be used for naming detected components
	 * within the Spring container.
	 * <p>The default value of the {@link BeanNameGenerator} interface itself indicates
	 * that the scanner used to process this {@code @ComponentScan} annotation should
	 * use its inherited bean name generator, e.g. the default
	 * {@link AnnotationBeanNameGenerator} or any custom instance supplied to the
	 * application context at bootstrap time.
	 * @see AnnotationConfigApplicationContext#setBeanNameGenerator(BeanNameGenerator)
	 */
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

	/**
	 * The {@link ScopeMetadataResolver} to be used for resolving the scope of detected components.
	 */
	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

	/**
	 * Indicates whether proxies should be generated for detected components, which may be
	 * necessary when using scopes in a proxy-style fashion.
	 * <p>The default is defer to the default behavior of the component scanner used to
	 * execute the actual scan.
	 * <p>Note that setting this attribute overrides any value set for {@link #scopeResolver}.
	 * @see ClassPathBeanDefinitionScanner#setScopedProxyMode(ScopedProxyMode)
	 */
	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	/**
	 * Controls the class files eligible for component detection.
	 * <p>Consider use of {@link #includeFilters} and {@link #excludeFilters}
	 * for a more flexible approach.
	 */
	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

	/**
	 * Indicates whether automatic detection of classes annotated with {@code @Component}
	 * {@code @Repository}, {@code @Service}, or {@code @Controller} should be enabled.
	 */
	boolean useDefaultFilters() default true;

	/**
	 * Specifies which types are eligible for component scanning.
	 * <p>Further narrows the set of candidate components from everything in {@link #basePackages}
	 * to everything in the base packages that matches the given filter or filters.
	 * <p>Note that these filters will be applied in addition to the default filters, if specified.
	 * Any type under the specified base packages which matches a given filter will be included,
	 * even if it does not match the default filters (i.e. is not annotated with {@code @Component}).
	 * @see #resourcePattern()
	 * @see #useDefaultFilters()
	 */
	Filter[] includeFilters() default {};

	/**
	 * Specifies which types are not eligible for component scanning.
	 * @see #resourcePattern
	 */
	Filter[] excludeFilters() default {};

	/**
	 * Specify whether scanned beans should be registered for lazy initialization.
	 * <p>Default is {@code false}; switch this to {@code true} when desired.
	 * @since 4.1
	 */
	boolean lazyInit() default false;


	/**
	 * Declares the type filter to be used as an {@linkplain ComponentScan#includeFilters
	 * include filter} or {@linkplain ComponentScan#excludeFilters exclude filter}.
	 */
	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

		/**
		 * The type of filter to use.
		 * <p>Default is {@link FilterType#ANNOTATION}.
		 * @see #classes
		 * @see #pattern
		 */
		FilterType type() default FilterType.ANNOTATION;

		/**
		 * Alias for {@link #classes}.
		 * @see #classes
		 */
		@AliasFor("classes")
		Class<?>[] value() default {};

		/**
		 * The class or classes to use as the filter.
		 * <p>The following table explains how the classes will be interpreted
		 * based on the configured value of the {@link #type} attribute.
		 * <table border="1">
		 * <tr><th>{@code FilterType}</th><th>Class Interpreted As</th></tr>
		 * <tr><td>{@link FilterType#ANNOTATION ANNOTATION}</td>
		 * <td>the annotation itself</td></tr>
		 * <tr><td>{@link FilterType#ASSIGNABLE_TYPE ASSIGNABLE_TYPE}</td>
		 * <td>the type that detected components should be assignable to</td></tr>
		 * <tr><td>{@link FilterType#CUSTOM CUSTOM}</td>
		 * <td>an implementation of {@link TypeFilter}</td></tr>
		 * </table>
		 * <p>When multiple classes are specified, <em>OR</em> logic is applied
		 * &mdash; for example, "include types annotated with {@code @Foo} OR {@code @Bar}".
		 * <p>Custom {@link TypeFilter TypeFilters} may optionally implement any of the
		 * following {@link org.springframework.beans.factory.Aware Aware} interfaces, and
		 * their respective methods will be called prior to {@link TypeFilter#match match}:
		 * <ul>
		 * <li>{@link org.springframework.context.EnvironmentAware EnvironmentAware}</li>
		 * <li>{@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware}
		 * <li>{@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware}
		 * <li>{@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware}
		 * </ul>
		 * <p>Specifying zero classes is permitted but will have no effect on component
		 * scanning.
		 * @since 4.2
		 * @see #value
		 * @see #type
		 */
		@AliasFor("value")
		Class<?>[] classes() default {};

		/**
		 * The pattern (or patterns) to use for the filter, as an alternative
		 * to specifying a Class {@link #value}.
		 * <p>If {@link #type} is set to {@link FilterType#ASPECTJ ASPECTJ},
		 * this is an AspectJ type pattern expression. If {@link #type} is
		 * set to {@link FilterType#REGEX REGEX}, this is a regex pattern
		 * for the fully-qualified class names to match.
		 * @see #type
		 * @see #classes
		 */
		String[] pattern() default {};

	}

}

/ Einde Intermezzo

		AnnotationAttributes attributes = searchWithGetSemantics(element, null, annotationName,
				new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap));
element	Class<T> (sia.knights.config.KnightConfig2) (id=122)	
annotationName	"org.springframework.context.annotation.ComponentScan" (id=1691)	
classValuesAsString	false	
nestedAnnotationsAsMap	true	
attributes	AnnotationAttributes  (id=1709)	
	[0]	LinkedHashMap$Entry<K,V>  (id=1713)	
		key	"basePackageClasses" (id=1728)	
		value	AnnotationUtils$DefaultValueHolder  (id=1729)	
	[1]	LinkedHashMap$Entry<K,V>  (id=1714)	
		key	"resourcePattern" (id=1732)	
		value	AnnotationUtils$DefaultValueHolder  (id=1733)	
	[2]	LinkedHashMap$Entry<K,V>  (id=1715)	
		key	"basePackages" (id=1735)	
		value	AnnotationUtils$DefaultValueHolder  (id=1736)	
	[3]	LinkedHashMap$Entry<K,V>  (id=1716)	
		key	"scopeResolver" (id=1738)	
		value	AnnotationUtils$DefaultValueHolder  (id=1739)	
	[4]	LinkedHashMap$Entry<K,V>  (id=1717)	
		key	"scopedProxy" (id=1742)	
		value	AnnotationUtils$DefaultValueHolder  (id=1743)	
	[5]	LinkedHashMap$Entry<K,V>  (id=1718)	
		key	"nameGenerator" (id=1745)	
		value	AnnotationUtils$DefaultValueHolder  (id=1746)	
	[6]	LinkedHashMap$Entry<K,V>  (id=1720)	
		key	"useDefaultFilters" (id=1748)	
		value	AnnotationUtils$DefaultValueHolder  (id=1749)	
	[7]	LinkedHashMap$Entry<K,V>  (id=1721)	
		key	"includeFilters" (id=1752)	
		value	AnnotationUtils$DefaultValueHolder  (id=1753)	
	[8]	LinkedHashMap$Entry<K,V>  (id=1723)	
		key	"excludeFilters" (id=1755)	
		value	AnnotationUtils$DefaultValueHolder  (id=1756)	
	[9]	LinkedHashMap$Entry<K,V>  (id=1725)	
		key	"lazyInit" (id=1759)	
		value	AnnotationUtils$DefaultValueHolder  (id=1760)	
	[10]	LinkedHashMap$Entry<K,V>  (id=1726)	
		key	"value" (id=1763)	
		value	AnnotationUtils$DefaultValueHolder  (id=1764)	

		AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);
		return attributes;
/t
AnnotationConfigUtils.attributesForRepeatable(AnnotationMetadata, String, String) line: 296	
		addAttributesIfNotNull(result, metadata.getAnnotationAttributes(annotationClassName, false));
/d
result	LinkedHashSet<E>  (id=222)	
	[0]	AnnotationAttributes  (id=224)	
		[0]	LinkedHashMap$Entry<K,V>  (id=233)	
		[1]	LinkedHashMap$Entry<K,V>  (id=234)	
		[2]	LinkedHashMap$Entry<K,V>  (id=235)	
		[3]	LinkedHashMap$Entry<K,V>  (id=236)	
		[4]	LinkedHashMap$Entry<K,V>  (id=237)	
		[5]	LinkedHashMap$Entry<K,V>  (id=238)	
		[6]	LinkedHashMap$Entry<K,V>  (id=239)	
		[7]	LinkedHashMap$Entry<K,V>  (id=243)	
		[8]	LinkedHashMap$Entry<K,V>  (id=244)	
		[9]	LinkedHashMap$Entry<K,V>  (id=245)	
		[10]	LinkedHashMap$Entry<K,V>  (id=246)	

		Map<String, Object> container = metadata.getAnnotationAttributes(containerClassName, false);	/ containerClassName=ComponentScans
																			/ en deze annot is er niet	,
null

		return Collections.unmodifiableSet(result);
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 264	
		// Process any @ComponentScan annotations
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
/d
componentScans	Collections$UnmodifiableSet<E>  (id=1803)	
	[0]	AnnotationAttributes  (id=1709)	
		[0]	LinkedHashMap$Entry<K,V>  (id=1713)	
		[1]	LinkedHashMap$Entry<K,V>  (id=1714)	
		[2]	LinkedHashMap$Entry<K,V>  (id=1715)	
		[3]	LinkedHashMap$Entry<K,V>  (id=1716)	
		[4]	LinkedHashMap$Entry<K,V>  (id=1717)	
		[5]	LinkedHashMap$Entry<K,V>  (id=1718)	
		[6]	LinkedHashMap$Entry<K,V>  (id=1720)	
		[7]	LinkedHashMap$Entry<K,V>  (id=1721)	
		[8]	LinkedHashMap$Entry<K,V>  (id=1723)	
		[9]	LinkedHashMap$Entry<K,V>  (id=1725)	
		[10]	LinkedHashMap$Entry<K,V>  (id=1726)	

		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			for (AnnotationAttributes componentScan : componentScans) {
componentScans=
[{basePackageClasses=[], resourcePattern=**/*.class, basePackages=[], scopeResolver=class org.springframework.context.annotation.AnnotationScopeMetadataResolver, scopedProxy=DEFAULT, nameGenerator=interface org.springframework.beans.factory.support.BeanNameGenerator, useDefaultFilters=true, includeFilters=[], excludeFilters=[], lazyInit=false, value=[]}]
/ er is maar 1 componentScan	,
componentScan=
{basePackages=[], includeFilters=[], excludeFilters=[], useDefaultFilters=true, nameGenerator=interface org.springframework.beans.factory.support.BeanNameGenerator, scopedProxy=DEFAULT, basePackageClasses=[], scopeResolver=class org.springframework.context.annotation.AnnotationScopeMetadataResolver, resourcePattern=**/*.class, lazyInit=false, value=[]}

				// The config class is annotated with @ComponentScan -> perform the scan immediately
				Set<BeanDefinitionHolder> scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/s
StandardAnnotationMetadata(StandardClassMetadata).getClassName() line: 55	
		return this.introspectedClass.getName();
/t
/s
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 77	
/=
	public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
this	ComponentScanAnnotationParser  (id=367)	
	beanNameGenerator	AnnotationBeanNameGenerator  (id=377)	
	environment	StandardEnvironment  (id=27)	
	registry	DefaultListableBeanFactory  (id=89)	
	resourceLoader	AnnotationConfigApplicationContext  (id=25)	
declaringClass	"sia.knights.config.KnightConfig2" (id=213)	
componentScan	AnnotationAttributes  (id=224)	 {basePackages=[], includeFilters=[], excludeFilters=[], useDefaultFilters=true, nameGenerator=interface org.springframework.beans.factory.support.BeanNameGenerator, scopedProxy=DEFAULT, basePackageClasses=[], scopeResolver=class org.springframework.context.annotation.AnnotationScopeMetadataResolver, resourcePattern=**/*.class, lazyInit=false, value=[]}

		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/s
AnnotationAttributes.getBoolean(String) line: 255	
		return getRequiredAttribute(attributeName, Boolean.class);	/ "useDefaultFilters"
/s
	/**
	 * Get the value stored under the specified {@code attributeName},
	 * ensuring that the value is of the {@code expectedType}.
	 * <p>If the {@code expectedType} is an array and the value stored
	 * under the specified {@code attributeName} is a single element of the
	 * component type of the expected array type, the single element will be
	 * wrapped in a single-element array of the appropriate type before
	 * returning it.
	 *
AnnotationAttributes.getRequiredAttribute(String, Class<T>) line: 431	
		Object value = get(attributeName);
true

/ public class AnnotationAttributes extends LinkedHashMap<String, Object> {	, dus get is LinkedHashMap.get	,

		return (T) value;
true
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 81	
		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/pd
/s
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean) line: 111	
		this(registry, useDefaultFilters, getOrCreateEnvironment(registry));	/ registry	DefaultListableBeanFactory  (id=89)	
/s
ClassPathBeanDefinitionScanner.getOrCreateEnvironment(BeanDefinitionRegistry) line: 350	
		if (registry instanceof EnvironmentCapable) {
/n
			return ((EnvironmentCapable) registry).getEnvironment();
/n
		}
		return new StandardEnvironment();
/t
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean) line: 111	
		this(registry, useDefaultFilters, getOrCreateEnvironment(registry));
/pd
/s
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 136	
		super(useDefaultFilters, environment);
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 84	
	static final String DEFAULT_RESOURCE_PATTERN = "**/*.class";
	private ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();
	private MetadataReaderFactory metadataReaderFactory =
			new CachingMetadataReaderFactory(this.resourcePatternResolver);
	private String resourcePattern = DEFAULT_RESOURCE_PATTERN;

		if (useDefaultFilters) {
			registerDefaultFilters();
/s
	/**
	 * Register the default filter for {@link Component @Component}.			/ dus filter op @Component	,	 WH
	 * <p>This will implicitly register all annotations that have the
	 * {@link Component @Component} meta-annotation including the
	 * {@link Repository @Repository}, {@link Service @Service}, and	/ @Component public @interface Repository , WH zo	,
	 * {@link Controller @Controller} stereotype annotations.
	 * <p>Also supports Java EE 6's {@link javax.annotation.ManagedBean} and
	 * JSR-330's {@link javax.inject.Named} annotations, if available.
	 *
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 239	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
/s
AnnotationTypeFilter.<init>(Class<Annotation>) line: 54	
		this(annotationType, true, false);
/s
AnnotationTypeFilter.<init>(Class<Annotation>, boolean, boolean) line: 74	
annotationType	Class<T> (org.springframework.stereotype.Component) (id=84)	
	annotations	LinkedHashMap<K,V>  (id=441)	
		[0]	LinkedHashMap$Entry<K,V>  (id=455)	
			key	Class<T> (java.lang.annotation.Target) (id=473)	
			value	$Proxy2  (id=474)	
		[1]	LinkedHashMap$Entry<K,V>  (id=456)	
			key	Class<T> (java.lang.annotation.Retention) (id=480)	
			value	$Proxy1  (id=481)	
		[2]	LinkedHashMap$Entry<K,V>  (id=457)	
			key	Class<T> (java.lang.annotation.Documented) (id=487)	
			value	$Proxy3  (id=488)	
considerMetaAnnotations	true	
considerInterfaces	false	
		super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces);	/ Class<T>.isAnnotationPresent	, 
/s
AnnotationTypeFilter(AbstractTypeHierarchyTraversingFilter).<init>(boolean, boolean) line: 49	
/t
AnnotationTypeFilter.<init>(Class<Annotation>, boolean, boolean) line: 76	
		super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces);
/d
		this.annotationType = annotationType;
		this.considerMetaAnnotations = considerMetaAnnotations;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 240	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
/d
			this.includeFilters.add(new AnnotationTypeFilter(
					((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));
/ class not found	,
			this.includeFilters.add(new AnnotationTypeFilter(
					((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));
/ class not found	,
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 119	
			registerDefaultFilters();
		this.environment = environment;
/t
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 70	
		super(useDefaultFilters, environment);
/d
		this.registry = registry;
		// Determine ResourceLoader to use.
		if (this.registry instanceof ResourceLoader) {
/n
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 82	
		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/d
scanner	ClassPathBeanDefinitionScanner  (id=493)	
	autowireCandidatePatterns	null	
	beanDefinitionDefaults	BeanDefinitionDefaults  (id=495)	
	beanNameGenerator	AnnotationBeanNameGenerator  (id=497)	
	conditionEvaluator	null	
	environment	StandardEnvironment  (id=494)	
	excludeFilters	LinkedList<E>  (id=498)	
	includeAnnotationConfig	true	
	includeFilters	LinkedList<E>  (id=499)	
	logger	Log4JLogger  (id=500)	
	metadataReaderFactory	CachingMetadataReaderFactory  (id=501)	
	registry	DefaultListableBeanFactory  (id=43)	
	resourcePattern	"**/*.class" (id=505)	
	resourcePatternResolver	PathMatchingResourcePatternResolver  (id=506)	
	scopeMetadataResolver	AnnotationScopeMetadataResolver  (id=508)	


/ Intermezzo

/ we zijn in	, 
/ stack
/s
	ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 82	
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 268	
		// Process any @ComponentScan annotations
			for (AnnotationAttributes componentScan : componentScans) {
componentScans	Collections$UnmodifiableSet<E>  (id=416)	
	[0]	AnnotationAttributes  (id=414)		 / lijst van 11 attrs	, 
				// The config class is annotated with @ComponentScan -> perform the scan immediately
				Set<BeanDefinitionHolder> scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());

	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 230	
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/cb
	ConfigurationClassParser.parse(AnnotationMetadata, String) line: 197	
		processConfigurationClass(new ConfigurationClass(metadata, beanName));
/cb
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 166	
			BeanDefinition bd = holder.getBeanDefinition();
					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
/cb
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 324	
		// Parse each @Configuration class
			parser.parse(candidates);
candidates	LinkedHashSet<E>  (id=142)	
	[0]	BeanDefinitionHolder  (id=196)	
		beanDefinition	AnnotatedGenericBeanDefinition  (id=201)	
			beanClass	Class<T> (sia.knights.config.KnightConfig2) (id=64)	
			metadata	StandardAnnotationMetadata  (id=33)	
				annotations	Annotation[2]  (id=234)	
					[0]	$Proxy5  (id=237)	
						h	AnnotationInvocationHandler  (id=244)	
							memberMethods	Method[11]  (id=247)	
							memberValues	LinkedHashMap<K,V>  (id=249)	
							type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=240)	
					[1]	$Proxy4  (id=238)	
						h	AnnotationInvocationHandler  (id=251)	
							memberMethods	Method[1]  (id=252)	
							memberValues	LinkedHashMap<K,V>  (id=253)	
							type	Class<T> (org.springframework.context.annotation.Configuration) (id=243)	
		beanName	"knightConfig2" (id=155)	
/cb
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 246	
		processConfigBeanDefinitions(registry);
/cb
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 270	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/cb
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 93	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
priorityOrderedPostProcessors=[org.springframework.context.annotation.ConfigurationClassPostProcessor@28de323b]
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 686	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 524	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
		refresh();
/cb
	MyKnightMain2.main(String[]) line: 11	
    	ApplicationContext context=new AnnotationConfigApplicationContext(KnightConfig2.class);

/ Einde Intermezzo

		scanner.setEnvironment(this.environment);
		scanner.setResourceLoader(this.resourceLoader);
		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
/s
AnnotationAttributes.getClass(String) line: 297	
/=
	public <T> Class<? extends T> getClass(String attributeName) {
/ GENERICS STUDY 
		return getRequiredAttribute(attributeName, Class.class);
/s
	/**
	 * Get the value stored under the specified {@code attributeName},
	 * ensuring that the value is of the {@code expectedType}.
	 * <p>If the {@code expectedType} is an array and the value stored
	 * under the specified {@code attributeName} is a single element of the
	 * component type of the expected array type, the single element will be
	 * wrapped in a single-element array of the appropriate type before
	 * returning it.
	 *
AnnotationAttributes.getRequiredAttribute(String, Class<T>) line: 431	
/=
	private <T> T getRequiredAttribute(String attributeName, Class<T> expectedType) {
attributeName	"nameGenerator" (id=542)	
expectedType	Class<T> (java.lang.Class) (id=65)	
this	AnnotationAttributes  (id=414)	
	...
	[7]	LinkedHashMap$Entry<K,V>  (id=434)	
		key	"nameGenerator" (id=542)	
		value	Class<T> (org.springframework.beans.factory.support.BeanNameGenerator) (id=477)	

		Object value = get(attributeName);	/ LinkedHashMap.get
value	Class<T> (org.springframework.beans.factory.support.BeanNameGenerator) (id=477)	

		return (T) value;
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 86	
		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
/d
generatorClass	Class<T> (org.springframework.beans.factory.support.BeanNameGenerator) (id=477)	

		boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
true
		scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : BeanUtils.instantiateClass(generatorClass));

		ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
/s
AnnotationAttributes.getEnum(String) line: 283	
/=
	public <E extends Enum<?>> E getEnum(String attributeName) {
/ GENERICS STUDY
this	AnnotationAttributes  (id=414)	
	...
	[8]	LinkedHashMap$Entry<K,V>  (id=435)	
		key	"scopedProxy" (id=441)	
		value	ScopedProxyMode  (id=442)	

		return (E) getRequiredAttribute(attributeName, Enum.class);
/s
AnnotationAttributes.getRequiredAttribute(String, Class<T>) line: 431	
		Object value = get(attributeName);
value	ScopedProxyMode  (id=442)	DEFAULT
		return (T) value;
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 91	
		ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy"); / ScopedProxyMode  (id=442)	DEFAULT
/d
		if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
/n
		else {
			Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
/s
AnnotationAttributes.getClass(String) line: 297	
/=
	public <T> Class<? extends T> getClass(String attributeName) {
		return getRequiredAttribute(attributeName, Class.class);
/s
AnnotationAttributes.getRequiredAttribute(String, Class<T>) line: 431	
this	AnnotationAttributes  (id=414)	
	...
	[9]	LinkedHashMap$Entry<K,V>  (id=436)	
		key	"scopeResolver" (id=440)	
		value	Class<T> (org.springframework.context.annotation.AnnotationScopeMetadataResolver) (id=32)	

		Object value = get(attributeName);
		return (T) value;
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 96	
		else {
			Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
/d
			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
/s
	/**
	 * Instantiate a class using its no-arg constructor.
	 * <p>Note that this method tries to set the constructor accessible
	 * if given a non-accessible (that is, non-public) constructor.
	 */
	public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {
			return instantiateClass(clazz.getDeclaredConstructor());
/s
BeanUtils.instantiateClass(Constructor<T>, Object...) line: 139	
			ReflectionUtils.makeAccessible(ctor);	/ TODO
			return ctor.newInstance(args);
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 99	
			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
/d
		scanner.setResourcePattern(componentScan.getString("resourcePattern"));
componentScan	AnnotationAttributes  (id=414)	
	...
	[2]	LinkedHashMap$Entry<K,V>  (id=426)	
		key	"resourcePattern" (id=457)	
		value	"**/*.class" (id=458)	

		for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {
/n
		for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {
/n
		boolean lazyInit = componentScan.getBoolean("lazyInit");
componentScan	AnnotationAttributes  (id=414)	
	[10]	LinkedHashMap$Entry<K,V>  (id=437)	
		key	"lazyInit" (id=438)	
		value	Boolean  (id=439)	false

		if (lazyInit) {
/n
		Set<String> basePackages = new LinkedHashSet<String>();
		String[] basePackagesArray = componentScan.getStringArray("basePackages");
componentScan	AnnotationAttributes  (id=414)	
	[1]	LinkedHashMap$Entry<K,V>  (id=425)	
		key	"basePackages" (id=459)	
		value	String[0]  (id=460)	
	[6]	LinkedHashMap$Entry<K,V>  (id=433)	
		key	"basePackageClasses" (id=446)	
		value	Class<T>[0]  (id=447)	

		for (String pkg : basePackagesArray) {
/n
		for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
/n
		if (basePackages.isEmpty()) {
			basePackages.add(ClassUtils.getPackageName(declaringClass));
declaringClass	"sia.knights.config.KnightConfig2" (id=158)	

		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);
			}
		});
		return scanner.doScan(StringUtils.toStringArray(basePackages));	/ [sia.knights.config]
/s
	/**
	 * Perform a scan within the specified base packages,
	 * returning the registered bean definitions.
	 * <p>This method does <i>not</i> register an annotation config processor
	 * but rather leaves this up to the caller.
	 *
ClassPathBeanDefinitionScanner.doScan(String...) line: 245	

/ Intermezzo

/ we zien hieronder ConfigurationClassPostProcessor en ConfigurationClassParser	, 
/ we zien dat ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry called omdat we @ComponentScan hebben TODO  

/ we zijn in 	,
/ stack
/s
	ClassPathBeanDefinitionScanner.doScan(String...) line: 245	
	ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 137	
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 268	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 230	
	ConfigurationClassParser.parse(AnnotationMetadata, String) line: 197	
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 166	
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 324	
			parser.parse(candidates);
/cb
/**
 * {@link BeanFactoryPostProcessor} used for bootstrapping processing of
 * {@link Configuration @Configuration} classes.
 *
 * <p>Registered by default when using {@code <context:annotation-config/>} or
 * {@code <context:component-scan/>}. Otherwise, may be declared manually as
 * with any other BeanFactoryPostProcessor.
 *
 * <p>This post processor is {@link Ordered#HIGHEST_PRECEDENCE} as it is important
 * that any {@link Bean} methods declared in Configuration classes have their
 * respective bean definitions registered before any other BeanFactoryPostProcessor
 * executes.
 *
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 246	
		processConfigBeanDefinitions(registry);
/cb
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 270	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 93	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 686	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 524	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	MyKnightMain2.main(String[]) line: 11	


/ Einde Intermezzo

/s
	/**
	 * Perform a scan within the specified base packages,
	 * returning the registered bean definitions.
	 * <p>This method does <i>not</i> register an annotation config processor
	 * but rather leaves this up to the caller.
	 * @param basePackages the packages to check for annotated classes
	 * @return set of beans registered if any for tooling registration purposes (never {@code null})
	 */
ClassPathBeanDefinitionScanner.doScan(String...) line: 245	
		for (String basePackage : basePackages) { / [sia.knights.config]
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/s
	/**
	 * Scan the class path for candidate components.
	 * @param basePackage the package to check for annotated classes
	 * @return a corresponding Set of autodetected bean definitions
	 */
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 266	
		try {
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern;
classpath*:sia/knights/config/**/*.class
			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/s
	/**
	 * This implementation delegates to this context's ResourceLoader if it
	 * implements the ResourcePatternResolver interface, falling back to the
	 * default superclass behavior else.
	 * @see #setResourceLoader
	 */
AnnotationConfigApplicationContext(GenericApplicationContext).getResources(String) line: 228	
		if (this.resourceLoader instanceof ResourcePatternResolver) {
/n
		return super.getResources(locationPattern);
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).getResources(String) line: 1296	
		return this.resourcePatternResolver.getResources(locationPattern);
/s
PathMatchingResourcePatternResolver.getResources(String) line: 274	
		if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
/j
			// a class path resource (multiple resources for same name possible)
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
/j
/want
locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())=="sia/knights/config/**/*.class"
getPathMatcher()=org.springframework.util.AntPathMatcher@4910c30
/s
AntPathMatcher.isPattern(String) line: 169	
		return (path.indexOf('*') != -1 || path.indexOf('?') != -1);
path	"sia/knights/config/**/*.class" (id=271)	
/t
PathMatchingResourcePatternResolver.getResources(String) line: 279	
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
/d
				// a class path resource pattern
				return findPathMatchingResources(locationPattern);
locationPattern	"classpath*:sia/knights/config/**/*.class" (id=251)	
/s
	/**
	 * Find all resources that match the given location pattern via the
	 * Ant-style PathMatcher. Supports resources in jar files and zip files
	 * and in the file system.
	 */
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 459	
		String rootDirPath = determineRootDir(locationPattern);
classpath*:sia/knights/config/
		String subPattern = locationPattern.substring(rootDirPath.length());
**/*.class
		Resource[] rootDirResources = getResources(rootDirPath);
/s
PathMatchingResourcePatternResolver.getResources(String) line: 274	
/=
	public Resource[] getResources(String locationPattern) throws IOException {
locationPattern	"classpath*:sia/knights/config/" (id=273)	
			// a class path resource (multiple resources for same name possible)
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
/ locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())=="sia/knights/config/"
/n 	
/ zit geen * of ? in	,
			else {
				// all class path resources with the given name
				return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
/s
	/**
	 * Find all class location resources with the given location via the ClassLoader.
	 * Delegates to {@link #doFindAllClassPathResources(String)}.
	 */
PathMatchingResourcePatternResolver.findAllClassPathResources(String) line: 311	
/=
	protected Resource[] findAllClassPathResources(String location) throws IOException {
location	"sia/knights/config/" (id=280)	
		String path = location;
		if (path.startsWith("/")) {
/n
		Set<Resource> result = doFindAllClassPathResources(path);
/s
	/**
	 * Find all class location resources with the given path via the ClassLoader.
	 */
PathMatchingResourcePatternResolver.doFindAllClassPathResources(String) line: 330	
		ClassLoader cl = getClassLoader();
		Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));			<-
		while (resourceUrls.hasMoreElements()) {
			URL url = resourceUrls.nextElement();	
file:/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/
			result.add(convertClassLoaderURL(url));
/s
	/**
	 * Convert the given URL as returned from the ClassLoader into a {@link Resource}.
	 * <p>The default implementation simply creates a {@link UrlResource} instance.
	 */
	protected Resource convertClassLoaderURL(URL url) {
		return new UrlResource(url);		/ Spring type	,

/ Intermezzo

[eric@localhost apache-tomcat-8.0.28]$ ls /home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config
KnightConfig2.class  KnightConfig.class  SoundSystemConfig.class

/ Einde Intermezzo

PathMatchingResourcePatternResolver.doFindAllClassPathResources(String) line: 337	
		while (resourceUrls.hasMoreElements()) {
			URL url = resourceUrls.nextElement();
			result.add(convertClassLoaderURL(url));
/d
result	LinkedHashSet<E>  (id=282)	
	[0]	UrlResource  (id=334)	
		cleanedUrl	URL  (id=338)	
file:/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/
		uri	null	
		url	URL  (id=330)	
file:/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/

		return result;
/t
PathMatchingResourcePatternResolver.findAllClassPathResources(String) line: 319	
		Set<Resource> result = doFindAllClassPathResources(path);
/d
		return result.toArray(new Resource[result.size()]);		/ Resource is een Spring type	,
/t
PathMatchingResourcePatternResolver.getResources(String) line: 283	
			else {
				// all class path resources with the given name
				return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
/d
/t
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 462	
		Resource[] rootDirResources = getResources(rootDirPath);
/d
[URL [file:/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/]]

		Set<Resource> result = new LinkedHashSet<Resource>(16);
		for (Resource rootDirResource : rootDirResources) {
			rootDirResource = resolveRootDirResource(rootDirResource);		/= return original;
			URL rootDirURL = rootDirResource.getURL();
file:/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/

			else if (ResourceUtils.isJarURL(rootDirURL) || isJarResource(rootDirResource)) {
/n
				result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirURL, subPattern));
			}
			else {
				result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
subPattern="**/*.class"
/s
	/**
	 * Find all resources in the file system that match the given location pattern
	 * via the Ant-style PathMatcher.
	 *
PathMatchingResourcePatternResolver.doFindPathMatchingFileResources(Resource, String) line: 687	
			rootDir = rootDirResource.getFile().getAbsoluteFile();
		return doFindMatchingFileSystemResources(rootDir, subPattern);
/s
PathMatchingResourcePatternResolver.doFindMatchingFileSystemResources(File, String) line: 713	
		Set<File> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);
/s
PathMatchingResourcePatternResolver.retrieveMatchingFiles(File, String) line: 754	
		if (!pattern.startsWith("/")) {
			fullPattern += "/";
/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/
/ eindigt op /
		Set<File> result = new LinkedHashSet<File>(8);
		doRetrieveMatchingFiles(fullPattern, rootDir, result);
/s
PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(String, File, Set<File>) line: 772	
/=
	protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set<File> result) throws IOException {
fullPattern	"/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/**/*.class" (id=404)	
dir	File  (id=396)	/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config

		File[] dirContents = dir.listFiles();
dirContents	File[3]  (id=415)	
	[0]	File  (id=417)	
/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/KnightConfig.class
	[1]	File  (id=418)	
/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/KnightConfig2.class
	[2]	File  (id=419)	
/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/SoundSystemConfig.class

			if (getPathMatcher().match(fullPattern, currPath)) {
				result.add(content);
/t
PathMatchingResourcePatternResolver.retrieveMatchingFiles(File, String) line: 759	
		doRetrieveMatchingFiles(fullPattern, rootDir, result);
/d
		return result;
/t
PathMatchingResourcePatternResolver.doFindMatchingFileSystemResources(File, String) line: 714	
		Set<File> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);
/d
		for (File file : matchingFiles) {
			result.add(new FileSystemResource(file));	/ String type	,
		}
		return result;
/t
PathMatchingResourcePatternResolver.doFindPathMatchingFileResources(Resource, String) line: 696	
		return doFindMatchingFileSystemResources(rootDir, subPattern);
/d
/t
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 479	
		for (Resource rootDirResource : rootDirResources) {
			else {
				result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
/pd
/d
/ Geen volgende for loop	,
		return result.toArray(new Resource[result.size()]);
/t
PathMatchingResourcePatternResolver.getResources(String) line: 279	
		if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
			// a class path resource (multiple resources for same name possible)
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
				// a class path resource pattern
				return findPathMatchingResources(locationPattern);
/d
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).getResources(String) line: 1296	
		return this.resourcePatternResolver.getResources(locationPattern);
/d
/t
AnnotationConfigApplicationContext(GenericApplicationContext).getResources(String) line: 231	
		return super.getResources(locationPattern);
/d
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 271	
			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/d
resources	Resource[3]  (id=442)	
	[0]	FileSystemResource  (id=445)	
file [/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/KnightConfig.class]
	[1]	FileSystemResource  (id=446)	
file [/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/KnightConfig2.class]
	[2]	FileSystemResource  (id=447)	
file [/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/SoundSystemConfig.class]

			for (Resource resource : resources) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
/s
CachingMetadataReaderFactory.getMetadataReader(Resource) line: 102	
		synchronized (this.metadataReaderCache) {
			MetadataReader metadataReader = this.metadataReaderCache.get(resource);
			if (metadataReader == null) {
				metadataReader = super.getMetadataReader(resource);
/s
CachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(Resource) line: 98	
		return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
/s
SimpleMetadataReader.<init>(Resource, ClassLoader) line: 64	
			classReader = new ClassReader(is);
/s
ClassReader.<init>(InputStream) line: 426	
        this(readClass(is, false));
/s
    /**
     * Reads the bytecode of a class.
     * 
     * @param is
     *            an input stream from which to read the class.
     * @param close
     *            true to close the input stream after reading.
     * @return the bytecode read from the given input stream.
     */
    private static byte[] readClass(final InputStream is, boolean close)
            throws IOException {
        if (is == null) {
            throw new IOException("Class not found");
        }
        try {
            byte[] b = new byte[is.available()];
            int len = 0;
            while (true) {
                int n = is.read(b, len, b.length - len);
/t
/s
ClassReader.<init>(InputStream) line: 426	
        this(readClass(is, false));
/pd
/s
ClassReader.<init>(byte[]) line: 153	
        this(b, 0, b.length);
/s
ClassReader.<init>(byte[], int, int) line: 181	
/=
    public ClassReader(final byte[] b, final int off, final int len) {
/ off=0
/ len=875
        // parses the constant pool
        items = new int[readUnsignedShort(off + 8)];
        int n = items.length;
41
        strings = new String[n];
        int max = 0;
        int index = off + 10;
        for (int i = 1; i < n; ++i) {
            items[i] = index + 1;
[0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            int size;
            switch (b[index]) {
            default:
                size = 3;
                break;
            }
            index += size;
		}
/ volgende,
        for (int i = 1; i < n; ++i) {
            items[i] = index + 1;
[0, 11, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            int size;
            switch (b[index]) {
            case ClassWriter.UTF8:
                size = 3 + readUnsignedShort(index + 1);
34
                if (size > max) {
                    max = size;
                }
                break;
			}
            index += size;
/ volgende	,
        for (int i = 1; i < n; ++i) {
            items[i] = index + 1;
[0, 11, 14, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            int size;
            switch (b[index]) {
            default:
                size = 3;
                break;
            }
...
/ TODO Afmaken
/t
SimpleMetadataReader.<init>(Resource, ClassLoader) line: 60	
			classReader = new ClassReader(is);
/d
classReader	ClassReader  (id=539)	
	b	(id=540)	
	header	621	
	items	(id=544)	
[0, 11, 14, 48, 51, 70, 79, 85, 92, 97, 102, 120, 141, 148, 184, 193, 218, 246, 294, 297, 323, 328, 333, 341, 365, 370, 375, 400, 403, 433, 438, 441, 460, 465, 471, 495, 500, 505, 532, 545, 565]
	maxStringLength	57	
	strings	String[41]  (id=545)	

		AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);
		classReader.accept(visitor, ClassReader.SKIP_DEBUG);
/s
ClassReader.accept(ClassVisitor, int) line: 508	
        accept(classVisitor, new Attribute[0], flags);
/s
    /**
     * Makes the given visitor visit the Java class of this {@link ClassReader}.
     * This class is the one specified in the constructor (see
     * {@link #ClassReader(byte[]) ClassReader}).
     * 
     * @param classVisitor
     *            the visitor that must visit this class.
     * @param attrs
     *            prototypes of the attributes that must be parsed during the
     *            visit of the class. Any attribute whose type is not equal to
     *            the type of one the prototypes will not be parsed: its byte
     *            array value will be passed unchanged to the ClassWriter.
     *            <i>This may corrupt it if this value contains references to
     *            the constant pool, or has syntactic or semantic links with a
     *            class element that has been transformed by a class adapter
     *            between the reader and the writer</i>.
     * @param flags
     *            option flags that can be used to modify the default behavior
     *            of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES}
     *            , {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
     */
ClassReader.accept(ClassVisitor, Attribute[], int) line: 543	
/ MORGENOCHTEND V


/ TO MERGE 

/ 13
		if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {							<-
			RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
		}
"org.springframework.context.annotation.internalConfigurationAnnotationProcessor":new RootBeanDefinition(ConfigurationClassPostProcessor.class)

		if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
			RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
		}
"org.springframework.context.annotation.internalAutowiredAnnotationProcessor":new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class)

		if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
			RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
			def.setSource(source);
			beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
		}
"org.springframework.context.annotation.internalRequiredAnnotationProcessor":new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class)

	public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment) {

/ 13

/ KnightConfig2's metaData= 2 annotations @ComponentScan en @Configuration
abd	AnnotatedGenericBeanDefinition  (id=214)	
	metadata	StandardAnnotationMetadata  (id=224)	
		annotations	Annotation[2]  (id=1111)	
			[0]	$Proxy4  (id=1113)	
				h	AnnotationInvocationHandler  (id=1116)	
					memberMethods	Method[1]  (id=1118)	
					memberValues	LinkedHashMap<K,V>  (id=1119)	
					type	Class<T> (org.springframework.context.annotation.Configuration) (id=1043)	
			[1]	$Proxy5  (id=1114)	
				h	AnnotationInvocationHandler  (id=1121)	
					memberMethods	Method[11]  (id=1123)	
					memberValues	LinkedHashMap<K,V>  (id=1124)	
					type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=898)	
		introspectedClass	Class<T> (sia.knights.config.KnightConfig2) (id=204)	
		nestedAnnotationsAsMap	true	

		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
/ Geen 	@Lazy, @Primary, @DependsOn, @Role	, @Description	, 

AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 524	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/s
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 81	
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
/ want	,
"org.springframework.context.annotation.internalConfigurationAnnotationProcessor":new RootBeanDefinition(ConfigurationClassPostProcessor.class)
/ en	,
public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {

/stack	,
/s
	ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 122	
		if (isFullConfigurationCandidate(metadata)) {	/= 		return metadata.isAnnotated(Configuration.class.getName());
/j
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL); / org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass : full
		return true;
/cb
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 285	
		for (String beanName : candidateNames) { 							/ 9	, waaronder KnightConfig2	,
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {	 / heeft @Configuration	?
/ WHERE @CONFIGURATION IS USED
/j
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
[Bean definition with name 'knightConfig2': Generic bean: class [sia.knights.config.KnightConfig2]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null]
f
		// Return immediately if no @Configuration classes were found
		if (configCandidates.isEmpty()) {								
/n
			return;
/n
		}
/cb
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 246	
		processConfigBeanDefinitions(registry);
/cb
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 270	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/cb
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 93	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 686	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 524	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	MyKnightMain2.main(String[]) line: 11	
/ debug	,
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 317	
		for (String beanName : candidateNames) {
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
		// Return immediately if no @Configuration classes were found
		if (configCandidates.isEmpty()) {								/j als KnightConfig2 GEEN @Configuration	,
/ WHERE @CONFIGURATION IS USED
/n
			return;
/n
		}
/d
onfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
/s
ConfigurationClassParser.<init>(MetadataReaderFactory, ProblemReporter, Environment, ResourceLoader, BeanNameGenerator, BeanDefinitionRegistry) line: 153	
		this.componentScanParser = new ComponentScanAnnotationParser(
				environment, resourceLoader, componentScanBeanNameGenerator, registry);
		Set<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);
		Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());
		do {
			parser.parse(candidates);
/s
ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 166	
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition();
			try {
				if (bd instanceof AnnotatedBeanDefinition) {
					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
/s
ConfigurationClassParser.parse(AnnotationMetadata, String) line: 197	
		processConfigurationClass(new ConfigurationClass(metadata, beanName));
/s
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 230	
		// Recursively process the configuration class and its superclass hierarchy.
		SourceClass sourceClass = asSourceClass(configClass);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 247	
		// Process any @ComponentScan annotations
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
/s
AnnotationConfigUtils.attributesForRepeatable(AnnotationMetadata, Class<?>, Class<?>) line: 286	
		return attributesForRepeatable(metadata, containerClass.getName(), annotationClass.getName());
/s
AnnotationConfigUtils.attributesForRepeatable(AnnotationMetadata, String, String) line: 296	
/ TODO
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 267	
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
/d
/ WHERE @COMPONENTSCAN IS USED
sourceClass=KnightConfig2	,
[{basePackageClasses=[], nameGenerator=interface org.springframework.beans.factory.support.BeanNameGenerator, scopeResolver=class org.springframework.context.annotation.AnnotationScopeMetadataResolver, scopedProxy=DEFAULT, basePackages=[], lazyInit=false, includeFilters=[], excludeFilters=[], useDefaultFilters=true, resourcePattern=**/*.class, value=[]}]
		if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			for (AnnotationAttributes componentScan : componentScans) {
/componentScan=
{basePackageClasses=[], nameGenerator=interface org.springframework.beans.factory.support.BeanNameGenerator, scopeResolver=class org.springframework.context.annotation.AnnotationScopeMetadataResolver, scopedProxy=DEFAULT, basePackages=[], lazyInit=false, includeFilters=[], excludeFilters=[], useDefaultFilters=true, resourcePattern=**/*.class, value=[]}
				// The config class is annotated with @ComponentScan -> perform the scan immediately
				Set<BeanDefinitionHolder> scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/s
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 77	
		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/s
	/**
	 * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.
	 * <p>If the passed-in bean factory does not only implement the
	 * {@code BeanDefinitionRegistry} interface but also the {@code ResourceLoader}
	 * interface, it will be used as default {@code ResourceLoader} as well. This will
	 * usually be the case for {@link org.springframework.context.ApplicationContext}
	 * implementations.
	 * <p>If given a plain {@code BeanDefinitionRegistry}, the default {@code ResourceLoader}
	 * will be a {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.
	 * <p>If the passed-in bean factory also implements {@link EnvironmentCapable} its
	 * environment will be used by this reader.  Otherwise, the reader will initialize and
	 * use a {@link org.springframework.core.env.StandardEnvironment}. All
	 * {@code ApplicationContext} implementations are {@code EnvironmentCapable}, while
	 * normal {@code BeanFactory} implementations are not.
	 * @param registry the {@code BeanFactory} to load bean definitions into, in the form
	 * of a {@code BeanDefinitionRegistry}
	 */
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean) line: 111	
		this(registry, useDefaultFilters, getOrCreateEnvironment(registry));
/s
/**
 * A component provider that scans the classpath from a base package. It then
 * applies exclude and include filters to the resulting classes to find candidates.
 *
 * <p>This implementation is based on Spring's
 * {@link org.springframework.core.type.classreading.MetadataReader MetadataReader}
 * facility, backed by an ASM {@link org.springframework.asm.ClassReader ClassReader}.
 *
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 81	
	static final String DEFAULT_RESOURCE_PATTERN = "**/*.class";
	private ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();
	private String resourcePattern = DEFAULT_RESOURCE_PATTERN;
		if (useDefaultFilters) {
			registerDefaultFilters();
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 239	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
/s
/**
 * A simple filter which matches classes with a given annotation,
 * checking inherited annotations as well.
 *
public class AnnotationTypeFilter extends AbstractTypeHierarchyTraversingFilter {
	/**
	 * Create a new AnnotationTypeFilter for the given annotation type.
	 * This filter will also match meta-annotations. To disable the
	 * meta-annotation matching, use the constructor that accepts a
	 * '{@code considerMetaAnnotations}' argument. The filter will
	 * not match interfaces.
	 * @param annotationType the annotation type to match
	 */
AnnotationTypeFilter.<init>(Class<Annotation>) line: 54	
		this(annotationType, true, false);
annotationType=interface org.springframework.stereotype.Component
/t
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 70	
	private BeanNameGenerator beanNameGenerator = new AnnotationBeanNameGenerator();
	private ScopeMetadataResolver scopeMetadataResolver = new AnnotationScopeMetadataResolver();
		// Determine ResourceLoader to use.
		if (this.registry instanceof ResourceLoader) {	/ registry=DefaultListableBeanFactory	, 
/n
			setResourceLoader((ResourceLoader) this.registry);
/n
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 82	
		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/d
		scanner.setResourceLoader(this.resourceLoader);
this	ComponentScanAnnotationParser  (id=177)	
	beanNameGenerator	AnnotationBeanNameGenerator  (id=235)	
	environment	StandardEnvironment  (id=28)	
	registry	DefaultListableBeanFactory  (id=89)	
	resourceLoader	AnnotationConfigApplicationContext  (id=25)	

		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");	/ via attributes of @ComponentScan	,
...
scanner	ClassPathBeanDefinitionScanner  (id=245)	
	autowireCandidatePatterns	null	
	beanDefinitionDefaults	BeanDefinitionDefaults  (id=278)	
	beanNameGenerator	AnnotationBeanNameGenerator  (id=235)	
	conditionEvaluator	null	
	environment	StandardEnvironment  (id=28)	
	excludeFilters	LinkedList<E>  (id=342)	
	includeAnnotationConfig	true	
	includeFilters	LinkedList<E>  (id=343)	
	logger	Log4JLogger  (id=348)	
	metadataReaderFactory	CachingMetadataReaderFactory  (id=351)	
	registry	DefaultListableBeanFactory  (id=89)	
	resourcePattern	"**/*.class" (id=356)	
	resourcePatternResolver	AnnotationConfigApplicationContext  (id=25)	
	scopeMetadataResolver	AnnotationScopeMetadataResolver  (id=357)	

		return scanner.doScan(StringUtils.toStringArray(basePackages));
basePackages=[sia.knights.config]
/s
ClassPathBeanDefinitionScanner.doScan(String...) line: 248	
		for (String basePackage : basePackages) {
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 279	
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					resolveBasePackage(basePackage) + '/' + this.resourcePattern;
classpath*:sia/knights/config/**/*.class

			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/ antwoord	,
resources	Resource[3]  (id=510)	
	[0]	FileSystemResource  (id=505)	
file [/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/KnightConfig.class]
	[1]	FileSystemResource  (id=506)	
file [/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/KnightConfig2.class]
	[2]	FileSystemResource  (id=509)	
file [/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace-wicket7_5/my-knight/target/classes/sia/knights/config/SoundSystemConfig.class]
/s
/stack
	ClassReader.accept(ClassVisitor, Attribute[], int) line: 547	
	ClassReader.accept(ClassVisitor, int) line: 508	
	SimpleMetadataReader.<init>(Resource, ClassLoader) line: 64	
	CachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(Resource) line: 98	
	CachingMetadataReaderFactory.getMetadataReader(Resource) line: 102	
	ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 279	
/ debug	,
/s
ClassReader.accept(ClassVisitor, Attribute[], int) line: 547	
this	ClassReader  (id=548)	
	b	(id=550)	
[-54, -2, -70, -66, 0, 0, 0, 49, 0, 41, 7, 0, 2, 1, 0, 31, 115, 105, 97, 47, 107, 110, 105, 103, 104, 116, 115, 47, 99, 111, 110, 102, 105, 103, 47, 75, 110, 105, 103, 104, 116, 67, 111, 110, 102, 105, 103, 7, 0, 4, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 10, 0, 3, 0, 9, 12, 0, 5, 0, 6, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 18, 76, 111, 99, 97, 108, 86, 97, 114, 105, 97, 98, 108, 101, 84, 97, 98, 108, 101, 1, 0, 4, 116, 104, 105, 115, 1, 0, 33, 76, 115, 105, 97, 47, 107, 110, 105, 103, 104, 116, 115, 47, 99, 111, 110, 102, 105, 103, 47, 75, 110, 105, 103, 104, 116, 67, 111, 110, 102, 105, 103, 59, 1, 0, 6, 107, 110, 105, 103, 104, 116, 1, 0, 22, 40, 41, 76, 115, 105, 97, 47, 107, 110, 105, 103, 104, 116, 115, 47, 75, 110, 105, 103, 104, 116, 59, 1, 0, 25, 82, 117, 110, 116, 105, 109, 101, 86, 105, 115, 105, 98, 108, 101, 65, 110, 110, 111, 116, 97, 116, 105, 111, 110, 115, 1, 0, 45, 76, 111, 114, 103, 47, 115, 112, 114, 105, 110, 103, 102, 114, 97, 109, 101, 119, 111, 114, 107, 47, 99, 111, 110, 116, 101, 120, 116, 47, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110, 47, 66, 101, 97, 110, 59, 7, 0, 19, 1, 0, 23, 115, 105, 97, 47, 107, 110, 105, 103, 104, 116, 115, 47, 66, 114, 97, 118, 101, 75, 110, 105, 103, 104, 116, 10, 0, 1, 0, 21, 12, 0, 22, 0, 23, 1, 0, 5, 113, 117, 101, 115, 116, 1, 0, 21, 40, 41, 76, 115, 105, 97, 47, 107, 110, 105, 103, 104, 116, 115, 47, 81, 117, 101, 115, 116, 59, 10, 0, 18, 0, 25, 12, 0, 5, 0, 26, 1, 0, 22, 40, 76, 115, 105, 97, 47, 107, 110, 105, 103, 104, 116, 115, 47, 81, 117, 101, 115, 116, 59, 41, 86, 7, 0, 28, 1, 0, 27, 115, 105, 97, 47, 107, 110, 105, 103, 104, 116, 115, 47, 83, 108, 97, 121, 68, 114, 97, 103, 111, 110, 81, 117, 101, 115, 116, 9, 0, 30, 0, 32, 7, 0, 31, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 121, 115, 116, 101, 109, 12, 0, 33, 0, 34, 1, 0, 3, 111, 117, 116, 1, 0, 21, 76, 106, 97, 118, 97, 47, 105, 111, 47, 80, 114, 105, 110, 116, 83, 116, 114, 101, 97, 109, 59, 10, 0, 27, 0, 36, 12, 0, 5, 0, 37, 1, 0, 24, 40, 76, 106, 97, 118, 97, 47, 105, 111, 47, 80, 114, 105, 110, 116, 83, 116, 114, 101, 97, 109, 59, 41, 86, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 17, 75, 110, 105, 103, 104, 116, 67, 111, 110, 102, 105, 103, 46, 106, 97, 118, 97, 1, 0, 54, 76, 111, 114, 103, 47, 115, 112, 114, 105, 110, 103, 102, 114, 97, 109, 101, 119, 111, 114, 107, 47, 99, 111, 110, 116, 101, 120, 116, 47, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110, 47, 67, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 59, 0, 33, 0, 1, 0, 3, 0, 0, 0, 0, 0, 3, 0, 1, 0, 5, 0, 6, 0, 1, 0, 7, 0, 0, 0, 47, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 8, -79, 0, 0, 0, 2, 0, 10, 0, 0, 0, 6, 0, 1, 0, 0, 0, 12, 0, 11, 0, 0, 0, 12, 0, 1, 0, 0, 0, 5, 0, 12, 0, 13, 0, 0, 0, 1, 0, 14, 0, 15, 0, 2, 0, 16, 0, 0, 0, 6, 0, 1, 0, 17, 0, 0, 0, 7, 0, 0, 0, 54, 0, 3, 0, 1, 0, 0, 0, 12, -69, 0, 18, 89, 42, -74, 0, 20, -73, 0, 24, -80, 0, 0, 0, 2, 0, 10, 0, 0, 0, 6, 0, 1, 0, 0, 0, 16, 0, 11, 0, 0, 0, 12, 0, 1, 0, 0, 0, 12, 0, 12, 0, 13, 0, 0, 0, 1, 0, 22, 0, 23, 0, 2, 0, 16, 0, 0, 0, 6, 0, 1, 0, 17, 0, 0, 0, 7, 0, 0, 0, 53, 0, 3, 0, 1, 0, 0, 0, 11, -69, 0, 27, 89, -78, 0, 29, -73, 0, 35, -80, 0, 0, 0, 2, 0, 10, 0, 0, 0, 6, 0, 1, 0, 0, 0, 21, 0, 11, 0, 0, 0, 12, 0, 1, 0, 0, 0, 11, 0, 12, 0, 13, 0, 0, 0, 2, 0, 38, 0, 0, 0, 2, 0, 39, 0, 16, 0, 0, 0, 6, 0, 1, 0, 40, 0, 0]
	header	621	
	items	(id=570)	
[0, 11, 14, 48, 51, 70, 79, 85, 92, 97, 102, 120, 141, 148, 184, 193, 218, 246, 294, 297, 323, 328, 333, 341, 365, 370, 375, 400, 403, 433, 438, 441, 460, 465, 471, 495, 500, 505, 532, 545, 565]
	maxStringLength	57	
	strings	String[41]  (id=572)	
[null, null, sia/knights/config/KnightConfig, null, java/lang/Object, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]

        Context context = new Context();
        context.attrs = attrs;
        context.flags = flags;
        context.buffer = c;

        // reads the class declaration
        int access = readUnsignedShort(u);
33
        String name = readClass(u + 2, c);
sia/knights/config/KnightConfig
        String superClass = readClass(u + 4, c);
java/lang/Object
        String[] interfaces = new String[readUnsignedShort(u + 6)];
[]
        u += 8;
        for (int i = 0; i < interfaces.length; ++i) {
/n
        int u = header; // current offset in the class file
        u = getAttributes();
853
        for (int i = readUnsignedShort(u); i > 0; --i) {
            String attrName = readUTF8(u + 2, c);
SourceFile
            if ("SourceFile".equals(attrName)) {
                sourceFile = readUTF8(u + 8, c);
KnightConfig.java
/ TODO Afmaken	, 
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 279	
			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/d
			for (Resource resource : resources) {
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
/s
CachingMetadataReaderFactory.getMetadataReader(Resource) line: 103		/ KnightConfig.class	, heeft alleen @Configuration	, 	
																				/ en @interface Configuration heeft @Component	,
		synchronized (this.metadataReaderCache) {
			MetadataReader metadataReader = this.metadataReaderCache.get(resource);
			if (metadataReader == null) {
				metadataReader = super.getMetadataReader(resource);
				this.metadataReaderCache.put(resource, metadataReader);
			return metadataReader;
metaDataReader
	annotationMetadata
		annotationSet
			[0] "org.springframework.context.annotation.Configuration"
		attributesMap
			[0] 
				key "org.springframework.context.annotation.Configuration"
				value ...
			[1] 
				key "org.springframework.context.annotation.Component"
				value ...
	classMetadata
		annotationSet
			[0] "org.springframework.context.annotation.Configuration"
		attributesMap
			[0] 
				key "org.springframework.context.annotation.Configuration"
				value ...
			[1] 
				key "org.springframework.context.annotation.Component"
				value ...
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 280	
			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/ 3 config classe	,
			for (Resource resource : resources) {
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);	/ KnightConfig	,
/d
						if (isCandidateComponent(metadataReader)) {
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 341	
		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/s
ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 65	
		if (matchClassName(metadata.getClassName())) {
/s
ComponentScanAnnotationParser$1.matchClassName(String) line: 134	
/=
	public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {	/ declaringClass=KnightConfig2
		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);			/ declaringClass=KnightConfig2	, 
																		/ className=KnightConfig	, die we nu bekijken	,
/t
ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 65	
		if (matchClassName(metadata.getClassName())) {
/n
		return false;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 347	

this	ClassPathBeanDefinitionScanner  (id=210)	
	excludeFilters	LinkedList<E>  (id=1291)	
		[0]	ComponentScanAnnotationParser$1  (id=302)	
	includeFilters	LinkedList<E>  (id=1292)	
		[0]	AnnotationTypeFilter  (id=1303)	
			annotationType	Class<T> (org.springframework.stereotype.Component) (id=131)	

		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/n
		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/j
/ TODO
				return isConditionMatch(metadataReader);
/ TODO
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 281	
			for (Resource resource : resources) {		/ KnightConfig
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
/d
/j
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
metadataReader	SimpleMetadataReader  (id=229)	
	annotationMetadata	AnnotationMetadataReadingVisitor  (id=245)	
	classMetadata	AnnotationMetadataReadingVisitor  (id=245)	
	resource	FileSystemResource  (id=219)	

							sbd.setResource(resource);	/ KnightConfig
							sbd.setSource(resource);
							if (isCandidateComponent(sbd)) {
								if (debugEnabled) {
									logger.debug("Identified candidate component class: " + resource);
								}
								candidates.add(sbd);
/ volgende	,
			for (Resource resource : resources) {	/ KnightConfig2
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
/s
CachingMetadataReaderFactory.getMetadataReader(Resource) line: 103	
				metadataReader = super.getMetadataReader(resource);
metaDataReader
	annotationMetadata
		annotationSet
			[0] "org.springframework.context.annotation.Configuration"
			[1] "org.springframework.context.annotation.ComponentScan"
		attributesMap
			[0] 
				key "org.springframework.context.annotation.Configuration"
				value ...
			[1] 
				key "org.springframework.context.annotation.Component"
				value ...
			[2] 
				key "org.springframework.context.annotation.ComponentScan"
				value ...
	classMetadata
		annotationSet
			[0] "org.springframework.context.annotation.Configuration"
		attributesMap
			[0] 
				key "org.springframework.context.annotation.Configuration"
				value ...
			[1] 
				key "org.springframework.context.annotation.Component"
				value ...
			[2] 
				key "org.springframework.context.annotation.ComponentScan"
				value ...
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 280	
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
/d
						if (isCandidateComponent(metadataReader)) {
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 342	
		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/s
ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 66	
		if (matchClassName(metadata.getClassName())) {
/s
ComponentScanAnnotationParser$1.matchClassName(String) line: 134	
				return declaringClass.equals(className);			/ true	,
/t
ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 66	
		if (matchClassName(metadata.getClassName())) {
/j
			return true;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 342	
		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/j
				return false
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 280	
						if (isCandidateComponent(metadataReader)) {
/n
/ volgende, 
			for (Resource resource : resources) {	/ SoundSystemConfig.class
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
/j
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
							sbd.setResource(resource);
							sbd.setSource(resource);
							if (isCandidateComponent(sbd)) {
								candidates.add(sbd);
		return candidates;
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 249	
		for (String basePackage : basePackages) {
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/d
candidates	LinkedHashSet<E>  (id=235)	
	[0]	ScannedGenericBeanDefinition  (id=1391)	
		beanClass	"sia.knights.config.KnightConfig" (id=253)	
	[1]	ScannedGenericBeanDefinition  (id=1445)	
		beanClass	"sia.knights.config.SoundSystemConfig" (id=1487)	





/ Einde TO MERGE

/ TO MERGE

/ ws workspace-wicket7_5
/ proj stereo-autoconfig

/ 13	. 

/ stack
/s
	AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 144	

		AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
abd	AnnotatedGenericBeanDefinition  (id=60)	
	metadata	StandardAnnotationMetadata  (id=78)	
		introspectedClass	Class<T> (soundsystem.CDPlayerConfig) (id=54)	
			annotations null	

		if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
abd	AnnotatedGenericBeanDefinition  (id=60)	
	metadata	StandardAnnotationMetadata  (id=78)	
		introspectedClass	Class<T> (soundsystem.CDPlayerConfig) (id=54)	
			annotations	HashMap<K,V>  (id=86)	
				[0]	HashMap$Entry<K,V>  (id=96)	
					key	Class<T> (org.springframework.context.annotation.Configuration) (id=129)	
					value	$Proxy4  (id=130)	
				[1]	HashMap$Entry<K,V>  (id=97)	
					key	Class<T> (org.springframework.context.annotation.ComponentScan) (id=142)	
					value	$Proxy5  (id=143)	
/cb
	AnnotatedBeanDefinitionReader.registerBean(Class<?>) line: 127	
	AnnotatedBeanDefinitionReader.register(Class<?>...) line: 122	
	AnnotationConfigApplicationContext.register(Class<?>...) line: 151	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 83	
	Main.main(String[]) line: 8	
/ debug	,
/s
AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 165	
		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
this	AnnotatedBeanDefinitionReader  (id=22)	
	registry	AnnotationConfigApplicationContext  (id=23)	
		beanFactory	DefaultListableBeanFactory  (id=991)	
			beanDefinitionMap	ConcurrentHashMap<K,V>  (id=1000)	
				[0]	ConcurrentHashMap$WriteThroughEntry  (id=1060)	
					key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1007)	
					value	RootBeanDefinition  (id=1103)	
				[1]	ConcurrentHashMap$WriteThroughEntry  (id=1061)	
					key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1006)	
					value	RootBeanDefinition  (id=1098)	
				[2]	ConcurrentHashMap$WriteThroughEntry  (id=1062)	
					key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1005)	
					value	RootBeanDefinition  (id=1093)	
				[3]	ConcurrentHashMap$WriteThroughEntry  (id=1069)	
					key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1004)	
					value	RootBeanDefinition  (id=1088)	
				[4]	ConcurrentHashMap$WriteThroughEntry  (id=1070)	
					key	"CDPlayerConfig" (id=983)	
					value	AnnotatedGenericBeanDefinition  (id=60)	

/ 13	. 

/c
/ stack
/s
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 274	
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	Main.main(String[]) line: 8	
/debug	,
/s
    ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 274
		for (String beanName : registry.getBeanDefinitionNames()) { 
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
CDPlayerConfig																										/ we kijken alleen naar deze	, 
org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor
org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor

			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
CDPlayerConfig																			
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
/n
					logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
/n
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/= WHERE @CONFIGURATION IS USED
/s
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 86	
		if (metadata != null) {
			if (isFullConfigurationCandidate(metadata)) {
/s
ConfigurationClassUtils.isFullConfigurationCandidate(AnnotationMetadata) line: 117	
		return metadata.isAnnotated(Configuration.class.getName());
/t

/ 13	. 

/c
/stack
/s
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 247	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
	ConfigurationClassParser.parse(Class<?>, String) line: 185	
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 155	
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	Main.main(String[]) line: 8	
/debug	,
/s
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 247	

sourceClass	ConfigurationClassParser$SourceClass  (id=1716)	
	metadata	StandardAnnotationMetadata  (id=1705)	
		introspectedClass	Class<T> (soundsystem.CDPlayerConfig) (id=54)	
			annotations	HashMap<K,V>  (id=86)	
				[0]	HashMap$Entry<K,V>  (id=96)	
					key	Class<T> (org.springframework.context.annotation.Configuration) (id=129)	
					value	$Proxy4  (id=130)	
				[1]	HashMap$Entry<K,V>  (id=97)	
					key	Class<T> (org.springframework.context.annotation.ComponentScan) (id=142)	
					value	$Proxy5  (id=143)	

		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
/ WHERE @COMPONENTSCAN IS USED
componentScan	AnnotationAttributes  (id=1717)	
	[0]	LinkedHashMap$Entry<K,V>  (id=1747)	
		key	"value" (id=1773)	
		value	String[0]  (id=1774)	
	[1]	LinkedHashMap$Entry<K,V>  (id=1748)	
		key	"basePackages" (id=1771)	
		value	String[0]  (id=1772)	
	[2]	LinkedHashMap$Entry<K,V>  (id=1749)	
		key	"scopeResolver" (id=1770)	
		value	Class<T> (org.springframework.context.annotation.AnnotationScopeMetadataResolver) (id=492)	
	[3]	LinkedHashMap$Entry<K,V>  (id=1750)	
		key	"scopedProxy" (id=1768)	
		value	ScopedProxyMode  (id=1769)	
	[4]	LinkedHashMap$Entry<K,V>  (id=1751)	
		key	"basePackageClasses" (id=1766)	
		value	Class<T>[0]  (id=1767)	
	[5]	LinkedHashMap$Entry<K,V>  (id=1752)	
		key	"nameGenerator" (id=1765)	
		value	Class<T> (org.springframework.beans.factory.support.BeanNameGenerator) (id=105)	
	[6]	LinkedHashMap$Entry<K,V>  (id=1753)	
		key	"resourcePattern" (id=1763)	
		value	"**/*.class" (id=1764)	
	[7]	LinkedHashMap$Entry<K,V>  (id=1754)	
		key	"useDefaultFilters" (id=1761)	
		value	Boolean  (id=1762)	
	[8]	LinkedHashMap$Entry<K,V>  (id=1755)	
		key	"includeFilters" (id=1759)	
		value	AnnotationAttributes[0]  (id=1760)	
	[9]	LinkedHashMap$Entry<K,V>  (id=1756)	
		key	"excludeFilters" (id=1757)	
		value	AnnotationAttributes[0]  (id=1758)	

		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			// The config class is annotated with @ComponentScan -> perform the scan immediately
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/ MORGENOCHTEND







/ Einde TO MERGE























	














/ Einde SPRING AUTOCONFIG



/ Einde DEBUG SPRING


/ 7	. 

/ we maken my-stereo-autoconfig	,

/ Lees	, 
http://stackoverflow.com/questions/34543108/where-is-the-org-junit-contrib-java-lang-system-standardoutputstreamlog
/->
https://stefanbirkner.github.io/system-rules/apidocs/org/junit/contrib/java/lang/system/StandardOutputStreamLog.html
/->
https://stefanbirkner.github.io/system-rules/apidocs/org/junit/contrib/java/lang/system/SystemOutRule.html

/ StandardOutputStreamLog is deprecated	, use SystemOutRule	,

$ vi CDPlayerTest.java

public class CDPlayerTest {

  @Rule
  public final SystemOutRule  systemOutRule=new SystemOutRule().enableLog();

  @Test
  public void play() {
    player.play();
    assertEquals( "Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n", systemOutRule.getLog());
  }

/ Waarom in originele stereo-autoconfig  GEEN deprecated	?
/ TODO

/ 7	. 

/ AUTOCONFIG JAVACONFIG

/ Lees	,
http://projects.spring.io/spring-framework/

/ ws workspace-wicket7_5
/ proj my-knight
/ prog MyKnightMain

/ We moeten AnnotationConfig- ipv ClassPathXml- ApplicationContext

/ Dit is Java config	,

$ vi MyKnightMain.java

import sia.knights.config.KnightConfig;

public class MyKnightMain {

  public static void main(String[] args) throws Exception {
    ApplicationContext context=new AnnotationConfigApplicationContext(KnightConfig.class);
    Knight knight = context.getBean(Knight.class);
    knight.embarkOnQuest();
  }
}

$ vi KnightConfig.java

@Configuration
public class KnightConfig {

  @Bean
  public Knight knight() {
    return new BraveKnight(quest());
  }
  
  @Bean
  public Quest quest() {
    return new SlayDragonQuest(System.out);
  }

}

/ Dit is Auto config	,

$ vi KnightConfig2.java

@Configuration
@ComponentScan
public class KnightConfig2 {
}

$ vi KnightConfig.java

public class MyKnightMain2 {

  public static void main(String[] args) throws Exception {
    ApplicationContext context=new AnnotationConfigApplicationContext(KnightConfig2.class);
    Knight knight = context.getBean(Knight.class);
    knight.embarkOnQuest();
  }

}


/ 7	 

/ ws wicket7_5
/ we import Spittr	, 

Download http://maven.springframework.org/release/org/springframework/spring-webmvc/4.0.7.RELEASE/spring-webmvc-4.0.7.RELEASE.pom
Download http://maven.springframework.org/release/org/springframework/spring-jdbc/4.0.7.RELEASE/spring-jdbc-4.0.7.RELEASE.pom
Download http://repo1.maven.org/maven2/com/h2database/h2/1.4.182/h2-1.4.182.pom
Download http://repo1.maven.org/maven2/org/hibernate/hibernate-validator/5.0.1.Final/hibernate-validator-5.0.1.Final.pom
Download http://repo1.maven.org/maven2/org/hibernate/hibernate-validator-parent/5.0.1.Final/hibernate-validator-parent-5.0.1.Final.pom
Download http://repo1.maven.org/maven2/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.pom
Download http://repo1.maven.org/maven2/javax/el/javax.el-api/2.2.4/javax.el-api-2.2.4.pom
Download http://repo1.maven.org/maven2/junit/junit-dep/4.11/junit-dep-4.11.pom
Download http://repo1.maven.org/maven2/com/fasterxml/classmate/0.8.0/classmate-0.8.0.pom
Download http://repo1.maven.org/maven2/org/jboss/logging/jboss-logging/3.1.1.GA/jboss-logging-3.1.1.GA-sources.jar
Download http://repo1.maven.org/maven2/org/hibernate/hibernate-validator/5.0.1.Final/hibernate-validator-5.0.1.Final-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-jdbc/4.0.7.RELEASE/spring-jdbc-4.0.7.RELEASE-sources.jar
Download http://repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.1/commons-lang3-3.1-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-tx/4.0.7.RELEASE/spring-tx-4.0.7.RELEASE-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-webmvc/4.0.7.RELEASE/spring-webmvc-4.0.7.RELEASE-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-beans/4.0.7.RELEASE/spring-beans-4.0.7.RELEASE-sources.jar
Download http://repo1.maven.org/maven2/org/objenesis/objenesis/1.0/objenesis-1.0-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-expression/4.0.7.RELEASE/spring-expression-4.0.7.RELEASE-sources.jar
Download http://repo1.maven.org/maven2/javax/validation/validation-api/1.1.0.Final/validation-api-1.1.0.Final-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-web/4.0.7.RELEASE/spring-web-4.0.7.RELEASE-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-core/4.0.7.RELEASE/spring-core-4.0.7.RELEASE-sources.jar
Download http://repo1.maven.org/maven2/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1-sources.jar
Download http://repo1.maven.org/maven2/javax/servlet/jstl/1.2/jstl-1.2-sources.jar
Download http://repo1.maven.org/maven2/com/fasterxml/classmate/0.8.0/classmate-0.8.0-sources.jar
Download http://repo1.maven.org/maven2/org/hamcrest/hamcrest-library/1.3/hamcrest-library-1.3-sources.jar
Download http://repo1.maven.org/maven2/com/h2database/h2/1.4.182/h2-1.4.182-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-aop/4.0.7.RELEASE/spring-aop-4.0.7.RELEASE-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-test/4.0.7.RELEASE/spring-test-4.0.7.RELEASE-sources.jar
Download http://repo1.maven.org/maven2/org/mockito/mockito-core/1.9.5/mockito-core-1.9.5-sources.jar
Download http://repo1.maven.org/maven2/javax/el/javax.el-api/2.2.4/javax.el-api-2.2.4-sources.jar
Download http://maven.springframework.org/release/org/springframework/spring-webmvc/4.0.7.RELEASE/spring-webmvc-4.0.7.RELEASE.jar
Download http://maven.springframework.org/release/org/springframework/spring-jdbc/4.0.7.RELEASE/spring-jdbc-4.0.7.RELEASE.jar
Download http://repo1.maven.org/maven2/com/h2database/h2/1.4.182/h2-1.4.182.jar
Download http://repo1.maven.org/maven2/org/hibernate/hibernate-validator/5.0.1.Final/hibernate-validator-5.0.1.Final.jar
Download http://repo1.maven.org/maven2/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.jar
Download http://repo1.maven.org/maven2/javax/el/javax.el-api/2.2.4/javax.el-api-2.2.4.jar
Download http://maven.springframework.org/release/org/springframework/spring-web/4.0.7.RELEASE/spring-web-4.0.7.RELEASE.jar
Download http://repo1.maven.org/maven2/com/fasterxml/classmate/0.8.0/classmate-0.8.0.jar

/ lees	,
http://stackoverflow.com/questions/4209847/gradle-copy-war-to-tomcat-directory
/ TODO
/ MORGENOCHTEND	 my-Spittr	,	 wicket7_5, WH web.xml add	, WH Spittr doet alleen tests	,  import ook SpringPizza uit ch8	,

/ 7	. 

/ ws workspace-wicket7_5
/ proj RoadRantz	,

$ vi pom.xml

<properties>
    <tomcat.version>2.2</tomcat.version>
...

    <dependency>
	    <groupId>org.quartz-scheduler</groupId>
	    <artifactId>quartz</artifactId>
	    <version>2.1.3</version>
	</dependency>


	<plugin>
		<groupId>org.apache.tomcat.maven</groupId>
		<artifactId>tomcat7-maven-plugin</artifactId>
		<version>${tomcat.version}</version>
		<configuration>
   			<port>8080</port>
   			<path>/${project.artifactId}</path>
   			<url>http://localhost:9090/manager/text</url>
   			<server>my_tomcat</server>
 			</configuration>
	</plugin>
     
   </plugins>
  </build>

/ quartz 2.2.3	, de jar werd niet download	, daarom 2.1.3	, 
/ TODO	

/ we zien in proj's build path dat c3p0 is missing	, maar in pom nergens dep	, 
/ TODO

/ deploy naar tomcat ERRs	, 
/ TODO

/ lees	,
https://www.mkyong.com/spring/spring-quartz-scheduler-example/
http://docs.spring.io/spring-batch/1.0.x/spring-batch-docs/reference/html/execution.html





/ 7	. 

/ ws wicket7_5
/ import proj. SpringPizza	,

/ 7	. 

/ mkyong 

/ ws wicket7_5

/ lees	,
http://www.mkyong.com/spring3/spring-3-mvc-hello-world-example/
http://www.mkyong.com/spring-mvc/spring-mvc-how-to-include-js-or-css-files-in-a-jsp-page/

/ we maken proj. 

/ SPRING MVC CONFIG

/ RoadRantz
$ less web.xml

<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-app_2_4.xsd"
    version="2.4">
    
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>
      classpath:roadrantz-security.xml
      classpath:roadrantz-services.xml
      classpath:roadrantz-email.xml
      classpath:roadrantz-data.xml
      classpath:roadrantz-data-jpa-pure.xml
      classpath:roadrantz-transactions.xml
      classpath:roadrantz-cache.xml
      classpath:roadrantz-mbeans.xml
    </param-value>
  </context-param>
   
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>

  <servlet>
    <servlet-name>roadrantz</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<!--
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:roadrantz-servlet.xml</param-value>
    </init-param>
-->
    <load-on-startup>1</load-on-startup>
  </servlet>

/ DispatcherServlet loads configuration file <servlet-name>-servlet.xml
/ TODO Waarom staat er <init-param/>?

/ <context-param> is voor ContextLoaderListener	, als <context-param/> er niet is, verwacht Spring WEB-INF/applicationContext.xml	,



/ Einde SPRING MVC CONFIG

/ 7	. 

/ we zijn in DispatcherServlet, en we komen uit op de superclass HttpServlet	, 

/ we zien 	, 
/home/eric/.m2/repository	, 
/home/eric/.gradle/caches	, 
/ we zien in de gradle caches javax.servlet-api-3.1.0.jar
/ in maven repo zien we 
javax.servlet-api-3.1.0.jar
servlet-api-2.4.jar
servlet-api-2.5.jar

/ Dit is dus servlet-api-2.5.jar
public abstract class HttpServlet extends GenericServlet
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
    protected void doHead(HttpServletRequest req, HttpServletResponse resp)
	...
public abstract class GenericServlet 
    implements Servlet, ...

/ lees	, 
http://stackoverflow.com/questions/4008010/why-is-creating-servlets-in-eclipse-breaking-my-web-xml/24273240#24273240

I was having a similar issue. I brought a web app over from an old Tomcat 6/Java 6 to Tomcat 7/Java 7. I copy and pasted existing web.xml body into the new 3.0 web.xml. Everything was fine until I added a servlet that had init-param, display-name, description and load-on-startup paramters. Eclipse flagged these params as broken with an "invalid content found at...". Thanks to stackoverflow, I found that load-on-startup had to come after init-params but only a RTFM for how they knew. My other params were still flagged as broken. This is what the web.xml header looked like when it was broken:

<?xml version="1.0" encoding="UTF-8"?>
<web-app 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns="http://java.sun.com/xml/ns/javaee" 
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
version="3.0">
I changed the dtds to ns/j2ee and web-app_2_5.xsd, and Ecliupse stopped complaining. But its 2014 and we'll be moving to Tomcat 8 soon. So I dug in hard and found the docs for . In web-app 3.0 the parameters have to be in this order:

jee:descriptionGroup = any combo of 3 params: description, display-name, icon
servlet-name
chose 1: servlet-class or jsp-file
n number of init-params
load-on-startup
options: enabled, asynch-supported, run-as, security-role-ref, multipart-config
Once I put my params in order, Eclipse was happy with ns/javaee and web-app_3_0.xsd.

/ we moeten <load-on-startup/> na <init-param/>	, anders geeft eclipse ERR	, 
/ TODO

/ kunnen we op 3_0 overgaan , ipv 2_5	?
/ TODO

/ 7	. 

/ we maken hello.jsp	, en we zien ERR	,
The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path

/ we moeten	, 
$ vi pom.xml

	<dependency>
	    <groupId>javax.servlet</groupId>
	    <artifactId>servlet-api</artifactId>
	    <version>2.5</version>
	    <scope>provided</scope>
	</dependency>


/ lees	, 
http://stackoverflow.com/questions/4076601/how-do-i-import-the-javax-servlet-api-in-my-eclipse-project
I too received the same error as quoted below:

The superclass โjavax.servlet.http.HttpServletโ was not found on the Java Build Path.
I followed these steps to resolve the issue:

Right Click on Project
Select Properties
Select Project Facets
Select Apache Tomcat as Runtime server
Click OK
/ Wat is dat	, met die Facets	?

/ 7	. 

[eric@localhost Spring]$ pwd
/home/eric/Devel/Java/Spring
[eric@localhost Spring]$ git clone https://github.com/mkyong/spring3-mvc-maven-xml-hello-world.git
Cloning into 'spring3-mvc-maven-xml-hello-world'...
remote: Counting objects: 37, done.
remote: Total 37 (delta 0), reused 0 (delta 0), pack-reused 37
Unpacking objects: 100% (37/37), done.
Checking connectivity... done.

/ we moeten in src/main/webapp 
resources/code/css 
resources/code/js
/ waarom niet in src/main/resources	?
/ TODO

/ 7	. 

/ we zien de content van de war	, 

[eric@localhost eclipse-jee-test]$ (cd workspace-wicket7_5/spring3-mvc-xml-hello-world/target/spring3-mvc-hello-world-xml-0.0.1-SNAPSHOT/;find).
./META-INF
./WEB-INF
./WEB-INF/classes
./WEB-INF/classes/controller
./WEB-INF/classes/controller/HelloController.class
./WEB-INF/views
./WEB-INF/views/jsp
./WEB-INF/views/jsp/hello.jsp
./WEB-INF/lib
./WEB-INF/lib/jstl-1.2.jar
./WEB-INF/lib/spring-web-3.2.13.RELEASE.jar
./WEB-INF/lib/spring-core-3.2.13.RELEASE.jar
./WEB-INF/lib/aopalliance-1.0.jar
./WEB-INF/lib/spring-context-3.2.13.RELEASE.jar
./WEB-INF/lib/spring-beans-3.2.13.RELEASE.jar
./WEB-INF/lib/spring-expression-3.2.13.RELEASE.jar
./WEB-INF/lib/spring-aop-3.2.13.RELEASE.jar
./WEB-INF/lib/spring-webmvc-3.2.13.RELEASE.jar
./WEB-INF/lib/commons-logging-1.1.3.jar
./WEB-INF/spring-web-servlet.xml
./WEB-INF/web.xml
./resources
./resources/js
./resources/js/hello.js
./resources/js/bootstrap.min.js
./resources/css
./resources/css/hello.css
./resources/css/bootstrap.min.css

/ of	, 

[eric@localhost eclipse-jee-test]$ jar tvf workspace-wicket7_5/spring3-mvc-xml-hello-world/target/spring3-mvc-hello-world-xml-0.0.1-SNAPSHOT.war 
     0 Thu Dec 15 08:41:18 CET 2016 META-INF/
   123 Thu Dec 15 08:41:16 CET 2016 META-INF/MANIFEST.MF
     0 Thu Dec 15 08:41:18 CET 2016 WEB-INF/
     0 Thu Dec 15 08:41:18 CET 2016 WEB-INF/classes/
     0 Thu Dec 15 08:41:18 CET 2016 WEB-INF/classes/controller/
     0 Thu Dec 15 08:41:18 CET 2016 WEB-INF/views/
     0 Thu Dec 15 08:41:18 CET 2016 WEB-INF/views/jsp/
     0 Thu Dec 15 08:41:18 CET 2016 WEB-INF/lib/
     0 Thu Dec 15 08:41:18 CET 2016 resources/
     0 Thu Dec 15 08:41:18 CET 2016 resources/js/
     0 Thu Dec 15 08:41:18 CET 2016 resources/css/
  1578 Thu Dec 15 08:41:18 CET 2016 WEB-INF/classes/controller/HelloController.class
  1915 Wed Dec 14 14:33:32 CET 2016 WEB-INF/views/jsp/hello.jsp
414240 Mon Feb 23 11:11:32 CET 2015 WEB-INF/lib/jstl-1.2.jar
631720 Wed Dec 14 07:40:46 CET 2016 WEB-INF/lib/spring-web-3.2.13.RELEASE.jar
885410 Wed Dec 14 07:40:46 CET 2016 WEB-INF/lib/spring-core-3.2.13.RELEASE.jar
  4467 Fri May 02 16:41:08 CEST 2014 WEB-INF/lib/aopalliance-1.0.jar
868187 Wed Dec 14 07:40:46 CET 2016 WEB-INF/lib/spring-context-3.2.13.RELEASE.jar
614483 Wed Dec 14 07:40:46 CET 2016 WEB-INF/lib/spring-beans-3.2.13.RELEASE.jar
196545 Wed Dec 14 07:40:44 CET 2016 WEB-INF/lib/spring-expression-3.2.13.RELEASE.jar
338500 Wed Dec 14 07:40:46 CET 2016 WEB-INF/lib/spring-aop-3.2.13.RELEASE.jar
640809 Wed Dec 14 07:40:46 CET 2016 WEB-INF/lib/spring-webmvc-3.2.13.RELEASE.jar
 62050 Tue May 06 17:12:52 CEST 2014 WEB-INF/lib/commons-logging-1.1.3.jar
  1213 Wed Dec 14 15:56:18 CET 2016 WEB-INF/spring-web-servlet.xml
   787 Wed Dec 14 12:17:58 CET 2016 WEB-INF/web.xml
     0 Wed Dec 14 13:25:44 CET 2016 resources/js/hello.js
 35951 Wed Dec 14 13:25:44 CET 2016 resources/js/bootstrap.min.js
     0 Wed Dec 14 13:25:44 CET 2016 resources/css/hello.css
117305 Wed Dec 14 13:25:44 CET 2016 resources/css/bootstrap.min.css
     0 Thu Dec 15 08:41:20 CET 2016 META-INF/maven/
     0 Thu Dec 15 08:41:20 CET 2016 META-INF/maven/my.own/
     0 Thu Dec 15 08:41:20 CET 2016 META-INF/maven/my.own/spring3-mvc-hello-world-xml/
  1908 Wed Dec 14 12:39:36 CET 2016 META-INF/maven/my.own/spring3-mvc-hello-world-xml/pom.xml
   127 Thu Dec 15 08:41:18 CET 2016 META-INF/maven/my.own/spring3-mvc-hello-world-xml/pom.properties

$ less WEB-INF/web.xml

<mvc:resources mapping="/resources/**" location="/resources/"/>



/ 7	. 

[eric@localhost spring-mvc-css-example]$ pwd
/home/eric/Devel/Java/Spring/spring-mvc-css-example

/ doe dit voortaan altijd	,
/ in .settings stonden M2_REPO jars	, die uit onze pom zoals servlet-api-2.5.jar	, worden dan niet gezien	, 
[eric@localhost spring-css]$ rm -rf .settings/ .project  .classpath
[eric@localhost spring-css]$ rm -rf target/

[eric@localhost spring-css]$ rm -rf __MACOSX/
[eric@localhost spring-css]$ rm .DS_Store 
[eric@localhost spring-css]$ rm src/.DS_Store 
[eric@localhost spring-css]$ rm src/main/.DS_Store 

/ 7	. 

/ workspace-wicket7_5	, 
/ proj. spring-css	,

/ Tijdens deploy van webapp creates tomcat de servlets die in web.xml vermeld staan	, bij ons alleen DispatcherServlet, en maakt spring de app context	, dwz creates beans en injects	, 

/ Wat hieronder staat gebeurt dus allemaal tijdens deployment	,

/ We debug spring-css-deploy	, 
/s
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 145	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1139	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1042	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 476	
	BeanDefinitionValueResolver.resolveInnerBean(Object, String, BeanDefinition) line: 299	
	BeanDefinitionValueResolver.resolveValueIfNecessary(Object, Object) line: 129	
	ConstructorResolver.resolveConstructorArguments(String, RootBeanDefinition, BeanWrapper, ConstructorArgumentValues, ConstructorArgumentValues) line: 634	
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 140	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1139	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1042	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 476	
	AbstractBeanFactory$1.getObject() line: 303	
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 230	
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 299	
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 194	
	DefaultListableBeanFactory.preInstantiateSingletons() line: 755	
	XmlWebApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 757	
	XmlWebApplicationContext(AbstractApplicationContext).refresh() line: 480	
	DispatcherServlet(FrameworkServlet).configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext) line: 663	
	DispatcherServlet(FrameworkServlet).createWebApplicationContext(ApplicationContext) line: 629	
/ (**)
	DispatcherServlet(FrameworkServlet).createWebApplicationContext(WebApplicationContext) line: 677	
	DispatcherServlet(FrameworkServlet).initWebApplicationContext() line: 548	
	DispatcherServlet(FrameworkServlet).initServletBean() line: 489	
	DispatcherServlet(HttpServletBean).init() line: 136	
	DispatcherServlet(GenericServlet).init(ServletConfig) line: 158	
	StandardWrapper.initServlet(Servlet) line: 1231	
/ (*)
	StandardWrapper.loadServlet() line: 1144	
	StandardWrapper.load() line: 1031	
	StandardContext.loadOnStartup(Container[]) line: 4923	
	StandardContext.startInternal() line: 5215	
	StandardContext(LifecycleBase).start() line: 150	
	StandardHost(ContainerBase).addChildInternal(Container) line: 725	
	StandardHost(ContainerBase).addChild(Container) line: 701	
	StandardHost.addChild(Container) line: 717	
	HostConfig.deployWAR(ContextName, File) line: 945	
	HostConfig.deployApps(String) line: 466	
	HostConfig.check(String) line: 1586	
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 57	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	BaseModelMBean.invoke(String, Object[], String[]) line: 300	
	DefaultMBeanServerInterceptor.invoke(ObjectName, String, Object[], String[]) line: 819	
	JmxMBeanServer.invoke(ObjectName, String, Object[], String[]) line: 801	
	ManagerServlet.check(String) line: 1460	
	ManagerServlet.deploy(PrintWriter, ContextName, String, boolean, HttpServletRequest, StringManager) line: 733	
	ManagerServlet.doPut(HttpServletRequest, HttpServletResponse) line: 432	
	ManagerServlet(HttpServlet).service(HttpServletRequest, HttpServletResponse) line: 651	
	ManagerServlet(HttpServlet).service(ServletRequest, ServletResponse) line: 729	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 291	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	WsFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 52	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	SetCharacterEncodingFilter.doFilter(ServletRequest, ServletResponse, FilterChain) line: 108	
	ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse) line: 239	
	ApplicationFilterChain.doFilter(ServletRequest, ServletResponse) line: 206	
	StandardWrapperValve.invoke(Request, Response) line: 217	
	StandardContextValve.invoke(Request, Response) line: 106	
	BasicAuthenticator(AuthenticatorBase).invoke(Request, Response) line: 614	
	StandardHostValve.invoke(Request, Response) line: 142	
	ErrorReportValve.invoke(Request, Response) line: 79	
	AccessLogValve(AbstractAccessLogValve).invoke(Request, Response) line: 616	
	StandardEngineValve.invoke(Request, Response) line: 88	
	CoyoteAdapter.service(Request, Response) line: 518	
	Http11NioProcessor(AbstractHttp11Processor<S>).process(SocketWrapper<S>) line: 1091	
	Http11NioProtocol$Http11ConnectionHandler(AbstractProtocol$AbstractConnectionHandler<S,P>).process(SocketWrapper<S>, SocketStatus) line: 673	
	NioEndpoint$SocketProcessor.doRun() line: 1500	
	NioEndpoint$SocketProcessor.run() line: 1456	
	ThreadPoolExecutor(ThreadPoolExecutor).runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	TaskThread$WrappingRunnable.run() line: 61	
	TaskThread(Thread).run() line: 745	


////////////////////////////////
/ We moeten toch in de debug configuration tomcat-remote-debug de de project goed zetten	, 
/ we moeten toch aparte maken	, bijv 
$ less tomcat-remote-debug-spring-css
project: spring-css
host: localhost
port:996

/ 13	. 

/ (*)

/ we hadden	, 

/ in de pom.xml
		<!-- ERICJ -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>

/ inderdaad provided	, want in tomcat is lib/servlet-api.jar	. 
/ we tar xvf deze	, 

[eric@localhost servlet]$  less META-INF/MANIFEST.MF 
Manifest-Version: 1.0
Ant-Version: Apache Ant 1.9.6
Created-By: 1.7.0_80-b15 (Oracle Corporation)
X-Compile-Source-JDK: 1.7
X-Compile-Target-JDK: 1.7

Name: javax/servlet/
Specification-Title: Java API for Servlets
Specification-Version: 3.1
Specification-Vendor: Sun Microsystems, Inc.
Implementation-Title: javax.servlet
Implementation-Version: 3.1.FR
Implementation-Vendor: Apache Software Foundation

/ we moeten de tomcat versie geven, 8.0.28 bij ons	, en dan heb je de servlet-api die tomcat uses	,
$ vi pom.xml

		<!-- ERICJ -->
		<dependency>
		    <groupId>org.apache.tomcat</groupId>
		    <artifactId>tomcat-servlet-api</artifactId>
		    <version>8.0.28</version>
		    <scope>provided</scope>
		</dependency>


/ je zou ook kunnen proberen	, 

<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
</dependency>


 
/ 13	. 

/ in (**)
this	DispatcherServlet  (id=12972)	
wac	XmlWebApplicationContext  (id=12970)	
	active	AtomicBoolean  (id=13011)	
	allowBeanDefinitionOverriding	null	
	allowCircularReferences	null	
	applicationEventMulticaster	SimpleApplicationEventMulticaster  (id=13023)	
	applicationListeners	LinkedHashSet<E>  (id=13025)	
	beanFactory	DefaultListableBeanFactory  (id=12966)	
		aliasMap	ConcurrentHashMap<K,V>  (id=13081)	
		allBeanNamesByType	ConcurrentHashMap<K,V>  (id=13082)	
		allowBeanDefinitionOverriding	true	
		allowCircularReferences	true	
		allowEagerClassLoading	true	
		allowRawInjectionDespiteWrapping	false	
		alreadyCreated	Collections$SetFromMap<E>  (id=13083)	
		autowireCandidateResolver	ContextAnnotationAutowireCandidateResolver  (id=13084)	
		beanClassLoader	WebappClassLoader  (id=12986)	
		beanDefinitionMap	ConcurrentHashMap<K,V>  (id=13089)	
			entrySet	ConcurrentHashMap$EntrySet  (id=13135)	
			hashSeed	0	
			keySet	null	
			keySet	null	
			segmentMask	15	
			segments	ConcurrentHashMap$Segment<K,V>[16]  (id=13136)	
				[0]	ConcurrentHashMap$Segment<K,V>  (id=13137)	
					count	3	
					loadFactor	0.75	
					modCount	3	
					sync	ReentrantLock$NonfairSync  (id=13150)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13151)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13152)	
							hash	91824253	
							key	"mvcResourceUrlProvider" (id=13156)	
							next	null	
							value	RootBeanDefinition  (id=13157)	
						[2]	ConcurrentHashMap$HashEntry<K,V>  (id=13153)	
							hash	186871722	
							key	"org.springframework.format.support.FormattingConversionServiceFactoryBean#0" (id=13166)	
							next	null	
							value	RootBeanDefinition  (id=13167)	
						[3]	ConcurrentHashMap$HashEntry<K,V>  (id=13154)	
							hash	79478715	
							key	"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#0" (id=13169)	
							next	null	
							value	RootBeanDefinition  (id=13170)	
					threshold	3	
				[1]	ConcurrentHashMap$Segment<K,V>  (id=13138)	
					count	1	
					loadFactor	0.75	
					modCount	1	
					sync	ReentrantLock$NonfairSync  (id=13178)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13179)	
						[3]	ConcurrentHashMap$HashEntry<K,V>  (id=13295)	
							hash	395679759	
							key	"helloController" (id=13296)	
							next	null	
							value	ScannedGenericBeanDefinition  (id=13297)	
								abstractFlag	false	
								attributes	LinkedHashMap<K,V>  (id=13301)	
								autowireCandidate	true	
								autowireMode	0	
								beanClass	"com.mkyong.web.controller.HelloController" (id=13302)	
								constructorArgumentValues	ConstructorArgumentValues  (id=13303)	
								dependencyCheck	0	
								dependsOn	null	
								description	null	
								destroyMethodName	null	
								enforceDestroyMethod	false	
								enforceInitMethod	false	
								factoryBeanName	null	
								factoryMethodName	null	
								initMethodName	null	
								lazyInit	false	
								lenientConstructorResolution	true	
								metadata	AnnotationMetadataReadingVisitor  (id=13304)	
								methodOverrides	MethodOverrides  (id=13309)	
								nonPublicAccessAllowed	true	
								parentName	null	
								primary	false	
								propertyValues	MutablePropertyValues  (id=13313)	
								qualifiers	LinkedHashMap<K,V>  (id=13316)	
								resource	FileSystemResource  (id=13317)	
								role	0	
								scope	"singleton" (id=13323)	
								source	FileSystemResource  (id=13317)	
								synthetic	false	
					threshold	3	
				[2]	ConcurrentHashMap$Segment<K,V>  (id=13139)	
					count	1	
					loadFactor	0.75	
					modCount	1	
					sync	ReentrantLock$NonfairSync  (id=13180)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13181)	
						[0]	ConcurrentHashMap$HashEntry<K,V>  (id=13292)	
							hash	583674528	
							key	"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" (id=13293)	
							next	null	
							value	RootBeanDefinition  (id=13294)	
					threshold	3	
				[3]	ConcurrentHashMap$Segment<K,V>  (id=13140)	
					count	2	
					loadFactor	0.75	
					modCount	2	
					sync	ReentrantLock$NonfairSync  (id=13182)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13183)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13284)	
							hash	915567169	
							key	"mvcUriComponentsContributor" (id=13286)	
							next	null	
							value	RootBeanDefinition  (id=13287)	
						[3]	ConcurrentHashMap$HashEntry<K,V>  (id=13285)	
							hash	1058419543	
							key	"org.springframework.web.servlet.view.InternalResourceViewResolver#0" (id=13289)	
							next	null	
							value	GenericBeanDefinition  (id=13290)	
					threshold	3	
				[5]	ConcurrentHashMap$Segment<K,V>  (id=13141)	
					count	2	
					loadFactor	0.75	
					modCount	2	
					sync	ReentrantLock$NonfairSync  (id=13184)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13185)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13278)	
							hash	1595572273	
							key	"org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#0" (id=13280)	
							next	null	
							value	RootBeanDefinition  (id=13281)	
						[3]	ConcurrentHashMap$HashEntry<K,V>  (id=13279)	
							hash	1359237343	
							key	"mvcUrlPathHelper" (id=13282)	
							next	null	
							value	RootBeanDefinition  (id=13283)	
					threshold	3	
				[6]	ConcurrentHashMap$Segment<K,V>  (id=13142)	
					count	2	
					loadFactor	0.75	
					modCount	2	
					sync	ReentrantLock$NonfairSync  (id=13186)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13187)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13272)	
							hash	1611157429	
							key	"mvcPathMatcher" (id=13274)	
							next	null	
							value	RootBeanDefinition  (id=13275)	
						[3]	ConcurrentHashMap$HashEntry<K,V>  (id=13273)	
							hash	1630952499	
							key	"org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#0" (id=13276)	
							next	null	
							value	RootBeanDefinition  (id=13277)	
					threshold	3	
				[7]	ConcurrentHashMap$Segment<K,V>  (id=13143)	
					count	5	
					loadFactor	0.75	
					modCount	5	
					sync	ReentrantLock$NonfairSync  (id=13188)	
					table	ConcurrentHashMap$HashEntry<K,V>[8]  (id=13189)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13256)	
							hash	2117442745	
							key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=13260)	
							next	null	
							value	RootBeanDefinition  (id=13261)	
						[2]	ConcurrentHashMap$HashEntry<K,V>  (id=13257)	
							hash	2081640930	
							key	"org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#0" (id=13262)	
							next	null	
							value	RootBeanDefinition  (id=13263)	
						[4]	ConcurrentHashMap$HashEntry<K,V>  (id=13258)	
							hash	1883042492	
							key	"mvcContentNegotiationManager" (id=13264)	
							next	ConcurrentHashMap$HashEntry<K,V>  (id=13265)	
								hash	1952909196	
								key	"org.springframework.web.servlet.resource.ResourceHttpRequestHandler#0" (id=13267)	
								next	null	
								value	RootBeanDefinition  (id=13268)	
							value	RootBeanDefinition  (id=13266)	
						[7]	ConcurrentHashMap$HashEntry<K,V>  (id=13259)	
							hash	2003513351	
							key	"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter" (id=13270)	
							next	null	
							value	RootBeanDefinition  (id=13271)	
					threshold	6	
				[8]	ConcurrentHashMap$Segment<K,V>  (id=13144)	
					count	1	
					loadFactor	0.75	
					modCount	1	
					sync	ReentrantLock$NonfairSync  (id=13190)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13191)	
						[2]	ConcurrentHashMap$HashEntry<K,V>  (id=13252)	
							hash	-2013983934	
							key	"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#0" (id=13253)	
							next	null	
							value	RootBeanDefinition  (id=13254)	
					threshold	3	
				[9]	ConcurrentHashMap$Segment<K,V>  (id=13145)	
					count	1	
					loadFactor	0.75	
					modCount	1	
					sync	ReentrantLock$NonfairSync  (id=13192)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13193)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13248)	
							hash	-1849868119	
							key	"org.springframework.web.servlet.handler.MappedInterceptor#1" (id=13249)	
							next	null	
							value	RootBeanDefinition  (id=13250)	
					threshold	3	
				[10]	ConcurrentHashMap$Segment<K,V>  (id=13174)	
					count	3	
					loadFactor	0.75	
					modCount	3	
					sync	ReentrantLock$NonfairSync  (id=13194)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13195)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13236)	
							hash	-1375622727	
							key	"org.springframework.web.servlet.handler.MappedInterceptor#0" (id=13237)	
							next	ConcurrentHashMap$HashEntry<K,V>  (id=13238)	
								hash	-1505211531	
								key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=13240)	
								next	ConcurrentHashMap$HashEntry<K,V>  (id=13241)	
									hash	-1410972547	
									key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=13243)	
									next	null	
									value	RootBeanDefinition  (id=13244)	
								value	RootBeanDefinition  (id=13242)	
							value	RootBeanDefinition  (id=13239)	
					threshold	3	
				[11]	ConcurrentHashMap$Segment<K,V>  (id=13175)	
					count	2	
					loadFactor	0.75	
					modCount	2	
					sync	ReentrantLock$NonfairSync  (id=13196)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13197)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13228)	
							hash	-1230512831	
							key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=13230)	
							next	null	
							value	RootBeanDefinition  (id=13231)	
						[2]	ConcurrentHashMap$HashEntry<K,V>  (id=13229)	
							hash	-1100170294	
							key	"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" (id=13232)	
							next	null	
							value	RootBeanDefinition  (id=13233)	
					threshold	3	
				[12]	ConcurrentHashMap$Segment<K,V>  (id=13176)	
					count	1	
					loadFactor	0.75	
					modCount	1	
					sync	ReentrantLock$NonfairSync  (id=13198)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13199)	
						[2]	ConcurrentHashMap$HashEntry<K,V>  (id=13224)	
							hash	-871175446	
							key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=13225)	
							next	null	
							value	RootBeanDefinition  (id=13226)	
					threshold	3	
				[15]	ConcurrentHashMap$Segment<K,V>  (id=13177)	
					count	2	
					loadFactor	0.75	
					modCount	2	
					sync	ReentrantLock$NonfairSync  (id=13200)	
					table	ConcurrentHashMap$HashEntry<K,V>[4]  (id=13201)	
						[0]	ConcurrentHashMap$HashEntry<K,V>  (id=13205)	
							hash	-159084424	
							key	"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#0" (id=13210)	
							next	null	
							value	RootBeanDefinition  (id=13211)	
						[1]	ConcurrentHashMap$HashEntry<K,V>  (id=13206)	
							hash	-141827095	
							key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=13208)	
							next	null	
							value	RootBeanDefinition  (id=13209)	
					threshold	3	
			segmentShift	28	
			values	null	
			values	null	
		beanDefinitionNames	ArrayList<E>  (id=13090)	
		beanExpressionResolver	StandardBeanExpressionResolver  (id=13091)	
		beanPostProcessors	ArrayList<E>  (id=13094)	
		cacheBeanMetadata	true	
		configurationFrozen	true	
		containedBeanMap	ConcurrentHashMap<K,V>  (id=13095)	
			entrySet	ConcurrentHashMap$EntrySet  (id=13112)	
			hashSeed	0	
			keySet	null	
			keySet	null	
			segmentMask	15	
			segments	ConcurrentHashMap$Segment<K,V>[16]  (id=13113)	
				[0]	ConcurrentHashMap$Segment<K,V>  (id=13114)	
				[6]	ConcurrentHashMap$Segment<K,V>  (id=13115)	
				[10]	ConcurrentHashMap$Segment<K,V>  (id=13116)	
					count	1	
					loadFactor	0.75	
					modCount	1	
					sync	ReentrantLock$NonfairSync  (id=13131)	
					table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=13132)	
					threshold	1	
			segmentShift	28	
			values	null	
			values	null	
		conversionService	null	
		customEditors	HashMap<K,V>  (id=13100)	
		dependenciesForBeanMap	ConcurrentHashMap<K,V>  (id=13101)	
		dependencyComparator	AnnotationAwareOrderComparator  (id=13103)	
		dependentBeanMap	ConcurrentHashMap<K,V>  (id=13106)	
		disposableBeans	LinkedHashMap<K,V>  (id=13107)	
		earlySingletonObjects	HashMap<K,V>  (id=13108)	
		embeddedValueResolvers	LinkedList<E>  (id=13109)	
		factoryBeanInstanceCache	ConcurrentHashMap<K,V>  (id=13110)	
		factoryBeanObjectCache	ConcurrentHashMap<K,V>  (id=13450)	
		filteredPropertyDescriptorsCache	ConcurrentHashMap<K,V>  (id=13451)	
		frozenBeanDefinitionNames	String[26]  (id=13452)	
		hasDestructionAwareBeanPostProcessors	true	
		hasInstantiationAwareBeanPostProcessors	true	
		ignoredDependencyInterfaces	HashSet<E>  (id=13453)	
		ignoredDependencyTypes	HashSet<E>  (id=13454)	
		inCreationCheckExclusions	Collections$SetFromMap<E>  (id=13455)	
		instantiationStrategy	CglibSubclassingInstantiationStrategy  (id=13456)	
		logger	Jdk14Logger  (id=13460)	
		manualSingletonNames	LinkedHashSet<E>  (id=13461)	
		mergedBeanDefinitions	ConcurrentHashMap<K,V>  (id=13462)	
		parameterNameDiscoverer	DefaultParameterNameDiscoverer  (id=13463)	
		parentBeanFactory	null	
		propertyEditorRegistrars	LinkedHashSet<E>  (id=13467)	
		prototypesCurrentlyInCreation	NamedThreadLocal<T>  (id=13468)	
		registeredSingletons	LinkedHashSet<E>  (id=13470)	
		resolvableDependencies	HashMap<K,V>  (id=13471)	
		scopes	LinkedHashMap<K,V>  (id=13472)	
		securityContextProvider	null	
		serializationId	"org.springframework.web.context.WebApplicationContext:/spring-css/hello-dispatcher" (id=13043)	
		singletonBeanNamesByType	ConcurrentHashMap<K,V>  (id=13473)	
		singletonFactories	HashMap<K,V>  (id=13474)	
		singletonObjects	ConcurrentHashMap<K,V>  (id=12961)	
		singletonsCurrentlyInCreation	Collections$SetFromMap<E>  (id=13475)	
		singletonsCurrentlyInDestruction	false	
		suppressedExceptions	LinkedHashSet<E>  (id=13476)	
		tempClassLoader	null	
		typeConverter	null	
	beanFactoryMonitor	Object  (id=13030)	
	beanFactoryPostProcessors	ArrayList<E>  (id=13031)	
	classLoader	WebappClassLoader  (id=12986)	
	closed	AtomicBoolean  (id=13032)	
	configLocations	String[1]  (id=13041)	
	displayName	"WebApplicationContext for namespace 'hello-dispatcher-servlet'" (id=13042)	
	environment	StandardServletEnvironment  (id=13014)	
	id	"org.springframework.web.context.WebApplicationContext:/spring-css/hello-dispatcher" (id=13043)	
	lifecycleProcessor	null	
	logger	Jdk14Logger  (id=13044)	
	messageSource	DelegatingMessageSource  (id=13047)	
	namespace	"hello-dispatcher-servlet" (id=13051)	
	parent	null	
	resourcePatternResolver	ServletContextResourcePatternResolver  (id=13052)	
	servletConfig	StandardWrapperFacade  (id=13055)	
	servletContext	ApplicationContextFacade  (id=13056)	
	setIdCalled	true	
	shutdownHook	null	
	startupDate	1481789299807	
	startupShutdownMonitor	Object  (id=12962)	
	themeSource	ResourceBundleThemeSource  (id=13057)	
env	StandardServletEnvironment  (id=13014)	

/ 13	. 

/ we zullen hieronder de list van beans zien	, 

[helloController,
 org.springframework.context.annotation.internalConfigurationAnnotationProcessor,
 org.springframework.context.annotation.internalAutowiredAnnotationProcessor,
 org.springframework.context.annotation.internalRequiredAnnotationProcessor,
 org.springframework.context.annotation.internalCommonAnnotationProcessor,
 org.springframework.web.servlet.view.InternalResourceViewResolver#0,
 mvcResourceUrlProvider,
 org.springframework.web.servlet.handler.MappedInterceptor#0,
 org.springframework.web.servlet.resource.ResourceHttpRequestHandler#0,
 mvcPathMatcher,
 mvcUrlPathHelper,
 org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#0,
 org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,
 org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,
 org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,
 mvcContentNegotiationManager,
 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#0,
 org.springframework.format.support.FormattingConversionServiceFactoryBean#0,
 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#0,
 mvcUriComponentsContributor,
 org.springframework.web.servlet.handler.MappedInterceptor#1,
 org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#0,
 org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#0,
 org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#0,
 org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,
 org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]

/ de stack trace in meer detail	, 
/s
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 145	

	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1139	
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1042	
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
			return autowireConstructor(beanName, mbd, ctors, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 476	
		Object beanInstance = doCreateBean(beanName, mbd, args);
args	null	
/cb
	BeanDefinitionValueResolver.resolveInnerBean(Object, String, BeanDefinition) line: 299	
			// Actually create the inner bean instance now...
			Object innerBean = this.beanFactory.createBean(actualInnerBeanName, mbd, null);
actualInnerBeanName	"(inner bean)#4fd9a0" (id=13122)	
/cb
	BeanDefinitionValueResolver.resolveValueIfNecessary(Object, Object) line: 129	
/=
	public Object resolveValueIfNecessary(Object argName, Object value) {
argName	"constructor argument" (id=13541)	
value	RootBeanDefinition  (id=13540)	Root bean: class [org.springframework.web.servlet.resource.ResourceUrlProviderExposingInterceptor]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null
		else if (value instanceof BeanDefinition) {
			// Resolve plain BeanDefinition, without contained name: use dummy name.
			BeanDefinition bd = (BeanDefinition) value;
			String innerBeanName = "(inner bean)" + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +
					ObjectUtils.getIdentityHexString(bd);
			return resolveInnerBean(argName, innerBeanName, bd);
innerBeanName	"(inner bean)#4fd9a0" (id=13122)	
/cb
	ConstructorResolver.resolveConstructorArguments(String, RootBeanDefinition, BeanWrapper, ConstructorArgumentValues, ConstructorArgumentValues) line: 634	
			else {
				Object resolvedValue =
						valueResolver.resolveValueIfNecessary("constructor argument", valueHolder.getValue());
/cb
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 140	
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1139	
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
beanName	"org.springframework.web.servlet.handler.MappedInterceptor#0" (id=13237)	
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1042	
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
/n
				mbd.hasConstructorArgumentValues() 
/j
				|| !ObjectUtils.isEmpty(args))  {
			return autowireConstructor(beanName, mbd, ctors, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 476	
		Object beanInstance = doCreateBean(beanName, mbd, args);
/cb
	AbstractBeanFactory$1.getObject() line: 303	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
->								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 230	
				try {
					singletonObject = singletonFactory.getObject();
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 299	
				// Create bean instance.
				if (mbd.isSingleton()) {
->					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);

/cb
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 194	
		return doGetBean(name, null, null, false);
/cb
	DefaultListableBeanFactory.preInstantiateSingletons() line: 755	
		for (String beanName : beanNames) {
[helloController,
 org.springframework.context.annotation.internalConfigurationAnnotationProcessor,
 org.springframework.context.annotation.internalAutowiredAnnotationProcessor,
 org.springframework.context.annotation.internalRequiredAnnotationProcessor,
 org.springframework.context.annotation.internalCommonAnnotationProcessor,
 org.springframework.web.servlet.view.InternalResourceViewResolver#0,
 mvcResourceUrlProvider,
 org.springframework.web.servlet.handler.MappedInterceptor#0,
 org.springframework.web.servlet.resource.ResourceHttpRequestHandler#0,
 mvcPathMatcher,
 mvcUrlPathHelper,
 org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#0,
 org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,
 org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,
 org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,
 mvcContentNegotiationManager,
 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#0,
 org.springframework.format.support.FormattingConversionServiceFactoryBean#0,
 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#0,
 mvcUriComponentsContributor,
 org.springframework.web.servlet.handler.MappedInterceptor#1,
 org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#0,
 org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#0,
 org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#0,
 org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,
 org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]
				else {
					getBean(beanName);
beanName	"org.springframework.web.servlet.handler.MappedInterceptor#0" (id=13237)	
/cb
	XmlWebApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 757	
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/cb
	XmlWebApplicationContext(AbstractApplicationContext).refresh() line: 480	
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);
/cb
	DispatcherServlet(FrameworkServlet).configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext) line: 663	
				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
						ObjectUtils.getDisplayString(getServletContext().getContextPath()) + "/" + getServletName()); 		"org.springframework.web.context.WebApplicationContext:/spring-css/hello-dispatcher"	, getServletName()="hello-dispatcher"	, dit staat in web-xml	,
		wac.setServletContext(getServletContext());
		wac.setServletConfig(getServletConfig());	 servlet config heeft servlet context	, dus waarom wac.setServletContext(getServletContext()) ? TODO
		wac.setNamespace(getNamespace()); / hello-dispatcher-servlet	,

		if (env instanceof ConfigurableWebEnvironment) {
			((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());
/ TODO 
		wac.refresh();
/cb
	DispatcherServlet(FrameworkServlet).createWebApplicationContext(ApplicationContext) line: 629	
		ConfigurableWebApplicationContext wac =
				(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
		wac.setEnvironment(getEnvironment());
		wac.setParent(parent);
		wac.setConfigLocation(getContextConfigLocation()); 		/WEB-INF/spring-web-config.xml 					(1)
		configureAndRefreshWebApplicationContext(wac);
/cb
	DispatcherServlet(FrameworkServlet).createWebApplicationContext(WebApplicationContext) line: 677	
		return createWebApplicationContext((ApplicationContext) parent);
/cb
	DispatcherServlet(FrameworkServlet).initWebApplicationContext() line: 548	
		if (wac == null) {
			// No context instance is defined for this servlet -> create a local one
			wac = createWebApplicationContext(rootContext);
/cb
	DispatcherServlet(FrameworkServlet).initServletBean() line: 489	
			this.webApplicationContext = initWebApplicationContext();
/cb
	DispatcherServlet(HttpServletBean).init() line: 136	
		// Let subclasses do whatever initialization they like.
		initServletBean();
/cb
	DispatcherServlet(GenericServlet).init(ServletConfig) line: 158	

/ MORGENOCHTEND

/ (1) 
/ dit staat in web.xml, tomcat leest deze	, en heeft ook DispatcherServlet create	, daarom WH rol classloaders in tomcat, in web.xml staat ook de DispatcherServlet	,
<web-app  ...>
    <servlet>
        <servlet-name>hello-dispatcher</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-web-config.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
//////////////////////////////////////////////////////////////////////////////////////////////////
/ WH zijn 1 of meer <servlet/> de servlets die tomcat moet gaan create	, bij deployment	,

/ SPRING FULL LITE CONFIGURATION 

/ 7	. 

/ in boek zien we 	,

/ 13	. 
/ autoconfig	,

@Configuration
@ComponentScan
public class CDPlayerConfig { 
}

/ 13	. 
/ javaconfig

@Configuration
public class CDPlayerConfig {
  
  @Bean
  public CompactDisc compactDisc() {
    return new SgtPeppers();
  }
  
  @Bean
  public CDPlayer cdPlayer(CompactDisc compactDisc) {
    return new CDPlayer(compactDisc);
  }

}

/ 13	. 

/ Geef in google	,
spring configuration full lite
/ Lees	,

http://stackoverflow.com/questions/26641349/why-does-this-java-based-spring-configuration-create-two-instances-of-a-singleto
http://dimafeng.com/2015/08/29/spring-configuration_vs_component/


/ Einde SPRING FULL LITE CONFIGURATION 

/ PROXIES

https://springframework.guru/gang-of-four-design-patterns/proxy-pattern/
http://blog.codeleak.pl/2014/07/spring-4-cglib-based-proxy-classes-with-no-default-ctor.html

/ Einde PROXIES
