/ HIBERNATE

/ 7	.

/ Waar worden de class type mapping create?

$ vi Configuration.java

	protected Map<String, PersistentClass> classes;

	public Iterator<PersistentClass> getClassMappings() {
		return classes.values().iterator();

	public PersistentClass getClassMapping(String entityName) {
		return classes.get( entityName );

		private void processHbmXml(XmlDocument metadataXml, Set<String> entityNames) {
			try {
				HbmBinder.bindRoot( metadataXml, createMappings(), Collections.EMPTY_MAP, entityNames );
...

/ er zijn AnnotationBinder en HbmBinder	,

/ AnnotationBinder	,
	private static PersistentClass makePersistentClass(InheritanceState inheritanceState, PersistentClass superEntity) {
		//we now know what kind of persistent entity it is
		PersistentClass persistentClass;
		//create persistent class
		if ( !inheritanceState.hasParents() ) {
			persistentClass = new RootClass();

/ HbmBinder	,
	public static void bindRoot(
			}
			else if ( "class".equals( elementName ) ) {
				RootClass rootclass = new RootClass();
...

/ 7. 	

/ Debug	,

/s
Configuration.doConfigure(Document) line: 2206	
/=
	protected Configuration doConfigure(Document doc) throws HibernateException {


		Element sfNode = doc.getRootElement().element( "session-factory" );

////////////////////////////
/ hibernate.cfg.xml

sfNode	DefaultElement  (id=25)	
	attributes	ArrayList<E>  (id=386)	
	content	ArrayList<E>  (id=387)	

/ de attributes zien we vanzelf als we sfNode print	,

/ click sfNode	,
org.dom4j.tree.DefaultElement@666adef3 [Element: <session-factory attributes: []/>]

/ click sfNode, content

[
	org.dom4j.tree.DefaultComment@62470c64 [Comment: " Database connection settings "], 
	org.dom4j.tree.DefaultElement@267eaba4 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@4636afba [Attribute: name name value "connection.driver_class"]]/>], 
	org.dom4j.tree.DefaultElement@304b0059 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@c03ebd4 [Attribute: name name value "connection.url"]]/>], 
	org.dom4j.tree.DefaultElement@556fb175 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@17eba425 [Attribute: name name value "connection.username"]]/>], 
	org.dom4j.tree.DefaultElement@6f658567 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@72196653 [Attribute: name name value "connection.password"]]/>], 
	org.dom4j.tree.DefaultComment@618d0daa [Comment: " [ERICJ] <property name="transaction.factory_class">org.hibernate.transaction.JDBCTransactionFactory</property> "], 
	org.dom4j.tree.DefaultComment@737c45ee [Comment: " SQL dialect - generate SQL for a particular database "]
	 org.dom4j.tree.DefaultElement@63d3477d [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@43fa92be [Attribute: name name value "dialect"]]/>]
	 org.dom4j.tree.DefaultComment@77b81acf [Comment: " Echo all executed SQL statements "]
	 org.dom4j.tree.DefaultElement@57e84970 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@532d8526 [Attribute: name name value "show_sql"]]/>]
	 org.dom4j.tree.DefaultComment@5180ac73 [Comment: " Enable Hibernate's automatic session context management "]
	 org.dom4j.tree.DefaultElement@56b9dbd2 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@440ee479 [Attribute: name name value "current_session_context_class"]]/>]
	 org.dom4j.tree.DefaultComment@2db9e6d7 [Comment: " [ERICJ] we create de tables vanuit Hibernate "]
	 org.dom4j.tree.DefaultComment@7e244b5 [Comment: " Drop and re-create the database schema on startup "]
	 org.dom4j.tree.DefaultElement@180ccb1e [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@6feb2ae7 [Attribute: name name value "hbm2ddl.auto"]]/>]
	 org.dom4j.tree.DefaultElement@384ddd18 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@7fee6f88 [Attribute: name name value "cache.use_second_level_cache"]]/>]
	 org.dom4j.tree.DefaultElement@7edc8b55 [Element: <property attributes: [org.dom4j.tree.DefaultAttribute@413fba84 [Attribute: name name value "cache.region.factory_class"]]/>]
	 org.dom4j.tree.DefaultComment@3eee5193 [Comment: "         <property name="cache.use_query_cache">true</property>
 "]
	 org.dom4j.tree.DefaultElement@102daa2c [Element: <mapping attributes: [org.dom4j.tree.DefaultAttribute@25ff3700 [Attribute: name resource value "my/test/own/hibernate_collections_xml/Employee.hbm.xml"]]/>]
	 org.dom4j.tree.DefaultElement@1673f47d [Element: <mapping attributes: [org.dom4j.tree.DefaultAttribute@16b8460f [Attribute: name resource value "my/test/own/hibernate_collections_xml/Address.hbm.xml"]]/>]]

		addProperties( sfNode );
/ Komen allemaal in de grote lijst van properties	,

		parseSessionFactory( sfNode, name );
/s
	private void parseSessionFactory(Element sfNode, String name) {
		Iterator elements = sfNode.elementIterator();
		while ( elements.hasNext() ) {
			Element subelement = (Element) elements.next();
			String subelementName = subelement.getName();
			if ( "mapping".equals( subelementName ) ) {
				parseMappingElement( subelement, name );
/s
	private void parseMappingElement(Element mappingElement, String name) {
		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
		final Attribute fileAttribute = mappingElement.attribute( "file" );
		final Attribute jarAttribute = mappingElement.attribute( "jar" );
		final Attribute packageAttribute = mappingElement.attribute( "package" );
		final Attribute classAttribute = mappingElement.attribute( "class" );

/ we hebben er 2 met resource attr	,

	private void parseMappingElement(Element mappingElement, String name) {
		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
		final Attribute fileAttribute = mappingElement.attribute( "file" );
		final Attribute jarAttribute = mappingElement.attribute( "jar" );
		final Attribute packageAttribute = mappingElement.attribute( "package" );
		final Attribute classAttribute = mappingElement.attribute( "class" );

/ we hebben er 2 met resource attr	,
	private void parseMappingElement(Element mappingElement, String name) {
		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
		final Attribute fileAttribute = mappingElement.attribute( "file" );
		final Attribute jarAttribute = mappingElement.attribute( "jar" );
		final Attribute packageAttribute = mappingElement.attribute( "package" );
		final Attribute classAttribute = mappingElement.attribute( "class" );

/ we hebben er 2 met resource attr	,
...
/s
Configuration.add(XmlDocument) line: 522	
		if ( inSecondPass || !isOrmXml( metadataXml ) ) {
/ JA	, 
			metadataSourceQueue.add( metadataXml );
/ want isOrmXml=
		return "entity-mappings".equals( xmlDocument.getDocumentTree().getRootElement().getName() );
false
/ JPA

/s
Configuration$MetadataSourceQueue.add(XmlDocument) line: 3673	

/////////////////////////
// Employee.hbm.xml

<hibernate-mapping 
	package="my.test.own.hibernate_collections_xml">

<class 
	name="Employee" 
	table="employee"
>
 	<id 
		name="id"
		column="id_"
	>	
	<property
		name="name"
		column="name_"
	/>
	<property 
		name="salary"
		column="salary_"
	>
	</property>
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	></many-to-one>
 </class>
</hibernate-mapping>

/ we zien	,

hmNode	DefaultElement  (id=194)	
	attributes	ArrayList<E>  (id=196)	
	content	DefaultElement  (id=197)	
		attributes	ArrayList<E>  (id=207)	
		content	ArrayList<E>  (id=208)	

/ als we click op hmNode, zien we meteen de attributes (die er onder ook staan)	, 
/ als we click op hmNode, content, zien we meteen de attributes (die er onder ook staan)	, 


/ click hmNode	,

org.dom4j.tree.DefaultElement@efccf98 [Element: <hibernate-mapping attributes: [	org.dom4j.tree.DefaultAttribute@77a10bd7 [Attribute: name package value "my.test.own.hibernate_collections_xml"]
	 org.dom4j.tree.DefaultAttribute@6e108d9c [Attribute: name default-cascade value "none"]
	 org.dom4j.tree.DefaultAttribute@c13538 [Attribute: name default-access value "property"]
	 org.dom4j.tree.DefaultAttribute@c8cefeb [Attribute: name default-lazy value "true"]
	 org.dom4j.tree.DefaultAttribute@78db33bc [Attribute: name auto-import value "true"]]/>]

/ click hmNode, content	,

org.dom4j.tree.DefaultElement@697ef1a5 [Element: <class attributes: 
	[org.dom4j.tree.DefaultAttribute@d2abdbf [Attribute: name name value "Employee"]
	 org.dom4j.tree.DefaultAttribute@710f4d59 [Attribute: name table value "employee"]
	 org.dom4j.tree.DefaultAttribute@239f480c [Attribute: name mutable value "true"]
	 org.dom4j.tree.DefaultAttribute@2e331e19 [Attribute: name polymorphism value "implicit"]
	 org.dom4j.tree.DefaultAttribute@1dfd1301 [Attribute: name dynamic-update value "false"]
	 org.dom4j.tree.DefaultAttribute@51eab608 [Attribute: name dynamic-insert value "false"]
	 org.dom4j.tree.DefaultAttribute@854f13c [Attribute: name select-before-update value "false"]
	 org.dom4j.tree.DefaultAttribute@a99e6a [Attribute: name optimistic-lock value "version"]]/>]

/ click hmNode, content, content	,

[org.dom4j.tree.DefaultComment@ad02624 [Comment: " 	<cache 
		usage="read-only"/>
 "]
	 org.dom4j.tree.DefaultElement@67780b07 [Element: <id attributes: [
		org.dom4j.tree.DefaultAttribute@7a1c2da2 [Attribute: name name value "id"]
	 	org.dom4j.tree.DefaultAttribute@4ff8254f [Attribute: name column value "id_"]]/>]

	 org.dom4j.tree.DefaultElement@2c598e8d [Element: <property attributes: [
		org.dom4j.tree.DefaultAttribute@2b9de1ba [Attribute: name name value "name"]
	 	org.dom4j.tree.DefaultAttribute@a4e90b5 [Attribute: name column value "name_"]
	 	org.dom4j.tree.DefaultAttribute@2bfe605c [Attribute: name unique value "false"]
	 	org.dom4j.tree.DefaultAttribute@49684e94 [Attribute: name optimistic-lock value "true"]
	 	org.dom4j.tree.DefaultAttribute@5efefc32 [Attribute: name lazy value "false"]
	 	org.dom4j.tree.DefaultAttribute@365f6757 [Attribute: name generated value "never"]]/>]

	 org.dom4j.tree.DefaultElement@31799ca4 [Element: <property attributes: [	
		org.dom4j.tree.DefaultAttribute@271aec5c [Attribute: name name value "salary"]
	 	org.dom4j.tree.DefaultAttribute@5893a012 [Attribute: name column value "salary_"]
	 	org.dom4j.tree.DefaultAttribute@43f22b2c [Attribute: name unique value "false"]
	 	org.dom4j.tree.DefaultAttribute@4ff0788d [Attribute: name optimistic-lock value "true"]
	 	org.dom4j.tree.DefaultAttribute@347a99fb [Attribute: name lazy value "false"]
	 	org.dom4j.tree.DefaultAttribute@5d1348a7 [Attribute: name generated value "never"]]/>]

	 org.dom4j.tree.DefaultElement@1d06fbae [Element: <many-to-one attributes: [
		org.dom4j.tree.DefaultAttribute@35756b65 [Attribute: name name value "address"]
	 	org.dom4j.tree.DefaultAttribute@2fddcf4e [Attribute: name column value "address_"]
	 	org.dom4j.tree.DefaultAttribute@b55226f [Attribute: name not-null value "true"]
	 	org.dom4j.tree.DefaultAttribute@247ab39 [Attribute: name unique value "false"]
	 	org.dom4j.tree.DefaultAttribute@2f3a2c5a [Attribute: name update value "true"]
	 	org.dom4j.tree.DefaultAttribute@1435e0ef [Attribute: name insert value "true"]
	 	org.dom4j.tree.DefaultAttribute@5d427546 [Attribute: name optimistic-lock value "true"]
	 	org.dom4j.tree.DefaultAttribute@3621767f [Attribute: name not-found value "exception"]
	 	org.dom4j.tree.DefaultAttribute@4eeaa79c [Attribute: name embed-xml value "true"]]/>]

	 org.dom4j.tree.DefaultComment@fa21b3e [Comment: " 		cascade="save-update"
		unique="true"
 "], org.dom4j.tree.DefaultComment@5baa8b76 [Comment: " 	<one-to-one 
		name="address"

	></one-to-one> "], org.dom4j.tree.DefaultComment@19aa1efe [Comment: " 		cascade="all"
 "]]

Configuration$MetadataSourceQueue.add(XmlDocument) line: 3673	
			findClassNames( defaultPackage, hmNode, entityNames );
/s
Configuration$MetadataSourceQueue.findClassNames(String, Element, Set<String>) line: 3689	
/=
		private void findClassNames(String defaultPackage, Element startNode, Set<String> names) {
			Iterator[] classes = new Iterator[4];
			classes[0] = startNode.elementIterator( "class" );
			classes[1] = startNode.elementIterator( "subclass" );
			classes[2] = startNode.elementIterator( "joined-subclass" );
			classes[3] = startNode.elementIterator( "union-subclass" );

/ bij ons staat er 
<hibernate-mapping ...>
	<class name="..." ...>

				String entityName = element.attributeValue( "entity-name" );
				if ( entityName == null ) {
/ JA
					entityName = getClassName( element.attribute( "name" ), defaultPackage );
/ my.test.own.hibernate_collections_xml.Employee

/t
Configuration$MetadataSourceQueue.add(XmlDocument) line: 3675	
			for ( String entity : entityNames ) {
				hbmMetadataByEntityNameXRef.put( entity, metadataXml );
			}
			this.hbmMetadataToEntityNamesMap.put( metadataXml, entityNames );

/t
Configuration.doConfigure(Document) line: 2209	
		parseSessionFactory( sfNode, name );
/ D
		Element secNode = doc.getRootElement().element( "security" );
null
/TODO

/t
	public Configuration configure() throws HibernateException {
		configure( "/hibernate.cfg.xml" );
/ D

/t
	protected void setUp() throws Exception {
        	Configuration configuration=new Configuration().configure();
/ D

/ later	,
Main.setUp() line: 70	
        	Configuration configuration=new Configuration().configure();
/ D
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
/s
StandardServiceRegistryBuilder.build() line: 251	
this	StandardServiceRegistryBuilder  (id=452)	
	initiators	ArrayList<E>  (id=498)	
[org.hibernate.engine.config.internal.ConfigurationServiceInitiator@26aa607e
 org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractorInitiator@279a3929
 org.hibernate.engine.jndi.internal.JndiServiceInitiator@7e1ec70e
 org.hibernate.jmx.internal.JmxServiceInitiator@169ea8d2
 org.hibernate.persister.internal.PersisterClassResolverInitiator@a5d7e98
 org.hibernate.persister.internal.PersisterFactoryInitiator@223279
 org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator@451fa600
 org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator@20cb6d74
 org.hibernate.engine.jdbc.dialect.internal.DialectResolverInitiator@b7eeb7e
 org.hibernate.engine.jdbc.dialect.internal.DialectFactoryInitiator@3996a317
 org.hibernate.engine.jdbc.batch.internal.BatchBuilderInitiator@50ad588a
 org.hibernate.engine.jdbc.internal.JdbcServicesInitiator@248ff567
 org.hibernate.engine.jdbc.cursor.internal.RefCursorSupportInitiator@67384ff1
 org.hibernate.id.factory.internal.MutableIdentifierGeneratorFactoryInitiator@22088c28
 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformResolverInitiator@2abb9259
 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator@5b29297f
 org.hibernate.engine.transaction.internal.TransactionFactoryInitiator@42bed1e7
 org.hibernate.service.internal.SessionFactoryServiceRegistryFactoryInitiator@3652ac26
 org.hibernate.cache.internal.RegionFactoryInitiator@3fd7ada9]
	providedServices	ArrayList<E>  (id=499)	
[org.hibernate.service.internal.ProvidedService@7b4c6598]

/t
	protected void setUp() throws Exception {
             
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
/ D

/ HIER HIER
    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);
...
/s
	public <R extends Service> R getService(Class<R> serviceRole) {

		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
serviceBinding	ServiceBinding<R>  (id=572)	
	serviceInitiator	JdbcServicesInitiator  (id=574)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=548)	
	service	null	

		if ( service == null ) {
			service = initializeService( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 225	
/=
	private <R extends Service> R initializeService(ServiceBinding<R> serviceBinding) {

		// PHASE 1 : create service
		R service = createService( serviceBinding );
/s
	protected <R extends Service> R createService(ServiceBinding<R> serviceBinding) {

		final ServiceInitiator<R> serviceInitiator = serviceBinding.getServiceInitiator();
		try {
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/ serviceBinding.getLifecycleOwner()=org.hibernate.boot.registry.internal.StandardServiceRegistryImpl@1567904d
service	JdbcServicesImpl  (id=594)	
/t
/s
StandardServiceRegistryImpl.initiateService(ServiceInitiator<R>) line: 105	
		return ( (StandardServiceInitiator<R>) serviceInitiator ).initiateService( configurationValues, this );
/s
JdbcServicesInitiator.initiateService(Map, ServiceRegistryImplementor) line: 52	
		return new JdbcServicesImpl();

/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 231	
		// PHASE 1 : create service
		R service = createService( serviceBinding );
/ D
		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 231	
/=
	private <R extends Service> void applyInjections(R service) {
		try {
			for ( Method method : service.getClass().getMethods() ) {
				InjectService injectService = method.getAnnotation( InjectService.class );
null
/ voor alle methods hieronder	,

[public void org.hibernate.engine.jdbc.internal.JdbcServicesImpl.injectServices(org.hibernate.service.spi.ServiceRegistryImplementor)
 public void org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(java.util.Map)
 public org.hibernate.dialect.Dialect org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getDialect()
 public org.hibernate.engine.jdbc.spi.ExtractedDatabaseMetaData org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getExtractedMetaDataSupport()
 public org.hibernate.engine.jdbc.LobCreator org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getLobCreator(org.hibernate.engine.jdbc.LobCreationContext)
 public org.hibernate.engine.jdbc.spi.SqlStatementLogger org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getSqlStatementLogger()
 public org.hibernate.engine.jdbc.connections.spi.ConnectionProvider org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getConnectionProvider()
 public org.hibernate.engine.jdbc.spi.SqlExceptionHelper org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getSqlExceptionHelper()
 public org.hibernate.engine.jdbc.spi.ResultSetWrapper org.hibernate.engine.jdbc.internal.JdbcServicesImpl.getResultSetWrapper()
 public final void java.lang.Object.wait(long
int) throws java.lang.InterruptedException
 public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
 public final void java.lang.Object.wait() throws java.lang.InterruptedException
 public boolean java.lang.Object.equals(java.lang.Object)
 public java.lang.String java.lang.Object.toString()
 public native int java.lang.Object.hashCode()
 public final native java.lang.Class java.lang.Object.getClass()
 public final native void java.lang.Object.notify()
 public final native void java.lang.Object.notifyAll()]

/ t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 234	

serviceBinding	ServiceBinding<R>  (id=572)	
	service	JdbcServicesImpl  (id=601)	

		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/s
	public <R extends Service> void configureService(ServiceBinding<R> serviceBinding) {
		if ( Configurable.class.isInstance( serviceBinding.getService() ) ) {
			( (Configurable) serviceBinding.getService() ).configure( configurationValues );
/s
JdbcServicesImpl.configure(Map) line: 94	
		final JdbcConnectionAccess jdbcConnectionAccess = buildJdbcConnectionAccess( configValues );
/ configValues = alle properties	,
/s
JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 260	
		if ( MultiTenancyStrategy.NONE == multiTenancyStrategy ) {
			connectionProvider = serviceRegistry.getService( ConnectionProvider.class );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 206	

		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
serviceRole	Class<T> (org.hibernate.engine.jdbc.connections.spi.ConnectionProvider) (id=658)	

		R service = serviceBinding.getService();
		if ( service == null ) {
/ JA
			service = initializeService( serviceBinding );
/s
/ recursive call	,
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 234	

serviceBinding	ServiceBinding<R>  (id=655)	
	service	DriverManagerConnectionProviderImpl  (id=656)	

		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/s
	public <R extends Service> void configureService(ServiceBinding<R> serviceBinding) {
		if ( Configurable.class.isInstance( serviceBinding.getService() ) ) {
			( (Configurable) serviceBinding.getService() ).configure( configurationValues );
/s
DriverManagerConnectionProviderImpl.configure(Map) line: 106	
		for ( int i = 0; i < initialSize; i++ ) {
initialSize	1	
			connections.add( connectionCreator.createConnection() );
/s
DriverConnectionCreator(BasicConnectionCreator).createConnection() line: 75	
		final Connection conn = makeConnection( url, connectionProps );
/s
	protected Connection makeConnection(String url, Properties connectionProps) {
		try {
			return driver.connect( url, connectionProps );
/ we komen in postgres code	,

/t
DriverConnectionCreator(BasicConnectionCreator).createConnection() line: 75	
			if ( isolation != null ) {
/ TODO
				conn.setTransactionIsolation( isolation );

		try {
			if ( conn.getAutoCommit() != autoCommit ) {
/ JA	, want conn's auto commit=true
				conn.setAutoCommit( autoCommit );
/ H sets auto commit false	,

/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 237	
		// PHASE 4 : Start service
		serviceBinding.getLifecycleOwner().startService( serviceBinding );
/NIETS

/t
JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 261	
			connectionProvider = serviceRegistry.getService( ConnectionProvider.class );
/ D
			return new ConnectionProviderJdbcConnectionAccess( connectionProvider );

/t
JdbcServicesImpl.configure(Map) line: 95	
		final JdbcConnectionAccess jdbcConnectionAccess = buildJdbcConnectionAccess( configValues );
/ D
		final DialectFactory dialectFactory = serviceRegistry.getService( DialectFactory.class );
/ TODO

...
					metaSupportsScrollable = meta.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );
/s
Jdbc4DatabaseMetaData(AbstractJdbc2DatabaseMetaData).supportsResultSetType(int) line: 4276	
    public boolean supportsResultSetType(int type) throws SQLException
    {
        // The only type we don't support
        return type != java.sql.ResultSet.TYPE_SCROLL_SENSITIVE;

/t
					metaSupportsBatchUpdates = meta.supportsBatchUpdates();
/s
Jdbc4DatabaseMetaData(AbstractJdbc2DatabaseMetaData).supportsBatchUpdates() line: 4356	
        return true;

/t
					typeInfoSet.addAll( TypeInfo.extractTypeInfo( meta ) );
/ TODO

...
/ TODO

		final boolean showSQL = ConfigurationHelper.getBoolean( Environment.SHOW_SQL, configValues, false );
true
		final boolean formatSQL = ConfigurationHelper.getBoolean( Environment.FORMAT_SQL, configValues, false );
false

/t
Configuration.buildSessionFactory(ServiceRegistry) line: 1844	
		buildTypeRegistrations( serviceRegistry );
/ D
		secondPassCompile();
/s
				AnnotationBinder.bindDefaults( createMappings() );
/s
AnnotationBinder.bindDefaults(Mappings) line: 221	

			List<SequenceGenerator> anns = ( List<SequenceGenerator> ) defaults.get( SequenceGenerator.class );
...
			List<NamedQuery> anns = ( List<NamedQuery> ) defaults.get( NamedQuery.class );
...
/ TODO

...
			caches.clear();
/ TODO

/later	,
SettingsFactory.buildSettings(Properties, ServiceRegistry) line: 134	



/ 7	.

        	Configuration configuration=new Configuration().configure();
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();

    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);
/ deze maps types->tbls in db	,

/ Na	,
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
this	Main  (id=16)	
	serviceRegistry	StandardServiceRegistryImpl  (id=21)	
		serviceBindingList	ArrayList<E>  (id=34)	
			elementData	Object[20]  (id=45)	
		serviceBindingMap	ConcurrentServiceBinding<K,V>  (id=44)	
			treeRoot	ConcurrentServiceBinding$Node<K,V>  (id=66)	

/ click elementData, de feitenlijk registered services	,
[org.hibernate.service.spi.ServiceBinding@1625b930, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]


/click treeRoot	,
<interface org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory, org.hibernate.service.spi.ServiceBinding@4d0e1da2>
L-> <interface org.hibernate.engine.config.spi.ConfigurationService, org.hibernate.service.spi.ServiceBinding@59bb9e33>
	L-> <interface org.hibernate.engine.jndi.spi.JndiService, org.hibernate.service.spi.ServiceBinding@2c8f544b>
		L-> <interface org.hibernate.engine.jdbc.connections.spi.ConnectionProvider, org.hibernate.service.spi.ServiceBinding@75e71ec7>
			L-> <interface org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider, org.hibernate.service.spi.ServiceBinding@1895d74a>
		R-> <interface org.hibernate.engine.jdbc.cursor.spi.RefCursorSupport, org.hibernate.service.spi.ServiceBinding@156947e2>
			L-> <interface org.hibernate.persister.spi.PersisterFactory, org.hibernate.service.spi.ServiceBinding@32ee5169>
	R-> <interface org.hibernate.engine.jdbc.spi.JdbcServices, org.hibernate.service.spi.ServiceBinding@3c22de9e>
		L-> <interface org.hibernate.engine.jdbc.dialect.spi.DialectFactory, org.hibernate.service.spi.ServiceBinding@154575ea>
			L-> <interface org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform, org.hibernate.service.spi.ServiceBinding@340608f>
		R-> <interface org.hibernate.persister.spi.PersisterClassResolver, org.hibernate.service.spi.ServiceBinding@77834df3>
R-> <interface org.hibernate.engine.transaction.spi.TransactionFactory, org.hibernate.service.spi.ServiceBinding@4d72c9d1>
	L-> <interface org.hibernate.secure.spi.JaccService, org.hibernate.service.spi.ServiceBinding@1cfd04a1>
		L-> <interface org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractor, org.hibernate.service.spi.ServiceBinding@2b1fe010>
			L-> <interface org.hibernate.engine.jdbc.dialect.spi.DialectResolver, org.hibernate.service.spi.ServiceBinding@39af508e>
		R-> <interface org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformResolver, org.hibernate.service.spi.ServiceBinding@24d1b838>
	R-> <interface org.hibernate.jmx.spi.JmxService, org.hibernate.service.spi.ServiceBinding@4495776a>
		L-> <interface org.hibernate.service.spi.SessionFactoryServiceRegistryFactory, org.hibernate.service.spi.ServiceBinding@30d2f353>
			L-> <interface org.hibernate.cache.spi.RegionFactory, org.hibernate.service.spi.ServiceBinding@6964e72f>
		R-> <interface org.hibernate.engine.jdbc.batch.spi.BatchBuilder, org.hibernate.service.spi.ServiceBinding@5f85f4b7>
/ TODO

    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);
/s
	public SessionFactory buildSessionFactory(ServiceRegistry serviceRegistry) throws HibernateException {
		buildTypeRegistrations( serviceRegistry );
/s
Configuration.buildTypeRegistrations(ServiceRegistry) line: 1885	
		// add Dialect contributed types
		final Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 199	
/=
	public <R extends Service> R getService(Class<R> serviceRole) {
/ TODO

		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
serviceBinding	ServiceBinding<R>  (id=1586)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
	service	null	
	serviceInitiator	JdbcServicesInitiator  (id=1588)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=1585)	

			service = initializeService( serviceBinding );
	private <R extends Service> R initializeService(ServiceBinding<R> serviceBinding) {

		// PHASE 1 : create service
		R service = createService( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 254	
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/s
		return ( (StandardServiceInitiator<R>) serviceInitiator ).initiateService( configurationValues, this );
/s
		return new JdbcServicesImpl();
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 254	
			registerService( serviceBinding, service );
/s
		serviceBinding.setService( service );
		synchronized ( serviceBindingList ) {
			serviceBindingList.add( serviceBinding );

/ Dus nu 2 services in deze list	,
[org.hibernate.service.spi.ServiceBinding@1625b930, org.hibernate.service.spi.ServiceBinding@3ac113ae]

/t

		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );

		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/s
			( (Configurable) serviceBinding.getService() ).configure( configurationValues );
/s
///////////////////////
/ Specifieke class for configure	,
JdbcServicesImpl.configure(Map) line: 94	

		final JdbcConnectionAccess jdbcConnectionAccess = buildJdbcConnectionAccess( configValues );
/s
JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 260	
			connectionProvider = serviceRegistry.getService( ConnectionProvider.class );
/s
JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 260	
			service = initializeService( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 234	

serviceBinding	ServiceBinding<R>  (id=1626)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
	service	DriverManagerConnectionProviderImpl  (id=1639)	
	serviceInitiator	ConnectionProviderInitiator  (id=1627)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.connections.spi.ConnectionProvider) (id=1621)	

		// PHASE 1 : create service
		R service = createService( serviceBinding );

		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );

		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/s
			( (Configurable) serviceBinding.getService() ).configure( configurationValues );
/s
///////////////////////
/ Specifieke class for configure	,
DriverManagerConnectionProviderImpl.configure(Map) line: 95	

		connectionCreator = buildCreator( configurationValues );
/s
DriverManagerConnectionProviderImpl.buildCreator(Map) line: 189	

		final ConnectionCreatorBuilder connectionCreatorBuilder = new ConnectionCreatorBuilder( serviceRegistry );

		final String driverClassName = (String) configurationValues.get( AvailableSettings.DRIVER );
		connectionCreatorBuilder.setDriver( loadDriverIfPossible( driverClassName ) );

		final String url = (String) configurationValues.get( AvailableSettings.URL );
		connectionCreatorBuilder.setUrl( url );

		final Properties connectionProps = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
		connectionCreatorBuilder.setConnectionProps( connectionProps );

		final boolean autoCommit = ConfigurationHelper.getBoolean( AvailableSettings.AUTOCOMMIT, configurationValues, false );
		log.autoCommitMode( autoCommit );
		connectionCreatorBuilder.setAutoCommit( autoCommit );

		final Integer isolation = ConfigurationHelper.getInteger( AvailableSettings.ISOLATION, configurationValues );
null
		connectionCreatorBuilder.setIsolation( isolation );

connectionCreatorBuilder	ConnectionCreatorBuilder  (id=1650)	
	autoCommit	false	
	connectionProps	Properties  (id=1659)	
	driver	Driver  (id=1690)	
org.postgresql.Driver@4cf20c6d
	isolation	null	
	serviceRegistry	StandardServiceRegistryImpl  (id=19)	
	url	"jdbc:postgresql://localhost/foo" (id=1657)	

		return connectionCreatorBuilder.build();
/s
			return new DriverConnectionCreator( driver, serviceRegistry, url, connectionProps, autoCommit, isolation );
/ set van parameters	,

/t
DriverManagerConnectionProviderImpl.configure(Map) line: 97	
		for ( int i = 0; i < initialSize; i++ ) {
			connections.add( connectionCreator.createConnection() );
/s
DriverConnectionCreator(BasicConnectionCreator).createConnection() line: 75	
		final Connection conn = makeConnection( url, connectionProps );
/s
			return driver.connect( url, connectionProps );
/t
			if ( conn.getAutoCommit() != autoCommit ) {
				conn.setAutoCommit( autoCommit );

			if ( isolation != null ) {
/ NEE
				conn.setTransactionIsolation( isolation );
/ NIET


/t
DriverManagerConnectionProviderImpl.configure(Map) line: 106	
		for ( int i = 0; i < initialSize; i++ ) {
			connections.add( connectionCreator.createConnection() );

		executorService = Executors.newSingleThreadScheduledExecutor();
/ TODO

/t
JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 261	
			connectionProvider = serviceRegistry.getService( ConnectionProvider.class );
/ D

/t
JdbcServicesImpl.configure(Map) line: 95	
		final JdbcConnectionAccess jdbcConnectionAccess = buildJdbcConnectionAccess( configValues );
/ D
		final DialectFactory dialectFactory = serviceRegistry.getService( DialectFactory.class );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 206	

			service = initializeService( serviceBinding );
this	StandardServiceRegistryImpl  (id=19)	
serviceBinding	ServiceBinding<R>  (id=1787)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
	service	null	
	serviceInitiator	DialectFactoryInitiator  (id=1788)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.dialect.spi.DialectFactory) (id=1784)	
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 220	

		// PHASE 1 : create service
		R service = createService( serviceBinding );
/s
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/s
		return ( (StandardServiceInitiator<R>) serviceInitiator ).initiateService( configurationValues, this );
/s
///////////////////////
/ Specifieke class for configure	,
DialectFactoryInitiator.initiateService(Map, ServiceRegistryImplementor) line: 37	
		return new DialectFactoryImpl();

/t
			registerService( serviceBinding, service );

/t

		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 226	

serviceBinding	ServiceBinding<R>  (id=1825)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
	service	DialectResolverSet  (id=1826)	
	serviceInitiator	DialectResolverInitiator  (id=1829)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.dialect.spi.DialectResolver) (id=1828)	
service	DialectResolverSet  (id=1826)	
/ NIETS

		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/ NIETS

/t
JdbcServicesImpl.configure(Map) line: 97	
		final DialectFactory dialectFactory = serviceRegistry.getService( DialectFactory.class );
/ D
				final Connection connection = jdbcConnectionAccess.obtainConnection();
					final DatabaseMetaData meta = connection.getMetaData();

					metaSupportsNamedParams = meta.supportsNamedParameters();
/s
Jdbc4DatabaseMetaData(AbstractJdbc3DatabaseMetaData).supportsNamedParameters() line: 46	
/=
   public boolean supportsNamedParameters() throws SQLException
        return false;

/ AbstractJdbc3DatabaseMetaData is een postgres class	,

/t
					metaSupportsScrollable = meta.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );
/s
Jdbc4DatabaseMetaData(AbstractJdbc2DatabaseMetaData).supportsResultSetType(int) line: 4276	
       // The only type we don't support
        return type != java.sql.ResultSet.TYPE_SCROLL_SENSITIVE;

/ AbstractJdbc2DatabaseMetaData is een postgres class	,

/ t
JdbcServicesImpl.configure(Map) line: 163	
..
					typeInfoSet.addAll( TypeInfo.extractTypeInfo( meta ) );
/s
TypeInfo.extractTypeInfo(DatabaseMetaData) line: 101	

			final ResultSet resultSet = metaData.getTypeInfo();
/s
Jdbc4DatabaseMetaData(AbstractJdbc2DatabaseMetaData).getTypeInfo() line: 3970	

/ postgres class

            sql = "SELECT t.typname,t.oid FROM pg_catalog.pg_type t"
            	+ " JOIN pg_catalog.pg_namespace n ON (t.typnamespace = n.oid) "
            	+ " WHERE n.nspname != 'pg_toast'";

foo=> select t.typname,t.oid from pg_catalog.pg_type t join pg_catalog.pg_namespace n on ( t.typnamespace=n.oid) where n.nspname!='pg_toast';
                typname                |  oid  
---------------------------------------+-------
 bool                                  |    16
 bytea                                 |    17
 char                                  |    18
 name                                  |    19
 int8                                  |    20
 int2                                  |    21
 int2vector                            |    22
 int4                                  |    23
 regproc                               |    24
 text                                  |    25
 oid                                   |    26
 tid                                   |    27
 xid                                   |    28
 cid                                   |    29
 oidvector                             |    30
 pg_type                               |    71
 pg_attribute                          |    75
 pg_proc                               |    81
 pg_class                              |    83
 json                                  |   114
 xml                                   |   142
 _xml                                  |   143
 _json                                 |   199
 pg_node_tree                          |   194
 smgr                                  |   210
 point                                 |   600
 lseg                                  |   601
 path                                  |   602
 box                                   |   603
 polygon                               |   604
 line                                  |   628
 _line                                 |   629
 float4                                |   700
 float8                                |   701
 abstime                               |   702
 reltime                               |   703
 tinterval                             |   704
 unknown                               |   705
 circle                                |   718
 _circle                               |   719
 money                                 |   790
 _money                                |   791
 macaddr                               |   829
 inet                                  |   869
 cidr                                  |   650
 _bool                                 |  1000
 _bytea                                |  1001
 _char                                 |  1002
 _name                                 |  1003
 _int2                                 |  1005
 _int2vector                           |  1006
 _int4                                 |  1007
 _regproc                              |  1008
 _text                                 |  1009
 _oid                                  |  1028
 _tid                                  |  1010
 _xid                                  |  1011
 _cid                                  |  1012
 _oidvector                            |  1013
 _bpchar                               |  1014
 _varchar                              |  1015
 _int8                                 |  1016
 _point                                |  1017
 _lseg                                 |  1018
 _path                                 |  1019
 _box                                  |  1020
 _float4                               |  1021
 _float8                               |  1022
 _abstime                              |  1023
 _reltime                              |  1024
 _tinterval                            |  1025
 _polygon                              |  1027
 aclitem                               |  1033
 _aclitem                              |  1034
 _macaddr                              |  1040
 _inet                                 |  1041
 _cidr                                 |   651
 _cstring                              |  1263
 bpchar                                |  1042
 varchar                               |  1043
 date                                  |  1082
 time                                  |  1083
 timestamp                             |  1114
 _timestamp                            |  1115
 _date                                 |  1182
 _time                                 |  1183
 timestamptz                           |  1184
 _timestamptz                          |  1185
 interval                              |  1186
 _interval                             |  1187
 _numeric                              |  1231
 timetz                                |  1266
 _timetz                               |  1270
 bit                                   |  1560
 _bit                                  |  1561
 varbit                                |  1562
 _varbit                               |  1563
 numeric                               |  1700
 refcursor                             |  1790
 _refcursor                            |  2201
 regprocedure                          |  2202
 regoper                               |  2203
 regoperator                           |  2204
 regclass                              |  2205
 regtype                               |  2206
 _regprocedure                         |  2207
 _regoper                              |  2208
 _regoperator                          |  2209
 _regclass                             |  2210
 _regtype                              |  2211
 uuid                                  |  2950
 _uuid                                 |  2951
 tsvector                              |  3614
 gtsvector                             |  3642
 tsquery                               |  3615
 regconfig                             |  3734
 regdictionary                         |  3769
 _tsvector                             |  3643
 _gtsvector                            |  3644
 _tsquery                              |  3645
 _regconfig                            |  3735
 _regdictionary                        |  3770
 txid_snapshot                         |  2970
 _txid_snapshot                        |  2949
 int4range                             |  3904
 _int4range                            |  3905
 numrange                              |  3906
 _numrange                             |  3907
 tsrange                               |  3908
 _tsrange                              |  3909
 tstzrange                             |  3910
 _tstzrange                            |  3911
 daterange                             |  3912
 _daterange                            |  3913
 int8range                             |  3926
 _int8range                            |  3927
 record                                |  2249
 _record                               |  2287
 cstring                               |  2275
 any                                   |  2276
 anyarray                              |  2277
 void                                  |  2278
 trigger                               |  2279
 event_trigger                         |  3838
 language_handler                      |  2280
 internal                              |  2281
 opaque                                |  2282
 anyelement                            |  2283
 anynonarray                           |  2776
 anyenum                               |  3500
 fdw_handler                           |  3115
 anyrange                              |  3831
 pg_attrdef                            | 10000
 pg_constraint                         | 10001
 pg_inherits                           | 10002
 pg_index                              | 10003
 pg_operator                           | 10004
 pg_opfamily                           | 10005
 pg_opclass                            | 10006
 pg_am                                 | 10117
 pg_amop                               | 10118
 pg_amproc                             | 10522
 pg_language                           | 10814
 pg_largeobject_metadata               | 10815
 pg_largeobject                        | 10816
 pg_aggregate                          | 10817
 pg_statistic                          | 10818
 pg_rewrite                            | 10819
 pg_trigger                            | 10820
 pg_event_trigger                      | 10821
 pg_description                        | 10822
 pg_cast                               | 10823
 pg_enum                               | 11020
 pg_namespace                          | 11021
 pg_conversion                         | 11022
 pg_depend                             | 11023
 pg_database                           |  1248
 pg_db_role_setting                    | 11024
 pg_tablespace                         | 11025
 pg_pltemplate                         | 11026
 pg_authid                             |  2842
 pg_auth_members                       |  2843
 pg_shdepend                           | 11027
 pg_shdescription                      | 11028
 pg_ts_config                          | 11029
 pg_ts_config_map                      | 11030
 pg_ts_dict                            | 11031
 pg_ts_parser                          | 11032
 pg_ts_template                        | 11033
 pg_extension                          | 11034
 pg_foreign_data_wrapper               | 11035
 pg_foreign_server                     | 11036
 pg_user_mapping                       | 11037
 pg_foreign_table                      | 11038
 pg_default_acl                        | 11039
 pg_seclabel                           | 11040
 pg_shseclabel                         | 11041
 pg_collation                          | 11042
 pg_range                              | 11043
 pg_roles                              | 11055
 pg_shadow                             | 11058
 pg_group                              | 11061
 pg_user                               | 11064
 pg_rules                              | 11067
 pg_views                              | 11071
 pg_tables                             | 11075
 pg_matviews                           | 11079
 pg_indexes                            | 11083
 pg_stats                              | 11087
 pg_locks                              | 11091
 pg_cursors                            | 11094
 pg_available_extensions               | 11097
 pg_available_extension_versions       | 11100
 pg_prepared_xacts                     | 11103
 pg_prepared_statements                | 11107
 pg_seclabels                          | 11110
 pg_settings                           | 11114
 pg_timezone_abbrevs                   | 11119
 pg_timezone_names                     | 11122
 pg_stat_all_tables                    | 11125
 pg_stat_xact_all_tables               | 11129
 pg_stat_sys_tables                    | 11133
 pg_stat_xact_sys_tables               | 11137
 pg_stat_user_tables                   | 11140
 pg_stat_xact_user_tables              | 11144
 pg_statio_all_tables                  | 11147
 pg_statio_sys_tables                  | 11151
 pg_statio_user_tables                 | 11154
 pg_stat_all_indexes                   | 11157
 pg_stat_sys_indexes                   | 11161
 pg_stat_user_indexes                  | 11164
 pg_statio_all_indexes                 | 11167
 pg_statio_sys_indexes                 | 11171
 pg_statio_user_indexes                | 11174
 pg_statio_all_sequences               | 11177
 pg_statio_sys_sequences               | 11181
 pg_statio_user_sequences              | 11184
 pg_stat_activity                      | 11187
 pg_stat_replication                   | 11190
 pg_stat_database                      | 11193
 pg_stat_database_conflicts            | 11196
 pg_stat_user_functions                | 11199
 pg_stat_xact_user_functions           | 11203
 pg_stat_bgwriter                      | 11207
 pg_user_mappings                      | 11210
 cardinal_number                       | 12414
 character_data                        | 12416
 sql_identifier                        | 12417
 information_schema_catalog_name       | 12419
 time_stamp                            | 12421
 yes_or_no                             | 12422
 applicable_roles                      | 12425
 administrable_role_authorizations     | 12429
 attributes                            | 12432
 character_sets                        | 12436
 check_constraint_routine_usage        | 12440
 check_constraints                     | 12444
 collations                            | 12448
 collation_character_set_applicability | 12451
 column_domain_usage                   | 12454
 column_privileges                     | 12458
 column_udt_usage                      | 12462
 columns                               | 12466
 constraint_column_usage               | 12470
 constraint_table_usage                | 12474
 domain_constraints                    | 12478
 domain_udt_usage                      | 12482
 domains                               | 12485
 enabled_roles                         | 12489
 key_column_usage                      | 12492
 parameters                            | 12496
 referential_constraints               | 12500
 role_column_grants                    | 12504
 routine_privileges                    | 12507
 role_routine_grants                   | 12511
 routines                              | 12514
 schemata                              | 12518
 sequences                             | 12521
 sql_features                          | 12525
 sql_implementation_info               | 12530
 sql_languages                         | 12535
 sql_packages                          | 12540
 sql_parts                             | 12545
 sql_sizing                            | 12550
 sql_sizing_profiles                   | 12555
 table_constraints                     | 12560
 table_privileges                      | 12564
 role_table_grants                     | 12568
 tables                                | 12571
 triggered_update_columns              | 12575
 triggers                              | 12579
 udt_privileges                        | 12583
 role_udt_grants                       | 12587
 usage_privileges                      | 12590
 role_usage_grants                     | 12594
 user_defined_types                    | 12597
 view_column_usage                     | 12601
 view_routine_usage                    | 12605
 view_table_usage                      | 12609
 views                                 | 12613
 data_type_privileges                  | 12617
 element_types                         | 12621
 _pg_foreign_table_columns             | 12625
 column_options                        | 12629
 _pg_foreign_data_wrappers             | 12632
 foreign_data_wrapper_options          | 12635
 foreign_data_wrappers                 | 12638
 _pg_foreign_servers                   | 12641
 foreign_server_options                | 12645
 foreign_servers                       | 12648
 _pg_foreign_tables                    | 12651
 foreign_table_options                 | 12655
 foreign_tables                        | 12658
 _pg_user_mappings                     | 12661
 user_mapping_options                  | 12664
 user_mappings                         | 12668
 events                                | 20571
 _events                               | 20570
 bids                                  | 20757
 _bids                                 | 20756
 items                                 | 20762
 _items                                | 20761
 item_bid                              | 21819
 _item_bid                             | 21818
 tbl                                   | 48883
 _tbl                                  | 48882
 pro                                   | 59063
 _pro                                  | 59062
 bid                                   | 64263
 _bid                                  | 64262
 item                                  | 64268
 hibernate_sequence                    | 61356
 _item                                 | 64267
 x                                     | 61955
 _x                                    | 61954
 pre                                   | 59054
 _pre                                  | 59053
 tbl                                   | 48886
 _tbl                                  | 48885
 y                                     | 48557
 _y                                    | 48556
 y                                     | 48576
 _y                                    | 48575
 z                                     | 48585
 _z                                    | 48584
 x                                     | 48590
 _x                                    | 48589
 t                                     | 48598
 _t                                    | 48597
 s                                     | 48603
 _s                                    | 48602
 a                                     | 48606
 _a                                    | 48605
 b                                     | 48609
 _b                                    | 48608
 d                                     | 48612
 _d                                    | 48611
 walnut                                | 48641
 _walnut                               | 48640
 walnut                                | 48890
 _walnut                               | 48889
 person_id___seq                       | 60884
 person                                | 60887
 _person                               | 60886
(364 rows)

/t
TypeInfo.extractTypeInfo(DatabaseMetaData) line: 103	
			final ResultSet resultSet = metaData.getTypeInfo();

resultSet	Jdbc4ResultSet  (id=1965)	
	fields	Field[18]  (id=1892)	
	rows	ArrayList<E>  (id=1894)	
		elementData	Object[366]  (id=1958)	
			[0...99]	
				[0]	(id=1923)	
					[0]	(id=1925)	
					[1]	(id=1926)	
					[2]	(id=1927)	
					[3]	(id=1920)	
					[4]	(id=1920)	
					[6]	(id=1921)	
					[7]	(id=1918)	
					[8]	(id=1922)	
					[9]	(id=1919)	
					[10]	(id=1918)	
					[11]	(id=1918)	
					[13]	(id=1916)	
					[14]	(id=1916)	
					[17]	(id=1917)	
				[1]	(id=1946)	
				[2]	(id=2031)	
			[100...199]	
			[200...299]	
			[300...365]	
				[364]	(id=2409)	
				[365]	(id=2410)	

/ er zijn 18 fields	, 
/ van iedere type , ieder van de 366 worden de 18 fields gegeven	,

				while ( resultSet.next() ) {
					typeInfoSet.add(
							new TypeInfo(
									resultSet.getString( "TYPE_NAME" ),
									resultSet.getInt( "DATA_TYPE" ),
									interpretCreateParams( resultSet.getString( "CREATE_PARAMS" ) ),
									resultSet.getBoolean( "UNSIGNED_ATTRIBUTE" ),
									resultSet.getInt( "PRECISION" ),
									resultSet.getShort( "MINIMUM_SCALE" ),
									resultSet.getShort( "MAXIMUM_SCALE" ),
									resultSet.getBoolean( "FIXED_PREC_SCALE" ),
									resultSet.getString( "LITERAL_PREFIX" ),
									resultSet.getString( "LITERAL_SUFFIX" ),
									resultSet.getBoolean( "CASE_SENSITIVE" ),
									TypeSearchability.interpret( resultSet.getShort( "SEARCHABLE" ) ),
									TypeNullability.interpret( resultSet.getShort( "NULLABLE" ) )
							)
					);

/ TODO

		return typeInfoSet;

/t
JdbcServicesImpl.configure(Map) line: 165	
					typeInfoSet.addAll( TypeInfo.extractTypeInfo( meta ) );
/ D

					dialect = dialectFactory.buildDialect(
							configValues,
							new DialectResolutionInfoSource() {
								@Override
								public DialectResolutionInfo getDialectResolutionInfo() {
									try {
										return new DatabaseMetaDataDialectResolutionInfoAdapter( connection.getMetaData() );
									}
									catch ( SQLException sqlException ) {
										throw new HibernateException(
												"Unable to access java.sql.DatabaseMetaData to determine appropriate Dialect to use",
												sqlException
										);
									}
								}
							}
					);

					catalogName = connection.getCatalog();
foo
...
						schemaName = schemaNameResolver.resolveSchemaName( connection );
null
		final boolean showSQL = ConfigurationHelper.getBoolean( Environment.SHOW_SQL, configValues, false );
true
		final boolean formatSQL = ConfigurationHelper.getBoolean( Environment.FORMAT_SQL, configValues, false );
false
		this.extractedMetaDataSupport = new ExtractedDatabaseMetaDataImpl(
				metaSupportsRefCursors,
				metaSupportsNamedParams,
				metaSupportsScrollable,
				metaSupportsGetGeneratedKeys,
				metaSupportsBatchUpdates,
				metaReportsDDLInTxnSupported,
				metaReportsDDLCausesTxnCommit,
				parseKeywords( extraKeywordsString ),
				parseSQLStateType( sqlStateType ),
				lobLocatorUpdateCopy,
				schemaName,
				catalogName,
				typeInfoSet
		);

/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 237	
		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/ D
serviceBinding	ServiceBinding<R>  (id=1586)	
	service	JdbcServicesImpl  (id=1613)	

/s
Configuration.buildTypeRegistrations(ServiceRegistry) line: 1885	
		// add Dialect contributed types
		final Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();
/D
dialect	PostgreSQLDialect  (id=2582)	

		dialect.contributeTypes( typeContributions, serviceRegistry );
/ NIETS

		// add TypeContributor contributed types.
		ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
		for ( TypeContributor contributor : classLoaderService.loadJavaServices( TypeContributor.class ) ) {
/ NEE
		}
		// from app registrations
		for ( TypeContributor contributor : typeContributorRegistrations ) {
 /NEE

/t
Configuration.buildSessionFactory(ServiceRegistry) line: 1844	
		buildTypeRegistrations( serviceRegistry );
/ D
		secondPassCompile();
/s
Configuration.secondPassCompile() line: 1387	

		{
			if ( !isDefaultProcessed ) {
				//use global delimiters if orm.xml declare it
/ TODO
				Map defaults = reflectionManager.getDefaults();
{schema=null
 interface javax.persistence.EntityListeners=[]
 catalog=null
 delimited-identifier=null}

				AnnotationBinder.bindDefaults( createMappings() );
/s
Configuration.createMappings() line: 911	
		return new MappingsImpl();
/t
/s
AnnotationBinder.bindDefaults(Mappings) line: 216	

		// id generators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		{
			List<SequenceGenerator> anns = ( List<SequenceGenerator> ) defaults.get( SequenceGenerator.class );
null

			List<TableGenerator> anns = ( List<TableGenerator> ) defaults.get( TableGenerator.class );
null

		// queries ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		{
			List<NamedQuery> anns = ( List<NamedQuery> ) defaults.get( NamedQuery.class );
null

			List<NamedNativeQuery> anns = ( List<NamedNativeQuery> ) defaults.get( NamedNativeQuery.class );
null

		// result-set-mappings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		{
			List<SqlResultSetMapping> anns = ( List<SqlResultSetMapping> ) defaults.get( SqlResultSetMapping.class );
null

		// stored procs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		{
			final List<NamedStoredProcedureQuery> annotations =
					(List<NamedStoredProcedureQuery>) defaults.get( NamedStoredProcedureQuery.class );
null

			final List<NamedStoredProcedureQueries> annotations =
					(List<NamedStoredProcedureQueries>) defaults.get( NamedStoredProcedureQueries.class );
null

/t
Configuration.secondPassCompile() line: 1409	
				AnnotationBinder.bindDefaults( createMappings() );
/ D
				isDefaultProcessed = true;

		// process metadata queue
		{
			metadataSourceQueue.syncAnnotatedClasses();
/s
Configuration$MetadataSourceQueue.syncAnnotatedClasses() line: 3720	

this	Configuration$MetadataSourceQueue  (id=44)	
	annotatedClasses	ArrayList<E>  (id=46)	
[]
	annotatedClassesByEntityNameMap	HashMap<K,V>  (id=52)	
{}
	hbmMetadataByEntityNameXRef	HashMap<K,V>  (id=55)	
{my.test.own.hibernate_collections_xml.Employee=org.hibernate.internal.util.xml.XmlDocumentImpl@58d38ce8
 my.test.own.hibernate_collections_xml.Address=org.hibernate.internal.util.xml.XmlDocumentImpl@793f044c}
	hbmMetadataToEntityNamesMap	LinkedHashMap<K,V>  (id=57)	
{org.hibernate.internal.util.xml.XmlDocumentImpl@58d38ce8=[my.test.own.hibernate_collections_xml.Employee]
 org.hibernate.internal.util.xml.XmlDocumentImpl@793f044c=[my.test.own.hibernate_collections_xml.Address]}

			final Iterator<XClass> itr = annotatedClasses.iterator();
			while ( itr.hasNext() ) {
/ NEE

/t
Configuration$MetadataSourceQueue.processMetadata(List<MetadataSourceType>) line: 3737	
/=
		protected void processMetadata(List<MetadataSourceType> order) {
order	Collections$UnmodifiableRandomAccessList<E>  (id=87)	
[hbm, class]

			for ( MetadataSourceType type : order ) {
/ type=hbm
				if ( MetadataSourceType.HBM.equals( type ) ) {
/ JA
					processHbmXmlQueue();
/s
Configuration$MetadataSourceQueue.processHbmXmlQueue() line: 3748	

			for ( Map.Entry<XmlDocument, Set<String>> entry : hbmMetadataToEntityNamesMap.entrySet() ) {
entry	LinkedHashMap$Entry<K,V>  (id=107)	
org.hibernate.internal.util.xml.XmlDocumentImpl@58d38ce8=[my.test.own.hibernate_collections_xml.Employee]

				// Unfortunately we have to create a Mappings instance for each iteration here
				processHbmXml( entry.getKey(), entry.getValue() );
/s
Configuration$MetadataSourceQueue.processHbmXml(XmlDocument, Set<String>) line: 3759	
/=
		private void processHbmXml(XmlDocument metadataXml, Set<String> entityNames) {

/ Intermezzo

metadataXml	XmlDocumentImpl  (id=117)	

	documentTree	DefaultDocument  (id=125)	
org.dom4j.tree.DefaultDocument@4f4e18a1 [Document: name null]

		content	ArrayList<E>  (id=137)	
[org.dom4j.tree.DefaultElement@371fac61 [Element: <hibernate-mapping attributes: [
 org.dom4j.tree.DefaultAttribute@6e308d [Attribute: name package value "my.test.own.hibernate_collections_xml"]
 org.dom4j.tree.DefaultAttribute@42357933 [Attribute: name default-cascade value "none"]
 org.dom4j.tree.DefaultAttribute@44a8253a [Attribute: name default-access value "property"]
 org.dom4j.tree.DefaultAttribute@7b24260c [Attribute: name default-lazy value "true"]
 org.dom4j.tree.DefaultAttribute@23e1cfd [Attribute: name auto-import value "true"]]/>]]

		rootElement	DefaultElement  (id=157)	
			content	ArrayList<E>  (id=168)	
[org.dom4j.tree.DefaultElement@5546c05c [Element: <class attributes: [
 org.dom4j.tree.DefaultAttribute@17ff03c1 [Attribute: name name value "Employee"]
 org.dom4j.tree.DefaultAttribute@674f8035 [Attribute: name table value "employee"]
 org.dom4j.tree.DefaultAttribute@146a4c90 [Attribute: name mutable value "true"]
 org.dom4j.tree.DefaultAttribute@4ec88c68 [Attribute: name polymorphism value "implicit"]
 org.dom4j.tree.DefaultAttribute@507a2840 [Attribute: name dynamic-update value "false"]
 org.dom4j.tree.DefaultAttribute@3e8ab07 [Attribute: name dynamic-insert value "false"]
 org.dom4j.tree.DefaultAttribute@20345a92 [Attribute: name select-before-update value "false"]
 org.dom4j.tree.DefaultAttribute@4d2637c2 [Attribute: name optimistic-lock value "version"]]/>]]

				elementData	Object[5]  (id=173)	
					[0]	DefaultElement  (id=256)	
						content	ArrayList<E>  (id=269)	
[org.dom4j.tree.DefaultComment@67744ae6 [Comment: " 	<cache 
		usage="read-only"/>
 "]
 org.dom4j.tree.DefaultElement@3e1771a [Element: <id attributes: [
 org.dom4j.tree.DefaultAttribute@47524df3 [Attribute: name name value "id"]
 org.dom4j.tree.DefaultAttribute@6c7bb119 [Attribute: name column value "id_"]]/>]

 org.dom4j.tree.DefaultElement@2ca817f3 [Element: <property attributes: [
 org.dom4j.tree.DefaultAttribute@4fbc696c [Attribute: name name value "name"]
 org.dom4j.tree.DefaultAttribute@5aad5a59 [Attribute: name column value "name_"]
 org.dom4j.tree.DefaultAttribute@2b06b791 [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@45fda6a8 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@fc8837e [Attribute: name lazy value "false"]
 org.dom4j.tree.DefaultAttribute@3530cd4a [Attribute: name generated value "never"]]/>]

 org.dom4j.tree.DefaultElement@16f5d08e [Element: <property attributes: [
 org.dom4j.tree.DefaultAttribute@644f2668 [Attribute: name name value "salary"]
 org.dom4j.tree.DefaultAttribute@862a94b [Attribute: name column value "salary_"]
 org.dom4j.tree.DefaultAttribute@5587f3a [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@7508bb93 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@1052ebec [Attribute: name lazy value "false"]
 org.dom4j.tree.DefaultAttribute@33fedb53 [Attribute: name generated value "never"]]/>]

 org.dom4j.tree.DefaultElement@20f140d0 [Element: <many-to-one attributes: [
 org.dom4j.tree.DefaultAttribute@3ed62895 [Attribute: name name value "address"]
 org.dom4j.tree.DefaultAttribute@5e026e6d [Attribute: name column value "address_"]
 org.dom4j.tree.DefaultAttribute@719fe652 [Attribute: name not-null value "true"]
 org.dom4j.tree.DefaultAttribute@38ca4bc5 [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@69348fa3 [Attribute: name update value "true"]
 org.dom4j.tree.DefaultAttribute@79c24c4a [Attribute: name insert value "true"]
 org.dom4j.tree.DefaultAttribute@431eccb9 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@1b12a81c [Attribute: name not-found value "exception"]
 org.dom4j.tree.DefaultAttribute@65dad426 [Attribute: name embed-xml value "true"]]/>]

 org.dom4j.tree.DefaultComment@19e3f08 [Comment: " 		cascade="save-update"
		unique="true"
 "], org.dom4j.tree.DefaultComment@3c3c270c [Comment: " 	<one-to-one 
		name="address"

	></one-to-one> "], org.dom4j.tree.DefaultComment@1127a3b9 [Comment: " 		cascade="all"
 "]]

/ Einde Intermezzo

			try {
				HbmBinder.bindRoot( metadataXml, createMappings(), Collections.EMPTY_MAP, entityNames );
/s
HbmBinder.bindRoot(XmlDocument, Mappings, Map, Set<String>) line: 140	
/=
	public static void bindRoot(
			XmlDocument metadataXml,
			Mappings mappings,
			java.util.Map inheritedMetas,
			java.util.Set<String> entityNames) throws MappingException {
metadataXml	XmlDocumentImpl  (id=117)	
mappings	Configuration$MappingsImpl  (id=178)	
inheritedMetas	Collections$EmptyMap<K,V>  (id=182)	
entityNames	HashSet<E>  (id=122)	

		final Document doc = metadataXml.getDocumentTree();
org.dom4j.tree.DefaultDocument@4f4e18a1 [Document: name null]

		final Element hibernateMappingElement = doc.getRootElement();
org.dom4j.tree.DefaultElement@371fac61 [Element: <hibernate-mapping attributes: [
 org.dom4j.tree.DefaultAttribute@6e308d [Attribute: name package value "my.test.own.hibernate_collections_xml"]
 org.dom4j.tree.DefaultAttribute@42357933 [Attribute: name default-cascade value "none"]
 org.dom4j.tree.DefaultAttribute@44a8253a [Attribute: name default-access value "property"]
 org.dom4j.tree.DefaultAttribute@7b24260c [Attribute: name default-lazy value "true"]
 org.dom4j.tree.DefaultAttribute@23e1cfd [Attribute: name auto-import value "true"]]/>]

		java.util.List<String> names = HbmBinder.getExtendsNeeded( metadataXml, mappings );
[]
/ TODO

		inheritedMetas = getMetas( hibernateMappingElement, inheritedMetas, true );
{}
		extractRootAttributes( hibernateMappingElement, mappings );
/s
HbmBinder.extractRootAttributes(Element, Mappings) line: 291	
		Attribute schemaNode = hmNode.attribute( "schema" );
		mappings.setSchemaName( ( schemaNode == null ) ? null : schemaNode.getValue() );

		Attribute catalogNode = hmNode.attribute( "catalog" );
		mappings.setCatalogName( ( catalogNode == null ) ? null : catalogNode.getValue() );

		Attribute dcNode = hmNode.attribute( "default-cascade" );
		mappings.setDefaultCascade( ( dcNode == null ) ? "none" : dcNode.getValue() );

		Attribute daNode = hmNode.attribute( "default-access" );
		mappings.setDefaultAccess( ( daNode == null ) ? "property" : daNode.getValue() );

		Attribute dlNode = hmNode.attribute( "default-lazy" );
		mappings.setDefaultLazy( dlNode == null || dlNode.getValue().equals( "true" ) );

		Attribute aiNode = hmNode.attribute( "auto-import" );
		mappings.setAutoImport( ( aiNode == null ) || "true".equals( aiNode.getValue() ) );

		Attribute packNode = hmNode.attribute( "package" );
		if ( packNode != null ) mappings.setDefaultPackage( packNode.getValue() );

mappings	Configuration$MappingsImpl  (id=178)	
	autoImport	true	
	catalogName	null	
	defaultAccess	"property" (id=252)	
	defaultCascade	"none" (id=253)	
	defaultLazy	true	
	defaultPackage	"my.test.own.hibernate_collections_xml" (id=237)	
	forceDiscriminatorInSelectsByDefault	null	
	ignoreExplicitDiscriminatorColumnForJoinedInheritance	null	
	implicitDiscriminatorColumnForJoinedInheritance	null	
	schemaName	null	


terator rootChildren = hibernateMappingElement.elementIterator();
rootChildren	ArrayList$Itr  (id=376)	
	this$0	BackedList  (id=379)	
[org.dom4j.tree.DefaultElement@5546c05c [Element: <class attributes: [
 org.dom4j.tree.DefaultAttribute@17ff03c1 [Attribute: name name value "Employee"]
 org.dom4j.tree.DefaultAttribute@674f8035 [Attribute: name table value "employee"]
 org.dom4j.tree.DefaultAttribute@146a4c90 [Attribute: name mutable value "true"]
 org.dom4j.tree.DefaultAttribute@4ec88c68 [Attribute: name polymorphism value "implicit"]
 org.dom4j.tree.DefaultAttribute@507a2840 [Attribute: name dynamic-update value "false"]
 org.dom4j.tree.DefaultAttribute@3e8ab07 [Attribute: name dynamic-insert value "false"]
 org.dom4j.tree.DefaultAttribute@20345a92 [Attribute: name select-before-update value "false"]
 org.dom4j.tree.DefaultAttribute@4d2637c2 [Attribute: name optimistic-lock value "version"]]/>]]

		while ( rootChildren.hasNext() ) {
			final Element element = (Element) rootChildren.next();
/ die hier vlak boven	,

			final String elementName = element.getName();
"class"

			if ( "filter-def".equals( elementName ) ) {
				parseFilterDef( element, mappings );
			}
			else if ( "fetch-profile".equals( elementName ) ) {
				parseFetchProfile( element, mappings, null );
			}
			else if ( "identifier-generator".equals( elementName ) ) {
				parseIdentifierGeneratorRegistration( element, mappings );
			}
			else if ( "typedef".equals( elementName ) ) {
				bindTypeDef( element, mappings );
			}
			else if ( "class".equals( elementName ) ) {
				RootClass rootclass = new RootClass();
				bindRootClass( element, rootclass, mappings, inheritedMetas );
				mappings.addClass( rootclass );
			}
			else if ( "subclass".equals( elementName ) ) {
				PersistentClass superModel = getSuperclass( mappings, element );
				handleSubclass( superModel, mappings, element, inheritedMetas );
			}
			else if ( "joined-subclass".equals( elementName ) ) {
				PersistentClass superModel = getSuperclass( mappings, element );
				handleJoinedSubclass( superModel, mappings, element, inheritedMetas );
			}
			else if ( "union-subclass".equals( elementName ) ) {
				PersistentClass superModel = getSuperclass( mappings, element );
				handleUnionSubclass( superModel, mappings, element, inheritedMetas );
			}
			else if ( "query".equals( elementName ) ) {
				bindNamedQuery( element, null, mappings );
			}
			else if ( "sql-query".equals( elementName ) ) {
				bindNamedSQLQuery( element, null, mappings );
			}
			else if ( "resultset".equals( elementName ) ) {
				bindResultSetMappingDefinition( element, null, mappings );
			}
			else if ( "import".equals( elementName ) ) {
				bindImport( element, mappings );
			}
			else if ( "database-object".equals( elementName ) ) {
				bindAuxiliaryDatabaseObject( element, mappings );
			}

/ we komen dus in	,
			else if ( "class".equals( elementName ) ) {
				RootClass rootclass = new RootClass();
				bindRootClass( element, rootclass, mappings, inheritedMetas );
/s
HbmBinder.bindRootClass(Element, RootClass, Mappings, Map) line: 324	
/ node = <class ...>
/ mappings=attrs van <hibernate-mapping ...>

		bindClass( node, rootClass, mappings, inheritedMetas );
/s
HbmBinder.bindClass(Element, PersistentClass, Mappings, Map) line: 569	

		Attribute lazyNode = node.attribute( "lazy" );
null
		boolean lazy = lazyNode == null ?
				mappings.isDefaultLazy() :
true
				"true".equals( lazyNode.getValue() );

/ <class ...> heeft zelf geen attr lazy, dus haalt van <hibernate-mapping ...> , die default lazy="true" heeft	,

		// go ahead and set the lazy here, since pojo.proxy can override it.
		persistentClass.setLazy( lazy );
/ De RootClass inst	,

		String entityName = node.attributeValue( "entity-name" );
		if ( entityName == null ) entityName = getClassName( node.attribute("name"), mappings );
entityName	"my.test.own.hibernate_collections_xml.Employee" (id=494)	

/ node.attribute("name") is de attr	, deze heeft value="Employee",	 de pkg name komt uit mappings	,

		persistentClass.setEntityName( entityName );
		persistentClass.setJpaEntityName( StringHelper.unqualify( entityName ) );
persistentClass	RootClass  (id=454)	
	entityName	"my.test.own.hibernate_collections_xml.Employee" (id=494)	
	jpaEntityName	"Employee" (id=536)	

		bindPojoRepresentation( node, persistentClass, mappings, inheritedMetas );
/ node=<class ...>
/ mapoings= attr <hibernate-mapping ...>
/s
HbmBinder.bindPojoRepresentation(Element, PersistentClass, Mappings, Map) line: 600	

		String className = getClassName( node.attribute( "name" ), mappings );
className	"my.test.own.hibernate_collections_xml.Employee" (id=544)	
		String proxyName = getClassName( node.attribute( "proxy" ), mappings );
null
		entity.setClassName( className );

		else if ( entity.isLazy() ) {
			entity.setProxyInterfaceName( className );

		Element tuplizer = locateTuplizerDefinition( node, EntityMode.POJO );
null
/ want	,
/s
HbmBinder.locateTuplizerDefinition(Element, EntityMode) line: 647	

		Iterator itr = container.elements( "tuplizer" ).iterator();
/ NIET 	,

/t
HbmBinder.bindClass(Element, PersistentClass, Mappings, Map) line: 585	
		bindPojoRepresentation( node, persistentClass, mappings, inheritedMetas );
/ D
		bindDom4jRepresentation( node, persistentClass, mappings, inheritedMetas );
/s
HbmBinder.bindDom4jRepresentation(Element, PersistentClass, Mappings, Map) line: 621	

		String nodeName = node.attributeValue( "node" );
null
		if (nodeName==null) nodeName = StringHelper.unqualify( entity.getEntityName() );
"Employee"
		entity.setNodeName(nodeName);

/t
HbmBinder.bindClass(Element, PersistentClass, Mappings, Map) line: 585	

		bindDom4jRepresentation( node, persistentClass, mappings, inheritedMetas );
/ D
		bindMapRepresentation( node, persistentClass, mappings, inheritedMetas );
/s
HbmBinder.bindMapRepresentation(Element, PersistentClass, Mappings, Map) line: 633	
		Element tuplizer = locateTuplizerDefinition( node, EntityMode.MAP );
/s
HbmBinder.locateTuplizerDefinition(Element, EntityMode) line: 647	
		Iterator itr = container.elements( "tuplizer" ).iterator();
/ NIET

/t
HbmBinder.bindClass(Element, PersistentClass, Mappings, Map) line: 588	
		bindMapRepresentation( node, persistentClass, mappings, inheritedMetas );
/D
		Iterator itr = node.elementIterator( "fetch-profile" );
/ NEE

/ HIER HIER

		bindPersistentClassCommonValues( node, persistentClass, mappings, inheritedMetas );
/s
HbmBinder.bindPersistentClassCommonValues(Element, PersistentClass, Mappings, Map) line: 660	

		Attribute discriminatorNode = node.attribute( "discriminator-value" );
null
		entity.setDiscriminatorValue( ( discriminatorNode == null )
			? entity.getEntityName()
			: discriminatorNode.getValue() );
"my.test.own.hibernate_collections_xml.Employee" (id=494)	


		Attribute dynamicNode = node.attribute( "dynamic-update" );
org.dom4j.tree.DefaultAttribute@507a2840 [Attribute: name dynamic-update value "false"]
		entity.setDynamicUpdate(
				dynamicNode != null && "true".equals( dynamicNode.getValue() )
		);
false

		Attribute insertNode = node.attribute( "dynamic-insert" );
org.dom4j.tree.DefaultAttribute@3e8ab07 [Attribute: name dynamic-insert value "false"]
		entity.setDynamicInsert(
				insertNode != null && "true".equals( insertNode.getValue() )
		);
false

		mappings.addImport( entity.getEntityName(), entity.getEntityName() );
/s
Configuration$MappingsImpl.addImport(String, String) line: 2841	
			String existing = imports.put( rename, entityName );
null, 
/ want	,
this	Configuration$MappingsImpl  (id=178)	
	this$0	Configuration  (id=17)	
		imports	HashMap<K,V>  (id=625)	
{my.test.own.hibernate_collections_xml.Employee=my.test.own.hibernate_collections_xml.Employee}

/t
		if ( mappings.isAutoImport() && entity.getEntityName().indexOf( '.' ) > 0 ) {
/ JA
			mappings.addImport(
					entity.getEntityName(),
					StringHelper.unqualify( entity.getEntityName() )
this	Configuration$MappingsImpl  (id=178)	
	this$0	Configuration  (id=17)	
		imports	HashMap<K,V>  (id=625)	
{my.test.own.hibernate_collections_xml.Employee=my.test.own.hibernate_collections_xml.Employee
 Employee=my.test.own.hibernate_collections_xml.Employee}

		Attribute batchNode = node.attribute( "batch-size" );
null
		if ( batchNode != null ) entity.setBatchSize( Integer.parseInt( batchNode.getValue() ) );
/ NEE

		Attribute sbuNode = node.attribute( "select-before-update" );
org.dom4j.tree.DefaultAttribute@20345a92 [Attribute: name select-before-update value "false"]
		if ( sbuNode != null ) entity.setSelectBeforeUpdate( "true".equals( sbuNode.getValue() ) );

		Attribute olNode = node.attribute( "optimistic-lock" );
org.dom4j.tree.DefaultAttribute@4d2637c2 [Attribute: name optimistic-lock value "version"]
		entity.setOptimisticLockStyle( getOptimisticLockStyle( olNode ) );
/s
HbmBinder.getOptimisticLockStyle(Attribute) line: 2975	
		final String olMode = olAtt.getValue();
		if ( olMode == null || "version".equals( olMode ) ) {
/ JA
			return OptimisticLockStyle.VERSION;
		}
		else if ( "dirty".equals( olMode ) ) {
			return OptimisticLockStyle.DIRTY;
		}
		else if ( "all".equals( olMode ) ) {
			return OptimisticLockStyle.ALL;
		}
		else if ( "none".equals( olMode ) ) {
			return OptimisticLockStyle.NONE;
		}

/t
		entity.setMetaAttributes( getMetas( node, inheritedMetas ) );
 inheritedMetas={}
/ NIETS	,
/want	,
/s
		return getMetas( node, inheritedMeta, false );
/s
HbmBinder.getMetas(Element, Map, boolean) line: 3003	
...

/t
		Attribute persisterNode = node.attribute( "persister" );
null

		handleCustomSQL( node, entity );
/ NIETS	,
/ want	,
/s
HbmBinder.handleCustomSQL(Element, PersistentClass) line: 736	

		Element element = node.element( "sql-insert" );
null
		element = node.element( "sql-delete" );
null
		element = node.element( "sql-update" );
null
		element = node.element( "loader" );
null

/t
		Iterator tables = node.elementIterator( "synchronize" );
tables	ArrayList$Itr  (id=763)	
	this$0	BackedList  (id=765)	
[]

		Attribute abstractNode = node.attribute( "abstract" );
null
		Boolean isAbstract = abstractNode == null
				? null
		entity.setAbstract( isAbstract );

/t
HbmBinder.bindRootClass(Element, RootClass, Mappings, Map) line: 325	
		bindClass( node, rootClass, mappings, inheritedMetas );
/ D
		inheritedMetas = getMetas( node, inheritedMetas, true ); // get meta's from <class>
/ node=<class ...>
/ inheritedMetas={}
{}

		bindRootPersistentClassCommonValues( node, inheritedMetas, mappings, rootClass );
/s
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 335	

		Attribute schemaNode = node.attribute( "schema" );
null
		String schema = schemaNode == null ?
				mappings.getSchemaName() : schemaNode.getValue();
null

		Attribute catalogNode = node.attribute( "catalog" );
null
		String catalog = catalogNode == null ?
				mappings.getCatalogName() : catalogNode.getValue();
null

		Table table = mappings.addTable(
				schema,
				catalog,
				getClassTableName( entity, node, schema, catalog, null, mappings ),
				getSubselect( node ),
		        entity.isAbstract() != null && entity.isAbstract()
			);
/s
HbmBinder.getClassTableName(PersistentClass, Element, String, String, Table, Mappings) line: 886	

		Attribute tableNameNode = node.attribute( "table" );
org.dom4j.tree.DefaultAttribute@674f8035 [Attribute: name table value "employee"]

		else {
			logicalTableName = tableNameNode.getValue();
"employee"
			physicalTableName = mappings.getNamingStrategy().tableName( logicalTableName );
/s
Configuration$MappingsImpl.getNamingStrategy() line: 2802	
			return namingStrategy;
this	Configuration$MappingsImpl  (id=178)	
	this$0	Configuration  (id=17)	
		namingStrategy	EJB3NamingStrategy  (id=707)	
/t
/s
EJB3NamingStrategy.tableName(String) line: 47	
		return tableName;
"employee"

/t
		mappings.addTableBinding( schema, catalog, logicalTableName, physicalTableName, denormalizedSuperTable );
/s
Configuration$MappingsImpl.addTableBinding(String, String, String, String, Table) line: 3118	
			String key = buildTableNameKey( schema, catalog, physicalName );
/s
		private String buildTableNameKey(String schema, String catalog, String finalName) {
			StringBuilder keyBuilder = new StringBuilder();
			if (schema != null) keyBuilder.append( schema );
			keyBuilder.append( ".");
			if (catalog != null) keyBuilder.append( catalog );
			keyBuilder.append( ".");
			keyBuilder.append( finalName );
			return keyBuilder.toString();
/t
key	"..employee" (id=915)	

			TableDescription tableDescription = new TableDescription( logicalName, denormalizedSuperTable );
			TableDescription oldDescriptor = ( TableDescription ) tableNameBinding.put( key, tableDescription );
null
/ want	,
this	Configuration$MappingsImpl  (id=178)	
	this$0	Configuration  (id=17)	
		tableNameBinding	HashMap<K,V>  (id=727)	
{..employee=org.hibernate.cfg.Configuration$MappingsImpl$TableDescription@4f1b5c27}

/t
		Table table = mappings.addTable(
				schema,
				catalog,
				getClassTableName( entity, node, schema, catalog, null, mappings ),
				getSubselect( node ),
		        	entity.isAbstract() != null && entity.isAbstract()
			);
/s
HbmBinder.getSubselect(Element) line: 3131	
		String subselect = element.attributeValue( "subselect" );
null
		else {
			Element subselectElement = element.element( "subselect" );
			return subselectElement == null ? null : subselectElement.getText();
null

/t
/s
RootClass(PersistentClass).isAbstract() line: 695	
		return isAbstract;
null

/t
/s
Configuration$MappingsImpl.addTable(String, String, String, String, boolean) line: 2878	

			String key = subselect == null ? Table.qualify( catalog, schema, name ) : subselect;
/s
Table.qualify(String, String, String) line: 123	
/s
		StringBuilder qualifiedName = new StringBuilder();
		if ( catalog != null ) {
			qualifiedName.append( catalog ).append( '.' );
		}
		if ( schema != null ) {
			qualifiedName.append( schema ).append( '.' );
		}
		return qualifiedName.append( table ).toString();

/t
			String key = subselect == null ? Table.qualify( catalog, schema, name ) : subselect;
employee
			Table table = tables.get( key );
null
			if ( table == null ) {
				table = new Table();
				table.setAbstract( isAbstract );
false
				table.setName( name );
employee
				table.setSchema( schema );
null
				table.setCatalog( catalog );
null
				table.setSubselect( subselect );
null
				tables.put( key, table );
/ key="employee"

/t
		Table table = mappings.addTable(
				schema,
				catalog,
				getClassTableName( entity, node, schema, catalog, null, mappings ),
				getSubselect( node ),
		        entity.isAbstract() != null && entity.isAbstract()
			);
/ D
catalog	null	
table	Table  (id=994)	
	catalog	null	
	catalogQuoted	false	
	checkConstraints	ArrayList<E>  (id=996)	
	columns	LinkedHashMap<K,V>  (id=997)	
	comment	null	
	foreignKeys	LinkedHashMap<K,V>  (id=998)	
	hasDenormalizedTables	false	
	idValue	null	
	indexes	LinkedHashMap<K,V>  (id=999)	
	isAbstract	false	
	name	"employee" (id=829)	
	primaryKey	null	
	quoted	false	
	rowId	null	
	schema	null	
	schemaQuoted	false	
	sizeOfUniqueKeyMapOnLastCleanse	0	
	subselect	null	
	uniqueInteger	0	
	uniqueKeys	LinkedHashMap<K,V>  (id=1000)	

		entity.setTable( table );

		bindComment(table, node);
/ NIETS	, <class ...> heeft geen child <comment ...>	,

		Attribute mutableNode = node.attribute( "mutable" );
org.dom4j.tree.DefaultAttribute@146a4c90 [Attribute: name mutable value "true"]
		entity.setMutable( ( mutableNode == null ) || mutableNode.getValue().equals( "true" ) );

		Attribute whereNode = node.attribute( "where" );
null

		Attribute chNode = node.attribute( "check" );
null

		Attribute polyNode = node.attribute( "polymorphism" );
org.dom4j.tree.DefaultAttribute@4ec88c68 [Attribute: name polymorphism value "implicit"]
		entity.setExplicitPolymorphism( ( polyNode != null )
			&& polyNode.getValue().equals( "explicit" ) );
/ NEE

		Attribute rowidNode = node.attribute( "rowid" );
null

		Iterator subnodes = node.elementIterator();
		while ( subnodes.hasNext() ) {
			Element subnode = (Element) subnodes.next();

subnode	DefaultElement  (id=1035)	
org.dom4j.tree.DefaultElement@3e1771a [Element: <id attributes: [
	org.dom4j.tree.DefaultAttribute@47524df3 [Attribute: name name value "id"]
 	org.dom4j.tree.DefaultAttribute@6c7bb119 [Attribute: name column value "id_"]]/>]

	attributes	ArrayList<E>  (id=1036)	
	content	DefaultComment  (id=1037)	
org.dom4j.tree.DefaultComment@be0f9eb [Comment: " 		<generator 
			class="increment"/>
 "]

/ attributes hoeven we niet te bekjken, want verschijnen altijd in element zelf (subnode hier)	, content wel, want de element (subnode ) geeft deze niet	,


			String name = subnode.getName();
id
/= qname.name 

			if ( "id".equals( name ) ) {
				// ID
				bindSimpleId( subnode, entity, mappings, inheritedMetas );
/s
HbmBinder.bindSimpleId(Element, RootClass, Mappings, Map) line: 416	

		String propertyName = idNode.attributeValue( "name" );
"id"
		SimpleValue id = new SimpleValue( mappings, entity.getTable() );
/ TODO (heeft niets met id )	,
		entity.setIdentifier( id );

		if ( propertyName == null ) {
/ NEE
		else {
			bindSimpleValue( idNode, id, false, propertyName, mappings );
/ 3de arg false=isNullable hieronder	,
/ we zijn in de bindSimpleId method, vandaar dat hier false staat	,
/s
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1191	
		bindSimpleValueType( node, simpleValue, mappings );
/s
HbmBinder.bindSimpleValueType(Element, SimpleValue, Mappings) line: 1201	

		Attribute typeNode = node.attribute( "type" );
null
        if ( typeNode == null ) {
            typeNode = node.attribute( "id-type" ); // for an any
null

		Element typeChild = node.element( "type" );
null
		if ( typeName == null && typeChild != null ) {
/ NEE

		resolveAndBindTypeDef(simpleValue, mappings, typeName, parameters);
/ NIETS	,
/ want	,
/s
HbmBinder.resolveAndBindTypeDef(SimpleValue, Mappings, String, Properties) line: 1232	

		TypeDef typeDef = mappings.getTypeDef( typeName );
typeName	null	
typeDef	null	

/t
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1193	

		bindSimpleValueType( node, simpleValue, mappings );
/ D
		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/s
HbmBinder.bindColumnsOrFormula(Element, SimpleValue, String, boolean, Mappings) line: 1620	

		Attribute formulaNode = node.attribute( "formula" );
null

		else {
			bindColumns( node, simpleValue, isNullable, true, path, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1061	

		Table table = simpleValue.getTable();

		// COLUMN(S)
		Attribute columnAttribute = node.attribute( "column" );
/ node=<id ...>
org.dom4j.tree.DefaultAttribute@6c7bb119 [Attribute: name column value "id_"]

		else {

			Column column = new Column();
			column.setValue( simpleValue );
/ simpleValue heette id hierboven	, 
			bindColumn( node, column, isNullable );
/ node=<id ...>
/s
HbmBinder.bindColumn(Element, Column, boolean) line: 1783	
/=
	public static void bindColumn(Element node, Column column, boolean isNullable) throws MappingException {
/ isNullable=false

		Attribute lengthNode = node.attribute( "length" );
null

		Attribute scalNode = node.attribute( "scale" );
null

		Attribute precNode = node.attribute( "precision" );
null

		Attribute nullNode = node.attribute( "not-null" );
null
		column.setNullable( nullNode == null ? isNullable : nullNode.getValue().equals( "false" ) );
/ isNullable=false, want we zijn altijd nog in de bindSimpleId method	,

///////////////
/ bij <id not-null="false" ...> is niet nodig: is de default	,

		Attribute unqNode = node.attribute( "unique" );
null
/ Dus 2 dezelfde id's kan	,
/ Geen pk	, 
/ TODO

		column.setCheckConstraint( node.attributeValue( "check" ) );

		column.setCheckConstraint( node.attributeValue( "check" ) );
null
		column.setDefaultValue( node.attributeValue( "default" ) );
null

		Attribute typeNode = node.attribute( "sql-type" );
null

		String customWrite = node.attributeValue( "write" );
null

		column.setCustomWrite( customWrite );
null
		column.setCustomRead( node.attributeValue( "read" ) );
null

		Element comment = node.element("comment");
null

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1128	
			bindColumn( node, column, isNullable );
/ D
			if ( column.isUnique() && ManyToOne.class.isInstance( simpleValue ) ) {
/ NEE
				( (ManyToOne) simpleValue ).markAsLogicalOneToOne();
/ NIET

/ ManyToOne.class.isInstance( simpleValue )=false
/ TODO (dat is Employee toch wel)

			String columnName = columnAttribute.getValue();
id_
			String logicalColumnName = mappings.getNamingStrategy().logicalColumnName( columnName, propertyPath);
id_
/ want	,
/s
EJB3NamingStrategy.logicalColumnName(String, String) line: 81	
		return StringHelper.isNotEmpty( columnName ) ? columnName : StringHelper.unqualify( propertyName );

/t
			columnName = mappings.getNamingStrategy().columnName( columnName );
id_
			columnName = quoteIdentifier( columnName, mappings );
id_
/ TODO
			column.setName( columnName );
			if ( table != null ) {
				table.addColumn( column ); // table=null -> an association - fill
/s
Table.addColumn(Column) line: 216	
		Column old = getColumn( column );
/s
Table.getColumn(Column) line: 202	
		Column myColumn = (Column) columns.get( column.getCanonicalName() );
null
/ want,
/ column.getCanonicalName()=
		return quoted ? name : name.toLowerCase();
/ quoted==false

		return column.equals( myColumn ) ?
				myColumn :
				null;
/t
Table.addColumn(Column) line: 217	
		Column old = getColumn( column );
null
		if ( old == null ) {
			columns.put( column.getCanonicalName(), column );
			column.uniqueInteger = columns.size();

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1142	
				table.addColumn( column ); // table=null -> an association - fill
/ D
				mappings.addColumnBinding( logicalColumnName, column, table );
/s
Configuration$MappingsImpl.addColumnBinding(String, Column, Table) line: 3197	

this	Configuration$MappingsImpl  (id=178)	
	this$0	Configuration  (id=17)	
		columnNameBindingPerTable	HashMap<K,V>  (id=607)	
{}

			TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( table );
null
			if ( binding == null ) {
				binding = new TableColumnNameBinding( table.getName() );
binding	Configuration$MappingsImpl$TableColumnNameBinding  (id=1246)	
	logicalToPhysical	HashMap<K,V>  (id=1247)	
	physicalToLogical	HashMap<K,V>  (id=1249)	
	tableName	"employee" (id=829)	
	this$1	Configuration$MappingsImpl  (id=178)	

				columnNameBindingPerTable.put( table, binding );
			}
			binding.addBinding( logicalName, physicalColumn );
physicalColumn	Column  (id=1168)	

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1144	
			simpleValue.addColumn( column );
/ in simpleValue.columns	,

			bindIndex( node.attribute( "index" ), table, column, mappings );
/ NIETS
/ want	 node.attribute( "index" )==null
			bindUniqueKey( node.attribute( "unique-key" ), table, column, mappings );
/ NIETS
/ want	 node.attribute( "unique-key" )==null


		if ( autoColumn && simpleValue.getColumnSpan() == 0 ) {
/ NEE
/ TODO (als we geen column attr hebben )
/ TODO ATTRIBUTES 

/t
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1195	

		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/ D

simpleValue	SimpleValue  (id=1088)	
	columns	ArrayList<E>  (id=1092)	
[org.hibernate.mapping.Column(id_)]
	mappings	Configuration$MappingsImpl  (id=178)	
		this$0	Configuration  (id=17)	
			columnNameBindingPerTable	HashMap<K,V>  (id=607)	
				table	HashMap$Entry<K,V>[16]  (id=1327)	
					[6]	HashMap$Entry<K,V>  (id=1331)	
						value	Configuration$MappingsImpl$TableColumnNameBinding  (id=1246)	
							logicalToPhysical	HashMap<K,V>  (id=1247)	
{id_=id_}
							physicalToLogical	HashMap<K,V>  (id=1249)	
{id_=id_}
	table	Table  (id=994)	
org.hibernate.mapping.Table(employee)

		Attribute fkNode = node.attribute( "foreign-key" );
null

/ Lees	over foreign-key	,
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch21.html#toolsetguide-s1-2

/t
HbmBinder.bindSimpleId(Element, RootClass, Mappings, Map) line: 446	
			bindSimpleValue( idNode, id, false, propertyName, mappings );
/ D
		else {
			id.setTypeUsingReflection( entity.getClassName(), propertyName );

/entity=RootClass inst	, corresp. met <class ...> in <hibernate-mapping ...>	,

entity	RootClass  (id=454)	
	className	"my.test.own.hibernate_collections_xml.Employee" (id=494)	
/s
SimpleValue.setTypeUsingReflection(String, String) line: 362	
			typeName = ReflectHelper.reflectedPropertyClass( className, propertyName ).getName();
/s
ReflectHelper.reflectedPropertyClass(String, String) line: 229	

className	"my.test.own.hibernate_collections_xml.Employee" (id=494)	
name	"id" (id=1084)	
/ TODO (Afmaken)

/t
HbmBinder.bindSimpleId(Element, RootClass, Mappings, Map) line: 457	
			id.setTypeUsingReflection( entity.getClassName(), propertyName );
/ D
id	SimpleValue  (id=1088)	
	typeName	"long" (id=1543)	


		if ( propertyName != null ) {
/ propertyName="id"	, klopt	,
			Property prop = new Property();
			prop.setValue( id );
			bindProperty( idNode, prop, mappings, inheritedMetas );
/s
HbmBinder.bindProperty(Element, Property, Mappings, Map) line: 1278	

		String propName = node.attributeValue( "name" );
id
		property.setName( propName );
		String nodeName = node.attributeValue( "node" );
null
		if (nodeName==null) nodeName = propName;
		property.setNodeName( nodeName );

		Attribute accessNode = node.attribute( "access" );
null
		if ( accessNode != null ) {
			property.setPropertyAccessorName( accessNode.getValue() );
		}
		else if ( node.getName().equals( "properties" ) ) {
			property.setPropertyAccessorName( "embedded" );
		}
		else {
			property.setPropertyAccessorName( mappings.getDefaultAccess() );
property	Property  (id=1586)	
	propertyAccessorName	"property" (id=252)	

		Attribute cascadeNode = node.attribute( "cascade" );
null
		property.setCascade( cascadeNode == null ? mappings.getDefaultCascade() : cascadeNode
			.getValue() );

property	Property  (id=1586)	
	cascade	"none" (id=253)	

		Attribute updateNode = node.attribute( "update" );
null
		property.setUpdateable( updateNode == null || "true".equals( updateNode.getValue() ) );

property	Property  (id=1586)	
updateable	true	
/ was AL	,

		Attribute insertNode = node.attribute( "insert" );
null
		property.setInsertable( insertNode == null || "true".equals( insertNode.getValue() ) );

property	Property  (id=1586)	
inserteable	true	
/ was AL	,

		Attribute lockNode = node.attribute( "optimistic-lock" );
null
		property.setOptimisticLocked( lockNode == null || "true".equals( lockNode.getValue() ) );

property	Property  (id=1586)	
optimisticLocked	true	
/ was AL	,

		Attribute generatedNode = node.attribute( "generated" );
null
        	String generationName = generatedNode == null ? null : generatedNode.getValue();
null
		GenerationTiming generationTiming = GenerationTiming.parseFromName( generationName );
NEVER
		if ( generationTiming == GenerationTiming.ALWAYS || generationTiming == GenerationTiming.INSERT ) {
/ NEE

		boolean isLazyable = "property".equals( node.getName() ) ||
				"component".equals( node.getName() ) ||
				"many-to-one".equals( node.getName() ) ||
				"one-to-one".equals( node.getName() ) ||
				"any".equals( node.getName() );
false
/ straks node.getName()=="property", en dan true	,

		if ( isLazyable ) {
/ NEE

		property.setMetaAttributes( getMetas( node, inheritedMetas ) );
/ inheritedMetas={}
/s
		return getMetas( node, inheritedMeta, false );
/s
HbmBinder.getMetas(Element, Map, boolean) line: 3003	
/ returns {}

/t
		property.setMetaAttributes( getMetas( node, inheritedMetas ) );
/ D
property	Property  (id=1586)	
	metaAttributes	HashMap<K,V>  (id=1632)	
{}
/ was null	,

/t
HbmBinder.bindSimpleId(Element, RootClass, Mappings, Map) line: 460	
			bindProperty( idNode, prop, mappings, inheritedMetas );
/ D
idNode	DefaultElement  (id=1035)	, de xml	,
entity	RootClass  (id=454)	

			entity.setIdentifierProperty( prop );
entity	RootClass  (id=454)	
	identifier	SimpleValue  (id=1088)	
/ heeft column, table, ...
	identifierProperty	Property  (id=1586)	
/ heeft cascade, lazy	, ...

			entity.setDeclaredIdentifierProperty( prop );

		makeIdentifier( idNode, id, mappings );
/s
HbmBinder.makeIdentifier(Element, SimpleValue, Mappings) line: 2141	

		Element subnode = node.element( "generator" );
		if ( subnode != null ) {
/ NEE

		model.getTable().setIdentifierValue( model );
/////////////////////////////////
/ Hier set we de id van de table	,

		Attribute nullValueNode = node.attribute( "unsaved-value" );
null
		if ( nullValueNode != null ) {
/ NEE
		else {
			if ( "assigned".equals( model.getIdentifierGeneratorStrategy() ) ) {
/ JA
				model.setNullValue( "undefined" );

/t
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 379	
		while ( subnodes.hasNext() ) {

			Element subnode = (Element) subnodes.next();

subnode	DefaultElement  (id=1752)	
org.dom4j.tree.DefaultElement@2ca817f3 [Element: <property attributes: [
 org.dom4j.tree.DefaultAttribute@4fbc696c [Attribute: name name value "name"]
 org.dom4j.tree.DefaultAttribute@5aad5a59 [Attribute: name column value "name_"]
 org.dom4j.tree.DefaultAttribute@2b06b791 [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@45fda6a8 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@fc8837e [Attribute: name lazy value "false"]
 org.dom4j.tree.DefaultAttribute@3530cd4a [Attribute: name generated value "never"]]/>]
	content	null	

			String name = subnode.getName();
"property"
"many-to-one"
			if ( "id".equals( name ) ) {
/ NEE
			}
			else if ( "composite-id".equals( name ) ) {
/ NEE
			}
			else if ( "version".equals( name ) || "timestamp".equals( name ) ) {
/ NEE
			}
			else if ( "discriminator".equals( name ) ) {
/ NEE
			}
			else if ( "cache".equals( name ) ) {
/ NEE
			}

		// Primary key constraint
		entity.createPrimaryKey();
/s
RootClass(PersistentClass).createPrimaryKey() line: 333	
		PrimaryKey pk = new PrimaryKey();
		Table table = getTable();
		pk.setTable(table);
		pk.setName( PK_ALIAS.toAliasString( table.getName() ) );
employee_PK
		table.setPrimaryKey(pk);

		pk.addColumns( getKey().getColumnIterator() );
/ TODO
pk	PrimaryKey  (id=1803)	
	columns	ArrayList<E>  (id=1805)	
	name	"employeePK" (id=1832)	
	table	Table  (id=994)	

/t
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 411	

		entity.createPrimaryKey();
/ D
		createClassProperties( node, entity, mappings, inheritedMetas );
/s
		createClassProperties(node, persistentClass, mappings, inheritedMetas, null, true, true, false);
/s
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2211	
/=
	protected static void createClassProperties(Element node, PersistentClass persistentClass,
			Mappings mappings, java.util.Map inheritedMetas, UniqueKey uniqueKey,
			boolean mutable, boolean nullable, boolean naturalId) throws MappingException {

uniqueKey=null
mutable=true
nullable=true
naturalId=false

		String entityName = persistentClass.getEntityName();
entityName	"my.test.own.hibernate_collections_xml.Employee" (id=494)	
		Table table = persistentClass.getTable();

/ node	DefaultElement  (id=256)	, =<class ...>

		Iterator iter = node.elementIterator();

/ Voor id doet NIETS,
/ want	,
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
       <id
                name="id"
                column="id_"
        >

			String name = subnode.getName();
id
			String propertyName = subnode.attributeValue( "name" );
id

			CollectionType collectType = CollectionType.collectionTypeFromString( name );
null
/ want id is geen coll	,	
/s
HbmBinder$CollectionType.collectionTypeFromString(String) line: 2970	
/=
		public static CollectionType collectionTypeFromString(String xmlTagName) {
xmlTagName="id"
			return (CollectionType) INSTANCES.get( xmlTagName );
INSTANCES=
{primitive-array=primitive-array, set=set, bag=bag, map=map, list=list, idbag=idbag, array=array}

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2221	

			Value value = null;
			if ( collectType != null ) {
/ NEE
			else if ( "many-to-one".equals( name ) ) {
/ NEE
			else if ( "any".equals( name ) ) {
/ NEE
			else if ( "one-to-one".equals( name ) ) {
/ NEE
			else if ( "property".equals( name ) ) {
/ NEE
			else if ( "component".equals( name )
				|| "dynamic-component".equals( name )
				|| "properties".equals( name ) ) {
/ NEE
			else if ( "join".equals( name ) ) {
/ NEE
			else if ( "subclass".equals( name ) ) {
/ NEE
			else if ( "joined-subclass".equals( name ) ) {
/ NEE
			else if ( "union-subclass".equals( name ) ) {
/ NEE
			else if ( "filter".equals( name ) ) {
/ NEE
			else if ( "natural-id".equals( name ) ) {
/ NEE
			else if ( "query".equals(name) ) {
/ NEE
			else if ( "sql-query".equals(name) ) {
/ NEE
			else if ( "resultset".equals(name) ) {
/ NEE
			if ( value != null ) {
/ NEE

/ volgende	,

		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
        <property
                name="name"
                column="name_"
        />
			String name = subnode.getName();
"property"
			String propertyName = subnode.attributeValue( "name" );
"name"

			else if ( "property".equals( name ) ) {
				value = new SimpleValue( mappings, table );
				bindSimpleValue( subnode, (SimpleValue) value, nullable, propertyName, mappings );
/ nullable=true
/s
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1191	
		bindSimpleValueType( node, simpleValue, mappings );
/ doet NIETS	, 
/ want	,
/s
HbmBinder.bindSimpleValueType(Element, SimpleValue, Mappings) line: 1201	
...
/ sets typeName=null	,
		resolveAndBindTypeDef(simpleValue, mappings, typeName, parameters);
/ typeName=null
/s
HbmBinder.resolveAndBindTypeDef(SimpleValue, Mappings, String, Properties) line: 1232	
/=
	private static void resolveAndBindTypeDef(SimpleValue simpleValue,
			Mappings mappings, String typeName, Properties parameters) {
/ typeName=null
/ parameters={}

		TypeDef typeDef = mappings.getTypeDef( typeName );
null
/ doet NIETS	,

/t
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1191	
		bindSimpleValueType( node, simpleValue, mappings );
/ D
		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/s
HbmBinder.bindColumnsOrFormula(Element, SimpleValue, String, boolean, Mappings) line: 1620	
		else {
			bindColumns( node, simpleValue, isNullable, true, path, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1061	
/=
	public static void bindColumns(final Element node, final SimpleValue simpleValue,
			final boolean isNullable, final boolean autoColumn, final String propertyPath,
			final Mappings mappings) throws MappingException {
/ isNullable=true
/ autoColumn =true
/ propertyPath=name

/ simpleValue heeft alleen table (en mappings)	,

		Attribute columnAttribute = node.attribute( "column" );
org.dom4j.tree.DefaultAttribute@5aad5a59 [Attribute: name column value "name_"]

			Column column = new Column();
			column.setValue( simpleValue );
			bindColumn( node, column, isNullable );
/s
HbmBinder.bindColumn(Element, Column, boolean) line: 1783	

		Attribute nullNode = node.attribute( "not-null" );
null
		column.setNullable( nullNode == null ? isNullable : nullNode.getValue().equals( "false" ) );
true

		Attribute unqNode = node.attribute( "unique" );
null
/ in column blijft unique=false


/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1128	
			bindColumn( node, column, isNullable );
/ D
			if ( column.isUnique() && ManyToOne.class.isInstance( simpleValue ) ) {
/ NEE

			String columnName = columnAttribute.getValue();
/ _name
/ want	,
/ columnAttribute is 
	<property
->		column="name_"
	>


			String logicalColumnName = mappings.getNamingStrategy().logicalColumnName(
					columnName, propertyPath
			);
_name
			columnName = mappings.getNamingStrategy().columnName( columnName );
_name
			columnName = quoteIdentifier( columnName, mappings );
_name

			column.setName( columnName );

			if ( table != null ) {
				table.addColumn( column ); // table=null -> an association - fill
table	Table  (id=994)	
	columns	LinkedHashMap<K,V>  (id=997)	
{id_=org.hibernate.mapping.Column(id_), name_=org.hibernate.mapping.Column(name_)}

				mappings.addColumnBinding( logicalColumnName, column, table );

mappings	Configuration$MappingsImpl  (id=178)	
	this$0	Configuration  (id=17)	
		columnNameBindingPerTable	HashMap<K,V>  (id=607)	
			table	HashMap$Entry<K,V>[16]  (id=1327)	
				[6]	HashMap$Entry<K,V>  (id=1331)	
					value	Configuration$MappingsImpl$TableColumnNameBinding  (id=1246)	
						logicalToPhysical	HashMap<K,V>  (id=1247)	
{id_=id_, name_=name_}
						physicalToLogical	HashMap<K,V>  (id=1249)	
{id_=id_, name_=name_}
						tableName	"employee" (id=829)	
						this$1	Configuration$MappingsImpl  (id=178)	

			simpleValue.addColumn( column );

simpleValue	SimpleValue  (id=1930)	
	columns	ArrayList<E>  (id=1932)	
[org.hibernate.mapping.Column(name_)]

/t
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1195	
		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/ D

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2246	

			else if ( "property".equals( name ) ) {
				value = new SimpleValue( mappings, table );
				bindSimpleValue( subnode, (SimpleValue) value, nullable, propertyName, mappings );
			}
/ D

			if ( value != null ) {
/ value=SimpleValue	,
				final Property property = createProperty(
						value,
						propertyName,
"name"
						persistentClass.getClassName(),
my.test.own.hibernate_collections_xml.Employee
						subnode,
org.dom4j.tree.DefaultElement@2ca817f3 [Element: <property attributes: [
 org.dom4j.tree.DefaultAttribute@4fbc696c [Attribute: name name value "name"]
 org.dom4j.tree.DefaultAttribute@5aad5a59 [Attribute: name column value "name_"]
 org.dom4j.tree.DefaultAttribute@2b06b791 [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@45fda6a8 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@fc8837e [Attribute: name lazy value "false"]
 org.dom4j.tree.DefaultAttribute@3530cd4a [Attribute: name generated value "never"]]/>]
						mappings,
						inheritedMetas
				);

/s
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2346	

		value.setTypeUsingReflection( className, propertyName );
"java.lang.String"

		if ( value instanceof ToOne ) {
/ NEE
		else if ( value instanceof Collection ) {
/ NEE

		value.createForeignKey();
/s
	public void createForeignKey() throws MappingException {}

/t

/ we zijn nog steeds in HbmBinder.ccreateProperty	,
		Property prop = new Property();
		prop.setValue( value );
prop	Property  (id=2146)	
	cascade	null	
	insertable	true	
	lazy	false	
	lob	false	
	metaAttributes	null	
	name	null	
	naturalIdentifier	false	
	nodeName	null	
	optimisticLocked	true	
	optional	false	
	persistentClass	null	
	propertyAccessorName	null	
	selectable	true	
	updateable	true	
	value	SimpleValue  (id=1930)	
	valueGenerationStrategy	null	

/ unique is in Column	,

		bindProperty( subnode, prop, mappings, inheritedMetas );
/s
HbmBinder.bindProperty(Element, Property, Mappings, Map) line: 1267	

		String propName = node.attributeValue( "name" );
name
		property.setName( propName );
		String nodeName = node.attributeValue( "node" );
null
		if (nodeName==null) nodeName = propName;
		property.setNodeName( nodeName );
name

		Attribute accessNode = node.attribute( "access" );
null
...
		else {
			property.setPropertyAccessorName( mappings.getDefaultAccess() );
		}
property	Property  (id=2146)	
	propertyAccessorName	"property" (id=252)	

		Attribute cascadeNode = node.attribute( "cascade" );
null
		property.setCascade( cascadeNode == null ? mappings.getDefaultCascade() : cascadeNode
			.getValue() );
"none"

		Attribute updateNode = node.attribute( "update" );
		property.setUpdateable( updateNode == null || "true".equals( updateNode.getValue() ) );
true
/ default
		Attribute insertNode = node.attribute( "insert" );
		property.setInsertable( insertNode == null || "true".equals( insertNode.getValue() ) );
true
/ default

		Attribute lockNode = node.attribute( "optimistic-lock" );
org.dom4j.tree.DefaultAttribute@45fda6a8 [Attribute: name optimistic-lock value "true"]
		property.setOptimisticLocked( lockNode == null || "true".equals( lockNode.getValue() ) );

		Attribute generatedNode = node.attribute( "generated" );
org.dom4j.tree.DefaultAttribute@3530cd4a [Attribute: name generated value "never"]
        	String generationName = generatedNode == null ? null : generatedNode.getValue();
"never"
		GenerationTiming generationTiming = GenerationTiming.parseFromName( generationName );
NEVER=
generationTiming	GenerationTiming$1  (id=1614)	
	name	"NEVER" (id=1617)	
	ordinal	0	

			if ( property.isUpdateable() && generationTiming == GenerationTiming.ALWAYS ) {
/ NEE

		boolean isLazyable = "property".equals( node.getName() ) ||
				"component".equals( node.getName() ) ||
				"many-to-one".equals( node.getName() ) ||
				"one-to-one".equals( node.getName() ) ||
				"any".equals( node.getName() );
true
		if ( isLazyable ) {
			Attribute lazyNode = node.attribute( "lazy" );
org.dom4j.tree.DefaultAttribute@fc8837e [Attribute: name lazy value "false"]
			property.setLazy( lazyNode != null && "true".equals( lazyNode.getValue() ) );
false 
/ de default was ook false

		property.setMetaAttributes( getMetas( node, inheritedMetas ) );
/ NIETS	, 
/ want	,
{}

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2323	
				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
/ D
				if ( !mutable ) {
/ NEE
					property.setUpdateable(false);
/ NIET
				}
				if ( naturalId ) {
/ NEE

				persistentClass.addProperty( property );
/ de 1ste	,
/ zojuist hadden we persistentClass' identifier set	,

				if ( uniqueKey!=null ) {
/ NEE

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2215	

/ volgende	,

		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
        <property
                name="salary"
                column="salary_"
        >
        </property>

/ volgende,	

		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
        <many-to-one
                name="address"
                column="address_"
                not-null="true"
        ></many-to-one>

			String name = subnode.getName();
many-to-one
			String propertyName = subnode.attributeValue( "name" );
address
			CollectionType collectType = CollectionType.collectionTypeFromString( name );
/name="many-to-one"
null

			else if ( "many-to-one".equals( name ) ) {
				value = new ManyToOne( mappings, table );

/ ManyToOne extends ToOne extends SimpleValue	,

/s
ManyToOne.<init>(Mappings, Table) line: 43	
/=
public class ManyToOne extends ToOne {
	public ManyToOne(Mappings mappings, Table table) {
		super( mappings, table );
/s
ManyToOne(ToOne).<init>(Mappings, Table) line: 47	
/=
	protected ToOne(Mappings mappings, Table table) {
		super( mappings, table );
	}
/s
ManyToOne(SimpleValue).<init>(Mappings, Table) line: 89	
/=
	public SimpleValue(Mappings mappings, Table table) {
		this( mappings );
		this.table = table;
	}

/t
ManyToOne(ToOne).<init>(Mappings, Table) line: 47	
	private boolean lazy = true;
	protected boolean referenceToPrimaryKey = true;

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2234	
			else if ( "many-to-one".equals( name ) ) {
				value = new ManyToOne( mappings, table );
/ D
				bindManyToOne( subnode, (ManyToOne) value, propertyName, nullable, mappings );
/s
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1639	
		bindColumnsOrFormula( node, manyToOne, path, isNullable, mappings );
/s
HbmBinder.bindColumnsOrFormula(Element, SimpleValue, String, boolean, Mappings) line: 1620	
		else {
			bindColumns( node, simpleValue, isNullable, true, path, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1061	

		Table table = simpleValue.getTable();
/ see ctor	, is er	,
			Column column = new Column();
			column.setValue( simpleValue );
			bindColumn( node, column, isNullable );
/s
HbmBinder.bindColumn(Element, Column, boolean) line: 1783	

		Attribute nullNode = node.attribute( "not-null" );
org.dom4j.tree.DefaultAttribute@719fe652 [Attribute: name not-null value "true"]
		column.setNullable( nullNode == null ? isNullable : nullNode.getValue().equals( "false" ) );
false

		Attribute unqNode = node.attribute( "unique" );
org.dom4j.tree.DefaultAttribute@38ca4bc5 [Attribute: name unique value "false"]
		if ( unqNode != null ) column.setUnique( unqNode.getValue().equals( "true" ) );
false

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1128	

			if ( column.isUnique() && ManyToOne.class.isInstance( simpleValue ) ) {
/ NEE
				( (ManyToOne) simpleValue ).markAsLogicalOneToOne();
/ NIET

			String columnName = columnAttribute.getValue();
/ columnAttribute=
org.dom4j.tree.DefaultAttribute@5e026e6d [Attribute: name column value "address_"]

			String columnName = columnAttribute.getValue();
			String logicalColumnName = mappings.getNamingStrategy().logicalColumnName(
					columnName, propertyPath
			);
			columnName = mappings.getNamingStrategy().columnName( columnName );
			columnName = quoteIdentifier( columnName, mappings );
address_
			column.setName( columnName );

			if ( table != null ) {
				table.addColumn( column ); // table=null -> an association - fill
				                           // it in later
				//TODO fill in the mappings for table == null
				mappings.addColumnBinding( logicalColumnName, column, table );

mappings	Configuration$MappingsImpl  (id=178)	
	this$0	Configuration  (id=17)	
		columnNameBindingPerTable	HashMap<K,V>  (id=607)	
			table	HashMap$Entry<K,V>[16]  (id=1327)	
				[6]	HashMap$Entry<K,V>  (id=1331)	
						logicalToPhysical	HashMap<K,V>  (id=1247)	
{salary_=salary_, address_=address_, id_=id_, name_=name_}
						physicalToLogical	HashMap<K,V>  (id=1249)	
{salary_=salary_, address_=address_, id_=id_, name_=name_}
						tableName	"employee" (id=829)	
						this$1	Configuration$MappingsImpl  (id=178)	

			simpleValue.addColumn( column );

		if ( autoColumn && simpleValue.getColumnSpan() == 0 ) {
/ NEE

/t
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1640	
		bindColumnsOrFormula( node, manyToOne, path, isNullable, mappings );
/ D
		initOuterJoinFetchSetting( node, manyToOne );
/s
HbmBinder.initOuterJoinFetchSetting(Element, Fetchable) line: 2073	

		Attribute fetchNode = node.attribute( "fetch" );
null
		boolean lazy = true;
		if ( fetchNode == null ) {
			Attribute jfNode = node.attribute( "outer-join" );
			if ( jfNode == null ) {
				if ( "many-to-many".equals( node.getName() ) ) {
/ NEE
				else if ( "one-to-one".equals( node.getName() ) ) {
/ NEE
				else {
					fetchStyle = FetchMode.DEFAULT;

model	ManyToOne  (id=2323)	
		model.setFetchMode( fetchStyle );
DEFAULT
		model.setLazy(lazy);
true

/t
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1641	
		initOuterJoinFetchSetting( node, manyToOne );
/ D
		initLaziness( node, manyToOne, mappings, true );
HbmBinder.initLaziness(Element, ToOne, Mappings, boolean) line: 1608	

		if ( "no-proxy".equals( node.attributeValue( "lazy" ) ) ) {
/ NEE
		else {
			initLaziness( node, fetchable, mappings, "proxy", defaultLazy );
/s
HbmBinder.initLaziness(Element, Fetchable, Mappings, String, boolean) line: 1595	
/=
	private static void initLaziness(
			Element node,
			Fetchable fetchable,
			Mappings mappings,
			String proxyVal,
			boolean defaultLazy

/ fetchable is de ManyToOne	, 
/ de hierarchy 	is	,
Fetchable
	Collection
		Bag
		IdentifierCollection
			IdentifierBag
		IdexedCollection
			List
		Set
	ToOne
		ManyToOne
		OneToOne



		Attribute lazyNode = node.attribute( "lazy" );
null
		boolean isLazyTrue = lazyNode == null ?
				defaultLazy && fetchable.isLazy() : //fetch="join" overrides default laziness
true

		fetchable.setLazy( isLazyTrue );
fetchable	ManyToOne  (id=2323)	
	lazy	true	

/s
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1643	
		initLaziness( node, manyToOne, mappings, true );
/ D

		Attribute ukName = node.attribute( "property-ref" );
null

/ Lees	,
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch05.html#mapping-declaration
property-ref (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used.

		if ( ukName != null ) {
/ NEE
			manyToOne.setReferencedPropertyName( ukName.getValue() );
/ NIET

		manyToOne.setReferenceToPrimaryKey( manyToOne.getReferencedPropertyName() == null );
/ manyToOne.getReferencedPropertyName() == null ==true

		manyToOne.setReferencedEntityName( getEntityName( node, mappings ) );
/s
HbmBinder.getEntityName(Element, Mappings) line: 3033	
		String entityName = elem.attributeValue( "entity-name" );
null
		return entityName == null ? getClassName( elem.attribute( "class" ), model ) : entityName;
/ elem=org.dom4j.tree.DefaultElement@20f140d0 [Element: <many-to-one attributes: [
 org.dom4j.tree.DefaultAttribute@3ed62895 [Attribute: name name value "address"]
 org.dom4j.tree.DefaultAttribute@5e026e6d [Attribute: name column value "address_"]
 org.dom4j.tree.DefaultAttribute@719fe652 [Attribute: name not-null value "true"]
 org.dom4j.tree.DefaultAttribute@38ca4bc5 [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@69348fa3 [Attribute: name update value "true"]
 org.dom4j.tree.DefaultAttribute@79c24c4a [Attribute: name insert value "true"]
 org.dom4j.tree.DefaultAttribute@431eccb9 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@1b12a81c [Attribute: name not-found value "exception"]
 org.dom4j.tree.DefaultAttribute@65dad426 [Attribute: name embed-xml value "true"]]/>]
/ model	Configuration$MappingsImpl  (id=178)	

/ getClassName( elem.attribute( "class" ), model )==null

/t
/s
	public void setReferencedEntityName(String referencedEntityName) {
/ referencedEntityName==null
		this.referencedEntityName = referencedEntityName==null ? 
				null : referencedEntityName.intern();
	}
/ set met null	,

/t
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1651	
		manyToOne.setReferencedEntityName( getEntityName( node, mappings ) );
/ D
		String embed = node.attributeValue( "embed-xml" );
true

/ node= org.dom4j.tree.DefaultElement@20f140d0 [Element: <many-to-one attributes: [
 org.dom4j.tree.DefaultAttribute@3ed62895 [Attribute: name name value "address"]
 org.dom4j.tree.DefaultAttribute@5e026e6d [Attribute: name column value "address_"]
 org.dom4j.tree.DefaultAttribute@719fe652 [Attribute: name not-null value "true"]
 org.dom4j.tree.DefaultAttribute@38ca4bc5 [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@69348fa3 [Attribute: name update value "true"]
 org.dom4j.tree.DefaultAttribute@79c24c4a [Attribute: name insert value "true"]
 org.dom4j.tree.DefaultAttribute@431eccb9 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@1b12a81c [Attribute: name not-found value "exception"]
 org.dom4j.tree.DefaultAttribute@65dad426 [Attribute: name embed-xml value "true"]]/>]

		manyToOne.setEmbedded( embed == null || "true".equals( embed ) );
true

		manyToOne.setIgnoreNotFound( "ignore".equals( notFound ) );
false
/ hij moet exception geven bij not-found	,

		if( ukName != null && !manyToOne.isIgnoreNotFound() ) {
/ NEE

		Attribute fkNode = node.attribute( "foreign-key" );
null
		if ( fkNode != null ) manyToOne.setForeignKeyName( fkNode.getValue() );
/ NEE

		String cascade = node.attributeValue( "cascade" );
null
		if ( cascade != null && cascade.indexOf( "delete-orphan" ) >= 0 ) {
/ NEE

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2314	
			else if ( "many-to-one".equals( name ) ) {
				value = new ManyToOne( mappings, table );
				bindManyToOne( subnode, (ManyToOne) value, propertyName, nullable, mappings );
			}
/ D

			if ( value != null ) {
value	ManyToOne  (id=2323)	
				final Property property = createProperty(
						value,
						propertyName,
address
						persistentClass.getClassName(),
persistenClass=RootClass
className	"my.test.own.hibernate_collections_xml.Employee" (id=494)	

						subnode,
org.dom4j.tree.DefaultElement@20f140d0 [Element: <many-to-one attributes: [org.dom4j.tree.DefaultAttribute@3ed62895 [Attribute: name name value "address"], org.dom4j.tree.DefaultAttribute@5e026e6d [Attribute: name column value "address_"], org.dom4j.tree.DefaultAttribute@719fe652 [Attribute: name not-null value "true"], org.dom4j.tree.DefaultAttribute@38ca4bc5 [Attribute: name unique value "false"], org.dom4j.tree.DefaultAttribute@69348fa3 [Attribute: name update value "true"], org.dom4j.tree.DefaultAttribute@79c24c4a [Attribute: name insert value "true"], org.dom4j.tree.DefaultAttribute@431eccb9 [Attribute: name optimistic-lock value "true"], org.dom4j.tree.DefaultAttribute@1b12a81c [Attribute: name not-found value "exception"], org.dom4j.tree.DefaultAttribute@65dad426 [Attribute: name embed-xml value "true"]]/>]
						mappings,
						inheritedMetas
				);
/s
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2346	

		value.setTypeUsingReflection( className, propertyName );
propertyName="address"
/s
ManyToOne(ToOne).setTypeUsingReflection(String, String) line: 80	
		if (referencedEntityName==null) {
/ JA
			referencedEntityName = ReflectHelper.reflectedPropertyClass( className, propertyName ).getName();
this	ManyToOne  (id=2323)	
	referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2642)	
/ want	,
...
/s
			return method.getReturnType();
class my.test.own.hibernate_collections_xml.Address

/t
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2354	
		value.setTypeUsingReflection( className, propertyName );
value	ManyToOne  (id=2323)	
	referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2642)	

		if ( value instanceof ToOne ) {
			ToOne toOne = (ToOne) value;
			String propertyRef = toOne.getReferencedPropertyName();
null
			if ( propertyRef != null ) {
/ NEE
				mappings.addUniquePropertyReference( toOne.getReferencedEntityName(), propertyRef );
/ NIET
			}
			toOne.setCascadeDeleteEnabled( "cascade".equals( subnode.attributeValue( "on-delete" ) ) );
false
/ was AL	,

		value.createForeignKey();
/s
ManyToOne.createForeignKey() line: 60	
		if (referencedPropertyName==null && !hasFormula() ) {
/ JA
			createForeignKeyOfEntity( ( (EntityType) getType() ).getAssociatedEntityName() );
/s
ManyToOne.getType() line: 47	
		return getMappings().getTypeResolver().getTypeFactory().manyToOne(
				getReferencedEntityName(),
				referenceToPrimaryKey, 
				getReferencedPropertyName(),
				isLazy(),
				isUnwrapProxy(),
				isIgnoreNotFound(),
				isLogicalOneToOne
		);
/s
ManyToOne(SimpleValue).getMappings() line: 94	
		return mappings;
mappings	Configuration$MappingsImpl  (id=178)	
/t
/s
Configuration$MappingsImpl.getTypeResolver() line: 2810	
			return typeResolver;
/t
/s
TypeResolver.getTypeFactory() line: 72	
		return typeFactory;
/t
/s
	public String getReferencedEntityName() {
		return referencedEntityName;
this	ManyToOne  (id=2323)	
	referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2642)	
/t
/s
ManyToOne(ToOne).getReferencedPropertyName() line: 62	
		return referencedPropertyName;
this	ManyToOne  (id=2323)	
	referencedPropertyName	null	
/t
/s
ManyToOne.createForeignKey() line: 61	
			createForeignKeyOfEntity( ( (EntityType) getType() ).getAssociatedEntityName() );
/s
ManyToOneType(EntityType).getAssociatedEntityName() line: 241	
this	ManyToOneType  (id=2691)	
	associatedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2642)	
/t
/s
ManyToOne(SimpleValue).createForeignKeyOfEntity(String) line: 146	
		if ( !hasFormula() && !"none".equals(getForeignKeyName())) {
/ JA
/ want	,
this	ManyToOne  (id=2323)	
	foreignKeyName	null	
			ForeignKey fk = table.createForeignKey( getForeignKeyName(), getConstraintColumns(), entityName );
/s
ManyToOne(SimpleValue).getForeignKeyName() line: 277	
		return foreignKeyName;
null
/t
/s
ManyToOne(SimpleValue).getConstraintColumns() line: 131	
		return columns;
[org.hibernate.mapping.Column(address_)]
/t
/s
Table.createForeignKey(String, List, String) line: 651	

		return createForeignKey( keyName, keyColumns, referencedEntityName, null );
keyName=null
keyColumns	ArrayList<E>  (id=105)	
	elementData	Object[10]  (id=114)	
		[0]	Column  (id=119)	
			name	"address_" (id=123)	
			value	ManyToOne  (id=61)	

referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2642)	
/s
Table.createForeignKey(String, List, String, List) line: 656	

/ we zijn in	,

/ STACK
Thread [main] (Suspended)	
	Table.createForeignKey(String, List, String, List) line: 661	
	Table.createForeignKey(String, List, String) line: 651	
	ManyToOne(SimpleValue).createForeignKeyOfEntity(String) line: 147	
	ManyToOne.createForeignKey() line: 61	
	HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2371	
	HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2315	
	HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map) line: 2204	
	HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 411	
	HbmBinder.bindRootClass(Element, RootClass, Mappings, Map) line: 326	
	HbmBinder.bindRoot(XmlDocument, Mappings, Map, Set<String>) line: 177	
	Configuration$MetadataSourceQueue.processHbmXml(XmlDocument, Set<String>) line: 3759	
	Configuration$MetadataSourceQueue.processHbmXmlQueue() line: 3751	
	Configuration$MetadataSourceQueue.processMetadata(List<MetadataSourceType>) line: 3739	
	Configuration.secondPassCompile() line: 1410	
	Configuration.buildSessionFactory(ServiceRegistry) line: 1844	
	Main.setUp() line: 71	
	Main.<init>() line: 59	
	Main.main(String[]) line: 54	

		Object key = new ForeignKeyKey( keyColumns, referencedEntityName, referencedColumns );
/ s
			this.referencedClassName = referencedClassName;
			this.columns = new ArrayList();
			this.columns.addAll( columns );
			if ( referencedColumns != null ) {
/ NEE
			else {
				this.referencedColumns = Collections.EMPTY_LIST;
/ fk is naar id, niet naar een bepaalde column(s)	,
/t
Table.createForeignKey(String, List, String, List) line: 661	

		Object key = new ForeignKeyKey( keyColumns, referencedEntityName, referencedColumns );
/ D

		ForeignKey fk = (ForeignKey) foreignKeys.get( key );
null
		if ( fk == null ) {
/ JA
			fk.setTable( this );
/ this=org.hibernate.mapping.Table(employee)
			fk.setReferencedEntityName( referencedEntityName );
referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2642)	
			fk.addColumns( keyColumns.iterator() );
[org.hibernate.mapping.Column(address_)]
			if ( referencedColumns != null ) {
/ NEE
			if ( keyName != null ) {
/ NEE
			else {
				fk.setName( Constraint.generateName( fk.generatedConstraintNamePrefix(),this, keyColumns ) );
/s
/ fk.generatedConstraintNamePrefix()="FK_"
/ this=org.hibernate.mapping.Table(employee)
/ keyColumns=[org.hibernate.mapping.Column(address_)]
/s
Constraint.generateName(String, Table, List<Column>) line: 101	
		return generateName( prefix, table, columns.toArray( new Column[columns.size()] ) );
/s
ForeignKey.generatedConstraintNamePrefix() line: 192	
		return "FK_";
/t
/s
Constraint.generateName(String, Table, List<Column>) line: 101	
		return generateName( prefix, table, columns.toArray( new Column[columns.size()] ) );
/s
ArrayList<E>.toArray(T[]) line: 393	
    public <T> T[] toArray(T[] a) {
        System.arraycopy(elementData, 0, a, 0, size);
        return a;
/t
/s
Constraint.generateName(String, Table, Column...) line: 76	
/=
	public static String generateName(String prefix, Table table, Column... columns) {
		StringBuilder sb = new StringBuilder( "table`" + table.getName() + "`" );
table`employee`
		Column[] alphabeticalColumns = columns.clone();
		Arrays.sort( alphabeticalColumns, ColumnComparator.INSTANCE );
[org.hibernate.mapping.Column(address_)]
		for ( Column column : alphabeticalColumns ) {
			String columnName = column == null ? "" : column.getName();
			sb.append( "column`" + columnName + "`" );
		}
/ sb=table`employee`column`address_`
		return prefix + hashedName( sb.toString() );
/t
/s
ForeignKey(Constraint).setName(String) line: 57	
		this.name = name;
name	"FK_lcwyx1va36145pv0w7f8dxqc8" (id=2856)	

/t
Table.createForeignKey(String, List, String, List) line: 676	

				fk.setName( Constraint.generateName( fk.generatedConstraintNamePrefix(),
						this, keyColumns ) );
fk	ForeignKey  (id=2732)	
	cascadeDeleteEnabled	false	
	columns	ArrayList<E>  (id=105)	
		elementData	Object[10]  (id=114)	
			[0]	Column  (id=119)	
				name	"address_" (id=123)	
				value	ManyToOne  (id=61)	
					fetchMode	FetchMode  (id=127)	
					referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=100)	
					table	Table  (id=60) employee	
	name	"FK_lcwyx1va36145pv0w7f8dxqc8" (id=2788)	
	referencedColumns	ArrayList<E>  (id=2743)	

	referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2642)	
	referencedTable	null	
	table	Table  (id=994)	
org.hibernate.mapping.ForeignKey(employee[org.hibernate.mapping.Column(address_)]) as FK_lcwyx1va36145pv0w7f8dxqc8
false
[org.hibernate.mapping.Column(address_)]
FK_lcwyx1va36145pv0w7f8dxqc8
[]
my.test.own.hibernate_collections_xml.Address
null
org.hibernate.mapping.Table(employee)

			foreignKeys.put( key, fk );
this	Table  (id=994)	
	foreignKeys	LinkedHashMap<K,V>  (id=998)	
{org.hibernate.mapping.Table$ForeignKeyKey@b75be30b=org.hibernate.mapping.ForeignKey(employee[org.hibernate.mapping.Column(address_)]) as FK_lcwyx1va36145pv0w7f8dxqc8}
		return fk;

/t
ManyToOne(SimpleValue).createForeignKeyOfEntity(String) line: 148	
			ForeignKey fk = table.createForeignKey( getForeignKeyName(), getConstraintColumns(), entityName );
/ D
			fk.setCascadeDeleteEnabled(cascadeDeleteEnabled);
false

/t
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2372	
		value.createForeignKey();
/ D
		Property prop = new Property();
		prop.setValue( value );
value	ManyToOne  (id=2323)	

		bindProperty( subnode, prop, mappings, inheritedMetas );
/s
HbmBinder.bindProperty(Element, Property, Mappings, Map) line: 1267	

		String propName = node.attributeValue( "name" );
address
		property.setName( propName );
		String nodeName = node.attributeValue( "node" );
null
		if (nodeName==null) nodeName = propName;
		property.setNodeName( nodeName );

		Attribute accessNode = node.attribute( "access" );
		else {
			property.setPropertyAccessorName( mappings.getDefaultAccess() );
"property"	,

property	Property  (id=2866)	
	cascade	null	
	insertable	true	
	lazy	false	
	lob	false	
	metaAttributes	null	
	name	"address" (id=2869)	
	naturalIdentifier	false	
	nodeName	"address" (id=2319)	
	optimisticLocked	true	
	optional	false	
	persistentClass	null	
	propertyAccessorName	"property" (id=252)	
	selectable	true	
	updateable	true	
	value	ManyToOne  (id=2323)	
	valueGenerationStrategy	null	

		Attribute cascadeNode = node.attribute( "cascade" );
		property.setCascade( cascadeNode == null ? mappings.getDefaultCascade() : cascadeNode .getValue() );
"none"

		Attribute updateNode = node.attribute( "update" );
		property.setUpdateable( updateNode == null || "true".equals( updateNode.getValue() ) );
/ insertable=true

		Attribute insertNode = node.attribute( "insert" );
		property.setInsertable( insertNode == null || "true".equals( insertNode.getValue() ) );
/ updateable=true

		Attribute lockNode = node.attribute( "optimistic-lock" );
		property.setOptimisticLocked( lockNode == null || "true".equals( lockNode.getValue() ) );
/ optimisticLocked=true

		Attribute generatedNode = node.attribute( "generated" );
null
        String generationName = generatedNode == null ? null : generatedNode.getValue();
null
...

		boolean isLazyable = "property".equals( node.getName() ) ||
				"component".equals( node.getName() ) ||
				"many-to-one".equals( node.getName() ) ||
				"one-to-one".equals( node.getName() ) ||
				"any".equals( node.getName() );
true
		if ( isLazyable ) {
			Attribute lazyNode = node.attribute( "lazy" );
null
			property.setLazy( lazyNode != null && "true".equals( lazyNode.getValue() ) );
false
/ was AL

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2323	
			if ( value != null ) {
				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
/ D
				persistentClass.addProperty( property );
				if ( uniqueKey!=null ) {
false

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2215	

/ volgende	,
		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
/ Geen volgende	,

/t
HbmBinder.bindRoot(XmlDocument, Mappings, Map, Set<String>) line: 178	
			else if ( "class".equals( elementName ) ) {
				RootClass rootclass = new RootClass();
				bindRootClass( element, rootclass, mappings, inheritedMetas );
/ D
				mappings.addClass( rootclass );

/ volgende	,
		Iterator rootChildren = hibernateMappingElement.elementIterator();
		while ( rootChildren.hasNext() ) {
/ Geen	,

/t
Configuration$MetadataSourceQueue.processHbmXml(XmlDocument, Set<String>) line: 3769	

				HbmBinder.bindRoot( metadataXml, createMappings(), Collections.EMPTY_MAP, entityNames );
/ D

/t
Configuration$MetadataSourceQueue.processHbmXmlQueue() line: 3749	

this	Configuration$MetadataSourceQueue  (id=44)	
	hbmMetadataToEntityNamesMap	LinkedHashMap<K,V>  (id=57)	
{org.hibernate.internal.util.xml.XmlDocumentImpl@58d38ce8=[my.test.own.hibernate_collections_xml.Employee]
 org.hibernate.internal.util.xml.XmlDocumentImpl@793f044c=[my.test.own.hibernate_collections_xml.Address]}

/ volgende	,
			for ( Map.Entry<XmlDocument, Set<String>> entry : hbmMetadataToEntityNamesMap.entrySet() ) {
				// Unfortunately we have to create a Mappings instance for each iteration here
				processHbmXml( entry.getKey(), entry.getValue() );
/s
Configuration$MetadataSourceQueue.processHbmXml(XmlDocument, Set<String>) line: 3759	
metadataXml	XmlDocumentImpl  (id=2939)	
entityNames	HashSet<E>  (id=2940)	
[my.test.own.hibernate_collections_xml.Address]

			HbmBinder.bindRoot( metadataXml, createMappings(), Collections.EMPTY_MAP, entityNames );
/s
	public Mappings createMappings() {
		return new MappingsImpl();

/ een mappings is per xml 	,
/t
/s
HbmBinder.bindRoot(XmlDocument, Mappings, Map, Set<String>) line: 140	

		final Document doc = metadataXml.getDocumentTree();
org.dom4j.tree.DefaultDocument@334e9cde [Document: name null]
		final Element hibernateMappingElement = doc.getRootElement();
org.dom4j.tree.DefaultElement@66be558a [Element: <hibernate-mapping attributes: [
 org.dom4j.tree.DefaultAttribute@59e20bb8 [Attribute: name package value "my.test.own.hibernate_collections_xml"]
 org.dom4j.tree.DefaultAttribute@76f8b22 [Attribute: name default-cascade value "none"]
 org.dom4j.tree.DefaultAttribute@2c1768fe [Attribute: name default-access value "property"]
 org.dom4j.tree.DefaultAttribute@34ee124f [Attribute: name default-lazy value "true"]
 org.dom4j.tree.DefaultAttribute@79f41bae [Attribute: name auto-import value "true"]]/>]

mappings	Configuration$MappingsImpl  (id=1949)	
	autoImport	false	
	catalogName	null	
	defaultAccess	null	
	defaultCascade	null	
	defaultLazy	false	
	defaultPackage	"my.test.own.hibernate_collections_xml" (id=1972)	
	forceDiscriminatorInSelectsByDefault	null	
	ignoreExplicitDiscriminatorColumnForJoinedInheritance	null	
	implicitDiscriminatorColumnForJoinedInheritance	null	
	schemaName	null	
	this$0	Configuration  (id=17)	
	useNationalizedCharacterData	null	
	useNewGeneratorMappings	null	
/ zojuist created	,

		extractRootAttributes( hibernateMappingElement, mappings );
/s
HbmBinder.extractRootAttributes(Element, Mappings) line: 311	

		Attribute schemaNode = hmNode.attribute( "schema" );
null
		mappings.setSchemaName( ( schemaNode == null ) ? null : schemaNode.getValue() );

		Attribute catalogNode = hmNode.attribute( "catalog" );
null
		mappings.setCatalogName( ( catalogNode == null ) ? null : catalogNode.getValue() );

		Attribute dcNode = hmNode.attribute( "default-cascade" );
org.dom4j.tree.DefaultAttribute@76f8b22 [Attribute: name default-cascade value "none"]
		mappings.setDefaultCascade( ( dcNode == null ) ? "none" : dcNode.getValue() );

		Attribute daNode = hmNode.attribute( "default-access" );
org.dom4j.tree.DefaultAttribute@2c1768fe [Attribute: name default-access value "property"]
		mappings.setDefaultAccess( ( daNode == null ) ? "property" : daNode.getValue() );

		Attribute dlNode = hmNode.attribute( "default-lazy" );
org.dom4j.tree.DefaultAttribute@34ee124f [Attribute: name default-lazy value "true"]
		mappings.setDefaultLazy( dlNode == null || dlNode.getValue().equals( "true" ) );

		Attribute aiNode = hmNode.attribute( "auto-import" );
org.dom4j.tree.DefaultAttribute@79f41bae [Attribute: name auto-import value "true"]
		mappings.setAutoImport( ( aiNode == null ) || "true".equals( aiNode.getValue() ) );

		Attribute packNode = hmNode.attribute( "package" );
org.dom4j.tree.DefaultAttribute@59e20bb8 [Attribute: name package value "my.test.own.hibernate_collections_xml"]
		if ( packNode != null ) mappings.setDefaultPackage( packNode.getValue() );

/t
HbmBinder.bindRoot(XmlDocument, Mappings, Map, Set<String>) line: 176	
		extractRootAttributes( hibernateMappingElement, mappings );
/ D
		Iterator rootChildren = hibernateMappingElement.elementIterator();
		while ( rootChildren.hasNext() ) {
			final Element element = (Element) rootChildren.next();
org.dom4j.tree.DefaultElement@ff5c8d2 [Element: <class attributes: [
 org.dom4j.tree.DefaultAttribute@51535b2d [Attribute: name name value "Address"]
 org.dom4j.tree.DefaultAttribute@37871111 [Attribute: name table value "address"]
 org.dom4j.tree.DefaultAttribute@4718f92 [Attribute: name mutable value "true"]
 org.dom4j.tree.DefaultAttribute@3b88bc85 [Attribute: name polymorphism value "implicit"]
 org.dom4j.tree.DefaultAttribute@e10de4c [Attribute: name dynamic-update value "false"]
 org.dom4j.tree.DefaultAttribute@757256ca [Attribute: name dynamic-insert value "false"]
 org.dom4j.tree.DefaultAttribute@25a02403 [Attribute: name select-before-update value "false"]
 org.dom4j.tree.DefaultAttribute@349c5441 [Attribute: name optimistic-lock value "version"]]/>]
			final String elementName = element.getName();
class
				RootClass rootclass = new RootClass();
				bindRootClass( element, rootclass, mappings, inheritedMetas );
/s
HbmBinder.bindRootClass(Element, RootClass, Mappings, Map) line: 324	
		bindClass( node, rootClass, mappings, inheritedMetas );
/s
HbmBinder.bindClass(Element, PersistentClass, Mappings, Map) line: 569	
		Attribute lazyNode = node.attribute( "lazy" );
null
		boolean lazy = lazyNode == null ?
				mappings.isDefaultLazy() :
true
				"true".equals( lazyNode.getValue() );
		// go ahead and set the lazy here, since pojo.proxy can override it.
		persistentClass.setLazy( lazy );
/ RootClass inst,

		String entityName = node.attributeValue( "entity-name" );
null
		if ( entityName == null ) entityName = getClassName( node.attribute("name"), mappings );
entityName	"my.test.own.hibernate_collections_xml.Address" (id=1993)	
/ node.attribute("name")="Address", 
/ uses  WH
mappings.defaultPackage	"my.test.own.hibernate_collections_xml" (id=1991)	

		persistentClass.setEntityName( entityName );
		persistentClass.setJpaEntityName( StringHelper.unqualify( entityName ) );

...
		bindPersistentClassCommonValues( node, persistentClass, mappings, inheritedMetas );

/t
HbmBinder.bindClass(Element, PersistentClass, Mappings, Map) line: 569	
		bindClass( node, rootClass, mappings, inheritedMetas );
/ D
...
		bindRootPersistentClassCommonValues( node, inheritedMetas, mappings, rootClass );
/s
///////////////////////////////
/ Belangrijke method	,
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 343	

		Table table = mappings.addTable(
				schema,
				catalog,
				getClassTableName( entity, node, schema, catalog, null, mappings ),
				getSubselect( node ),
		        	entity.isAbstract() != null && entity.isAbstract()
			);

		entity.setTable( table );
/ entity is RootClass inst	,

		Iterator subnodes = node.elementIterator();
		while ( subnodes.hasNext() ) {

			Element subnode = (Element) subnodes.next();
			String name = subnode.getName();

			if ( "id".equals( name ) ) {
				// ID
				bindSimpleId( subnode, entity, mappings, inheritedMetas );
/s
HbmBinder.bindSimpleId(Element, RootClass, Mappings, Map) line: 416	
		SimpleValue id = new SimpleValue( mappings, entity.getTable() );
		entity.setIdentifier( id );

		else {
			bindSimpleValue( idNode, id, false, propertyName, mappings );
/ false is isNullable beneden	,
/s
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1193	
		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/s
HbmBinder.bindColumnsOrFormula(Element, SimpleValue, String, boolean, Mappings) line: 1627	
		else {
			bindColumns( node, simpleValue, isNullable, true, path, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1127	

		Table table = simpleValue.getTable();
		Attribute columnAttribute = node.attribute( "column" );
		else {
			Column column = new Column();
			column.setValue( simpleValue );
			bindColumn( node, column, isNullable );
/s
HbmBinder.bindColumn(Element, Column, boolean) line: 1783	

		Attribute nullNode = node.attribute( "not-null" );
null
		column.setNullable( nullNode == null ? isNullable : nullNode.getValue().equals( "false" ) );
isNullable=false

		Attribute unqNode = node.attribute( "unique" );
null
/ column.unique=false blijft	,

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1127	
                        bindColumn( node, column, isNullable );
/ D
			String columnName = columnAttribute.getValue();
...
			column.setName( columnName );
			if ( table != null ) {
				table.addColumn( column ); // table=null -> an association - fill
...
			}
			simpleValue.addColumn( column );

/t
HbmBinder.bindSimpleId(Element, RootClass, Mappings, Map) line: 453	
		else {
			bindSimpleValue( idNode, id, false, propertyName, mappings );
/ D
		else {
			id.setTypeUsingReflection( entity.getClassName(), propertyName );
long (Java type)

		if ( propertyName != null ) {
			Property prop = new Property();
			prop.setValue( id );
			bindProperty( idNode, prop, mappings, inheritedMetas );
/ attrs van <id ...>
			entity.setIdentifierProperty( prop );
			entity.setDeclaredIdentifierProperty( prop );
		}
		makeIdentifier( idNode, id, mappings );
/s
HbmBinder.makeIdentifier(Element, SimpleValue, Mappings) line: 2172	

		model.getTable().setIdentifierValue( model );
model	SimpleValue  (id=1946)	
/ sets table's idValue	,

		else {
			if ( "assigned".equals( model.getIdentifierGeneratorStrategy() ) ) {
				model.setNullValue( "undefined" );

/t
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 381	

/ volgende	,
		while ( subnodes.hasNext() ) {
			Element subnode = (Element) subnodes.next();
/ alle properties, set voldoen niet aan de cases hieronder	,
			if ( "id".equals( name ) ) {
/ NEE
			else if ( "composite-id".equals( name ) ) {
/ NEE
			else if ( "version".equals( name ) || "timestamp".equals( name ) ) {
/ NEE
			else if ( "discriminator".equals( name ) ) {
/ NEE
			else if ( "cache".equals( name ) ) {
/ NEE

		// Primary key constraint
		entity.createPrimaryKey();
/ entity=RootClass inst	,
/s
RootClass(PersistentClass).createPrimaryKey() line: 339	

		PrimaryKey pk = new PrimaryKey();
		Table table = getTable();
		pk.setTable(table);
		pk.setName( PK_ALIAS.toAliasString( table.getName() ) );
		table.setPrimaryKey(pk);
/sets table.primaryKey	,
		pk.addColumns( getKey().getColumnIterator() );
/ getKey()=deze RootClass inst.identifier=SimpleValue inst	,
/ in deze SimpleValue inst zit de columns , Column inst met id_	,

/t
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 411	
		entity.createPrimaryKey();
/ D
		createClassProperties( node, entity, mappings, inheritedMetas );
/s
		createClassProperties(node, persistentClass, mappings, inheritedMetas, null, true, true, false);

/s
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2211	
/=
	protected static void createClassProperties(Element node, PersistentClass persistentClass,
			Mappings mappings, java.util.Map inheritedMetas, UniqueKey uniqueKey,
			boolean mutable, boolean nullable, boolean naturalId) throws MappingException {

nullable=true
/ bij <id was nullable=false set	,

node=<class ...>

terator iter = node.elementIterator();
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();

/ <id ...> is niet 1 van de cases hieronder	,

subnode=org.dom4j.tree.DefaultElement@27fac6e2 [Element: <property attributes: [
 org.dom4j.tree.DefaultAttribute@411733ef [Attribute: name name value "addressLine1"]
 org.dom4j.tree.DefaultAttribute@5a52b14b [Attribute: name column value "address_line1_"]
 org.dom4j.tree.DefaultAttribute@6af5e140 [Attribute: name unique value "false"]
 org.dom4j.tree.DefaultAttribute@3497679c [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@40134dbd [Attribute: name lazy value "false"]
 org.dom4j.tree.DefaultAttribute@3354d428 [Attribute: name generated value "never"]]/>] 

/ we zien bijv unique	, dit is bij een <property ...>, 	niet bij een <id ...>	,
/ TODO

			else if ( "property".equals( name ) ) {
				value = new SimpleValue( mappings, table );

				bindSimpleValue( subnode, (SimpleValue) value, nullable, propertyName, mappings );
/ creates Column	,
/s

		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/s
		else {
			bindColumns( node, simpleValue, isNullable, true, path, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1125	
			Column column = new Column();
			column.setValue( simpleValue );
/ sets column.value
			bindColumn( node, column, isNullable );
/s
HbmBinder.bindColumn(Element, Column, boolean) line: 1794	

		Attribute nullNode = node.attribute( "not-null" );
null
		column.setNullable( nullNode == null ? isNullable : nullNode.getValue().equals( "false" ) );
/ blijft true

		Attribute unqNode = node.attribute( "unique" );
org.dom4j.tree.DefaultAttribute@6af5e140 [Attribute: name unique value "false"]
		if ( unqNode != null ) column.setUnique( unqNode.getValue().equals( "true" ) );

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1137	
			Column column = new Column();
			column.setValue( simpleValue );
			bindColumn( node, column, isNullable );
/ D
			String columnName = columnAttribute.getValue();
...
			column.setName( columnName );
			if ( table != null ) {
				table.addColumn( column ); // table=null -> an association - fill
			simpleValue.addColumn( column );

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2315	

			else if ( "property".equals( name ) ) {
				value = new SimpleValue( mappings, table );
				bindSimpleValue( subnode, (SimpleValue) value, nullable, propertyName, mappings );
/ D
			if ( value != null ) {
				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
/s
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2346	
		value.setTypeUsingReflection( className, propertyName );

		Property prop = new Property();
		prop.setValue( value );
		bindProperty( subnode, prop, mappings, inheritedMetas );
/s
HbmBinder.bindProperty(Element, Property, Mappings, Map) line: 1268	
		String propName = node.attributeValue( "name" );
"addressLine1"
		property.setName( propName );

		Attribute updateNode = node.attribute( "update" );
null
		Attribute insertNode = node.attribute( "insert" );
null
		Attribute lockNode = node.attribute( "optimistic-lock" );
org.dom4j.tree.DefaultAttribute@3497679c [Attribute: name optimistic-lock value "true"]
		property.setOptimisticLocked( lockNode == null || "true".equals( lockNode.getValue() ) );

		Attribute generatedNode = node.attribute( "generated" );
org.dom4j.tree.DefaultAttribute@3354d428 [Attribute: name generated value "never"]
        	ring generationName = generatedNode == null ? null : generatedNode.getValue();
"never"
...
		boolean isLazyable = "property".equals( node.getName() ) ||
				"component".equals( node.getName() ) ||
				"many-to-one".equals( node.getName() ) ||
				"one-to-one".equals( node.getName() ) ||
				"any".equals( node.getName() );
true
		if ( isLazyable ) {
			Attribute lazyNode = node.attribute( "lazy" );
org.dom4j.tree.DefaultAttribute@40134dbd [Attribute: name lazy value "false"]
			property.setLazy( lazyNode != null && "true".equals( lazyNode.getValue() ) );

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2329	
				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
/ D
				persistentClass.addProperty( property );
/ adds aan persistentClass.properties	,

/ volgende,
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();

/ SAMENVATTING

persistentClass	RootClass  (id=1953)	
	declaredIdentifierProperty	Property  (id=1990)	
	identifierProperty	Property  (id=1990)	

	declaredProperties	ArrayList<E>  (id=1991)	
	properties	ArrayList<E>  (id=1998)	

/ 2 keer hezelfde, wat is de bedoeling van declared...	?
/ TODO


persistentClass	RootClass  (id=1953)	
	identifierProperty	Property  (id=1990)	
		cascade	"none" (id=2004)	
		insertable	true	
		lazy	false	
		lob	false	
		metaAttributes	HashMap<K,V>  (id=2226)	
		name	"id" (id=1956)	
		naturalIdentifier	false	
		nodeName	"id" (id=1955)	
		optimisticLocked	true	
		optional	false	
		persistentClass	RootClass  (id=1953)	
		propertyAccessorName	"property" (id=2003)	
		selectable	true	
		updateable	true	
		value	SimpleValue  (id=1946)	
		valueGenerationStrategy	null	


persistentClass	RootClass  (id=1953)	
	identifierProperty	Property  (id=1990)	
		value	SimpleValue  (id=1946)	
			columns	ArrayList<E>  (id=1950)	
			table	Table  (id=1949)	

persistentClass	RootClass  (id=1953)	
	identifierProperty	Property  (id=1990)	
		value	SimpleValue  (id=1946)	
			columns	ArrayList<E>  (id=1950)	
				elementData	Object[10]  (id=2298)	
					[0]	Column  (id=2302)	
						checkConstraint	null	
						comment	null	
						customRead	null	
						customWrite	null	
						defaultValue	null	
						length	255	
						name	"id_" (id=2306)	
						nullable	false	
						precision	19	
						quoted	false	
						scale	2	
						sqlType	null	
						sqlTypeCode	null	
						typeIndex	0	
						unique	false	
						uniqueInteger	1	
						value	SimpleValue  (id=1946)	
				modCount	1	
				size	1	

/ table bekijken we in een van de properties	,

persistentClass	RootClass  (id=1953)	
	properties	ArrayList<E>  (id=1998)	
		elementData	Object[10]  (id=2244)	
			[0]	Property  (id=2092)	
				cascade	"none" (id=2004)	
				insertable	true	
				lazy	false	
				lob	false	
				metaAttributes	HashMap<K,V>  (id=2236)	
				name	"addressLine1" (id=2055)	
				naturalIdentifier	false	
				nodeName	"addressLine1" (id=2055)	
				optimisticLocked	true	
				optional	false	
				persistentClass	RootClass  (id=1953)	
				propertyAccessorName	"property" (id=2003)	
				selectable	true	
				updateable	true	
				value	SimpleValue  (id=2054)	
					alternateUniqueKey	false	
					attributeConverterDefinition	null	
					cascadeDeleteEnabled	false	
					columns	ArrayList<E>  (id=2059)	
						elementData	Object[10]  (id=2400)	
							[0]	Column  (id=2064)	
								checkConstraint	null	
								comment	null	
								customRead	null	
								customWrite	null	
								defaultValue	null	
								length	255	
								name	"address_line1_" (id=2087)	
								nullable	true	
								precision	19	
								quoted	false	
								scale	2	
								sqlType	null	
								sqlTypeCode	null	
								typeIndex	0	
								unique	false	
								uniqueInteger	2	
								value	SimpleValue  (id=2054)	
						modCount	1	
						size	1	
					foreignKeyName	null	
					identifierGeneratorProperties	null	
					identifierGeneratorStrategy	"assigned" (id=1951)	
					mappings	Configuration$MappingsImpl  (id=1944)	
					nullValue	null	
					table	Table  (id=1949)	
						catalog	null	
						catalogQuoted	false	
						checkConstraints	ArrayList<E>  (id=1976)	
						columns	LinkedHashMap<K,V>  (id=1977)	
							accessOrder	false	
							entrySet	HashMap$EntrySet  (id=2725)	
							hashSeed	0	
							header	LinkedHashMap$Entry<K,V>  (id=2336)	
							keySet	null	
							loadFactor	0.75	
							modCount	4	
							size	4	
							table	HashMap$Entry<K,V>[16]  (id=2337)	
								[7]	LinkedHashMap$Entry<K,V>  (id=2395)	
									after	LinkedHashMap$Entry<K,V>  (id=2396)	
									before	LinkedHashMap$Entry<K,V>  (id=2397)	
									hash	343052279	
									key	"address_line1_" (id=2087)	
									next	null	
->									value	Column  (id=2064)	
								[10]	LinkedHashMap$Entry<K,V>  (id=2396)	
									after	LinkedHashMap$Entry<K,V>  (id=2398)	
									before	LinkedHashMap$Entry<K,V>  (id=2395)	
									hash	-151658998	
									key	"zipcoce_" (id=2401)	
									next	null	
->									value	Column  (id=2211)	
								[11]	LinkedHashMap$Entry<K,V>  (id=2397)	
									after	LinkedHashMap$Entry<K,V>  (id=2395)	
									before	LinkedHashMap$Entry<K,V>  (id=2336)	
									hash	101627	
									key	"id_" (id=2306)	
									next	null	
->									value	Column  (id=2302)	
								[15]	LinkedHashMap$Entry<K,V>  (id=2398)	
									after	LinkedHashMap$Entry<K,V>  (id=2336)	
									before	LinkedHashMap$Entry<K,V>  (id=2396)	
									hash	99994431	
									key	"city_" (id=2399)	
									next	null	
->									value	Column  (id=2217)	
							threshold	12	
							values	null	
						comment	null	
						foreignKeys	LinkedHashMap<K,V>  (id=1985)	
						hasDenormalizedTables	false	
						idValue	SimpleValue  (id=1946)	
						indexes	LinkedHashMap<K,V>  (id=1986)	
						isAbstract	false	
						name	"address" (id=1987)	
						primaryKey	PrimaryKey  (id=1978)	
						quoted	false	
						rowId	null	
						schema	null	
						schemaQuoted	false	
						sizeOfUniqueKeyMapOnLastCleanse	0	
						subselect	null	
						uniqueInteger	0	
						uniqueKeys	LinkedHashMap<K,V>  (id=2335)	
					type	null	
					typeName	"java.lang.String" (id=2091)	
					typeParameters	null	
				valueGenerationStrategy	null	
			[1]	Property  (id=2212)	
			[2]	Property  (id=2218)	

		modCount	2	
		size	2	

/ we hebben 3 columns processed	, 
/ dus we zien maar 3 columns in  RootClass, properties, SimpleValue, columns	, 
/ maar we zien 4 columns in RootClass, properties, SimpleValue, table, columns	,  ook id_ is daarbij	, die we zien in identifierProperty	, 

/ table vinden we ook direct in de RootClass	, dat is makkelijker	,

persistentClass	RootClass  (id=1953)	
	table	Table  (id=1949)	

/ Verschil property en column: in property staan WH H dingen, zoals lazy, insertable, .. in column staan db dingen, zoals length, nullable	,
/ TODO


/ Einde SAMENVATTING

/ s
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2220	

/ volgende	,

       <set
                name="employees"
                inverse="true">
                <key
                        column="address_"
                ></key>
                <one-to-many class="Employee"/>
        </set>


		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
			String name = subnode.getName();
set
			String propertyName = subnode.attributeValue( "name" );
employees
			CollectionType collectType = CollectionType.collectionTypeFromString( name );
/s
		public static CollectionType collectionTypeFromString(String xmlTagName) {
			return (CollectionType) INSTANCES.get( xmlTagName );

/ Intermezzo

public final class HbmBinder {

	abstract static class CollectionType {

		private static final CollectionType MAP = new CollectionType( "map" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				Map map = new Map( mappings, owner );
				bindCollection( node, map, owner.getEntityName(), path, mappings, inheritedMetas );
				return map;
			}
		};
		private static final CollectionType SET = new CollectionType( "set" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				Set set = new Set( mappings, owner );
				bindCollection( node, set, owner.getEntityName(), path, mappings, inheritedMetas );
				return set;
			}
		};
		private static final CollectionType LIST = new CollectionType( "list" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				List list = new List( mappings, owner );
				bindCollection( node, list, owner.getEntityName(), path, mappings, inheritedMetas );
				return list;
			}
		};
		private static final CollectionType BAG = new CollectionType( "bag" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				Bag bag = new Bag( mappings, owner );
				bindCollection( node, bag, owner.getEntityName(), path, mappings, inheritedMetas );
				return bag;
			}
		};
		private static final CollectionType IDBAG = new CollectionType( "idbag" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				IdentifierBag bag = new IdentifierBag( mappings, owner );
				bindCollection( node, bag, owner.getEntityName(), path, mappings, inheritedMetas );
				return bag;
			}
		};
		private static final CollectionType ARRAY = new CollectionType( "array" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				Array array = new Array( mappings, owner );
				bindArray( node, array, owner.getEntityName(), path, mappings, inheritedMetas );
				return array;
			}
		};
		private static final CollectionType PRIMITIVE_ARRAY = new CollectionType( "primitive-array" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				PrimitiveArray array = new PrimitiveArray( mappings, owner );
				bindArray( node, array, owner.getEntityName(), path, mappings, inheritedMetas );
				return array;
			}
		};
		private static final HashMap INSTANCES = new HashMap();

		static {
			INSTANCES.put( MAP.toString(), MAP );
			INSTANCES.put( BAG.toString(), BAG );
			INSTANCES.put( IDBAG.toString(), IDBAG );
			INSTANCES.put( SET.toString(), SET );
			INSTANCES.put( LIST.toString(), LIST );
			INSTANCES.put( ARRAY.toString(), ARRAY );
			INSTANCES.put( PRIMITIVE_ARRAY.toString(), PRIMITIVE_ARRAY );
		}

		public static CollectionType collectionTypeFromString(String xmlTagName) {
			return (CollectionType) INSTANCES.get( xmlTagName );
		}
	}


/ Einde Intermezzo

			CollectionType collectType = CollectionType.collectionTypeFromString( name );
/ D
collectType	HbmBinder$CollectionType$2  (id=2806)	

				Collection collection = collectType.create(
						subnode,
						StringHelper.qualify( entityName, propertyName ),
						persistentClass,
						mappings, inheritedMetas
					);
/ creates a Set	,
/s
		private static final CollectionType SET = new CollectionType( "set" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
->				Set set = new Set( mappings, owner );
				bindCollection( node, set, owner.getEntityName(), path, mappings, inheritedMetas );
				return set;
			}
		};
node=org.dom4j.tree.DefaultElement@5e5ecf [Element: <set attributes: [
 org.dom4j.tree.DefaultAttribute@33a26839 [Attribute: name name value "employees"]
 org.dom4j.tree.DefaultAttribute@6b6890aa [Attribute: name inverse value "true"]
 org.dom4j.tree.DefaultAttribute@1df1bffd [Attribute: name sort value "unsorted"]
 org.dom4j.tree.DefaultAttribute@6a738a66 [Attribute: name mutable value "true"]
 org.dom4j.tree.DefaultAttribute@47836523 [Attribute: name optimistic-lock value "true"]
 org.dom4j.tree.DefaultAttribute@3650183 [Attribute: name embed-xml value "true"]]/>]
path	"my.test.own.hibernate_collections_xml.Address.employees" (id=2817)	

/s
Set.<init>(Mappings, PersistentClass) line: 54	
/s
/ super class is org.hibernate.mapping.Collection

/t
/s
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1390	
/=
	public static void bindCollection(Element node, Collection collection, String className,
			String path, Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
node	DefaultElement  (id=2758)	
collection	Set  (id=2823)	
className	"my.test.own.hibernate_collections_xml.Address" (id=1989)	
path	"my.test.own.hibernate_collections_xml.Address.employees" (id=2817)	

		collection.setRole(path);
/ sets collection.role	,

		Attribute inverseNode = node.attribute( "inverse" );
org.dom4j.tree.DefaultAttribute@6b6890aa [Attribute: name inverse value "true"]
		if ( inverseNode != null ) {
			collection.setInverse( "true".equals( inverseNode.getValue() ) );
/ sets collection.inverse	,


		Attribute mutableNode = node.attribute( "mutable" );
org.dom4j.tree.DefaultAttribute@6a738a66 [Attribute: name mutable value "true"]
		if ( mutableNode != null ) {
			collection.setMutable( !"false".equals( mutableNode.getValue() ) );
		}

		Attribute olNode = node.attribute( "optimistic-lock" );
		collection.setOptimisticLocked( olNode == null || "true".equals( olNode.getValue() ) );

		String nodeName = node.attributeValue( "node" );
null
		if ( nodeName == null ) nodeName = node.attributeValue( "name" );
employees
		collection.setNodeName( nodeName );
		String embed = node.attributeValue( "embed-xml" );
true
		collection.setEmbedded( embed==null || "true".equals(embed) );

		initOuterJoinFetchSetting( node, collection );
/s
HbmBinder.initOuterJoinFetchSetting(Element, Fetchable) line: 2134	
		boolean lazy = true;
/ default	,
				else {
					fetchStyle = FetchMode.DEFAULT;
		model.setFetchMode( fetchStyle );
model	Set  (id=2823)	
		model.setLazy(lazy);
true
/ WAS false

/t
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1466	
		initOuterJoinFetchSetting( node, collection );
/ D
		initLaziness( node, collection, mappings, "true", mappings.isDefaultLazy() );
/ mappings.isDefaultLazy()==true
/s
		Attribute lazyNode = node.attribute( "lazy" );
null
		boolean isLazyTrue = lazyNode == null ?
				defaultLazy && fetchable.isLazy() : //fetch="join" overrides default laziness
true && true
				lazyNode.getValue().equals(proxyVal); //fetch="join" overrides default laziness
		fetchable.setLazy( isLazyTrue );
/ true
/ WAS true
/ TODO (join)	,

/t
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1473	

		Element oneToManyNode = node.element( "one-to-many" );
/ JA	, want	,

       <set
                name="employees"
                inverse="true">
                <key
                        column="address_"
                ></key>
                <one-to-many class="Employee"/>
        </set>

		if ( oneToManyNode != null ) {
			OneToMany oneToMany = new OneToMany( mappings, collection.getOwner() );
collection.getOwner()=RootClass 	, klopt	, de owner van <set ...> is <class ...>
/s
OneToMany.<init>(Mappings, PersistentClass) line: 60	
		this.mappings = mappings;
		this.referencingTable = (owner==null) ? null : owner.getTable();
org.hibernate.mapping.Table(address)
/ TODO

/t
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1476	
		if ( oneToManyNode != null ) {
			OneToMany oneToMany = new OneToMany( mappings, collection.getOwner() );
/ D
			collection.setElement( oneToMany );
			bindOneToMany( oneToManyNode, oneToMany, mappings );
/s
oneToManyNode=org.dom4j.tree.DefaultElement@3c820ae [Element: <one-to-many attributes: [
 org.dom4j.tree.DefaultAttribute@47d98172 [Attribute: name class value "Employee"]
 org.dom4j.tree.DefaultAttribute@18c18838 [Attribute: name not-found value "exception"]
 org.dom4j.tree.DefaultAttribute@49d6213a [Attribute: name embed-xml value "true"]]/>]
/s
HbmBinder.bindOneToMany(Element, OneToMany, Mappings) line: 1766	

		oneToMany.setReferencedEntityName( getEntityName( node, mappings ) );
/  getEntityName( node, mappings ) = my.test.own.hibernate_collections_xml.Employee
/ want	,
/s
HbmBinder.getEntityName(Element, Mappings) line: 3033	

		String entityName = elem.attributeValue( "entity-name" );
null
		return entityName == null ? getClassName( elem.attribute( "class" ), model ) : entityName;
/ model=mappings hierboven	,
/s
HbmBinder.getClassName(Attribute, Mappings) line: 3038	
		return getClassName( att.getValue(), model );
/s
	public static String getClassName(String unqualifiedName, Mappings model) {
		return getClassName( unqualifiedName, model.getDefaultPackage() );

/t
HbmBinder.bindOneToMany(Element, OneToMany, Mappings) line: 1768	
		oneToMany.setReferencedEntityName( getEntityName( node, mappings ) );
oneToMany	OneToMany  (id=2936)	
	referencedEntityName	"my.test.own.hibernate_collections_xml.Employee" (id=3012)	
/ D

		String embed = node.attributeValue( "embed-xml" );
		oneToMany.setEmbedded( embed == null || "true".equals( embed ) );
true

		String notFound = node.attributeValue( "not-found" );
		oneToMany.setIgnoreNotFound( "ignore".equals( notFound ) );
false

/t
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1528	
		if ( oneToManyNode != null ) {
			OneToMany oneToMany = new OneToMany( mappings, collection.getOwner() );
			collection.setElement( oneToMany );
			bindOneToMany( oneToManyNode, oneToMany, mappings );
/ D

/ Intermezzo

/ we zijn bij -> ,

Thread [main] (Suspended)	
	HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1565	
...
	Configuration.secondPassCompile() line: 1410	
->			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/ Daarna	,
			originalSecondPassCompile();

	Configuration.buildSessionFactory(ServiceRegistry) line: 1844	
...


/ Einde Intermezzo


		Attribute sortedAtt = node.attribute( "sort" );
org.dom4j.tree.DefaultAttribute@1df1bffd [Attribute: name sort value "unsorted"]
		if ( sortedAtt == null || sortedAtt.getValue().equals( "unsorted" ) ) {
/ JA
			collection.setSorted( false );

		Attribute cascadeAtt = node.attribute( "cascade" );
null

		else {
			mappings.addSecondPass( new CollectionSecondPass( node, mappings, collection, inheritedMetas ) );
/ voor een set	,
/s
HbmBinder$CollectionSecondPass.<init>(Element, Mappings, Collection, Map) line: 2802	
/=
public final class HbmBinder {
	static class CollectionSecondPass extends org.hibernate.cfg.CollectionSecondPass {
		Element node;

		CollectionSecondPass(Element node, Mappings mappings, Collection collection, java.util.Map inheritedMetas) {
			super(mappings, collection, inheritedMetas);
/s
HbmBinder$CollectionSecondPass(CollectionSecondPass).<init>(Mappings, Collection, Map) line: 53	
/=
public abstract class CollectionSecondPass implements SecondPass {
	public CollectionSecondPass(Mappings mappings, Collection collection, java.util.Map inheritedMetas) {
		this.collection = collection;
/ Set

/t
			super(mappings, collection, inheritedMetas);
/ D
			this.node = node;
/ <set ...>

/t
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1565	
		else {
			mappings.addSecondPass( new CollectionSecondPass( node, mappings, collection, inheritedMetas ) );
/s
Configuration$MappingsImpl.addSecondPass(SecondPass) line: 3265	
			addSecondPass( sp, false );
/s
			else {
				secondPasses.add( sp );
this	Configuration$MappingsImpl  (id=1944)	
	this$0	Configuration  (id=17)	
		secondPasses	ArrayList<E>  (id=3131)	
[org.hibernate.cfg.HbmBinder$CollectionSecondPass@774e834c]

/ Is er maar 1 mappings	?
/ TODO

/t
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1568	
		else {
			mappings.addSecondPass( new CollectionSecondPass( node, mappings, collection, inheritedMetas ) );
/ D
		collection.setReferencedPropertyName( node.element( "key" ).attributeValue( "property-ref" ) );
/ sets collection.referencedPropertyName	null	
        <set
                name="employees"
                inverse="true">
                <key
                        column="address_"
                ></key>
                <one-to-many class="Employee"/>
        </set>

/s

/ Intermezzo

/ we hadden property-ref alleen used in bijv ehcache_hibernate_xml4 in	,
	<one-to-one 
		name="employee"
		property-ref="address"
	></one-to-one> 

/ we lezen	,
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch05.html#mapping-declaration
<key
        column="columnname"                                
        on-delete="noaction|cascade"                       
        property-ref="propertyName"                        
        not-null="true|false"                              
        update="true|false"                                
        unique="true|false"                                
/>
property-ref (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data.


/ Einde Intermezzo

/t
HbmBinder$CollectionType$2.create(Element, String, PersistentClass, Mappings, Map) line: 2914	
		private static final CollectionType SET = new CollectionType( "set" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {
				Set set = new Set( mappings, owner );
				bindCollection( node, set, owner.getEntityName(), path, mappings, inheritedMetas );
/ D
				return set;

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2229	
			if ( collectType != null ) {
				Collection collection = collectType.create(
						subnode,
						StringHelper.qualify( entityName, propertyName ),
						persistentClass,
						mappings, inheritedMetas
					);
/ D
				mappings.addCollection( collection );
				value = collection;
mappings	Configuration$MappingsImpl  (id=1944)	
	this$0	Configuration  (id=17)	
		collections	HashMap<K,V>  (id=3075)	
{my.test.own.hibernate_collections_xml.Address.employees=org.hibernate.mapping.Set(my.test.own.hibernate_collections_xml.Address.employees)}

			if ( value != null ) {
				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
/s
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2350	
		value.setTypeUsingReflection( className, propertyName );
/s
Set(Collection).setTypeUsingReflection(String, String) line: 441	
	public void setTypeUsingReflection(String className, String propertyName) {
	}


/t
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2350	
		if ( value instanceof ToOne ) {
/ NEE
		else if ( value instanceof Collection ) {
			Collection coll = (Collection) value;

			String propertyRef = coll.getReferencedPropertyName();
null

		value.createForeignKey();
/s
Set(Collection).createForeignKey() line: 406	
	public void createForeignKey() {
	}

		Property prop = new Property();
		prop.setValue( value );
		bindProperty( subnode, prop, mappings, inheritedMetas );
/s
		String propName = node.attributeValue( "name" );
employees
		property.setName( propName );
		String nodeName = node.attributeValue( "node" );
		if (nodeName==null) nodeName = propName;
		property.setNodeName( nodeName );

		else {
			property.setPropertyAccessorName( mappings.getDefaultAccess() );
"property"

		Attribute cascadeNode = node.attribute( "cascade" );
null
		property.setCascade( cascadeNode == null ? mappings.getDefaultCascade() : cascadeNode
			.getValue() );
"none"

		boolean isLazyable = "property".equals( node.getName() ) ||
				"component".equals( node.getName() ) ||
				"many-to-one".equals( node.getName() ) ||
				"one-to-one".equals( node.getName() ) ||
				"any".equals( node.getName() );
false
		if ( isLazyable ) {
/ NEE
/ property.lazy=false (default)

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2329	
				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
/ D
				persistentClass.addProperty( property );


/t
HbmBinder.bindRoot(XmlDocument, Mappings, Map, Set<String>) line: 178	

		while ( rootChildren.hasNext() ) {
			final Element element = (Element) rootChildren.next();
			final String elementName = element.getName();

			else if ( "class".equals( elementName ) ) {
				RootClass rootclass = new RootClass();
				bindRootClass( element, rootclass, mappings, inheritedMetas );
/ D
				mappings.addClass( rootclass );
mappings	Configuration$MappingsImpl  (id=2006)	
	this$0	Configuration  (id=17)	
		classes	HashMap<K,V>  (id=2032)	
{my.test.own.hibernate_collections_xml.Employee=org.hibernate.mapping.RootClass(my.test.own.hibernate_collections_xml.Employee)
 my.test.own.hibernate_collections_xml.Address=org.hibernate.mapping.RootClass(my.test.own.hibernate_collections_xml.Address)}

/t
Configuration$MetadataSourceQueue.processMetadata(List<MetadataSourceType>) line: 3739	
			for ( MetadataSourceType type : order ) {
/ order=[hbm,class]
			for ( MetadataSourceType type : order ) {
				if ( MetadataSourceType.HBM.equals( type ) ) {
					processHbmXmlQueue();
/ D
				}
				else if ( MetadataSourceType.CLASS.equals( type ) ) {
					processAnnotatedClassesQueue();
/ NIETS

/ Intermezzo

/ property employees  gaat in de RootClass, net als alle andere properties	, (identifier zit apart in RootClass Address)die straks in de mapping , dwz configuration , gaat	,
/ RootClass Address gaat in de mappings(configuration)'s classes	, RootClass Employee was er al	,
/ collection (Set) ging in de mapping (configuration)'s collections	, maar ook in de secondPass, 
/ de secondPass gaat in mapping(configuration)'s secondPasses	, dus daar zit de collection (Set) ook	, want de Set moet nog processed: 

/ Einde Intermezzo

/t
Configuration.secondPassCompile() line: 1416	

			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/ D
			originalSecondPassCompile();
/s
Configuration.originalSecondPassCompile() line: 1695	
		LOG.debug( "Processing collection mappings" );
		Iterator itr = secondPasses.iterator();
		while ( itr.hasNext() ) {
			SecondPass sp = (SecondPass) itr.next();
			if ( ! (sp instanceof QuerySecondPass) ) {
				sp.doSecondPass( classes );

this	Configuration  (id=17)	

	classes
{my.test.own.hibernate_collections_xml.Employee=org.hibernate.mapping.RootClass(my.test.own.hibernate_collections_xml.Employee)
 my.test.own.hibernate_collections_xml.Address=org.hibernate.mapping.RootClass(my.test.own.hibernate_collections_xml.Address)}

	secondPasses	ArrayList<E>  (id=2121)	
		elementData	Object[10]  (id=2130)	
			[0]	HbmBinder$CollectionSecondPass  (id=2082)	
				collection	Set  (id=1997)	
org.hibernate.mapping.Set(my.test.own.hibernate_collections_xml.Address.employees)

				localInheritedMetas	HashMap<K,V>  (id=2009)	
				mappings	Configuration$MappingsImpl  (id=2006)	
				node	DefaultElement  (id=1999)	
<set ...>


/s
HbmBinder$CollectionSecondPass(CollectionSecondPass).doSecondPass(Map) line: 70	
/=
	public void doSecondPass(java.util.Map persistentClasses)

		secondPass( persistentClasses, localInheritedMetas ); // using local since the inheritedMetas at this point is not the correct map since it is always the empty map
/s
HbmBinder$CollectionSecondPass.secondPass(Map, Map) line: 2808	
/ =
		public void secondPass(java.util.Map persistentClasses, java.util.Map inheritedMetas)

			HbmBinder.bindCollectionSecondPass(
					node,
					collection,
					persistentClasses,
					mappings,
					inheritedMetas
				);
/s
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2553	
/=
	public static void bindCollectionSecondPass(Element node, Collection collection,
			java.util.Map persistentClasses, Mappings mappings, java.util.Map inheritedMetas)

		if ( collection.isOneToMany() ) {
/s
		return element instanceof OneToMany;
/ JA

/ Intermezzo

        <set
                name="employees"
                inverse="true">
                <key
                        column="address_"
                ></key>
                <one-to-many class="Employee"/>
        </set>


this	Set  (id=303)	
	element	OneToMany  (id=308)	
	key	null	

/ Einde Intermezzo

			OneToMany oneToMany = (OneToMany) collection.getElement();
			String assocClass = oneToMany.getReferencedEntityName();
assocClass	"my.test.own.hibernate_collections_xml.Employee" (id=2291)	
			PersistentClass persistentClass = (PersistentClass) persistentClasses.get( assocClass );
org.hibernate.mapping.RootClass(my.test.own.hibernate_collections_xml.Employee)
			oneToMany.setAssociatedClass( persistentClass );
			collection.setCollectionTable( persistentClass.getTable() );

		// contained elements:
		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
org.dom4j.tree.DefaultElement@5978d4f1 [Element: <key attributes: [
 org.dom4j.tree.DefaultAttribute@be4481b [Attribute: name column value "address_"]
 org.dom4j.tree.DefaultAttribute@3839eab6 [Attribute: name on-delete value "noaction"]]/>]
			String name = subnode.getName();
"key"
			if ( "key".equals( name ) ) {
				KeyValue keyVal;
				String propRef = collection.getReferencedPropertyName();
null
/ omdat we geen property-ref (legacy) hadden gedaan	,
				if ( propRef == null ) {
					keyVal = collection.getOwner().getIdentifier();
/ collection=Set inst	
org.hibernate.mapping.SimpleValue([org.hibernate.mapping.Column(id_)])
/ Van Address	,
/ TODO

/ Intermezzo

collection	Set  (id=1997)	
	element	OneToMany  (id=2256)	
		associatedClass	RootClass  (id=2312)	
/ Employee
		referencedEntityName	"my.test.own.hibernate_collections_xml.Employee" (id=2291)	
		referencingTable	Table  (id=2292)	
/ address
/ TODO

/ Einde Intermezzo

				SimpleValue key = new DependantValue( mappings, collection.getCollectionTable(), keyVal );
///////////////////////////////
/ we zien dat <key de table overneemt van <set	, employee dus	,

       <set
                name="employees"
                inverse="true">
                <key
                        column="address_"
                ></key>
                <one-to-many class="Employee"/>
        </set>


/s
collection	Set  (id=1997)	
	collectionTable	Table  (id=2319)	
employee
/s
DependantValue.<init>(Mappings, Table, KeyValue) line: 43	
/ extends SimpleValue	,
		super( mappings, table );
/ table=employee
		this.wrappedValue = prototype;
SimpleValue(_id van address)

				bindSimpleValue(
						subnode,
						key,
						collection.isOneToMany(),
						Collection.DEFAULT_KEY_COLUMN_NAME,
						mappings
					);
/s
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1191	
/=
	public static void bindSimpleValue(Element node, SimpleValue simpleValue, boolean isNullable,
			String path, Mappings mappings) throws MappingException {
node=<key ...>
simpleValue=DependantValue
isNullable	true	
path	"id" (id=2524)	
		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/s
		else {
			bindColumns( node, simpleValue, isNullable, true, path, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1061	
/=
	public static void bindColumns(final Element node, final SimpleValue simpleValue,
			final boolean isNullable, final boolean autoColumn, final String propertyPath,
			final Mappings mappings) throws MappingException {

/ node=<key

		Table table = simpleValue.getTable();
employee
/ <key had table genomen van <set


		Attribute columnAttribute = node.attribute( "column" );
org.dom4j.tree.DefaultAttribute@be4481b [Attribute: name column value "address_"]

/ klopt	,
               <key
                        column="address_"
                ></key>

		if ( columnAttribute == null ) {
/ NEE
		else{
			Column column = new Column();
			column.setValue( simpleValue );
simpleValue	DependantValue  (id=2485)	
	columns	ArrayList<E>  (id=2501)	
[]
	table	Table  (id=2319)	
employee
	wrappedValue	SimpleValue  (id=2447)	
		columns	ArrayList<E>  (id=2451)	
id_
		table	Table  (id=2292)	
address

//////////////////////////////////////////
/ we maken de Column (address_) van employee
/ terwijl we in de mapping van address zijn	,
/ TODO

			bindColumn( node, column, isNullable );
HbmBinder.bindColumn(Element, Column, boolean) line: 1783	
/=
	public static void bindColumn(Element node, Column column, boolean isNullable) throws MappingException {
node=<key ...>
isNullable=true

		Attribute nullNode = node.attribute( "not-null" );
null
		column.setNullable( nullNode == null ? isNullable : nullNode.getValue().equals( "false" ) );
true

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1132	

			bindColumn( node, column, isNullable );
/ D
			String columnName = columnAttribute.getValue();
address_
			column.setName( columnName );
			if ( table != null ) {
/ JA
table	Table  (id=2319)	

/ table is de table 

	columns	LinkedHashMap<K,V>  (id=2322)	
{id_=org.hibernate.mapping.Column(id_)
 name_=org.hibernate.mapping.Column(name_)
 salary_=org.hibernate.mapping.Column(salary_)
 address_=org.hibernate.mapping.Column(address_)}

	name	"employee" (id=2327)	

	primaryKey	PrimaryKey  (id=2328)	
org.hibernate.mapping.PrimaryKey(employee[org.hibernate.mapping.Column(id_)]) as employeePK

/ we zien dat de address_ er al is	,

				table.addColumn( column ); // table=null -> an association - fill
/s
		Column old = getColumn( column );
		if ( old == null ) {
/ NEE
		else {
			column.uniqueInteger = old.uniqueInteger;
4 
/ WAS 0
/ Dus adds Column niet	,

				mappings.addColumnBinding( logicalColumnName, column, table );
/s

		public void addColumnBinding(String logicalName, Column physicalColumn, Table table) throws DuplicateMappingException {
			TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( table );
			if ( binding == null ) {
/ NEE
			binding.addBinding( logicalName, physicalColumn );
binding	Configuration$MappingsImpl$TableColumnNameBinding  (id=2618)	
	logicalToPhysical	HashMap<K,V>  (id=2620)	
{salary_=salary_, address_=address_, id_=id_, name_=name_}
	physicalToLogical	HashMap<K,V>  (id=2621)	
{salary_=salary_, address_=address_, id_=id_, name_=name_}
/ TODO

/t
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1144	
				mappings.addColumnBinding( logicalColumnName, column, table );
/ D
			simpleValue.addColumn( column );
/ simpleValue=DependentValue	,
///////////////////////////////////////////////////////////
/ de Column gaat dus in de DependantValue	,


/t
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2598	
				bindSimpleValue(
						subnode,
						key,
						collection.isOneToMany(),
						Collection.DEFAULT_KEY_COLUMN_NAME,
						mappings
					);
/ D
				collection.setKey( key );
collection	Set  (id=1997)	

element	OneToMany  (id=308)	

key	DependantValue  (id=2485)	
	columns	ArrayList<E>  (id=2501)	
		elementData	Object[10]  (id=2674)	
			[0]	Column  (id=2539)	
				name	"address_" (id=2589)	
				value	DependantValue  (id=2485)	
	table	Table  (id=2319)	employee
	wrappedValue	SimpleValue  (id=2447)	
		columns id_
		table address
/TDDO


				Attribute notNull = subnode.attribute( "not-null" );
null
				( (DependantValue) key ).setNullable( notNull == null || notNull.getValue().equals( "false" ) );
true

				Attribute updateable = subnode.attribute( "update" );
				( (DependantValue) key ).setUpdateable( updateable == null || updateable.getValue().equals( "true" ) );
true

/t
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2576	

/ volgende	,

		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
org.dom4j.tree.DefaultElement@aeb1198 [Element: <one-to-many attributes: [
 org.dom4j.tree.DefaultAttribute@4ed017c1 [Attribute: name class value "Employee"]
 org.dom4j.tree.DefaultAttribute@3fc7a853 [Attribute: name not-found value "exception"]
 org.dom4j.tree.DefaultAttribute@4cfc01db [Attribute: name embed-xml value "true"]]/>]
			String name = subnode.getName();
name	"one-to-many" (id=2784)	

/ er is geen case voor one-to-many	,

		if ( collection.isOneToMany()
			&& !collection.isInverse()
			&& !collection.getKey().isNullable() ) {
/ NEE
/ Dit is WH als we omdraaien	,
/ TODO ANDERSOM

/t
HbmBinder$CollectionSecondPass(CollectionSecondPass).doSecondPass(Map) line: 71	
		secondPass( persistentClasses, localInheritedMetas ); // using local since the inheritedMetas at this point is not the correct map since it is always the empty map
/ D
		collection.createAllKeys();

this	HbmBinder$CollectionSecondPass  (id=2082)	
	collection	Set  (id=1997)	
		collectionTable	Table  (id=2319)	
		element	OneToMany  (id=2256)	
			referencedEntityName	"my.test.own.hibernate_collections_xml.Employee" (id=2291)	
			referencingTable	Table  (id=2292)	
address
		key	DependantValue  (id=2485)	
			columns	ArrayList<E>  (id=2501)	
[org.hibernate.mapping.Column(address_)]
			table	Table  (id=2319)	
employee
		role	"my.test.own.hibernate_collections_xml.Address.employees" (id=2284)	

/s
Set(Collection).createAllKeys() line: 428	
		createForeignKeys();
/s
Set(Collection).createForeignKeys() line: 418	
		if ( referencedPropertyName == null ) {
/ JA
			getElement().createForeignKey();
/ doet NIETS	,
/ want	,
/s
OneToMany.createForeignKey() line: 78	
	public void createForeignKey() {
		// no foreign key element of for a one-to-many
	}
/t
Set(Collection).createForeignKeys() line: 420	
			getElement().createForeignKey();
/ D
			key.createForeignKeyOfEntity( getOwner().getEntityName() );
/ key=DependantValue	,
	columns			address_
	table			employee
	wrappedValue
		columns		id_
		table		address

/ owner=RootClass van Address	,
//////////////////////
/ WH : getOwner().getEntityName()=Address, en Address' pk is waar de fk naar refs	,

/s
DependantValue(SimpleValue).createForeignKeyOfEntity(String) line: 146	
/=
	public void createForeignKeyOfEntity(String entityName) {
entityName	"my.test.own.hibernate_collections_xml.Address" (id=100)	
/ WH: fk refs naar Address's pk	,

		if ( !hasFormula() && !"none".equals(getForeignKeyName())) {
/ JA
/ want "none"!=null
			ForeignKey fk = table.createForeignKey( getForeignKeyName(), getConstraintColumns(), entityName );
this	DependantValue  (id=2485)	
	columns				address_
	table	Table  (id=2319)	employee
	wrappedValue	SimpleValue  (id=528)	 
		colunns			id_	
		table			address
/ TODO (Is dit pk waar de fk address_ naar refs?)

getForeignKeyName()==null
getConstraintColumns()==columns=[org.hibernate.mapping.Column(address_)]
/s
Table.createForeignKey(String, List, String) line: 651	
/=
	public ForeignKey createForeignKey(String keyName, List keyColumns, String referencedEntityName) {
keyName=null
keyColumns=address_ in employee
referencedEntityName=my.test.own.hibernate_collections_xml.Address

		return createForeignKey( keyName, keyColumns, referencedEntityName, null );

keyColumns	ArrayList<E>  (id=2501)	
	elementData	Object[10]  (id=2674)	
		[0]	Column  (id=2539)	
			name	"address_" (id=2589)	
			value	DependantValue  (id=2485)	
				table	Table  (id=2319)	
					name	"employee" (id=2327)	
/ TODO( is dit de manier om achter de table te komen van address_ ?_

referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=2021)	
//////////////////////////////
/ de fk address_ refs naar een Address	, klopt	,

/s
Table.createForeignKey(String, List, String, List) line: 656	
		Object key = new ForeignKeyKey( keyColumns, referencedEntityName, referencedColumns );
keyColumns	ArrayList<E>  (id=105)	
	elementData	Object[10]  (id=114)	
		[0]	Column  (id=119)	
			name	"address_" (id=123)	
			value	ManyToOne  (id=61)	
				referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=100)	
				table	Table  (id=60)	employee

referencedEntityName	"my.test.own.hibernate_collections_xml.Address" (id=100)	
referencedColumns	null								/ id fk naar pk van Address, en niet naar een bepaalde column	,

/s
			this.referencedClassName = referencedClassName;
Address
			this.columns = new ArrayList();
			this.columns.addAll( columns );
/ hierboven	,
			if ( referencedColumns != null ) {
/ NEE
			else {
				this.referencedColumns = Collections.EMPTY_LIST;
/ fk naar id	, niet naar een bepaalde column	,

		ForeignKey fk = (ForeignKey) foreignKeys.get( key );

/ Intermezzo

fk	ForeignKey  (id=3061)	
	columns	ArrayList<E>  (id=3062)	
		elementData	Object[10]  (id=3066)	
			[0]	Column  (id=2603)	
				name	"address_" (id=3069)	
				value	ManyToOne  (id=3071)	

/ vergl	,
key	Table$ForeignKeyKey  (id=3054)	
	columns	ArrayList<E>  (id=3057)	
		elementData	Object[10]  (id=3091)	
			[0]	Column  (id=2539)	
				name	"address_" (id=2589)	
				value	DependantValue  (id=2485)	


/ we deden dus	,
		Object key = new ForeignKeyKey( keyColumns, referencedEntityName, referencedColumns );
		ForeignKey fk = (ForeignKey) foreignKeys.get( key );

/Dus <key ...> wordt een fk key, dus een key in de hashtable van fk's 	,

/ Einde Intermezzo

	if ( fk == null ) {
/ NEE
			foreignKeys.put( key, fk );
/ NIET
/ Er gebeurt dus niets	, de fk is er al	,
/////////////////////////////////////////////////////

/t	
DependantValue(SimpleValue).createForeignKeyOfEntity(String) line: 148	
			ForeignKey fk = table.createForeignKey( getForeignKeyName(), getConstraintColumns(), entityName );
/ D
			fk.setCascadeDeleteEnabled(cascadeDeleteEnabled);


/t
Set(Collection).createAllKeys() line: 429	
		createForeignKeys();
/ D
		if ( !isInverse() ) createPrimaryKey();
/ NEE
/////////////////////////////////////////////
/ TODO ANDERSOM 

/t

Configuration.originalSecondPassCompile() line: 1696	

		LOG.debug( "Processing collection mappings" );
		Iterator itr = secondPasses.iterator();
		while ( itr.hasNext() ) {
			SecondPass sp = (SecondPass) itr.next();
			if ( ! (sp instanceof QuerySecondPass) ) {
				sp.doSecondPass( classes );
/ D
				itr.remove();

		LOG.debug( "Processing native query and ResultSetMapping mappings" );
/ TODO
		itr = secondPasses.iterator();
		while ( itr.hasNext() ) {
/ NEE

		LOG.debug( "Processing association property references" );
/ TODO
		itr = propertyReferences.iterator();
		while ( itr.hasNext() ) {
/ NEE

		itr = getTableMappings();
/s
Configuration.getTableMappings() line: 396	
		return tables.values().iterator();
this	Configuration  (id=17)	
	tables	TreeMap<K,V>  (id=2126)	
{address=org.hibernate.mapping.Table(address), employee=org.hibernate.mapping.Table(employee)}

		int uniqueInteger = 0;
		Set<ForeignKey> done = new HashSet<ForeignKey>();
		while ( itr.hasNext() ) {
			Table table = (Table) itr.next();
			table.setUniqueInteger( uniqueInteger++ );
			secondPassCompileForeignKeys( table, done );
/s
Configuration.secondPassCompileForeignKeys(Table, Set<ForeignKey>) line: 1787	

		table.createForeignKeys();
/s
Table.createForeignKeys() line: 648	
	public void createForeignKeys() {
	}

/t
Configuration.secondPassCompileForeignKeys(Table, Set<ForeignKey>) line: 1787	
		table.createForeignKeys();
/ D
		Iterator iter = table.getForeignKeyIterator();
this	Table  (id=60)	
	name	"employee" (id=646)	
	foreignKeys	LinkedHashMap<K,V>  (id=643)	
			[7]	LinkedHashMap$Entry<K,V>  (id=909)	
				value	ForeignKey  (id=201)	

		while ( iter.hasNext() ) {
 /NEE voor address
/ JA voor employee
			ForeignKey fk = (ForeignKey) iter.next();
			if ( !done.contains( fk ) ) {
/ JA
				done.add( fk );
				final String referencedEntityName = fk.getReferencedEntityName();
Address
				PersistentClass referencedClass = classes.get( referencedEntityName );
				fk.setReferencedTable( referencedClass.getTable() );
address
				fk.alignColumns();
/s
ForeignKey.alignColumns() line: 93	
		if ( isReferenceToPrimaryKey() ) alignColumns(referencedTable);
/s
ForeignKey.isReferenceToPrimaryKey() line: 164	
/=
	/** Does this foreignkey reference the primary key of the reference table */ 
	public boolean isReferenceToPrimaryKey() {
		return referencedColumns.isEmpty();
true

/t
/s
ForeignKey.alignColumns(Table) line: 97	
 		if ( referencedTable.getPrimaryKey().getColumnSpan()!=getColumnSpan() ) {
/ NEE
/ want	,
/s
Table.getPrimaryKey() line: 581	
/=
	public PrimaryKey getPrimaryKey() {
		return primaryKey;
org.hibernate.mapping.PrimaryKey(address[org.hibernate.mapping.Column(id_)]) as addressPK
/s
PrimaryKey(Constraint).getColumnSpan() line: 159	
		return columns.size();
1
/t
/s
ForeignKey(Constraint).getColumnSpan() line: 159	
		return columns.size();
1

		Iterator fkCols = getColumnIterator();
		Iterator pkCols = referencedTable.getPrimaryKey().getColumnIterator();
		while ( pkCols.hasNext() ) {
			( (Column) fkCols.next() ).setLength( ( (Column) pkCols.next() ).getLength() );
255

/t
Configuration.secondPassCompileForeignKeys(Table, Set<ForeignKey>) line: 1819	
		Iterator iter = table.getForeignKeyIterator();
		while ( iter.hasNext() ) {
/ Geen volgende	,

/t
Configuration.originalSecondPassCompile() line: 1742	
		itr = getTableMappings();
		int uniqueInteger = 0;
		Set<ForeignKey> done = new HashSet<ForeignKey>();
		while ( itr.hasNext() ) {
/ Geen volgende (address, employee gedaan)	,

Configuration.secondPassCompile() line: 1426	
			originalSecondPassCompile();
/ D

/t
Configuration.buildSessionFactory(ServiceRegistry) line: 1845	
		secondPassCompile();
/ D

		validate();
		Environment.verifyProperties( properties );
		Properties copy = new Properties();
		copy.putAll( properties );
		ConfigurationHelper.resolvePlaceHolders( copy );
		Settings settings = buildSettings( copy, serviceRegistry );
/ LATER

		return new SessionFactoryImpl(
				this,
				mapping,
				serviceRegistry,
				settings,
				sessionFactoryObserver
			);

/ 7	. 

/ tmp notes

Thread [main] (Suspended)	
	SingleTableEntityPersister(AbstractEntityPersister).<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor) line: 549	
	SingleTableEntityPersister.<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor, Mapping) line: 148	
	NativeConstructorAccessorImpl.newInstance0(Constructor, Object[]) line: not available [native method]	
	NativeConstructorAccessorImpl.newInstance(Object[]) line: 57	
	DelegatingConstructorAccessorImpl.newInstance(Object[]) line: 45	
	Constructor<T>.newInstance(Object...) line: 526	
	PersisterFactoryImpl.create(Class<EntityPersister>, Class[], Object, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor, Mapping) line: 163	
	PersisterFactoryImpl.createEntityPersister(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor, Mapping) line: 135	
	SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 401	
	Configuration.buildSessionFactory(ServiceRegistry) line: 1857	
	Main.setUp() line: 71	
	Main.<init>() line: 59	
	Main.main(String[]) line: 54	

/ 13	. 

/ Employee	,

	public AbstractEntityPersister(
			final PersistentClass persistentClass,
  org.hibernate.mapping.RootClass(my.test.own.hibernate_collections_xml.Employee)
			final EntityRegionAccessStrategy cacheAccessStrategy,
			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
			final SessionFactoryImplementor factory) throws HibernateException {

		Iterator iter = persistentClass.getIdentifier().getColumnIterator();
		int i = 0;
		while ( iter.hasNext() ) {
			Column col = ( Column ) iter.next();
			rootTableKeyColumnNames[i] = col.getQuotedName( factory.getDialect() );
[id_]
			rootTableKeyColumnReaders[i] = col.getReadExpr( factory.getDialect() );
[id_]
			rootTableKeyColumnReaderTemplates[i] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
[$PlaceHolder$.id_]
			identifierAliases[i] = col.getAlias( factory.getDialect(), persistentClass.getRootTable() );
[id_1_1_]
			i++;
		}

		sqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ? "( " + persistentClass.getWhere() + ") " : null;
null

		HashSet thisClassProperties = new HashSet();
		iter = persistentClass.getPropertyClosureIterator();
		i = 0;
		boolean foundFormula = false;
		while ( iter.hasNext() ) {
			Property prop = ( Property ) iter.next();
org.hibernate.mapping.Property(name)
			thisClassProperties.add( prop );
			while ( colIter.hasNext() ) {
/ 1 while loop	,
				Selectable thing = ( Selectable ) colIter.next();
				colAliases[k] = thing.getAlias( factory.getDialect() , prop.getValue().getTable() );
				else {
					Column col = (Column)thing;
					colNames[k] = col.getQuotedName( factory.getDialect() );
[name_]
					colReaderTemplates[k] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
[0]	"$PlaceHolder$.name_" (id=2186)	

					colWriters[k] = col.getWriteExpr();
[?]
				}
/  
			propertyColumnNames[i] = colNames;
[name_]
			propertyColumnFormulaTemplates[i] = formulaTemplates;
[null]
			propertyColumnReaderTemplates[i] = colReaderTemplates;
[0]	"$PlaceHolder$.name_" (id=2186)	
			propertyColumnWriters[i] = colWriters;
[?]
			propertyColumnAliases[i] = colAliases;
[name_2_1_]

			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
[[true], null, null]
/ we zijn pas bij 1ste prop	,
			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
[[true], null, null]
			propertySelectable[i] = prop.isSelectable();
[true, false, false]
			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
[false, false, false]

 			i++;
		}

/ net zo voor salary	,

/ dan address, de fk	,

		while ( iter.hasNext() ) {
			Property prop = ( Property ) iter.next();

			propertyColumnNames[i] = colNames;
[address_]
			propertyColumnFormulaTemplates[i] = formulaTemplates;
[null]
			propertyColumnReaderTemplates[i] = colReaderTemplates;
[$PlaceHolder$.address_]
			propertyColumnWriters[i] = colWriters;
[?]
			propertyColumnAliases[i] = colAliases;
[address_4_1_]


			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
[[true], [true], [true]]
			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
[[true], [true], [true]]
			propertySelectable[i] = prop.isSelectable();
[[true], [true], [true]]
			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
[false, false, false]


/ dan subclass...

/ t
SingleTableEntityPersister.<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor, Mapping) line: 158	
		super( persistentClass, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
/ D
		propertyTableNumbers = new int[ getPropertySpan() ];
		Iterator iter = persistentClass.getPropertyClosureIterator();
		int i=0;
		while( iter.hasNext() ) {
			Property prop = (Property) iter.next();
			propertyTableNumbers[i++] = persistentClass.getJoinNumber(prop);
[0, 0, 0]

		subclassColumnTableNumberClosure = ArrayHelper.toIntArray(columnJoinNumbers);
[0, 0, 0]
		subclassFormulaTableNumberClosure = ArrayHelper.toIntArray(formulaJoinedNumbers);
[]
		subclassPropertyTableNumberClosure = ArrayHelper.toIntArray(propertyJoinNumbers);
[0, 0, 0]

/ t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 401	

/ volgende, Address	,

			EntityPersister cp = persisterFactory.createEntityPersister(
					model,
					accessStrategy,
					naturalIdAccessStrategy,
					this,
					mapping
			);
/s
SingleTableEntityPersister.<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor, Mapping) line: 148	
		super( persistentClass, cacheAccessStrategy, naturalIdRegionAccessStrategy, factory );
/s
SingleTableEntityPersister(AbstractEntityPersister).<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor) line: 515	
		Iterator iter = persistentClass.getIdentifier().getColumnIterator();
		int i = 0;
		while ( iter.hasNext() ) {
/ 1 while loop	,
			Column col = ( Column ) iter.next();
			rootTableKeyColumnNames[i] = col.getQuotedName( factory.getDialect() );
[id_]
			rootTableKeyColumnReaders[i] = col.getReadExpr( factory.getDialect() );
[id_]
			rootTableKeyColumnReaderTemplates[i] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
[$PlaceHolder$.id_]
			identifierAliases[i] = col.getAlias( factory.getDialect(), persistentClass.getRootTable() );
[id_1_0_]

	iter = persistentClass.getPropertyClosureIterator();
		i = 0;
		boolean foundFormula = false;
		while ( iter.hasNext() ) {
			Property prop = ( Property ) iter.next();
			thisClassProperties.add( prop );
[org.hibernate.mapping.Property(addressLine1)]
			while ( colIter.hasNext() ) {
/ 1 while loop	,
				Selectable thing = ( Selectable ) colIter.next();
				colAliases[k] = thing.getAlias( factory.getDialect() , prop.getValue().getTable() );
				else {
					Column col = (Column)thing;
					colNames[k] = col.getQuotedName( factory.getDialect() );
[address_line1_]
					colReaderTemplates[k] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
[$PlaceHolder$.address_line1_]
					colWriters[k] = col.getWriteExpr();
[?]
				}
				k++;
			}
			propertyColumnNames[i] = colNames;
[[address_line1_], null, null, null]
			propertyColumnFormulaTemplates[i] = formulaTemplates;
[[null], null, null, null]
			propertyColumnReaderTemplates[i] = colReaderTemplates;
[[$PlaceHolder$.address_line1_], null, null, null]
			propertyColumnWriters[i] = colWriters;
[[?], null, null, null]
			propertyColumnAliases[i] = colAliases;
[[address_2_0_], null, null, null]

			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
[[true], null, null, null]
			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
[[true], null, null, null]
			propertySelectable[i] = prop.isSelectable();
[true, false, false, false]
			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
[false, false, false, false]


/ volgende, 
/ Address.employees



		Iterator iter = persistentClass.getIdentifier().getColumnIterator();
		int i = 0;
		while ( iter.hasNext() ) {
/ 1 while loop	,
			int span = prop.getColumnSpan();
0
			propertyColumnSpans[i] = span;
[1, 1, 1, 0]
			propertySubclassNames[i] = prop.getPersistentClass().getEntityName();
[my.test.own.hibernate_collections_xml.Address, my.test.own.hibernate_collections_xml.Address, my.test.own.hibernate_collections_xml.Address, my.test.own.hibernate_collections_xml.Address]

			Iterator colIter = prop.getColumnIterator();
			int k = 0;
			while ( colIter.hasNext() ) {
/ NEE
/ Dat is alleen bij employees	,

			propertyColumnNames[i] = colNames;
[[address_line1_], [zipcoce_], [city_], []]
			propertyColumnFormulaTemplates[i] = formulaTemplates;
[[null], [null], [null], []]
			propertyColumnReaderTemplates[i] = colReaderTemplates;
[[$PlaceHolder$.address_line1_], [$PlaceHolder$.zipcoce_], [$PlaceHolder$.city_], []]
			propertyColumnWriters[i] = colWriters;
[[?], [?], [?], []]
			propertyColumnAliases[i] = colAliases;
[[address_2_0_], [zipcoce_3_0_], [city_4_0_], []]


			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
[[true], [true], [true], []]
			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
[[true], [true], [true], []]
			propertySelectable[i] = prop.isSelectable();
[true, true, true, true]
			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
[false, false, false, false]


/ Dan de collection persister	,

		Iterator collections = cfg.getCollectionMappings();
		while ( collections.hasNext() ) {
			Collection model = (Collection) collections.next();
model	Set  (id=3035)	

			CollectionPersister persister = persisterFactory.createCollectionPersister(
					cfg,
					model,
					accessStrategy,
					this
			) ;
/s
PersisterFactoryImpl.createCollectionPersister(Configuration, Collection, CollectionRegionAccessStrategy, SessionFactoryImplementor) line: 201	
			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getCollectionPersisterClass( collectionMetadata );
persisterClass	Class<T> (org.hibernate.persister.collection.OneToManyPersister) (id=3052)	

		return create( persisterClass, COLLECTION_PERSISTER_CONSTRUCTOR_ARGS, cfg, collectionMetadata, cacheAccessStrategy, factory );
/s
PersisterFactoryImpl.create(Class<CollectionPersister>, Class[], Object, Object, CollectionRegionAccessStrategy, SessionFactoryImplementor) line: 229	
			Constructor<? extends CollectionPersister> constructor = persisterClass.getConstructor( persisterConstructorArgs );
			try {
				return constructor.newInstance( collectionMetadata, cacheAccessStrategy, cfg, factory );
/s
OneToManyPersister.<init>(Collection, CollectionRegionAccessStrategy, Configuration, SessionFactoryImplementor) line: 89	
		super( collection, cacheAccessStrategy, cfg, factory );
/s
OneToManyPersister(AbstractCollectionPersister).<init>(Collection, CollectionRegionAccessStrategy, Configuration, SessionFactoryImplementor) line: 252	

		elementType = collection.getElement().getType();
elementType	ManyToOneType  (id=3124)	

		qualifiedTableName = table.getQualifiedName(
				dialect,
				factory.getSettings().getDefaultCatalogName(),
				factory.getSettings().getDefaultSchemaName()
				);
employee

		keyType = collection.getKey().getType();
/ collection.key=DependantValue
/s
DependantValue.getType() line: 47	
		return wrappedValue.getType();
/s
SimpleValue.getType() line: 314	
		Type result = mappings.getTypeResolver().heuristicType( typeName, typeParameters );
/ typeName="long"
result	LongType  (id=3068)	
/ type waar de fk naar refs	, want collection.wrappedValue=address.id_	,

/t
		iter = collection.getKey().getColumnIterator();
		while ( iter.hasNext() ) {
			// NativeSQL: collect key column and auto-aliases
			Column col = ( (Column) iter.next() );
employee.address_
			keyColumnNames[k] = col.getQuotedName( dialect );
[address_]
			keyColumnAliases[k] = col.getAlias( dialect, collection.getOwner().getRootTable() );
[address_4_0_]

/ In een collection (Set) heb je een <key  en een <one-to-many class="Employee"	, dat laatste noemen ze een element	,

		// ELEMENT

		String elemNode = collection.getElementNodeName();
null
		if ( elementType.isEntityType() ) {
/ JA
elementType	ManyToOneType  (id=3124)	
			String entityName = ( (EntityType) elementType ).getAssociatedEntityName();
Employee
			elementPersister = factory.getEntityPersister( entityName );
elementPersister	SingleTableEntityPersister  (id=1999)	
			if ( elemNode == null ) {
				elemNode = cfg.getClassMapping( entityName ).getNodeName();
/ cfg.getClassMapping( entityName )=RootClass
"Employee"

		elementNodeName = elemNode;
		iter = collection.getElement().getColumnIterator();
/  collection.getElement()=OneToMany inst	, <one-to-many class="Employee"
		while ( iter.hasNext() ) {
/ 1 while loop	,
			Selectable selectable = (Selectable) iter.next();
Column(id_), van employee	,
			elementColumnAliases[j] = selectable.getAlias( dialect, table );
[id_1_1_]
			else {
				Column col = (Column) selectable;
				elementColumnNames[j] = col.getQuotedName( dialect );
[id_]
				elementColumnWriters[j] = col.getWriteExpr();
[?]
				elementColumnReaders[j] = col.getReadExpr( dialect );
[id_]
				elementColumnReaderTemplates[j] = col.getTemplate( dialect, factory.getSqlFunctionRegistry() );
[$PlaceHolder$.id_]
				elementColumnIsSettable[j] = true;
[true]
				elementColumnIsInPrimaryKey[j] = !col.isNullable();
[true]
				if ( !col.isNullable() ) {
/ JA
					hasNotNullableColumns = true;
				}
				isPureFormula = false;

//////////////////////////////////////
/ Hier zien we dus dat in de Set <one-to-many class="Employee"> -> id_ van employee 
/ TODO

		if ( collection.getCustomSQLInsert() == null ) {
/ JA
			sqlInsertRowString = generateInsertRowString();
/s
OneToManyPersister.generateInsertRowString() line: 124	
		Update update = new Update( getDialect() )
				.setTableName( qualifiedTableName )
				.addColumns( keyColumnNames );
update	Update  (id=1751)	
	columns	LinkedHashMap<K,V>  (id=1752)	
{address_=?}
	primaryKeyColumns	LinkedHashMap<K,V>  (id=1753)	
{}
	tableName	"employee" (id=1700)	
employee
	whereColumns	LinkedHashMap<K,V>  (id=1754)	
null

		return update.addPrimaryKeyColumns( elementColumnNames, elementColumnWriters ).toStatementString();

/t
OneToManyPersister(AbstractCollectionPersister).<init>(Collection, CollectionRegionAccessStrategy, Configuration, SessionFactoryImplementor) line: 482	
			sqlInsertRowString = generateInsertRowString();
sqlInsertRowString	"update employee set address_=? where id_=?" (id=1791)	

			insertCallable = false;
			insertCheckStyle = ExecuteUpdateResultCheckStyle.COUNT;
		}

		if ( collection.getCustomSQLUpdate() == null ) {
			sqlUpdateRowString = generateUpdateRowString();
update employee set  where id_=?
/ TODO
			updateCallable = false;
			updateCheckStyle = ExecuteUpdateResultCheckStyle.COUNT;
		}


		if ( collection.getCustomSQLDelete() == null ) {
			sqlDeleteRowString = generateDeleteRowString();
update employee set address_=null where address_=? and id_=?
			deleteCallable = false;
			deleteCheckStyle = ExecuteUpdateResultCheckStyle.NONE;
		}

		if ( collection.getCustomSQLDeleteAll() == null ) {
			sqlDeleteString = generateDeleteString();
update employee set address_=null where address_=?
			deleteAllCallable = false;
			deleteAllCheckStyle = ExecuteUpdateResultCheckStyle.NONE;
		}

		sqlSelectSizeString = generateSelectSizeString( collection.isIndexed() && !collection.isMap() );
select count(id_) from employee where address_ =?
		sqlDetectRowByIndexString = generateDetectRowByIndexString();
null
		sqlDetectRowByElementString = generateDetectRowByElementString();
select 1 from employee where address_ =? and id_ =?
		sqlSelectRowByIndexString = generateSelectRowByIndexString();
null

		isLazy = collection.isLazy();
true
		isExtraLazy = collection.isExtraLazy();
false
		isInverse = collection.isInverse();
true
		else {
			if ( elementPersister instanceof PropertyMapping ) { // not all classpersisters implement PropertyMapping!
/ JA	,
SingleTableEntityPersister(my.test.own.hibernate_collections_xml.Employee)
				elementPropertyMapping = (PropertyMapping) elementPersister;

		filterHelper = new FilterHelper( collection.getFilters(), factory);
org.hibernate.internal.FilterHelper@6a40c3b5

		// Handle any filters applied to this collection for many-to-many
		manyToManyFilterHelper = new FilterHelper( collection.getManyToManyFilters(), factory);
org.hibernate.internal.FilterHelper@18b9ae20

		manyToManyWhereString = StringHelper.isNotEmpty( collection.getManyToManyWhere() ) ?
				"( " + collection.getManyToManyWhere() + ")" :
				null;
null
		manyToManyWhereTemplate = manyToManyWhereString == null ?
				null :
				Template.renderWhereStringTemplate( manyToManyWhereString, factory.getDialect(), factory.getSqlFunctionRegistry() );
null

		hasManyToManyOrder = collection.getManyToManyOrdering() != null;
false

		initCollectionPropertyMap();
/s
OneToManyPersister(AbstractCollectionPersister).initCollectionPropertyMap() line: 1884	

		initCollectionPropertyMap( "key", keyType, keyColumnAliases, keyColumnNames );
keyType=org.hibernate.type.LongType@36293b29
keyColumnAliases=[address_4_0_]
keyColumnNames=[address_]
/s
OneToManyPersister(AbstractCollectionPersister).initCollectionPropertyMap(String, Type, String[], String[]) line: 1900	
		collectionPropertyColumnAliases.put( aliasName, columnAliases );
{key=[address_4_0_]}
		collectionPropertyColumnNames.put( aliasName, columnNames );
{key=[address]}

/t
OneToManyPersister(AbstractCollectionPersister).initCollectionPropertyMap() line: 1885	
		initCollectionPropertyMap( "element", elementType, elementColumnAliases, elementColumnNames );
/ elementType=org.hibernate.type.ManyToOneType(my.test.own.hibernate_collections_xml.Employee)
/ elementColumnAliases=[id_1_1_]
/ elementColumnNames=[id_]
/s
OneToManyPersister(AbstractCollectionPersister).initCollectionPropertyMap(String, Type, String[], String[]) line: 1900	

		collectionPropertyColumnAliases.put( aliasName, columnAliases );
{element=[id_1_1_], key=[address_4_0_]
		collectionPropertyColumnNames.put( aliasName, columnNames );
{element=[id_], key=[address_]

/t
OneToManyPersister.<init>(Collection, CollectionRegionAccessStrategy, Configuration, SessionFactoryImplementor) line: 90	
	super...
/ D
		cascadeDeleteEnabled = collection.getKey().isCascadeDeleteEnabled() &&
				factory.getDialect().supportsCascadeDelete();
false
		keyIsNullable = collection.getKey().isNullable();
true
		keyIsUpdateable = collection.getKey().isUpdateable();
true

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 436	
			CollectionPersister persister = persisterFactory.createCollectionPersister(
					cfg,
					model,
					accessStrategy,
					this
			) ;
/ D
			collectionPersisters.put( model.getRole(), persister );
{my.test.own.hibernate_collections_xml.Address.employees=OneToManyPersister(my.test.own.hibernate_collections_xml.Address.employees)}
			tmpCollectionMetadata.put( model.getRole(), persister.getCollectionMetadata() );
/ hetzelfde	,

			Type indexType = persister.getIndexType();
			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
/ NEE

			Type elementType = persister.getElementType();
org.hibernate.type.ManyToOneType(my.test.own.hibernate_collections_xml.Employee)
			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
/ JA
				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
my.test.own.hibernate_collections_xml.Employee
				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
null
				if ( roles == null ) {
/ JA
					roles = new HashSet();
					tmpEntityToCollectionRoleMap.put( entityName, roles );
{my.test.own.hibernate_collections_xml.Employee=[my.test.own.hibernate_collections_xml.Address.employees]}

				roles.add( persister.getRole() );
/ TODO

		collectionMetadata = Collections.unmodifiableMap( tmpCollectionMetadata );
{my.test.own.hibernate_collections_xml.Address.employees=OneToManyPersister(my.test.own.hibernate_collections_xml.Address.employees)}

		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
		while ( itr.hasNext() ) {
			final Map.Entry entry = ( Map.Entry ) itr.next();
my.test.own.hibernate_collections_xml.Employee=[my.test.own.hibernate_collections_xml.Address.employees]	/ string=[string]
			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
		}
/ tmpEntityToCollectionRoleMap={my.test.own.hibernate_collections_xml.Employee=[my.test.own.hibernate_collections_xml.Address.employees]}

		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );



		// after *all* persisters and named queries are registered
		for ( EntityPersister persister : entityPersisters.values() ) {
SingleTableEntityPersister(my.test.own.hibernate_collections_xml.Employee)
			persister.generateEntityDefinition();
/s
SingleTableEntityPersister(AbstractEntityPersister).generateEntityDefinition() line: 5324	
		prepareEntityIdentifierDefinition();
/ NIETS
		collectAttributeDefinitions();
/s
SingleTableEntityPersister(AbstractEntityPersister).collectAttributeDefinitions() line: 5431	

		Map<String,AttributeDefinition> attributeDefinitionsByName = new LinkedHashMap<String,AttributeDefinition>();
		collectAttributeDefinitions( attributeDefinitionsByName, getEntityMetamodel() );
/  attributeDefinitionsByName={}
/  getEntityMetamodel()=EntityMetamodel(my.test.own.hibernate_collections_xml.Employee:[
Attribute(name=name type=string [non-identifier])
Attribute(name=salary type=double [non-identifier])
Attribute(name=address type=my.test.own.hibernate_collections_xml.Address [non-identifier association])])

		this.attributeDefinitions = Collections.unmodifiableList(
				new ArrayList<AttributeDefinition>( attributeDefinitionsByName.values() )

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 477	

/ volgende	,
		for ( EntityPersister persister : entityPersisters.values() ) {
SingleTableEntityPersister(my.test.own.hibernate_collections_xml.Address)
			persister.generateEntityDefinition();
/ uses	net als bij Employee,
EntityMetamodel(my.test.own.hibernate_collections_xml.Address:[Attribute(name=addressLine1, type=string [non-identifier]),Attribute(name=zipcode, type=string [non-identifier]),Attribute(name=city, type=string [non-identifier]),Attribute(name=employees, type=java.util.Set(my.test.own.hibernate_collections_xml.Address.employees) [non-identifier,association])])


		for ( EntityPersister persister : entityPersisters.values() ) {
			persister.postInstantiate();
/ creates loaders	,
			registerEntityNameResolvers( persister );
		}
/ TODO
		for ( CollectionPersister persister : collectionPersisters.values() ) {
			persister.postInstantiate();
		}
/ TODO

		//JNDI + Serialization:

		SessionFactoryRegistry.INSTANCE.addSessionFactory(
				uuid,
				name,
				settings.isSessionFactoryNameAlsoJndiName(),
				this,
this	SessionFactoryImpl  (id=1607)	
				serviceRegistry.getService( JndiService.class )
		);

		settings.getMultiTableBulkIdStrategy().prepare(
				jdbcServices,
				buildLocalConnectionAccess(),
				cfg.createMappings(),
				cfg.buildMapping(),
				properties
		);

///////////////////////////////////////////////////////////////////////////////////
/ we zijn in 	,
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 517	
		if ( settings.isAutoCreateSchema() ) {
/ JA
			new SchemaExport( serviceRegistry, cfg )
					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
					.create( false, true );
/s
SchemaExport.<init>(ServiceRegistry, Configuration) line: 103	

		this.connectionHelper = new SuppliedConnectionProviderConnectionHelper(
				serviceRegistry.getService( ConnectionProvider.class )
		);
this	SchemaExport  (id=2221)	
	connectionHelper	SuppliedConnectionProviderConnectionHelper  (id=2227)	
		connection	null	
		provider	DriverManagerConnectionProviderImpl  (id=1562)	
		toggleAutoCommit	false	


		this.sqlStatementLogger = serviceRegistry.getService( JdbcServices.class ).getSqlStatementLogger();
this	SchemaExport  (id=2221)	
	sqlStatementLogger	SqlStatementLogger  (id=2264)	
		format	false	
		logToStdout	true	

		this.formatter = ( sqlStatementLogger.isFormat() ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
this	SchemaExport  (id=2221)	
	formatter	FormatStyle$NoFormatImpl  (id=2281)	

		this.sqlExceptionHelper = serviceRegistry.getService( JdbcServices.class ).getSqlExceptionHelper();
this	SchemaExport  (id=2221)	
	sqlExceptionHelper	SqlExceptionHelper  (id=1707)	
		sqlExceptionConverter	StandardSQLExceptionConverter  (id=2311)	
			delegates	ArrayList<E>  (id=2315)	
				elementData	Object[10]  (id=2317)	
					[0]	PostgreSQL81Dialect$2  (id=2322)	
					[1]	SQLExceptionTypeDelegate  (id=2323)	
					[2]	SQLStateConversionDelegate  (id=2330)	

		this.importFiles = ConfigurationHelper.getString(
				AvailableSettings.HBM2DDL_IMPORT_FILES,
				configuration.getProperties(),
				DEFAULT_IMPORT_FILE
importFiles	"/import.sql" (id=2400)	

		final Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();
		this.dropSQL = configuration.generateDropSchemaScript( dialect );
/s
Configuration.generateDropSchemaScript(Dialect) line: 972	
		secondPassCompile();
/ doet WH NIETS

		if ( dialect.dropConstraints() ) {
			Iterator itr = getTableMappings();
			while ( itr.hasNext() ) {
				Table table = (Table) itr.next();
org.hibernate.mapping.Table(address)
org.hibernate.mapping.Table(employee)
				if ( table.isPhysicalTable() ) {
					Iterator subItr = table.getForeignKeyIterator();
					while ( subItr.hasNext() ) {
/ NEE , address
/ JA, employee
						ForeignKey fk = (ForeignKey) subItr.next();
org.hibernate.mapping.ForeignKey(employee[org.hibernate.mapping.Column(address_)]) as FK_lcwyx1va36145pv0w7f8dxqc8
						if ( fk.isPhysicalConstraint() ) {
							script.add(
									fk.sqlDropString(
											dialect,
											defaultCatalog,
											defaultSchema
										)
								);
/s
ForeignKey.sqlDropString(Dialect, String, String) line: 130	
		final StringBuilder buf = new StringBuilder( "alter table " );
		buf.append( getTable().getQualifiedName(dialect, defaultCatalog, defaultSchema) );
alter table employee
		buf.append( dialect.getDropForeignKeyString() );
alter table employee drop constraint 
		if ( dialect.supportsIfExistsBeforeConstraintName() ) {
/ NEE
		buf.append( dialect.quote( getName() ) );
alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8

/t
script	ArrayList<E>  (id=3438)	
[alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8]

		Iterator itr = getTableMappings();
		while ( itr.hasNext() ) {
			Table table = (Table) itr.next();
org.hibernate.mapping.Table(address)
org.hibernate.mapping.Table(employee)
			if ( table.isPhysicalTable() ) {
				script.add(
						table.sqlDropString(
								dialect,
								defaultCatalog,
								defaultSchema
							)
					);

			}
script	ArrayList<E>  (id=3438)	
[alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8, drop table if exists address cascade, drop table if exists employee cascade]

tr = iterateGenerators( dialect );
		while ( itr.hasNext() ) {
/ NEE
		return ArrayHelper.toStringArray( script );

/t
SchemaExport.<init>(ServiceRegistry, Configuration) line: 124	
		this.dropSQL = configuration.generateDropSchemaScript( dialect );
/ D
		this.createSQL = configuration.generateSchemaCreationScript( dialect );
/s
Configuration.generateSchemaCreationScript(Dialect) line: 1059	

		Iterator iter = getTableMappings();
		while ( iter.hasNext() ) {
			Table table = (Table) iter.next();
			if ( table.isPhysicalTable() ) {
				script.add(
						table.sqlCreateString(
								dialect,
								mapping,
								defaultCatalog,
								defaultSchema
							)
					);
/s
Table.sqlCreateString(Dialect, Mapping, String, String) line: 489	
/=
	public String sqlCreateString(Dialect dialect, Mapping p, String defaultCatalog, String defaultSchema) {
/ p=configuration	,

		StringBuilder buf = new StringBuilder( hasPrimaryKey() ? dialect.getCreateTableString() : dialect.getCreateMultisetTableString() )
				.append( ' ' )
				.append( getQualifiedName( dialect, defaultCatalog, defaultSchema ) )
				.append( " (" );
create table address (

		boolean identityColumn = idValue != null && idValue.isIdentityColumn( p.getIdentifierGeneratorFactory(), dialect );
false
/ TODO
idValue=org.hibernate.mapping.SimpleValue([org.hibernate.mapping.Column(id_)])

		Iterator iter = getColumnIterator();
		while ( iter.hasNext() ) {
			Column col = (Column) iter.next();

			buf.append( col.getQuotedName( dialect ) )
					.append( ' ' );
create table address (id_ 
			else {

				buf.append( col.getSqlType( dialect, p ) );
/s
Column.getSqlType(Dialect, Mapping) line: 228	
        if ( sqlType == null ) {
            sqlType = dialect.getTypeName( getSqlTypeCode( mapping ), getLength(), getPrecision(), getScale() );
/s
Column.getSqlTypeCode(Mapping) line: 189	
        org.hibernate.type.Type type = getValue().getType();
/s
SimpleValue.getType() line: 314	
		Type result = mappings.getTypeResolver().heuristicType( typeName, typeParameters );
this.typeName="long"
		return result;
LongType inst	,

/t
       org.hibernate.type.Type type = getValue().getType();
/ D
        try {
            int sqlTypeCode = type.sqlTypes( mapping )[getTypeIndex()];
-5
            return sqlTypeCode;

/t
            sqlType = dialect.getTypeName( getSqlTypeCode( mapping ), getLength(), getPrecision(), getScale() );
this	Column  (id=3501)	
getSqlTypeCode( mapping )==-5
getLength()=255
getPrecision()=19
getScale() =2
/s
PostgreSQLDialect(Dialect).getTypeName(int, long, int, int) line: 330	
/=
	public String getTypeName(int code, long length, int precision, int scale) throws HibernateException {
		final String result = typeNames.get( code, length, precision, scale );
this	PostgreSQLDialect  (id=1692)	
	typeNames	TypeNames  (id=3533)	
		defaults	HashMap<K,V>  (id=3535)	
{1=char(1), 2=numeric($p, $s), 4=int4, 5=int2, 6=float4, 7=real, 8=float8, 12=varchar($l), -16=nvarchar($l), 16=boolean, -15=nchar($l), -9=nvarchar($l), 93=timestamp, 92=time, -7=bool, 1111=uuid, -6=int2, -5=int8, -4=bytea, -3=bytea, -2=bytea, 91=date, -1=text, 2004=oid, 2005=text, 2011=nclob}
		weighted	HashMap<K,V>  (id=3536)	
{}
/s
TypeNames.get(int, long, int, int) line: 105	
		return replace( get( typeCode ), size, precision, scale );
get( typeCode )="int8"
/t
/s
	private static String replace(String type, long size, int precision, int scale) {
		type = StringHelper.replaceOnce( type, "$s", Integer.toString( scale ) );
		type = StringHelper.replaceOnce( type, "$l", Long.toString( size ) );
		return StringHelper.replaceOnce( type, "$p", Integer.toString( precision ) );
/ $s, $l, $p staan niet in "int8", dus gebeurt hier niets	,

/t
Table.sqlCreateString(Dialect, Mapping, String, String) line: 513	
				buf.append( col.getSqlType( dialect, p ) );
/ D
create table address (id_ int8

				if ( col.isNullable() ) {
/ NEE
				else {
					buf.append( " not null" );

			if ( col.isUnique() ) {
/ NEE
			if ( iter.hasNext() ) {
/ JA
				buf.append( ", " );


/ volgende	,
	Iterator iter = getColumnIterator();
		while ( iter.hasNext() ) {
			Column col = (Column) iter.next();
org.hibernate.mapping.Column(address_line1_)

/ volgende	,
	Iterator iter = getColumnIterator();
		while ( iter.hasNext() ) {
			Column col = (Column) iter.next();
col=org.hibernate.mapping.Column(zipcoce_)
...
			else {
				buf.append( col.getSqlType( dialect, p ) );
...
/s
  public String getSqlType(Dialect dialect, Mapping mapping) throws HibernateException {
        if ( sqlType == null ) {
            sqlType = dialect.getTypeName( getSqlTypeCode( mapping ), getLength(), getPrecision(), getScale() );
/s
Column.getSqlTypeCode(Mapping) line: 191	
            int sqlTypeCode = type.sqlTypes( mapping )[getTypeIndex()];
sqlTypeCode	12	
            return sqlTypeCode;
/s
/t
           sqlType = dialect.getTypeName( getSqlTypeCode( mapping ), getLength(), getPrecision(), getScale() );
/s
PostgreSQLDialect(Dialect).getTypeName(int, long, int, int) line: 330	
		final String result = typeNames.get( code, length, precision, scale );
this	PostgreSQLDialect  (id=1692)	
	typeNames	TypeNames  (id=3533)	
		defaults	HashMap<K,V>  (id=3535)	
{1=char(1), 2=numeric($p, $s), 4=int4, 5=int2, 6=float4, 7=real, 8=float8, 12=varchar($l), -16=nvarchar($l), 16=boolean, -15=nchar($l), -9=nvarchar($l), 93=timestamp, 92=time, -7=bool, 1111=uuid, -6=int2, -5=int8, -4=bytea, -3=bytea, -2=bytea, 91=date, -1=text, 2004=oid, 2005=text, 2011=nclob}
/s
TypeNames.get(int, long, int, int) line: 105	
		return replace( get( typeCode ), size, precision, scale );
/s
	private static String replace(String type, long size, int precision, int scale) {
type="varchar($l)"
		type = StringHelper.replaceOnce( type, "$s", Integer.toString( scale ) );
		type = StringHelper.replaceOnce( type, "$l", Long.toString( size ) );
type	"varchar(255)" (id=3630)	
		return StringHelper.replaceOnce( type, "$p", Integer.toString( precision ) );

/ volgende	, 
	Iterator iter = getColumnIterator();
		while ( iter.hasNext() ) {
/ NEE
/ employees heeft geen Column	,

		if ( hasPrimaryKey() ) {
/ JA
			buf.append( ", " )
					.append( getPrimaryKey().sqlConstraintString( dialect ) );
/ TODO
buf	StringBuilder  (id=3475)	
create table address (id_ int8 not null, address_line1_ varchar(255), zipcoce_ varchar(255), city_ varchar(255), primary key (id_)

		buf.append( ')' );
		return buf.append( dialect.getTableTypeString() ).toString();
dialect.getTableTypeString() =""

/t
Configuration.generateSchemaCreationScript(Dialect) line: 1069	
		Iterator iter = getTableMappings();
		while ( iter.hasNext() ) {
			Table table = (Table) iter.next();
			if ( table.isPhysicalTable() ) {
				script.add(
						table.sqlCreateString(
								dialect,
								mapping,
								defaultCatalog,
								defaultSchema
							)
					);
/ D
script	ArrayList<E>  (id=3484)	
[create table address (id_ int8 not null, address_line1_ varchar(255), zipcoce_ varchar(255), city_ varchar(255), primary key (id_))]

/ volgende	,
		Iterator iter = getTableMappings();
		while ( iter.hasNext() ) {
			Table table = (Table) iter.next();
org.hibernate.mapping.Table(employee)
			if ( table.isPhysicalTable() ) {
				script.add(
						table.sqlCreateString(
								dialect,
								mapping,
								defaultCatalog,
								defaultSchema
							)
					);
/s
Table.sqlCreateString(Dialect, Mapping, String, String) line: 496	
	Iterator iter = getColumnIterator();
		while ( iter.hasNext() ) {
			Column col = (Column) iter.next();
org.hibernate.mapping.Column(address_)
/ we kijken alleen naar deze	, want  int8, float8 is wel OK	,

			buf.append( col.getQuotedName( dialect ) )
					.append( ' ' );
create table employee (id_ int8 not null, name_ varchar(255), salary_ float8, address_ 

			else {
				buf.append( col.getSqlType( dialect, p ) );
/s
  public String getSqlType(Dialect dialect, Mapping mapping) throws HibernateException {
        if ( sqlType == null ) {
            sqlType = dialect.getTypeName( getSqlTypeCode( mapping ), getLength(), getPrecision(), getScale() );
/s
   public int getSqlTypeCode(Mapping mapping) throws MappingException {
        org.hibernate.type.Type type = getValue().getType();
/ value=ManyToOne inst	,
/s
ManyToOne.getType() line: 47	
		return getMappings().getTypeResolver().getTypeFactory().manyToOne(
				getReferencedEntityName(),
my.test.own.hibernate_collections_xml.Address
				referenceToPrimaryKey, 
true
				getReferencedPropertyName(),
null
				isLazy(),
true
				isUnwrapProxy(),
false
				isIgnoreNotFound(),
false
				isLogicalOneToOne
false
		);
/s
TypeFactory.manyToOne(String, boolean, String, boolean, boolean, boolean, boolean) line: 364	

		return new ManyToOneType(
				typeScope,
				persistentClass,
				referenceToPrimaryKey,
				uniqueKeyPropertyName,
				lazy,
				unwrapProxy,
				ignoreNotFound,
				isLogicalOneToOne
		);

/t
Column.getSqlTypeCode(Mapping) line: 191	
       org.hibernate.type.Type type = getValue().getType();
/ D
           int sqlTypeCode = type.sqlTypes( mapping )[getTypeIndex()];
/s
ManyToOneType.sqlTypes(Mapping) line: 146	

		return getIdentifierOrUniqueKeyType( mapping ).sqlTypes( mapping );
/s
ManyToOneType(EntityType).getIdentifierOrUniqueKeyType(Mapping) line: 671	
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
/ JA
			return getIdentifierType(factory);
/s
ManyToOneType(EntityType).getIdentifierType(Mapping) line: 630	
		final Type type = associatedIdentifierType;
type	LongType  (id=1703)	
	return type
/s
	public final int[] sqlTypes(Mapping mapping) throws MappingException {
		return sqlTypes;
[-5]

/t
Column.getSqlTypeCode(Mapping) line: 191	
           int sqlTypeCode = type.sqlTypes( mapping )[getTypeIndex()];
/ D  type.sqlTypes( mapping )
getTypeIndex()=0
-5
            return sqlTypeCode;

/t
Column.getSqlType(Dialect, Mapping) line: 229	
            sqlType = dialect.getTypeName( getSqlTypeCode( mapping ), getLength(), getPrecision(), getScale() );
"int8"

/t
Table.sqlCreateString(Dialect, Mapping, String, String) line: 514	
			else {

				buf.append( col.getSqlType( dialect, p ) );
/ D
create table employee (id_ int8 not null, name_ varchar(255), salary_ float8, address_ int8

				else {
					buf.append( " not null" );
/ klopt, in mapping	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	></many-to-one>

/ Dan	,
		if ( hasPrimaryKey() ) {
			buf.append( ", " )
					.append( getPrimaryKey().sqlConstraintString( dialect ) );
/s
PrimaryKey.sqlConstraintString(Dialect) line: 36	

		StringBuilder buf = new StringBuilder("primary key (");
		Iterator iter = getColumnIterator();
		while ( iter.hasNext() ) {
			buf.append( ( (Column) iter.next() ).getQuotedName(dialect) );
			if ( iter.hasNext() ) buf.append(", ");
		}
		return buf.append(')').toString();

/t
Table.sqlCreateString(Dialect, Mapping, String, String) line: 556	
create table employee (id_ int8 not null, name_ varchar(255), salary_ float8, address_ int8 not null, primary key (id_)

		buf.append( ')' );

/t
Configuration.generateSchemaCreationScript(Dialect) line: 1077	

		iter = getTableMappings();
		while ( iter.hasNext() ) {
			Table table = (Table) iter.next();
org.hibernate.mapping.Table(address)
org.hibernate.mapping.Table(employee)
				Iterator subIter = table.getUniqueKeyIterator();
				while ( subIter.hasNext() ) {
/ NEE
				subIter = table.getIndexIterator();
				while ( subIter.hasNext() ) {
/ NEE

		// Foreign keys must be created *after* unique keys for numerous DBs.  See HH-8390.
		iter = getTableMappings();
		while ( iter.hasNext() ) {
			Table table = (Table) iter.next();
			if ( table.isPhysicalTable() ) {
org.hibernate.mapping.Table(address)
org.hibernate.mapping.Table(employee)
				if ( dialect.hasAlterTable() ) {
/ JA
					Iterator subIter = table.getForeignKeyIterator();
					while ( subIter.hasNext() ) {
/ JA, employee
						ForeignKey fk = (ForeignKey) subIter.next();
						if ( fk.isPhysicalConstraint() ) {
/ JA
							script.add(
									fk.sqlCreateString(
											dialect, mapping,
											defaultCatalog,
											defaultSchema
										)
								);
/s
ForeignKey(Constraint).sqlCreateString(Dialect, Mapping, String, String) line: 201	

		if ( isGenerated( dialect ) ) {
/ JA
			// Certain dialects (ex: HANA) don't support FKs as expected, but other constraints can still be created.
			// If that's the case, hasAlterTable() will be true, but getAddForeignKeyConstraintString will return
			// empty string.  Prevent blank "alter table" statements.
			String constraintString = sqlConstraintString( dialect, getName(), defaultCatalog, defaultSchema );
constraintString	" add constraint FK_lcwyx1va36145pv0w7f8dxqc8 foreign key (address_) references address" (id=3719)	

			if ( !StringHelper.isEmpty( constraintString ) ) {
				StringBuilder buf = new StringBuilder( "alter table " )
						.append( getTable().getQualifiedName( dialect, defaultCatalog, defaultSchema ) )
						.append( constraintString );
alter table employee add constraint FK_lcwyx1va36145pv0w7f8dxqc8 foreign key (address_) references address

/ t
Configuration.generateSchemaCreationScript(Dialect) line: 1135	
							script.add(
									fk.sqlCreateString(
											dialect, mapping,
											defaultCatalog,
											defaultSchema
										)
								);
/ D
script=[create table address (id_ int8 not null, address_line1_ varchar(255), zipcoce_ varchar(255), city_ varchar(255), primary key (id_)), create table employee (id_ int8 not null, name_ varchar(255), salary_ float8, address_ int8 not null, primary key (id_)), alter table employee add constraint FK_lcwyx1va36145pv0w7f8dxqc8 foreign key (address_) references address]

/t
SchemaExport.<init>(ServiceRegistry, Configuration) line: 125	
		this.createSQL = configuration.generateSchemaCreationScript( dialect );
/ D
this	SchemaExport  (id=2221)	
	createSQL	String[3]  (id=3733)	
[create table address (id_ int8 not null, address_line1_ varchar(255), zipcoce_ varchar(255), city_ varchar(255), primary key (id_)), create table employee (id_ int8 not null, name_ varchar(255), salary_ float8, address_ int8 not null, primary key (id_)), alter table employee add constraint FK_lcwyx1va36145pv0w7f8dxqc8 foreign key (address_) references address]

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 517	
			new SchemaExport( serviceRegistry, cfg )
/ D
					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
					.create( false, true );
/s
SchemaExport.create(boolean, boolean) line: 293	
		create( Target.interpret( script, export ) );
export=true
/s
Target.interpret(boolean, boolean) line: 44	
/=
	public static Target interpret(boolean script, boolean export) {
script=false	, 6 regels hierboven set	,
		if ( script ) {
/ NEE
		else {
			return export ? EXPORT : NONE;
EXPORT

/t
/s
SchemaExport.create(Target) line: 304	
/=
	public void create(Target output) {
		// need to drop tables before creating so need to specify Type.BOTH
		execute( output, Type.BOTH );
/s
SchemaExport.execute(Target, SchemaExport$Type) line: 338	
/=
	public void execute(Target output, Type type) {
output=EXPORT
type=BOTH

		final List<NamedReader> importFileReaders = new ArrayList<NamedReader>();
		for ( String currentFile : importFiles.split(",") ) {
this	SchemaExport  (id=2221)	
	importFiles	"/import.sql" (id=2400)	
/ hebben we niet	,

			try {
				final String resourceName = currentFile.trim();
				InputStream stream = ConfigHelper.getResourceAsStream( resourceName );
			}
			catch ( HibernateException e ) {
/ we komen HIER	,
org.hibernate.HibernateException: /import.sql not found
				LOG.debugf("Import file not found: %s", currentFile);

		final List<Exporter> exporters = new ArrayList<Exporter>();
		try {

/ output=EXPORT
/ type=BOTH

			// prepare exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if ( output.doScript() ) {
/ NEE,
/s
Target.doScript() line: 40	
		return this == BOTH || this == SCRIPT;
/ het is EXPORT

/t
			if ( outputFile != null ) {
/ NEE
			if ( output.doExport() ) {
/ JA
/s
		return this == BOTH || this == EXPORT;

				exporters.add( new DatabaseExporter( connectionHelper, sqlExceptionHelper ) );
this	SchemaExport  (id=2221)	
	connectionHelper	SuppliedConnectionProviderConnectionHelper  (id=3730)	
	sqlExceptionHelper	SqlExceptionHelper  (id=1707)	
/s
DatabaseExporter.<init>(ConnectionHelper, SqlExceptionHelper) line: 49	
		connectionHelper.prepare( true );
/ sets autocommit=true

/s
SuppliedConnectionProviderConnectionHelper.prepare(boolean) line: 51	
/=
	public void prepare(boolean needsAutoCommit) throws SQLException {
needsAutoCommit=true

		connection = provider.getConnection();
/s
DriverManagerConnectionProviderImpl.getConnection() line: 227	
		if ( (connection = connections.poll()) == null ) {
		return connection;

/t
SuppliedConnectionProviderConnectionHelper.prepare(boolean) line: 52	

		connection = provider.getConnection();
/ D
		toggleAutoCommit = needsAutoCommit && !connection.getAutoCommit();
true
		if ( toggleAutoCommit ) {
/ JA
			try {
				connection.commit();
			}
			catch( Throwable ignore ) {
				// might happen with a managed connection
			}
			connection.setAutoCommit( true );
/t
DatabaseExporter.<init>(ConnectionHelper, SqlExceptionHelper) line: 53	
		connectionHelper.prepare( true );
/ D
		connection = connectionHelper.getConnection();
/s
SuppliedConnectionProviderConnectionHelper.getConnection() line: 65	
	return connection;
/t

		statement = connection.createStatement();
/s
Jdbc4Connection(AbstractJdbc2Connection).createStatement() line: 310	
        // We now follow the spec and default to TYPE_FORWARD_ONLY.
        return createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY);

/t
SchemaExport.execute(Target, SchemaExport$Type) line: 367	
			if ( output.doExport() ) {
				exporters.add( new DatabaseExporter( connectionHelper, sqlExceptionHelper ) );
/ D
			// perform exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if ( type.doDrop() ) {
/s
SchemaExport$Type.doDrop() line: 89	
			return this == BOTH || this == DROP;

/t
SchemaExport.execute(Target, SchemaExport$Type) line: 372	
			if ( type.doDrop() ) {
/ JA
				perform( dropSQL, exporters );
/s
SchemaExport.perform(String[], List<Exporter>) line: 410	
		for ( String sqlCommand : sqlCommands ) {
[alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8, drop table if exists address cascade, drop table if exists employee cascade]

			String formatted = formatter.format( sqlCommand );
alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8

			sqlStatementLogger.logStatement( sqlCommand, formatter );
/ We zien in de console	,
HibernateLog --> 15:00:13 DEBUG org.hibernate.SQL - alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8
Hibernate: alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8

			for ( Exporter exporter : exporters ) {
				try {
					exporter.export( formatted );
/s
DatabaseExporter.export(String) line: 64	
		statement.executeUpdate( string );
string	"alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8" (id=3456)	

/ we hadden table employee al rm	,

/t
SchemaExport.perform(String[], List<Exporter>) line: 424	
			try {
					exporter.export( formatted );
				}
				catch (Exception e) {
org.postgresql.util.PSQLException: ERROR: relation "employee" does not exist

					if ( haltOnError ) {
/ NEE
						throw new HibernateException( "Error during DDL export", e );
					}
					exceptions.add( e );
					LOG.unsuccessfulCreate( sqlCommand );
					LOG.error( e.getMessage() );
/ we zien in console	,
HibernateLog --> 15:13:14 ERROR org.hibernate.tool.hbm2ddl.SchemaExport - HHH000389: Unsuccessful: alter table employee drop constraint FK_lcwyx1va36145pv0w7f8dxqc8
HibernateLog --> 15:13:16 ERROR org.hibernate.tool.hbm2ddl.SchemaExport - ERROR: relation "employee" does not exist

/ we zijn nog in	,
	private void perform(String[] sqlCommands, List<Exporter> exporters) {
/ volgende	,
		for ( String sqlCommand : sqlCommands ) {
sqlCommand	"drop table if exists address cascade" (id=3457)	
/ TODO (cascade)
			String formatted = formatter.format( sqlCommand );
	        if ( delimiter != null ) {
				formatted += delimiter;
			}
			sqlStatementLogger.logStatement( sqlCommand, formatter );
			for ( Exporter exporter : exporters ) {
				try {
					exporter.export( formatted );
/s
DatabaseExporter.export(String) line: 68	

		statement.executeUpdate( string );
		try {
			SQLWarning warnings = statement.getWarnings();
warnings	PSQLWarning  (id=3827)	
NOTICE: table "employee" does not exist, skipping

			if ( warnings != null) {
				sqlExceptionHelper.logAndClearWarnings( connection );
/t
SchemaExport.perform(String[], List<Exporter>) line: 430	
					exporter.export( formatted );
/ D
				}
				catch (Exception e) {
/ NEE



/ volgende	,
		for ( String sqlCommand : sqlCommands ) {
sqlCommand	"drop table if exists employee cascade" (id=3458)	

			String formatted = formatter.format( sqlCommand );
	        if ( delimiter != null ) {
				formatted += delimiter;
			}
			sqlStatementLogger.logStatement( sqlCommand, formatter );
			for ( Exporter exporter : exporters ) {
				try {
					exporter.export( formatted );
/ Net als boven , een Warning	,
				}
				catch (Exception e) {
/ NEE

/t
SchemaExport.execute(Target, SchemaExport$Type) line: 374	
			if ( type.doDrop() ) {
				perform( dropSQL, exporters );
/ D
			if ( type.doCreate() ) {
/s
SchemaExport$Type.doCreate() line: 85	
			return this == BOTH || this == CREATE;
/t
				perform( createSQL, exporters );
/s
SchemaExport.perform(String[], List<Exporter>) line: 410	
		for ( String sqlCommand : sqlCommands ) {
[create table address (id_ int8 not null, address_line1_ varchar(255), zipcoce_ varchar(255), city_ varchar(255), primary key (id_)), create table employee (id_ int8 not null, name_ varchar(255), salary_ float8, address_ int8 not null, primary key (id_)), alter table employee add constraint FK_lcwyx1va36145pv0w7f8dxqc8 foreign key (address_) references address]

		String formatted = formatter.format( sqlCommand );
			for ( Exporter exporter : exporters ) {
				try {
					exporter.export( formatted );
/s
DatabaseExporter.export(String) line: 66	
		statement.executeUpdate( string );
create table address (id_ int8 not null, address_line1_ varchar(255), zipcoce_ varchar(255), city_ varchar(255), primary key (id_))

/we zien	,
foo=> \d+ address
                                   Table "public.address"
     Column     |          Type          | Modifiers | Storage  | Stats target | Description 
----------------+------------------------+-----------+----------+--------------+-------------
 id_            | bigint                 | not null  | plain    |              | 
 address_line1_ | character varying(255) |           | extended |              | 
 zipcoce_       | character varying(255) |           | extended |              | 
 city_          | character varying(255) |           | extended |              | 
Indexes:
    "address_pkey" PRIMARY KEY, btree (id_)
Has OIDs: no

/t
SchemaExport.perform(String[], List<Exporter>) line: 411	

/ volgende	,

		for ( String sqlCommand : sqlCommands ) {
create table employee (id_ int8 not null, name_ varchar(255), salary_ float8, address_ int8 not null, primary key (id_))

			String formatted = formatter.format( sqlCommand );
			for ( Exporter exporter : exporters ) {
				try {
					exporter.export( formatted );
/ we zien	,
foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Has OIDs: no

/ volgende	,

		for ( String sqlCommand : sqlCommands ) {
alter table employee add constraint FK_lcwyx1va36145pv0w7f8dxqc8 foreign key (address_) references address
			String formatted = formatter.format( sqlCommand );
			for ( Exporter exporter : exporters ) {
				try {
					exporter.export( formatted );

/we zien	,

foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id_)
Has OIDs: no

/t
SchemaExport.execute(Target, SchemaExport$Type) line: 389	
			if ( type.doCreate() ) {
				perform( createSQL, exporters );
/ D
		finally {
			// release exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			for ( Exporter exporter : exporters ) {
				try {
					exporter.release();
/s
DatabaseExporter.release() line: 82	

	public void release() throws Exception {
		try {
			statement.close();
		}
		finally {
			connectionHelper.release();
/s
SuppliedConnectionProviderConnectionHelper.release() line: 73	

		if ( connection != null ) {
			if ( toggleAutoCommit ) {
/ JA
				connection.setAutoCommit( false );
			}
			provider.closeConnection( connection );
DriverManagerConnectionProviderImpl.closeConnection(Connection) line: 245	
		this.connections.offer( conn );
[org.postgresql.jdbc4.Jdbc4Connection@2f80e050, org.postgresql.jdbc4.Jdbc4Connection@172d56f6]

/ In this.connections zat al een conn	, nu komt deze erbij	,
/ TODO 
			connection = null;

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 521	
		if ( settings.isAutoCreateSchema() ) {
			new SchemaExport( serviceRegistry, cfg )
					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
					.create( false, true );
/ D
		if ( settings.isAutoUpdateSchema() ) {
/ NEE
		if ( settings.isAutoValidateSchema() ) {
/ NEE
		if ( settings.isAutoDropSchema() ) {
/ NEE

		currentSessionContext = buildCurrentSessionContext();
/s
SessionFactoryImpl.buildCurrentSessionContext() line: 1505	
		String impl = properties.getProperty( Environment.CURRENT_SESSION_CONTEXT_CLASS );
impl	"thread" (id=3858)	
		else if ( "thread".equals( impl ) ) {
			return new ThreadLocalSessionContext( this );

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 587	

		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
/ TODO

/t
Main.setUp() line: 73	
    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);
/ D

/ 7	.

/ employee:address=N-1

/ we zien dat hibernate_collections_xml 

/ Employee.hbm.xml

<class 
	name="Employee" 
	table="employee"
>
 	<id 
		name="id"
		column="id_"
	>	
	<property
		name="name"
		column="name_"
	/>
	
	<property 
		name="salary"
		column="salary_"
	>
	</property>
	
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"

	></many-to-one>
 </class>

/ Address.hbm.xml


<class 
	name="Address" 
	table="address"
>
	<id 
		name="id"
		column="id_"
	>	
 	</id>
	
	<property
		name="addressLine1"
		column="address_line1_"
	/>
	<property 
		name="zipcode" 
		column="zipcoce_">
	</property>
	
	<property 
		name="city"
		column="city_">
	</property>
	
  	<set
 		name="employees"
 		inverse="true">
 		<key
 			column="address_"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>
 
 </class>


foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id_)
Has OIDs: no

foo=> \d+ address
                                   Table "public.address"
     Column     |          Type          | Modifiers | Storage  | Stats target | Description 
----------------+------------------------+-----------+----------+--------------+-------------
 id_            | bigint                 | not null  | plain    |              | 
 address_line1_ | character varying(255) |           | extended |              | 
 zipcoce_       | character varying(255) |           | extended |              | 
 city_          | character varying(255) |           | extended |              | 
Indexes:
    "address_pkey" PRIMARY KEY, btree (id_)
Has OIDs: no


/we cp hibernate_collections_xml naar hibernate_xml_N_1	,

/ In de ctor van Address is er geen employees 	, 

/ we comment out	, 

	public class Address {

//	    Set<Employee>employees=new HashSet<Employee>();

/*		public Set<Employee> getEmployees() {
			return employees;
		}

		public void setEmployees(Set<Employee> employees) {
			this.employees = employees;
		}
*/

/ In Main we comment out	,

//			address2.getEmployees().add(employee2);
//			address2.getEmployees().add(employee21);

/*	        Set<Employee>employees=address.getEmployees();
	        for(Employee e:employees){
	        	String s=e.getName();
	        	boolean b=false;
	        }
*/	        

/ In de mapping van Address	,

<!--  	<set
 		name="employees"
 		inverse="true">
 		<key
 			column="address_"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>
  -->

/ we zien in de db	,

foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id_)
Has OIDs: no

foo=> \d+ address
                                   Table "public.address"
     Column     |          Type          | Modifiers | Storage  | Stats target | Description 
----------------+------------------------+-----------+----------+--------------+-------------
 id_            | bigint                 | not null  | plain    |              | 
 address_line1_ | character varying(255) |           | extended |              | 
 zipcoce_       | character varying(255) |           | extended |              | 
 city_          | character varying(255) |           | extended |              | 
Indexes:
    "address_pkey" PRIMARY KEY, btree (id_)
Referenced by:
    TABLE "employee" CONSTRAINT "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id_)
Has OIDs: no


/ Dus precies hetzelfde	,

/ 7	.

/ address:employee=1:N 

/ we cp hibernate_collections_xml naar hibernate_xml_1_N	,

 
class Address{
	    	Set<Employee>employees=new HashSet<Employee>();

		public Address(Long id,String addressLine1, String zipcode, String city) {
			this.id=id;
			this.addressLine1 = addressLine1;
			this.zipcode = zipcode;
			this.city = city;
		}

class Employee{
//    private Address address;

Address.hbm.xml

 	<set
 		name="employees"
 		>
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many 
			class="Employee"/>
 	</set>

Employee.hbm.xml

<!-- 	<many-to-one 
		name="address"
		column="address_"
		not-null="true"

	></many-to-one>
 -->

class Main{

			address.getEmployees().add(employee);
			address.getEmployees().add(employee11);

	        	Set<Employee>employees=address.getEmployees();
	        	for(Employee e:employees){
	        		String s=e.getName();
	        		boolean b=false;
	        }

/ we zien	,

foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id__)
Has OIDs: no

foo=> \d+ address
                                   Table "public.address"
     Column     |          Type          | Modifiers | Storage  | Stats target | Description 
----------------+------------------------+-----------+----------+--------------+-------------
 id__            | bigint                 | not null  | plain    |              | 
 address_line1__ | character varying(255) |           | extended |              | 
 zipcoce__       | character varying(255) |           | extended |              | 
 city__          | character varying(255) |           | extended |              | 
Indexes:
    "address_pkey" PRIMARY KEY, btree (id__)
Referenced by:
    TABLE "employee" CONSTRAINT "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id__)
Has OIDs: no

/ we zien de fk in employee address_ not null, dat is omdat we in de mapping	,
 		<key
 			column="address_"
 			not-null="true"
 		></key>
/ als we dat niet doen, zien we ook niet not null bij de fk address_ in employee	,

/ we debug	,

/ 13	.

HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2662	

			if ( "key".equals( name ) ) {
...
				SimpleValue key = new DependantValue( mappings, collection.getCollectionTable(), keyVal );
...
				bindSimpleValue(
						subnode,
						key,
						collection.isOneToMany(),
						Collection.DEFAULT_KEY_COLUMN_NAME,
						mappings
					);
				collection.setKey( key );


collection	Set  (id=573)	
	element	OneToMany  (id=632)	
		referencedEntityName	"my.test.own.hibernate_xml_1_N.Employee" (id=117)	
		referencingTable	Table  (id=441)	address
	key	DependantValue  (id=844)	
		columns	ArrayList<E>  (id=846)	[Column(address_)]
		table	Table  (id=291)		employee
		wrappedValue	SimpleValue  (id=435)	
			columns	ArrayList<E>  (id=440) Column(id__)	
			table	Table  (id=441)		address

/ maar ook in Table(employee) zit de DependantValue in de Colunn(address_)	,

collectionTable	Table  (id=291)	
key	DependantValue  (id=844)	
	table	Table  (id=291)	
		columns	LinkedHashMap<K,V>  (id=921)	
				[10]	LinkedHashMap$Entry<K,V>  (id=962)	
					value	Column  (id=885)	
						value	DependantValue  (id=844)	
 
/ Is dat bij N:1 ook?
/ TODO

/ we deden hierboven	,
				bindSimpleValue(...
...
/s
	public static void bindColumns(final Element node, final SimpleValue simpleValue,
...
		table.addColumn(column)

/ maar nu is er geen address_	, nu voor het eerst maar nu van de Address kant	,

/13	.

/ we zijn nog in 	,
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2662	

/ Nu  omdat we inverse="false"	, en <key not-null="true"	,

		if ( collection.isOneToMany()
			&& !collection.isInverse()
			&& !collection.getKey().isNullable() ) {
/ JA
			// for non-inverse one-to-many, with a not-null fk, add a backref!
			String entityName = ( (OneToMany) collection.getElement() ).getReferencedEntityName();
my.test.own.hibernate_xml_1_N.Employee
			PersistentClass referenced = mappings.getClass( entityName );
/ Dit is second pass, dus alle types zijn parsed	,
			Backref prop = new Backref();
			prop.setName( '_' + collection.getOwnerEntityName() + "." + node.attributeValue( "name" ) + "Backref" );
			prop.setUpdateable( false );
			prop.setSelectable( false );
			prop.setCollectionRole( collection.getRole() );
			prop.setEntityName( collection.getOwner().getEntityName() );
			prop.setValue( collection.getKey() );
			referenced.addProperty( prop );
		}
prop	Backref  (id=1423)	
	cascade	null	
	collectionRole	"my.test.own.hibernate_xml_1_N.Address.employees" (id=568)	
	entityName	"my.test.own.hibernate_xml_1_N.Address" (id=436)	
	insertable	true	
	lazy	false	
	lob	false	
	metaAttributes	null	
	name	"_my.test.own.hibernate_xml_1_N.Address.employeesBackref" (id=1433)	
	naturalIdentifier	false	
	nodeName	null	
	optimisticLocked	true	
	optional	false	
	persistentClass	null	
	propertyAccessorName	null	
	selectable	false	
	updateable	false	
	value	DependantValue  (id=844)	
	valueGenerationStrategy	null	

/ we zien dat de RootClass <class een extra property krijgt	,

persistentClasses	HashMap<K,V>  (id=188)	
	table	HashMap$Entry<K,V>[16]  (id=346)	
		[4]	HashMap$Entry<K,V>  (id=352)	
			key	"my.test.own.hibernate_xml_1_N.Employee" (id=229)	
			value	RootClass  (id=176)	
				identifier	SimpleValue  (id=312)	
				properties	ArrayList<E>  (id=337)	
					elementData	Object[10]  (id=435)	
						[0]	Property  (id=442)	
org.hibernate.mapping.Property(name)
						[1]	Property  (id=443)	
org.hibernate.mapping.Property(salary)
						[2]	Backref  (id=249)	

/ Employee heeft geen address_ field	,  want we doen address:employee=1:N	, 
/ maar dat staat hier los van	,
/ TODO

/ 13	. 

	public void doSecondPass(java.util.Map persistentClasses)
		secondPass( persistentClasses, localInheritedMetas ); // using local since the inheritedMetas at this point is not the correct map since it is always the empty map
/ D
		collection.createAllKeys();
/s
Set(Collection).createAllKeys() line: 429	

		createForeignKeys();
...
/s
Table.createForeignKey(String, List, String, List) line: 656	

		Object key = new ForeignKeyKey( keyColumns, referencedEntityName, referencedColumns );
keyColumns	ArrayList<E>  (id=846)	
	elementData	Object[10]  (id=1044)	
		[0]	Column  (id=885)	
			name	"address_" (id=914)	
			value	DependantValue  (id=844)	

		if ( fk == null ) {
/ JA
			fk = new ForeignKey();
			fk.setTable( this );
			fk.setReferencedEntityName( referencedEntityName );
Address
			fk.addColumns( keyColumns.iterator() );

			else {
				fk.setName( Constraint.generateName( fk.generatedConstraintNamePrefix(),
						this, keyColumns ) );
			foreignKeys.put( key, fk );

/t
Set(Collection).createAllKeys() line: 429	
		createForeignKeys();
 /D
		if ( !isInverse() ) createPrimaryKey();
/ JA
/s
Set.createPrimaryKey() line: 79	
		if ( !isOneToMany() ) {
/ NEE
/ Doet NIETS	,

/ 13	. 

/ we komen in export	,

	public SchemaExport(ServiceRegistry serviceRegistry, Configuration configuration) {
		this.createSQL = configuration.generateSchemaCreationScript( dialect );
/s
		Iterator iter = getTableMappings();
		while ( iter.hasNext() ) {
			Table table = (Table) iter.next();
			if ( table.isPhysicalTable() ) {
				script.add(
						table.sqlCreateString(
								dialect,
								mapping,
								defaultCatalog,
								defaultSchema
							)
					);
/ Voor Table(address), Table(employee)	,

/ Bij Table(employee)	,
			else {
				buf.append( col.getSqlType( dialect, p ) );
/s
Column.getSqlType(Dialect, Mapping) line: 229	
            sqlType = dialect.getTypeName( getSqlTypeCode( mapping ), getLength(), getPrecision(), getScale() );
/ In dialect is een table, typeNames.defaults={-5=int8, 12=varchar($l)	,...}
/s
Column.getSqlTypeCode(Mapping) line: 189	
       org.hibernate.type.Type type = getValue().getType();
/s
DependantValue.getType() line: 47	
		return wrappedValue.getType();

/ in wrappedValue=SimpleType(Table(Address), Column(id__)) staat typeName="long"

/ het wordt	, 
create table employee ... address_ int8 not null

/ Dan	,

					Iterator subIter = table.getForeignKeyIterator();
table=Table(employee)
					while ( subIter.hasNext() ) {
						ForeignKey fk = (ForeignKey) subIter.next();
						if ( fk.isPhysicalConstraint() ) {
							script.add(
									fk.sqlCreateString(
											dialect, mapping,
											defaultCatalog,
											defaultSchema
										)
								);
/s
ForeignKey(Constraint).sqlCreateString(Dialect, Mapping, String, String) line: 205	
			String constraintString = sqlConstraintString( dialect, getName(), defaultCatalog, defaultSchema );
getName()=
name	"FK_lcwyx1va36145pv0w7f8dxqc8" (id=1595)	

/s
ForeignKey.sqlConstraintString(Dialect, String, String, String) line: 61	
		Iterator iter = getColumnIterator();
		while ( iter.hasNext() ) {
			cols[i] = ( (Column) iter.next() ).getQuotedName(dialect);
[address_]
			refcols[i] = ( (Column) refiter.next() ).getQuotedName(dialect);
[id__]

		String result = dialect.getAddForeignKeyConstraintString(
			constraintName, cols, referencedTable.getQualifiedName(dialect, defaultCatalog, defaultSchema), refcols, isReferenceToPrimaryKey()
referencedTable=Table(address)
/s
ForeignKey.isReferenceToPrimaryKey() line: 164	
		return referencedColumns.isEmpty();
/ JA
/s
PostgreSQLDialect(Dialect).getAddForeignKeyConstraintString(String, String[], String, String[], boolean) line: 2079	
		res.append( " add constraint " )
				.append( quote( constraintName ) )
				.append( " foreign key (" )
				.append( StringHelper.join( ", ", foreignKey ) )
				.append( ") references " )
				.append( referencedTable );
 add constraint FK_lcwyx1va36145pv0w7f8dxqc8 foreign key (address_) references address


/ 7. 	

/ de volgorde van welke hbm.xml hij als 1ste parse, wordt bepaald door de volgorde in hibernate.cfg.xml	,

/ 7	.

/ address:employee=1:N	, maar we set in set inverse="true"

Address.hbm.xml

 	<set
 		name="employees"
 		inverse="true"
 		>
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ De mapping naar de db is OK	, of je nou insert="true" of niet	,
/ employee heeft fk address_	, want dat staat in de key	, 

foo=> \d+ address
                                    Table "public.address"
     Column      |          Type          | Modifiers | Storage  | Stats target | Description 
-----------------+------------------------+-----------+----------+--------------+-------------
 id__            | bigint                 | not null  | plain    |              | 
 address_line1__ | character varying(255) |           | extended |              | 
 zipcoce__       | character varying(255) |           | extended |              | 
 city_           | character varying(255) |           | extended |              | 
Indexes:
    "address_pkey" PRIMARY KEY, btree (id__)
Referenced by:
    TABLE "employee" CONSTRAINT "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id__)
Has OIDs: no

foo=> \d+ employee
                                Table "public.employee"
  Column  |          Type          | Modifiers | Storage  | Stats target | Description 
----------+------------------------+-----------+----------+--------------+-------------
 id_      | bigint                 | not null  | plain    |              | 
 name_    | character varying(255) |           | extended |              | 
 salary_  | double precision       |           | plain    |              | 
 address_ | bigint                 | not null  | plain    |              | 
Indexes:
    "employee_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_lcwyx1va36145pv0w7f8dxqc8" FOREIGN KEY (address_) REFERENCES address(id__)
Has OIDs: no


/ Maar we zien	,


HibernateLog --> 16:47:33 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 16:47:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 16:47:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 16:47:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity]
HibernateLog --> 16:47:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 16:47:33 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, id_) values (?, ?, ?)
Hibernate: insert into employee (name_, salary_, id_) values (?, ?, ?)
HibernateLog --> 16:47:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 16:47:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 16:47:33 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]
HibernateLog --> 16:47:33 WARN  org.hibernate.engine.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: 23502
HibernateLog --> 16:47:33 ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - ERROR: null value in column "address_" violates not-null constraint
  Detail: Failing row contains (1, Foo1, 1, null).
HibernateLog --> 16:47:33 INFO  org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl - HHH000010: On release of batch it still contained JDBC statements
org.hibernate.exception.ConstraintViolationException: could not execute statement

/ als we <set inverse="false" , gaat het goed	,

foo=> select*from address\g
 id__ | address_line1__ | zipcoce__ |  city_  
------+-----------------+-----------+---------
   12 | foostreet       | 12 foo    | FooCity
(1 row)

foo=> select*from employee\g
 id_ | name_ | salary_ | address_ 
-----+-------+---------+----------
   2 | Foo2  |      11 |       12
   1 | Foo1  |       1 |       12
(2 rows)



/ we debug	, 

/ In Main.setup we cancel b's	, 
/ we zien	,
configuration	Configuration  (id=22)	
	classes	HashMap<K,V>  (id=38)	
		table	HashMap$Entry<K,V>[16]  (id=57)	
			[1]	HashMap$Entry<K,V>  (id=66)	
			[4]	HashMap$Entry<K,V>  (id=68)	
				value	RootClass  (id=79)	
					identifierProperty	Property
					properties	ArrayList<E>  (id=147)	
[org.hibernate.mapping.Property(name), org.hibernate.mapping.Property(salary)]
/ Geen backref	,

/ 7. 	

/ hibernate_xml_1_N

/ als we in Address' mapping 
	<set
		inverse="true"

/ dan krijgen we een constraint exception, omdat er in van een Employee maar 3 properties worden persist, id, salary	, city	,

/ als we in Address' mapping 
	<set
		inverse="false"

/ dan OK	,

/ 13	.


/ met inverse="true"/"false"	, 

/ persist  'n Address altijd OK: de set wordt toch niet persist	,

SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3121	
				insert = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
insert	Jdbc4PreparedStatement  (id=417)	
insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)


				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
this
	propertyColumnInsertable	(id=432)	
[[true], [true], [true], []]
/ TODO (wordt niet used?)

/s
SetType(CollectionType).nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 183	
	public final void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable,
			SessionImplementor session) throws HibernateException, SQLException {
		//NOOP
	}

/ 13	.

/ met inverse="false"	,

DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 102	
			int entityCount = flushEntities( event, persistenceContext );
/ s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 154	

		final Object[] values = getValues( entity, entry, mightBeDirty, session );
values	Object[3]  (id=115)	
	[0]	"Foo1" (id=43)	
	[1]	Double  (id=116)	
	[2]	BackrefPropertyAccessor$1  (id=118)	

/t
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );

/ we kijken alleen naar persist van een Employee	,

/s
ActionQueue.executeActions(ExecutableList<E>) line: 463	
			for ( E e : list ) {
				try {
					e.execute();
/s
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );
id	Long  (id=230)	
1
getState()	Object[3]  (id=231)	
	[0]	"Foo1" (id=43)	
	[1]	Double  (id=232)	
	[2]	Long  (id=59)	

/ Deze entity insert action is create bij save	,

/ we herhalen parse hbm.xml	,
/ de value (SimpleValue, ... ) komt in de property (Property), en die komt in de persistentClass (RootClass)	,
/ see	,
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2216	

/ in de RootClass van Address is er properties	, de addressline1 property heeft als value een SimpleValue, de employees heeft als value een Set	,

/ we komen in	,
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2579	
/////////////////////////////////////////////////////////////////

/ Dit is een belangrijke fct	,

/ in de collection (Set) is een OneToMany element en een DependantValue key	,

/ key is een DependantValue	,
				bindSimpleValue(
						subnode,
						key,
						collection.isOneToMany(),
						Collection.DEFAULT_KEY_COLUMN_NAME,
						mappings
					);
...
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1142	
			column.setName( columnName );
address_
				table.addColumn( column ); // table=null -> an association - fill
/ in table onder columns verschijnt entry, name="address_", value=DependantValue	,


/ in de key is columns [Column(address_)] en  table Table(employee)	, en er is SimpleValue wrappedValue	, met daarin columns [Column(id__)] en table Table(address)	,

/ BACKREF

		if ( collection.isOneToMany()
			&& !collection.isInverse()
			&& !collection.getKey().isNullable() ) {
			String entityName = ( (OneToMany) collection.getElement() ).getReferencedEntityName();
"pkg.Employee"
			PersistentClass referenced = mappings.getClass( entityName );
			Backref prop = new Backref();
			prop.setName( '_' + collection.getOwnerEntityName() + "." + node.attributeValue( "name" ) + "Backref" );
			prop.setUpdateable( false );
			prop.setSelectable( false );
			prop.setCollectionRole( collection.getRole() );
			prop.setEntityName( collection.getOwner().getEntityName() );
"pkg.Address"
			prop.setValue( collection.getKey() );
DependantValue
			referenced.addProperty( prop );
/ Klopt	, wordt property in properties van de RootClass van Employee	, 
/ we zien,  WH ook als op de Set inverse="true", in deze RootClass van Employee ook in Table table in columns ook Column(address_)

/ de property heet NIET address_	, maar _my.test.own.hibernate_xml_1_N.Address.employeesBackref	, 
/ de column heet WEL address_	,

persistentClasses	HashMap<K,V>  (id=1953)	
	table	HashMap$Entry<K,V>[16]  (id=1995)	
		[4]	HashMap$Entry<K,V>  (id=1997)	
			key	"my.test.own.hibernate_xml_1_N.Employee" (id=1987)	
			value	RootClass  (id=1988)	
				properties	ArrayList<E>  (id=2037)	
					elementData	Object[10]  (id=2048)	
						[2]	Backref  (id=1991)	
							name	"_my.test.own.hibernate_xml_1_N.Address.employeesBackref" (id=2051)	
							value	DependantValue  (id=1949)	
				table	Table  (id=1961)	
					columns	LinkedHashMap<K,V>  (id=2045)	
						table	HashMap$Entry<K,V>[16]  (id=2066)	
							[10]	LinkedHashMap$Entry<K,V>  (id=2070)	
								key	"address_" (id=1971)	
								value	Column  (id=1974)	
									name	"address_" (id=1971)	
									value	DependantValue  (id=1949)	

/ Dan	,
	public void createAllKeys() throws MappingException {
		createForeignKeys();
		if ( !isInverse() ) createPrimaryKey();

/ eerst createForeignKeys()	,

/ Dan Table(employee) krijgt fk	,

	public ForeignKey createForeignKey(String keyName, List keyColumns, String referencedEntityName,
									   List referencedColumns) {
		Object key = new ForeignKeyKey( keyColumns, referencedEntityName, referencedColumns );
		ForeignKey fk = (ForeignKey) foreignKeys.get( key );
		if ( fk == null ) {
			fk = new ForeignKey();
			fk.setTable( this );
			fk.setReferencedEntityName( referencedEntityName );
			fk.addColumns( keyColumns.iterator() );

			foreignKeys.put( key, fk );

/ we zien	,

this	Table  (id=1961)	
	columns	LinkedHashMap<K,V>  (id=2045)	
{id_=org.hibernate.mapping.Column(id_), name_=org.hibernate.mapping.Column(name_), salary_=org.hibernate.mapping.Column(salary_), address_=org.hibernate.mapping.Column(address_)}
	foreignKeys	LinkedHashMap<K,V>  (id=2046)	
{org.hibernate.mapping.Table$ForeignKeyKey@b75be30b=org.hibernate.mapping.ForeignKey(employee[org.hibernate.mapping.Column(address_)]) as FK_lcwyx1va36145pv0w7f8dxqc8}
	name	"employee" (id=2054)	

/ Dan	,
		if ( !isInverse() ) createPrimaryKey();
/ NIETS, want is one-to-many	,

/ dan	,
			secondPassCompileForeignKeys( table, done );
/ adds referenced	,
this	Configuration  (id=21)	
	classes	HashMap<K,V>  (id=1953)	
		table	HashMap$Entry<K,V>[16]  (id=1995)	
			[4]	HashMap$Entry<K,V>  (id=1997)	
				value	RootClass  (id=1988)	
					table	Table  (id=1961)	
						foreignKeys	LinkedHashMap<K,V>  (id=2046)	
							table	HashMap$Entry<K,V>[16]  (id=2464)	
								[7]	LinkedHashMap$Entry<K,V>  (id=2468)	
									value	ForeignKey  (id=2341)	
										columns	ArrayList<E>  (id=2344)		[Column(address_)]
										name	"FK_lcwyx1va36145pv0w7f8dxqc8" (id=2370)	
										referencedEntityName	"my.test.own.hibernate_xml_1_N.Address" (id=1998)	
										referencedTable	Table  (id=2015)	Table(address)
										table	Table  (id=1961) 		Table(employee)	


/ 13	. 

/ create persister van Address	,

SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 401	

		classes = cfg.getClassMappings();
/ in hibernate.cfg.xml	,
		while ( classes.hasNext() ) {
...
/s
SingleTableEntityPersister(AbstractEntityPersister).<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor) line: 601	
		int hydrateSpan = entityMetamodel.getPropertySpan();
		propertyColumnSpans = new int[hydrateSpan];
		propertySubclassNames = new String[hydrateSpan];
		propertyColumnAliases = new String[hydrateSpan][];
		propertyColumnNames = new String[hydrateSpan][];
		propertyColumnFormulaTemplates = new String[hydrateSpan][];
		propertyColumnReaderTemplates = new String[hydrateSpan][];
		propertyColumnWriters = new String[hydrateSpan][];
		propertyUniqueness = new boolean[hydrateSpan];
		propertySelectable = new boolean[hydrateSpan];
		propertyColumnUpdateable = new boolean[hydrateSpan][];
		propertyColumnInsertable = new boolean[hydrateSpan][];
		HashSet thisClassProperties = new HashSet();

		while ( iter.hasNext() ) {
			Property prop = ( Property ) iter.next();
prop	Backref  (id=66)	
	cascade	null	
	collectionRole	"my.test.own.hibernate_xml_1_N.Address.employees" (id=1976)	
	entityName	"my.test.own.hibernate_xml_1_N.Address" (id=1977)	
	insertable	true	
	lazy	false	
	lob	false	
	metaAttributes	null	
	name	"_my.test.own.hibernate_xml_1_N.Address.employeesBackref" (id=1978)	
	naturalIdentifier	false	
	nodeName	null	
	optimisticLocked	true	
	optional	false	
	persistentClass	RootClass  (id=1955)	
	propertyAccessorName	null	
	selectable	false	
	updateable	false	
->	value	DependantValue  (id=1979)	
	valueGenerationStrategy	null	

			thisClassProperties.add( prop );
			int span = prop.getColumnSpan();
1
/ de prop bestaat uit 1 col	,
			propertyColumnSpans[i] = span;
[1,1,1]
			propertySubclassNames[i] = prop.getPersistentClass().getEntityName();
[Emp;loyee,Employee,Employee]

			Iterator colIter = prop.getColumnIterator();
/s
		return value.getColumnIterator();
/s
		return columns.iterator();

			int k = 0;
			while ( colIter.hasNext() ) {
				Selectable thing = ( Selectable ) colIter.next();

				colAliases[k] = thing.getAlias( factory.getDialect() , prop.getValue().getTable() );
[address_4_1_]
...
/ TODO (Afmaken)

		iter = persistentClass.getSubclassPropertyClosureIterator();
		while ( iter.hasNext() ) {
/ TODO (Afmaken)

/ 13	. 

	tx.commit();
/s
DefaultFlushEntityEventListener.getValues(Object, EntityEntry, boolean, SessionImplementor) line: 195	
/=
	private Object[] getValues(Object entity, EntityEntry entry, boolean mightBeDirty, SessionImplementor session) {
entity	Employee  (id=3079)	
	id	1	
	name	"Foo1" (id=3103)	
	salary	1.0	
entry	EntityEntry  (id=3533)	
	id	Long  (id=3566)	
	loadedState	Object[3]  (id=3544)	
		[0]	"Foo1" (id=3103)	
		[1]	Double  (id=3571)	
1.0
		[2]	Long  (id=3519)	
12
		final Object[] loadedState = entry.getLoadedState();
[Foo1, 1.0, 12]
			// grab its current state
			values = persister.getPropertyValues( entity );
/s
	public Object[] getPropertyValues(Object object) {
		return getEntityTuplizer().getPropertyValues( object );
/s
			return super.getPropertyValues( entity );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValues(Object) line: 607	
		final int span = entityMetamodel.getPropertySpan();
3
		final Object[] result = new Object[span];

/ entityMetamodel.getProperties()=[Attribute(name=name, type=string [non-identifier]), Attribute(name=salary, type=double [non-identifier]), Attribute(name=_my.test.own.hibernate_xml_1_N.Address.employeesBackref, type=long [non-identifier])]

		for ( int j = 0; j < span; j++ ) {
			NonIdentifierAttribute property = entityMetamodel.getProperties()[j];
			if ( getAll || !property.isLazy() ) {
				result[j] = getters[j].get( entity );
/ voor normale 	,
/s
BasicPropertyAccessor$BasicGetter.get(Object) line: 169	
				return method.invoke( target, (Object[]) null );
/ voor Backref	,
/s
BackrefPropertyAccessor$BackrefGetter.get(Object) line: 136	
		public Object get(Object target) {
			return UNKNOWN;
		}

/ UNKNOWN is BackrefPropertyAccessor$1	, die we zien in de values	,
/ Dit is de 3de prop van de loadedState	, de andere zijn "Foo1" en Double 1.0	,

/ Intermezzo

public class BackrefPropertyAccessor implements PropertyAccessor {
	public static final Serializable UNKNOWN = new Serializable() {
		@Override
		public String toString() {
			return "<unknown>";
		}

		public Object readResolve() {
			return UNKNOWN;
		}
	};


/ Einde Intermezzo


result	Object[3]  (id=3708)	
	[0]	"Foo1" (id=3103)	
	[1]	Double  (id=3709)	
	[2]	BackrefPropertyAccessor$1  (id=3710)	


/ Intermezzo

/ Wanneer worden de getters create?

/ we waren ooit in 	,
public abstract class AbstractEntityTuplizer implements EntityTuplizer {
	public Object[] getPropertyValues(Object entity) throws HibernateException {
				result[j] = getters[j].get( entity );
/ en we zagen dat hier de getters (en setters) worden create	,

/ we set dus een b in de <init>	,
	public AbstractEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo) {
...
			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );
...
/ en zo komen we hier in	,


Configuration.buildSessionFactory(ServiceRegistry) line: 1857	
		return new SessionFactoryImpl(
				this,
				mapping,
				serviceRegistry,
				settings,
				sessionFactoryObserver
			);
...
/s
SingleTableEntityPersister(AbstractEntityPersister).<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor) line: 520	
s.entityMetamodel = new EntityMetamodel( persistentClass, this, factory );
/s
			entityTuplizer = entityTuplizerFactory.constructDefaultTuplizer( entityMode, this, persistentClass );
...
/s
PojoEntityTuplizer(AbstractEntityTuplizer).<init>(EntityMetamodel, PersistentClass) line: 178	

		if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
/s
PojoEntityTuplizer.buildPropertyGetter(Property, PersistentClass) line: 411	
/s
   protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
/ mappedProperty=Prpperty	,
/  mappedEntity=RootClass
/s
Property.getGetter(Class) line: 323	
/=
	public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
		return getPropertyAccessor(clazz).getGetter( clazz, name );
/s
	public PropertyAccessor getPropertyAccessor(Class clazz) throws MappingException {
		return PropertyAccessorFactory.getPropertyAccessor( clazz, getPropertyAccessorName() );
/ getPropertyAccessorName()="property"
/s
PropertyAccessorFactory.getPropertyAccessor(Class, String) line: 154	
		if ( type==null ) type = optionalClass==null || optionalClass==Map.class ? "map" : "property";
"property"
		return getPropertyAccessor(type);
/s
public final class PropertyAccessorFactory {
	private static final PropertyAccessor BASIC_PROPERTY_ACCESSOR = new BasicPropertyAccessor();

	public static PropertyAccessor getPropertyAccessor(String type) throws MappingException {
		if ( type==null || "property".equals(type) ) return BASIC_PROPERTY_ACCESSOR;

/t
	public Setter getSetter(Class clazz) throws PropertyNotFoundException, MappingException {
		return getPropertyAccessor(clazz).getSetter(clazz, name);
/ D (first half)
/ TODO (setter ipv getter)	,
/s
	public Setter getSetter(Class theClass, String propertyName) throws PropertyNotFoundException {
		return createSetter(theClass, propertyName);
/s
	private static Setter createSetter(Class theClass, String propertyName) throws PropertyNotFoundException {
		BasicSetter result = getSetterOrNull(theClass, propertyName);
/s
	private static BasicSetter getSetterOrNull(Class theClass, String propertyName) {
		Method method = setterMethod(theClass, propertyName);
/s
	private static Method setterMethod(Class theClass, String propertyName) {
		BasicGetter getter = getGetterOrNull(theClass, propertyName);
/s
	private static BasicGetter getGetterOrNull(Class theClass, String propertyName) {
		Method method = getterMethod(theClass, propertyName);
/ Via .getDeclaredMethods() en dan kijken op name	,

		if (method!=null) {
			method.setAccessible(true);
			return new BasicGetter(theClass, method, propertyName);
/s
BasicPropertyAccessor$BasicGetter.<init>(Class, Method, String, BasicPropertyAccessor$1) line: 155	
/=
	public static final class BasicGetter implements Getter {
		private Class clazz;
		private final transient Method method;
		private final String propertyName;

		private BasicGetter(Class clazz, Method method, String propertyName) {
			this.clazz=clazz;
			this.method=method;
			this.propertyName=propertyName;
		}


/t
PojoEntityTuplizer(AbstractEntityTuplizer).<init>(EntityMetamodel, PersistentClass) line: 178	
			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
/ D
			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );

		while ( itr.hasNext() ) {
			Property property = (Property) itr.next();
			getters[i] = buildPropertyGetter(property, mappingInfo);
property	Backref  (id=258)	
/s
   protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
mappedProperty	Backref  (id=258)	
mappedEntity	RootClass  (id=243) Employee
		return mappedProperty.getGetter( mappedEntity.getMappedClass() );
/s
Backref(Property).getGetter(Class) line: 323	
		return getPropertyAccessor(clazz).getGetter( clazz, name );
clazz	Class<T> (my.test.own.hibernate_xml_1_N.Employee) (id=263)	
this	Backref  (id=258)	
	name	"_my.test.own.hibernate_xml_1_N.Address.employeesBackref" (id=281)	
	entityName	"my.test.own.hibernate_xml_1_N.Address" (id=164)	
/s
Backref.getPropertyAccessor(Class) line: 61	
		return new BackrefPropertyAccessor(collectionRole, entityName);
/s
	public BackrefPropertyAccessor(String collectionRole, String entityName) {
		this.propertyName = collectionRole.substring( entityName.length() + 1 );
		this.entityName = entityName;

		this.setter = new BackrefSetter();
		this.getter = new BackrefGetter();
/s
BackrefPropertyAccessor$BackrefSetter.<init>() line: 96	
/=
public class BackrefPropertyAccessor implements PropertyAccessor {
	public static final class BackrefSetter implements Setter {

/ er is ook	,
public class BackrefPropertyAccessor implements PropertyAccessor {
	public class BackrefGetter implements Getter {

/ Uiteindelijk	,

getters	Getter[3]  (id=311)	
	[0]	BasicPropertyAccessor$BasicGetter  (id=317)	
	[1]	BasicPropertyAccessor$BasicGetter  (id=318)	
	[2]	BackrefPropertyAccessor$BackrefGetter  (id=309)	
setters	Setter[3]  (id=315)	
	[0]	BasicPropertyAccessor$BasicSetter  (id=321)	
	[1]	BasicPropertyAccessor$BasicSetter  (id=322)	
	[2]	BackrefPropertyAccessor$BackrefSetter  (id=323)	


/ Einde Intermezzo

/ 13	.

/ .save(employee)

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );


/////////////////////////////////////
/ SAMENVATTING

/ de properties worden langs gegaan	, en de get methods  op de entity worden exec	, dus dat is de entity in de pc! waar we normaal mee werken	, 
/ de properties zijn een String, Double, Backref , maar in de entity zijn alleen id, String , Dboule
/ maar er is een extra prop van de Employee, van type Backref	,  die backref naar de Address.id	, hij doet dan op Address' entityEntry	,
					return entityEntry.getId();

/ als we geen Backref prop aan de Employee geven (see BACKREF, als we NIET : <key not-null="true"	, <set inverse="false",  er is in <set ...><one-to-many ...>)	, dan is de state ["Foo1", 1.0], en NIET ["Foo1", 1.0, 12]	,
/s
SingleTableEntityPersister(AbstractEntityPersister).getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 4817	
		return getEntityTuplizer().getPropertyValuesToInsert( object, mergeMap, session );
/s
PojoEntityTuplizer.getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 378	
		else {
			return super.getPropertyValuesToInsert( entity, mergeMap, session );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 620	
		final int span = entityMetamodel.getPropertySpan();
3
		final Object[] result = new Object[span];

		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
entity	Employee  (id=2861)	
	id	1	
	name	"Foo1" (id=2862)	
	salary	1.0	

/ 137
/ voor name_, salary_	,
/s
BasicPropertyAccessor$BasicGetter.getForInsert(Object, Map, SessionImplementor) line: 204	
/=
		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
			return get( target );
/s
BasicPropertyAccessor$BasicGetter.get(Object) line: 169	
/=
		public Object get(Object target) throws HibernateException {
			try {
				return method.invoke( target, (Object[]) null );
/ method=public java.lang.String my.test.own.hibernate_xml_1_N.Employee.getName()

/ 137
/ voor backref	naar Address.id	, address.id__, 

/ Employee krijgt property backref	, om zo backref te hebben naar Address.id	, address.id__	,
/s
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 121	
			if ( session == null ) {
/ NEE
				return UNKNOWN;
			}
			else {
				return session.getPersistenceContext().getOwnerId( entityName, propertyName, target, mergeMap );
this	BackrefPropertyAccessor$BackrefGetter  (id=2884)	
	this$0	BackrefPropertyAccessor  (id=2885)	
		entityName	"my.test.own.hibernate_xml_1_N.Address" (id=2886)	
		propertyName	"employees" (id=2887)	
target	Employee  (id=2861)	
/s
StatefulPersistenceContext.getOwnerId(String, String, Object, Map) line: 1063	
/s
	public Serializable getOwnerId(String entityName, String propertyName, Object childEntity, Map mergeMap) {

		final String collectionRole = entityName + '.' + propertyName;
collectionRole	"my.test.own.hibernate_xml_1_N.Address.employees" (id=2900)	

		final EntityPersister persister = session.getFactory().getEntityPersister( entityName );
persister	SingleTableEntityPersister  (id=2902)
SingleTableEntityPersister(my.test.own.hibernate_xml_1_N.Address)

		final CollectionPersister collectionPersister = session.getFactory().getCollectionPersister( collectionRole );
collectionPersister	OneToManyPersister  (id=2898)	
OneToManyPersister(my.test.own.hibernate_xml_1_N.Address.employees)

				boolean found = isFoundInParent(
						propertyName,
						childEntity,
						persister,
						collectionPersister,
						entityEntryInstance
				);
/s
StatefulPersistenceContext.isFoundInParent(String, Object, EntityPersister, CollectionPersister, Object) line: 1175	

		final Object collection = persister.getPropertyValue( potentialParent, property );
/s
		return getEntityTuplizer().getPropertyValue( object, propertyName );
object=Address inst	,
propertyName=employees
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValue(Object, String) line: 636	

		final Object baseValue = getPropertyValue( entity, index );
entity=Address inst	,
index=3
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValue(Object, int) line: 631	
		return getters[i].get( entity );
/s
				return method.invoke( target, (Object[]) null );
/ method=public java.util.Set my.test.own.hibernate_xml_1_N.Address.getEmployees()

/t
	return baseValue
baseValue	PersistentSet  (id=2935)	
[my.test.own.hibernate_xml_1_N.Employee@5fc0b36d, my.test.own.hibernate_xml_1_N.Employee@5c99c47d]

/t
	private boolean isFoundInParent(...
		final Object collection = persister.getPropertyValue( potentialParent, property );
/D
[my.test.own.hibernate_xml_1_N.Employee@5fc0b36d, my.test.own.hibernate_xml_1_N.Employee@5c99c47d]

		return collection != null
				&& Hibernate.isInitialized( collection )
				&& collectionPersister.getCollectionType().contains( collection, childEntity, session );
	}

/t
StatefulPersistenceContext.getOwnerId(String, String, Object, Map) line: 1099	
				boolean found = isFoundInParent(
						propertyName,
						childEntity,
						persister,
						collectionPersister,
						entityEntryInstance
				);
true
				if ( found ) {
					return entityEntry.getId();
12

/ 7	.

/ 7	. 

/ sesssion.save(employee)

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 288	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
[Foo1, 1.0, 12]
/ we zien dat de state (met .getForInsert geeft 12 en niet UNKNOWN)	,  in de entity insert action komt 	, 
/ .commit pakt deze en sets deze in de preparedstatement	,


/ session.commit

DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	


			int entityCount = flushEntities( event, persistenceContext );
/ TOOD (Wat doe deze method?)

/ sets [Foo1, 1.0, <unknown>] in event	,
/ terwijl loadedState in de EntityEntry van  
/s
DefaultFlushEntityEventListener.getValues(Object, EntityEntry, boolean, SessionImplementor) line: 197	
		final Object[] loadedState = entry.getLoadedState();
[Foo1, 1.0, 12]

			// grab its current state
			values = persister.getPropertyValues( entity );
[Foo1, 1.0, <unknown>]
/ want	,
/ s
	public Object[] getPropertyValues(Object entity) throws HibernateException {
		for ( int j = 0; j < span; j++ ) {
				result[j] = getters[j].get( entity );
/s
BackrefPropertyAccessor$BackrefGetter.get(Object) line: 136	
			return UNKNOWN;

/ we doen NIET .getForInsert	,  die long 12 geeft	,

/ TODO (wordt deze  [Foo1, 1.0, <unknown>] used?)

/ 7	.

/ later	,

	public void onFlush(FlushEvent event) throws HibernateException {
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
...
/s
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );

/ dus de state in de entity insert action wordt persist	, niet wat er in de entity staat	,

/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3121	
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );

/ de fields (state) worden in de preparedstatement set	,

/ 7	.

JdbcTransaction(AbstractTransactionImpl).commit() line: 182	

		beforeTransactionCommit();
		try {
			doCommit();
/ D
			localStatus = LocalStatus.COMMITTED;
			afterTransactionCompletion( Status.STATUS_COMMITTED );

/ Hoe state, entity	?

/ 7	.

/ assemble/disassemble alleen bij ehcache	, 

/ see ook	,
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
/ in	,
Thread [main] (Suspended)	
	DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
	DefaultLoadEventListener.load(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 213	
	DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 275	
	DefaultLoadEventListener.onLoad(LoadEvent, LoadEventListener$LoadType) line: 151	
	SessionImpl.fireLoad(LoadEvent, LoadEventListener$LoadType) line: 1070	
	SessionImpl.access$2000(SessionImpl, LoadEvent, LoadEventListener$LoadType) line: 176	
	SessionImpl$IdentifierLoadAccessImpl.load(Serializable) line: 2551	
	SessionImpl.get(Class, Serializable) line: 955	
	Main.testBasicUsage() line: 154	
	Main.<init>() line: 60	
	Main.main(String[]) line: 54	

/ 7	. 

/ SAMENVATTING

/ 13.	
	protected void secondPassCompile() throws MappingException {
			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/ processes hbm.xml files
			originalSecondPassCompile();
/ processes collections

/ 13	.

		protected void processMetadata(List<MetadataSourceType> order) {
/ for all hbm.xml files	,
	private static void bindRootPersistentClassCommonValues(Element node,
/ create Table	,
				bindSimpleId( subnode, entity, mappings, inheritedMetas );
/  creates SimpleValue met de Table, 
/ en creates ArrayList<Column>	, die in de SimpleValue komt	,
/ create Property, die de SimpleValue als value krijgt	,

/ create primary key	, en sets it in Table

		createClassProperties( node, entity, mappings, inheritedMetas );
/ creates andere Property's	, de meeste hebben een SimpleValue value, maar employees als value een Set	,

/ 13	.

/ een SimpleValue heeft een Table en ArrayList<Columm>	, 
/ een Set heeft een element en een key	,
/ een DependantValue heeft een Table en een ArrayList<Column> , employee.address_, en een value SimpleValue	, address.id__	,
/ de RootClass van Address heeft properties, 1 ervan is employees , die als value een Set heeft	, 
/ een Backref is een Property, de RootClass van Address krijgt naast de 2 properties uit de XML een Backref	, met value de DependantValue	,

	public static void bindCollectionSecondPass(Element node, Collection collection,
/ configures de Set, collection	,
/ 	configures element, a OneToMany	,
 	sets key	, a DependatValue	,	
	creates  a Backref , een Property	, met value de DependantValue	,	

/13	.

	public void doSecondPass(java.util.Map persistentClasses)
		secondPass( persistentClasses, localInheritedMetas ); // using local since the inheritedMetas at this point is not the correct map since it is always the empty map
/ D
		collection.createAllKeys();
/ sets foreignKeys in Table(employee)	,

/ 13

/ de properties raadplegen later de entity voor values	, dat gebeurt met getters	, die hier worden create	,

/ dan creates sessionfactory	, 
/ die de persisters create	,
/  die getters/setters van de properties creates	,
	public AbstractEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo) {
			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );
		while ( itr.hasNext() ) {
			//TODO: redesign how PropertyAccessors are acquired...
			Property property = (Property) itr.next();
			getters[i] = buildPropertyGetter(property, mappingInfo);
 			setters[i] = buildPropertySetter(property, mappingInfo);

/ uiteindelijk	,

/ een persister heeft een entityMetaModel en een entityTuplizer	,	
/ in de tuplizer zitten de getters/setters die de properties use om de entities om values te vragen	,


/ van Address	,

this	SessionFactoryImpl  (id=63)	
	entityPersisters	HashMap<K,V>  (id=501)	
		table	HashMap$Entry<K,V>[16]  (id=519)	
			[1]	HashMap$Entry<K,V>  (id=524)	
				value	SingleTableEntityPersister  (id=80)	
					entityMetamodel	EntityMetamodel  (id=551)	
						properties	NonIdentifierAttribute[4]  (id=596)	
							[0]	EntityBasedBasicAttribute  (id=609)	
								attributeInformation	BaselineAttributeInformation  (id=689)	
								attributeName	"addressLine1" (id=690)	
								attributeNumber	0	
								attributeType	StringType  (id=213)	
								sessionFactory	SessionFactoryImpl  (id=63)	
								source	SingleTableEntityPersister  (id=80)	
							[3]	EntityBasedAssociationAttribute  (id=612)	
								attributeInformation	BaselineAttributeInformation  (id=678)	
								attributeName	"employees" (id=679)	
								attributeNumber	3	
								attributeType	SetType  (id=680)	
								hydratedCompoundValueHandler	null	
								joinable	null	
								sessionFactory	SessionFactoryImpl  (id=63)	
								source	SingleTableEntityPersister  (id=80)	
							[0]	BasicPropertyAccessor$BasicGetter  (id=627)	
								clazz	Class<T> (my.test.own.hibernate_xml_1_N.Address) (id=636)	
								method	Method  (id=1199)	
								propertyName	"addressLine1" (id=690)	
							[3]	BasicPropertyAccessor$BasicGetter  (id=630)	
								clazz	Class<T> (my.test.own.hibernate_xml_1_N.Address) (id=636)	
								method	Method  (id=1319)	
								propertyName	"employees" (id=679)	
						idGetter	BasicPropertyAccessor$BasicGetter  (id=620)	
							clazz	Class<T> (my.test.own.hibernate_xml_1_N.Address) (id=636)	
							method	Method  (id=1092)	
							propertyName	"id" (id=1094)	


/ van Employee	,

this	SessionFactoryImpl  (id=63)	
	entityPersisters	HashMap<K,V>  (id=501)	
		table	HashMap$Entry<K,V>[16]  (id=519)	
			[4]	HashMap$Entry<K,V>  (id=525)	
				value	SingleTableEntityPersister  (id=93)	
					entityMetamodel	EntityMetamodel  (id=126)	
						properties	NonIdentifierAttribute[3]  (id=191)	
							[0]	EntityBasedBasicAttribute  (id=201)	
									dirtyCheckable true
								attributeInformation	BaselineAttributeInformation  (id=210)	
								attributeName	"name" (id=212)	
								attributeNumber	0	
								attributeType	StringType  (id=213)	
								sessionFactory	SessionFactoryImpl  (id=63)	
								source	SingleTableEntityPersister  (id=93)	
							[1]
							[2]	EntityBasedBasicAttribute  (id=207)	
									dirtyCheckable false 
								attributeInformation	BaselineAttributeInformation  (id=234)	
								attributeName	"_my.test.own.hibernate_xml_1_N.Address.employeesBackref" (id=235)	
								attributeNumber	2	
								attributeType	LongType  (id=236)	
								sessionFactory	SessionFactoryImpl  (id=63)	
								source	SingleTableEntityPersister  (id=93)	
						getters	Getter[3]  (id=130)	
							[0]	BasicPropertyAccessor$BasicGetter  (id=2194)	
								clazz	Class<T> (my.test.own.hibernate_xml_1_N.Employee) (id=113)	
								method	Method  (id=2217)	
								propertyName	"name" (id=212)	
							[1]
							[2]	BackrefPropertyAccessor$BackrefGetter  (id=404)	
								this$0	BackrefPropertyAccessor  (id=101)	
									entityName	"my.test.own.hibernate_xml_1_N.Address" (id=103)	
									getter	BackrefPropertyAccessor$BackrefGetter  (id=404)	
									propertyName	"employees" (id=400)	
									setter	BackrefPropertyAccessor$BackrefSetter  (id=401)	
						idGetter	BasicPropertyAccessor$BasicGetter  (id=132)	
							clazz	Class<T> (my.test.own.hibernate_xml_1_N.Employee) (id=113)	
							method	Method  (id=2533)	
							propertyName	"id" (id=1094)	

/ 13	. 

/ .save(employee)

	protected Serializable performSaveOrReplicate(
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s
	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
/ gewone property	,
/s
BasicPropertyAccessor$BasicGetter.getForInsert(Object, Map, SessionImplementor) line: 204	
			return get( target );
/s
BasicPropertyAccessor$BasicGetter.get(Object) line: 169	
				return method.invoke( target, (Object[]) null );

/ backref	,
/s
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 121	
				return session.getPersistenceContext().getOwnerId( entityName, propertyName, target, mergeMap );

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 288	
		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
/ de insert action krijgt de values	,
[Foo1, 1.0, 12]
/s
		insert.makeEntityManaged();

/ uiteindeljk	,

source	SessionImpl  (id=5262)	
	persistenceContext	StatefulPersistenceContext  (id=5266)	
		entityEntryContext	EntityEntryContext  (id=5267)	
			head	EntityEntryContext$ManagedEntityImpl  (id=5307)	
				entityEntry	EntityEntry  (id=5310)	
					id	Long  (id=5313)	
					loadedState	Object[4]  (id=5314)	
						[0]	"foostreet" (id=5337)	
						[1]	"12 foo" (id=5338)	
						[2]	"FooCity12" (id=5339)	
						[3]	PersistentSet  (id=5340)	
				entityInstance	Address  (id=2868)	
					addressLine1	"foostreet" (id=2873)	
					city	"FooCity12A" (id=2874)	
					employees	PersistentSet  (id=2875)	
[my.test.own.hibernate_xml_1_N.Employee@323701e9, my.test.own.hibernate_xml_1_N.Employee@29967e3f]
					id	12	
					zipcode	"12 foo" (id=2880)	

				next	EntityEntryContext$ManagedEntityImpl  (id=5283)	
					entityEntry	EntityEntry  (id=5282)	
						id	Long  (id=5276)	
						loadedState	Object[3]  (id=5277)	
							[0]	"Foo1" (id=5427)	
							[1]	Double  (id=5428)	
							[2]	Long  (id=5313)	
12
					entityInstance	Employee  (id=5274)	
						id	1	
						name	"Foo1" (id=5427)	
						salary	1.0	


/ Dus we zien dat de property Set in de H van Address wel values heeft	,  en de fk in  de H van Employee is er ook	,  

/ 13	. 

/ .save(address)

/ hoe is de Set set?

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 624	
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
/s
BasicPropertyAccessor$BasicGetter.getForInsert(Object, Map, SessionImplementor) line: 204	
			return get( target );
/s
				return method.invoke( target, (Object[]) null );
public java.util.Set my.test.own.hibernate_xml_1_N.Address.getEmployees()

/ 13.
/ na de .save's	,
			address.setCity("FooCity12A");
			employee.setName("Foo1A");
			tx.commit();
/s
DefaultFlushEventListener.onFlush(FlushEvent) line: 55	
				flushEverythingToExecutions( event );
				performExecutions( source );

/ eerst	,
				flushEverythingToExecutions( event );
//////////////////
/ Checks of update nodig is	,

SessionImpl.flush() line: 1222	
 		FlushEvent flushEvent = new FlushEvent( this );
/ dus de session zit in de event	,
/s
			int entityCount = flushEntities( event, persistenceContext );
			int collectionCount = flushCollections( session, persistenceContext );

/ eerst	, 
			int entityCount = flushEntities( event, persistenceContext );

/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 152	
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
entity	Address  (id=2868)	
	addressLine1	"foostreet" (id=2873)	
	city	"FooCity12A" (id=2874)	
	employees	PersistentSet  (id=2875)	
	id	12	
	zipcode	"12 foo" (id=2880)	

		event.setPropertyValues( values );
/ Dus de (nieuwe) values komen in event,	

			// grab its current state
			values = persister.getPropertyValues( entity );
values	Object[4]  (id=2894)	
	[0]	"foostreet" (id=2873)	
	[1]	"12 foo" (id=2880)	
	[2]	"FooCity12A" (id=2874)	
	[3]	PersistentSet  (id=2875)	
//////////////////////////////////////
/ calls getters	,

		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/s
			dirtyCheck( event );
/ de session, values zitten in de event	,
/s
		final Object[] values = event.getPropertyValues();
/ nieuwe values	,
		final SessionImplementor session = event.getSession();
		final EntityEntry entry = event.getEntityEntry();
		final Object[] loadedState = entry.getLoadedState();
/ init values	,
/////////////////////////////////////////////
/ dirty vergelijkt properties	,
					// dirty check against the usual snapshot of the entity
					dirtyProperties = persister.findDirty( values, loadedState, entity, session );
[2]
		event.setDirtyProperties( dirtyProperties );


////////////////////////
/ als we straks de Set employees veranderen in een Address	, verandert de  fk address_ in de Employee ook	, 
/ hoe dan dirty	?
/ TODO

			substitute = scheduleUpdate( event ) || substitute;
/ In de event staat dirtyProperties=[2]	,

		session.getActionQueue().addAction(
				new EntityUpdateAction(
						entry.getId(),
						values,
						dirtyProperties,
...

/ Intermezzo

/ we zijn in	,
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 102	
			int entityCount = flushEntities( event, persistenceContext );
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 163	

/ Einde Intermezzo

			if ( persister.hasCollections() ) {
/ JA, de persister van Address heeft een Set	,
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/s
FlushVisitor(AbstractVisitor).processEntityPropertyValues(Object[], Type[]) line: 76	
		for ( int i=0; i<types.length; i++ ) {
				processValue( i, values, types );
/ Alleen de laatste interessant	, i=3, types[3]=SetType inst	,
role	"my.test.own.hibernate_xml_1_N.Address.employees" (id=2886)	
/s
		processValue( values[i], types[i] );
/s
	final Object processValue(Object value, Type type) throws HibernateException {
		if ( type.isCollectionType() ) {
			return processCollection( value, (CollectionType) type );
/s
			Collections.processReachableCollection( coll, type, owner, getSession() );
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 165	
		collection.setOwner( entity );
collection	PersistentSet  (id=2888)	
[my.test.own.hibernate_xml_1_N.Employee@4fd02b85]

		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );

		// The CollectionEntry.isReached() stuff is just to detect any silly users
		// who set up circular or shared references between/to collections.
/ TODO
		if ( ce.isReached() ) {
/ NEE

		final SessionFactoryImplementor factory = session.getFactory();
		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
		ce.setCurrentPersister( persister );
		//TODO: better to pass the id in as an argument?
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
12
entity	Address  (id=2866)	
	id	12	

		prepareCollectionForUpdate( collection, ce, factory );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 250	
/=
	private static void prepareCollectionForUpdate(
			PersistentCollection collection,
			CollectionEntry entry,
...
		final CollectionPersister loadedPersister = entry.getLoadedPersister();
null
		final CollectionPersister currentPersister = entry.getCurrentPersister();
OneToManyPersister(my.test.own.hibernate_xml_1_N.Address.employees)

			// if either its role changed, or its key changed
			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );
			if ( ownerChanged ) {
/ JA
/ DORECREATE
				if ( currentPersister != null ) {
					entry.setDorecreate( true );


/ dan een Employee	,
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 152	
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/s
	public Object[] getPropertyValues(Object entity) throws HibernateException {
		for ( int j = 0; j < span; j++ ) {
				result[j] = getters[j].get( entity );
/s
BackrefPropertyAccessor$BackrefGetter.get(Object) line: 136	
			return UNKNOWN;

/t
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/ D
Foo1A, 1.0, <unknown>]
/ Hij calls .get , niet .getForInsert	,

		event.setPropertyValues( values );
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
/s
	public int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)
previousState	Object[3]  (id=2897)	
currentState	Object[3]  (id=2923)	
			final boolean dirty = currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY
					&& properties[i].isDirtyCheckable( anyUninitializedProperties )
					&& properties[i].getType().isDirty( previousState[i], currentState[i], includeColumns[i], session );
/ voor 1 van de properties	,
/s
StringType(AbstractStandardBasicType<T>).isDirty(Object, Object) line: 237	
...
/ voor een andere propperty	,
DoubleType(AbstractStandardBasicType<T>).isDirty(Object, Object, boolean[], SessionImplementor) line: 233	
/ voor de backref , die een property is	, worden niet vergeleken	, deze is nooit dirty of niet	,
/s
 properties[i].isDirtyCheckable( anyUninitializedProperties )==false voor een Backref	, set in de properties in de in entityMetamodel in de persister	,
/ Dus de Set's zijn dirty of niet	,

/ Intermezzo

	protected void flushEverythingToExecutions(FlushEvent event) throws HibernateException {
			int entityCount = flushEntities( event, persistenceContext );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 231	

		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
			EntityEntry entry = me.getValue();
...
				final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
				for ( FlushEntityEventListener listener : flushListeners ) {
					listener.onFlushEntity( entityEvent );
				}
/ Dus in een event zit 1 entity entry	,
/ Zo allemaal	,

/ TMP
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );



/ Einde Intermezzo

/ Intermezzo

/ als we entries van een PersistentSet rm, verandert de Set zelf niet, dus is dirty=false	,  

/ In Address is een Set	,
			final boolean dirty = currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY
					&& properties[i].isDirtyCheckable( anyUninitializedProperties )
					&& properties[i].getType().isDirty( previousState[i], currentState[i], includeColumns[i], session );
/s
SetType(CollectionType).isDirty(Object, Object, boolean[], SessionImplementor) line: 345	
		return isDirty(old, current, session);
false
/ maar old==current	, 

/ Als we een string veranderen, dan wel: er staat gewoon een andere string	,

/ Einde Intermezzo

/ dan 
			int collectionCount = flushCollections( session, persistenceContext );
/s
		for ( Map.Entry<PersistentCollection,CollectionEntry> me : IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries() )) {
			PersistentCollection coll = me.getKey();
			CollectionEntry ce = me.getValue();

/ DORECREATE
			if ( ce.isDorecreate() ) {
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
								ce.getCurrentKey(),
								session
							)
					);
/ 13	. 

DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
/s
			session.getActionQueue().executeActions();
/s
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );

this	ActionQueue  (id=2894)	
	executableLists	Collections$UnmodifiableRandomAccessList<E>  (id=3265)	
		list	ArrayList<E>  (id=3297)	
			elementData	Object[10]  (id=3298)	
				[1]	ExecutableList<E>  (id=3266)	
					executables	ArrayList<E>  (id=3268)	
[EntityInsertAction[my.test.own.hibernate_xml_1_N.Address#12], EntityInsertAction[my.test.own.hibernate_xml_1_N.Employee#1], EntityInsertAction[my.test.own.hibernate_xml_1_N.Employee#2]]
				[2]	ExecutableList<E>  (id=3296)	
					executables	ArrayList<E>  (id=3300)	
[EntityUpdateAction[my.test.own.hibernate_xml_1_N.Address#12], EntityUpdateAction[my.test.own.hibernate_xml_1_N.Employee#1], EntityUpdateAction[my.test.own.hibernate_xml_1_N.Address#12], EntityUpdateAction[my.test.own.hibernate_xml_1_N.Employee#1]]

				[6]	ExecutableList<E>  (id=3290)	
					executables	ArrayList<E>  (id=3311)	
[CollectionRecreateAction[my.test.own.hibernate_xml_1_N.Address.employees#12]]

			session.save(address);
			session.save(employee);
			session.save(employee2);
/ geven entityinsertactions	, 
			
			address.setCity("FooCity12A");
			employee.setName("Foo1A");

/ geven  entityupdateactions

/ geven collectionrecreateaction
/ TODO

/s
ActionQueue.executeActions(ExecutableList<E>) line: 463	
			for ( E e : list ) {
				try {
					e.execute();

/ de 3 .save	,

/s
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );
/ de entity insert action heeft de state	,
[foostreet, 12 foo, FooCity12, [my.test.own.hibernate_xml_1_N.Employee@49275b5e, my.test.own.hibernate_xml_1_N.Employee@4a052c9e]]
/ values in entityinsertaction na de .save,	 dus voor de updates	,
Hibernate: insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 13:31:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 13:31:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 13:31:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 13:31:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
/ De Set zien we niet	,

/ TODO EHCAHCE hierna cache	,

/ volgende,	
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 13:32:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 13:32:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 13:32:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 13:32:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]
/ we zien de fk	,

Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 13:34:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 13:34:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 13:34:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 13:34:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]
/ we zien de fk	,

/ de 2 updates	,

/ volgende list	,

		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
/s
			for ( E e : list ) {
				try {
					e.execute();
/s
EntityUpdateAction.execute() line: 129	

/ TODO EHCACHE eerst cache	,

			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
this	EntityUpdateAction  (id=3379)	
	dirtyFields	(id=3383)	
[2]
	state	Object[4]  (id=3397)	
[foostreet, 12 foo, FooCity12A, [my.test.own.hibernate_xml_1_N.Employee@49275b5e, my.test.own.hibernate_xml_1_N.Employee@4a052c9e]]

/ we zien	,
Hibernate: update address set address_line1__=?, zipcoce__=?, city_=? where id__=?
HibernateLog --> 13:43:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 13:43:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 13:43:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12A]
HibernateLog --> 13:43:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

/ volgende,	
Hibernate: update employee set name_=?, salary_=? where id_=?
HibernateLog --> 13:45:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1A]
HibernateLog --> 13:45:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 13:45:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]
/ we zien de fk NIET, deze worden update in de collection recreate action	,



/ Dan  de collection recreate action	, 

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:49:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:49:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
HibernateLog --> 13:49:02 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?

Hibernate: update employee set address_=? where id_=?
HibernateLog --> 13:49:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 13:49:02 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
HibernateLog --> 13:49:02 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?

/ deze updates de fk 
/ WH (  we hebben 2 employees	, dus 2 updates)



/ Einde SAMENVATTING

/ 7	. 

/ we doen in Main2	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address2=new Address(21l,"foostreet", "21 foo", "FooCity21");
			
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(address2);
			session.save(employee);
			session.save(employee2);
			
			address.setCity("FooCity12A");
			employee.setName("Foo1A");
			address.getEmployees().remove(employee2);
			address2.getEmployees().add(employee2);
			tx.commit();

/ we zien bij .commit de volgende sql	,

HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [21 foo]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity21]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [21]
HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]
HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]
HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - update address set address_line1__=?, zipcoce__=?, city_=? where id__=?
Hibernate: update address set address_line1__=?, zipcoce__=?, city_=? where id__=?
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12A]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - update employee set name_=?, salary_=? where id_=?
Hibernate: update employee set name_=?, salary_=? where id_=?
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1A]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]
HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]
HibernateLog --> 17:17:59 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [21]
HibernateLog --> 17:17:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/ Dus we zien de laatste update, die de fk op 21 set van de employee2	, 

/ in de pc is in de entryentitycontext de loadedState nog steeds ["Foo2", 1.0, 12]	, dus staat daar nog de oude fk	,

/ 7	.

/ APPLICATION

/ appl. getOld

DefaultFlushEventListener.onFlush(FlushEvent) line: 55	
		final PersistenceContext persistenceContext = source.getPersistenceContext();
source	SessionImpl  (id=2853)	
				flushEverythingToExecutions( event );

/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 102	
		final PersistenceContext persistenceContext = session.getPersistenceContext();
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 231	
		final Map.Entry<Object,EntityEntry>[] entityEntries = persistenceContext.reentrantSafeEntityEntries();
		final int count = entityEntries.length;

		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
			EntityEntry entry = me.getValue();
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 144	
		final Object entity = event.getEntity();
		final EntityEntry entry = event.getEntityEntry();
		final EventSource session = event.getSession();
		final EntityPersister persister = entry.getPersister();
		final Status status = entry.getStatus();
		final Type[] types = persister.getPropertyTypes();

		final boolean mightBeDirty = entry.requiresDirtyCheck( entity );

		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/s
DefaultFlushEntityEventListener.getValues(Object, EntityEntry, boolean, SessionImplementor) line: 179	
		final Object[] loadedState = entry.getLoadedState();
		final Status status = entry.getStatus();
		final EntityPersister persister = entry.getPersister();

/ Ook misschien	,
	private int flushCollections(final EventSource session, final PersistenceContext persistenceContext) throws HibernateException {
		LOG.trace( "Processing unreferenced collections" );

		final Map.Entry<PersistentCollection,CollectionEntry>[] entries = IdentityMap.concurrentEntries(
				(Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries()
		);

		final int count = entries.length;

		for ( Map.Entry<PersistentCollection,CollectionEntry> me : entries ) {

/ 7	.

/ tmp notes

Thread [main] (Suspended)	
	SingleTableEntityPersister(AbstractEntityPersister).generateInsertString(boolean, boolean[], int) line: 2704	
	SingleTableEntityPersister(AbstractEntityPersister).generateInsertString(boolean[], int) line: 2656	
	SingleTableEntityPersister(AbstractEntityPersister).doLateInit() line: 3971	
	SingleTableEntityPersister(AbstractEntityPersister).postInstantiate() line: 4015	
	SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 481	
	Configuration.buildSessionFactory(ServiceRegistry) line: 1857	
	Main.setUp() line: 71	
	Main.<init>() line: 59	
	Main.main(String[]) line: 54	

/s
SingleTableEntityPersister(AbstractEntityPersister).doLateInit() line: 3971	
		for ( int j = 0; j < joinSpan; j++ ) {
			sqlInsertStrings[j] = customSQLInsert[j] == null ?
					generateInsertString( getPropertyInsertability(), j ) :
					customSQLInsert[j];
/s
SingleTableEntityPersister(AbstractEntityPersister).generateInsertString(boolean[], int) line: 2656	
		return generateInsertString( false, includeProperty, j );
/s
SingleTableEntityPersister(AbstractEntityPersister).generateInsertString(boolean, boolean[], int) line: 2704	
					else if ( includeProperty[i] ) {
						insert.addColumns( getPropertyColumnNames(i), propertyColumnInsertable[i], propertyColumnWriters[i] );
this	SingleTableEntityPersister  (id=1688)	
	propertyColumnInsertable	(id=2023)	
[[true], [true], [true], []]
	propertyColumnNames	String[4][]  (id=2010)	
[[address_line1_], [zipcoce_], [city_], []]
	propertyColumnWriters	String[4][]  (id=2061)	
[[?], [?], [?], []]
////////////////////////////////////
/ we zien dat Address.employees  geen  mapping in de queries heeft	,


/ Einde HIBERNATE

/ HIBERNATE CONFIG

/ 7	.

	public Configuration configure() throws HibernateException {
		configure( "/hibernate.cfg.xml" );
...
/s
Configuration.doConfigure(Document) line: 2206	
		Element sfNode = doc.getRootElement().element( "session-factory" );
		String name = sfNode.attributeValue( "name" );
		if ( name != null ) {
			properties.setProperty( Environment.SESSION_FACTORY_NAME, name );
hibernate.session_factory_name=null

		addProperties( sfNode );
/ alle  <property ...>s in de hibernate.cfg.xml	, dus ook die van 2nd level cache	,
/s
Configuration.addProperties(Element) line: 2031	

		Iterator itr = parent.elementIterator( "property" );
		while ( itr.hasNext() ) {
			Element node = (Element) itr.next();
			String name = node.attributeValue( "name" );
			String value = node.getText().trim();
			LOG.debugf( "%s=%s", name, value );
			properties.setProperty( name, value );
			if ( !name.startsWith( "hibernate" ) ) {
				properties.setProperty( "hibernate." + name, value );
			}
name	"connection.driver_class" (id=71)	
value	"org.postgresql.Driver" (id=73)	
name	"connection.url" (id=90)	
value	"jdbc:postgresql://localhost/foo" (id=91)	
name	"connection.username" (id=93)	
value	"foo" (id=94)	
...
name	"show_sql" (id=93)	
value	"true" (id=94)	
name	"current_session_context_class" (id=105)	
value	"thread" (id=106)	
name	"hbm2ddl.auto" (id=108)	
value	"create" (id=109)	
//////////////////////////////////////////////////////////
name	"cache.use_second_level_cache" (id=111)	
value	"true" (id=112)	
name	"cache.region.factory_class" (id=114)	
value	"org.hibernate.cache.ehcache.EhCacheRegionFactory" (id=115)	

/t
Configuration.doConfigure(Document) line: 2207	
		addProperties( sfNode );
/ D
		parseSessionFactory( sfNode, name );
/s
	private void parseSessionFactory(Element sfNode, String name) {
		Iterator elements = sfNode.elementIterator();
		while ( elements.hasNext() ) {
			Element subelement = (Element) elements.next();
			String subelementName = subelement.getName();
			if ( "mapping".equals( subelementName ) ) {
				parseMappingElement( subelement, name );
/s
Configuration.parseMappingElement(Element, String) line: 2255	

		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
...
		if ( resourceAttribute != null ) {
			final String resourceName = resourceAttribute.getValue();
			addResource( resourceName );
/s
Configuration.addResource(String) line: 757	
		ClassLoader contextClassLoader = ClassLoaderHelper.getContextClassLoader();
		InputStream resourceInputStream = null;
		if ( contextClassLoader != null ) {
			resourceInputStream = contextClassLoader.getResourceAsStream( resourceName );
		}
		add( resourceInputStream, "resource", resourceName );
/s
Configuration.add(InputStream, String, String) line: 684	
		final InputSource inputSource = new InputSource( inputStream );
		try {
			return add( inputSource, type, name );
/s
		return add( inputSource, new OriginImpl( originType, originName ) );
/s
	private XmlDocument add(InputSource inputSource, Origin origin) {
		XmlDocument metadataXml = MappingReader.INSTANCE.readMappingDocument( entityResolver, inputSource, origin );
		add( metadataXml );
/s
	public void add(XmlDocument metadataXml) {
		if ( inSecondPass || !isOrmXml( metadataXml ) ) {
			metadataSourceQueue.add( metadataXml );
/s
Configuration$MetadataSourceQueue.add(XmlDocument) line: 3668	
			final Document document = metadataXml.getDocumentTree();
			final Element hmNode = document.getRootElement();
org.dom4j.tree.DefaultElement@4fc9008e [Element: <hibernate-mapping attributes: [org.dom4j.tree.DefaultAttribute@1543938e [Attribute: name package value "my.test.own.hibernate_xml_1_N_ehcache"], org.dom4j.tree.DefaultAttribute@78c5a8a [Attribute: name default-cascade value "none"], org.dom4j.tree.DefaultAttribute@f8c1de5 [Attribute: name default-access value "property"], org.dom4j.tree.DefaultAttribute@37fead5c [Attribute: name default-lazy value "true"], org.dom4j.tree.DefaultAttribute@31278fbc [Attribute: name auto-import value "true"]]/>]
			Attribute packNode = hmNode.attribute( "package" );
			String defaultPackage = packNode != null ? packNode.getValue() : "";
			Set<String> entityNames = new HashSet<String>();
			findClassNames( defaultPackage, hmNode, entityNames );
/ sets entityNames=[my.test.own.hibernate_xml_1_N_ehcache.Employee]
			for ( String entity : entityNames ) {
				hbmMetadataByEntityNameXRef.put( entity, metadataXml );
			}
			this.hbmMetadataToEntityNamesMap.put( metadataXml, entityNames );

/ Deze worden later, hieronder, parsed	,

/ t
Configuration.configure() line: 2055	
		configure( "/hibernate.cfg.xml" );
/D


/ tmp
org/hibernate/cache/internal/RegionFactoryInitiator.java

/ 7	.

Configuration.secondPassCompile() line: 1410	
			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/s
					processHbmXmlQueue();
/s
Configuration$MetadataSourceQueue.processHbmXml(XmlDocument, Set<String>) line: 3759	
				HbmBinder.bindRoot( metadataXml, createMappings(), Collections.EMPTY_MAP, entityNames );
/s
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 400	

		Iterator subnodes = node.elementIterator();
		while ( subnodes.hasNext() ) {
			Element subnode = (Element) subnodes.next();
org.dom4j.tree.DefaultElement@324177e3 [Element: <cache attributes: [org.dom4j.tree.DefaultAttribute@6825f1db [Attribute: name usage value "read-write"], org.dom4j.tree.DefaultAttribute@13299648 [Attribute: name include value "all"]]/>]
			String name = subnode.getName();
name	"cache" (id=330)	
			else if ( "cache".equals( name ) ) {
				entity.setCacheConcurrencyStrategy( subnode.attributeValue( "usage" ) );
/s
RootClass.setCacheConcurrencyStrategy(String) line: 303	
this	RootClass  (id=318)	
		this.cacheConcurrencyStrategy = cacheConcurrencyStrategy;
				entity.setCacheRegionName( subnode.attributeValue( "region" ) );
/s
	public void setCacheRegionName(String cacheRegionName) {
		this.cacheRegionName = cacheRegionName;
null
				entity.setLazyPropertiesCacheable( !"non-lazy".equals( subnode.attributeValue( "include" ) ) );
/s
	public void setLazyPropertiesCacheable(boolean lazyPropertiesCacheable) {
		this.lazyPropertiesCacheable = lazyPropertiesCacheable;
true

/ we hebben	,
        <cache 
                usage="read-write"/>

		}
		createClassProperties( node, entity, mappings, inheritedMetas );
/s
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2229	

		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
			String name = subnode.getName();
			String propertyName = subnode.attributeValue( "name" );

			CollectionType collectType = CollectionType.collectionTypeFromString( name );
			Value value = null;
			if ( collectType != null ) {
				Collection collection = collectType.create(
						subnode,
						StringHelper.qualify( entityName, propertyName ),
						persistentClass,
						mappings, inheritedMetas
					);
/ Hierin wordt <one-to-many ...> process, maar NIET <cache ...> en NIET <key ...>	, deze later	,

/t
Configuration.secondPassCompile() line: 1424	
			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/ D
			originalSecondPassCompile();
/s
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2552	
		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
			String name = subnode.getName();
			if ( "key".equals( name ) ) {
/ ook	,
			else if ( "cache".equals( name ) ) {
				collection.setCacheConcurrencyStrategy( subnode.attributeValue( "usage" ) );
				collection.setCacheRegionName( subnode.attributeValue( "region" ) );
collection	Set  (id=88)	
	cacheConcurrencyStrategy	"read-write" (id=120)	
	cacheRegionName	null	

/ 7	.

/t
Configuration.buildSessionFactory(ServiceRegistry) line: 1855	
		secondPassCompile();
/ D
		Settings settings = buildSettings( copy, serviceRegistry );
/s
SettingsFactory.buildSettings(Properties, ServiceRegistry) line: 295	

		// Second-level / query cache:

		boolean useSecondLevelCache = ConfigurationHelper.getBoolean( AvailableSettings.USE_SECOND_LEVEL_CACHE, properties, true );
true
/ Kunnen we dus ook weglaten	, true is de default	,
/ TODO
		settings.setSecondLevelCacheEnabled( useSecondLevelCache );

		boolean useQueryCache = ConfigurationHelper.getBoolean(AvailableSettings.USE_QUERY_CACHE, properties);
false
		settings.setQueryCacheEnabled( useQueryCache );
		if (useQueryCache) {
/NEE
			settings.setQueryCacheFactory( createQueryCacheFactory( properties, serviceRegistry ) );
/ NIET

		settings.setRegionFactory( serviceRegistry.getService( RegionFactory.class ) );
/s
RegionFactoryInitiator.initiateService(Map, ServiceRegistryImplementor) line: 85	
		final String setting = ConfigurationHelper.getString( AvailableSettings.CACHE_REGION_FACTORY,
				configurationValues, null );
setting	"org.hibernate.cache.ehcache.EhCacheRegionFactory" (id=220)	

				final Class<? extends RegionFactory> regionFactoryClass = registry.getService( StrategySelector.class )
						.selectStrategyImplementor( RegionFactory.class, setting );
				try {
					regionFactory = regionFactoryClass.getConstructor( Properties.class ).newInstance( p );
/s
EhCacheRegionFactory.<init>(Properties) line: 68	
	super();
/s
EhCacheRegionFactory(AbstractEhcacheRegionFactory).<init>() line: 102	

	protected final EhcacheAccessStrategyFactory accessStrategyFactory =
			new NonstopAccessStrategyFactory( new EhcacheAccessStrategyFactoryImpl() );

/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 254	
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/ D
service	EhCacheRegionFactory  (id=249)	
			registerService( serviceBinding, service );
/t
SettingsFactory.buildSettings(Properties, ServiceRegistry) line: 295	
		settings.setRegionFactory( serviceRegistry.getService( RegionFactory.class ) );
/ D (...)
/t
/s
		this.regionFactory = regionFactory;
/t


		boolean useMinimalPuts = ConfigurationHelper.getBoolean(
				AvailableSettings.USE_MINIMAL_PUTS, properties, settings.getRegionFactory().isMinimalPutsEnabledByDefault()
		);
true
		settings.setMinimalPutsEnabled( useMinimalPuts );

		String prefix = properties.getProperty( AvailableSettings.CACHE_REGION_PREFIX );
null
		if ( StringHelper.isEmpty(prefix) ) {
			prefix=null;
		}
		settings.setCacheRegionPrefix( prefix );

		boolean useStructuredCacheEntries = ConfigurationHelper.getBoolean( AvailableSettings.USE_STRUCTURED_CACHE, properties, false );
false
		settings.setStructuredCacheEntriesEnabled( useStructuredCacheEntries );

		boolean useDirectReferenceCacheEntries = ConfigurationHelper.getBoolean(
				AvailableSettings.USE_DIRECT_REFERENCE_CACHE_ENTRIES,
				properties,
				false
		);
false
		settings.setDirectReferenceCacheEntriesEnabled( useDirectReferenceCacheEntries );

		boolean autoEvictCollectionCache = ConfigurationHelper.getBoolean( AvailableSettings.AUTO_EVICT_COLLECTION_CACHE, properties, false);
false
		settings.setAutoEvictCollectionCache( autoEvictCollectionCache );

/ t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 273	
		this.cacheAccess = this.serviceRegistry.getService( CacheImplementor.class );
/ PARSES EHCACHE.XML
...
/s
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 254	
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
service	CacheImpl  (id=369)	
	allCacheRegions	ConcurrentHashMap<K,V>  (id=370)	
{}
	queryCache	null	
	queryCaches	null	
	regionFactory	EhCacheRegionFactory  (id=249)	
	sessionFactory	SessionFactoryImpl  (id=327)	
	settings	Settings  (id=186)	

		this.cacheAccess = this.serviceRegistry.getService( CacheImplementor.class );
/s
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 206	
		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
serviceRole	Class<T> (org.hibernate.engine.spi.CacheImplementor) (id=239)	

		R service = serviceBinding.getService();
		if ( service == null ) {
/ JA
			service = initializeService( serviceBinding );
/s
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 225	
		// PHASE 1 : create service
		R service = createService( serviceBinding );
/s
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 251	
		final ServiceInitiator<R> serviceInitiator = serviceBinding.getServiceInitiator();
serviceInitiator	CacheInitiator  (id=245)	
		try {
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/s
SessionFactoryServiceRegistryImpl.initiateService(ServiceInitiator<R>) line: 91	
		else if ( configuration != null ) {
			return sessionFactoryServiceInitiator.initiateService( sessionFactory, configuration, this );
/s
CacheInitiator.initiateService(SessionFactoryImplementor, Configuration, ServiceRegistryImplementor) line: 40	
		return new CacheImpl( sessionFactory );
/s
CacheImpl.<init>(SessionFactoryImplementor) line: 70	

		this.settings = sessionFactory.getSettings();
		this.regionFactory = settings.getRegionFactory();
this	CacheImpl  (id=244)	
	regionFactory	EhCacheRegionFactory  (id=219)	
		regionFactory.start( settings, sessionFactory.getProperties() );
/s
EhCacheRegionFactory.start(Settings, Properties) line: 73	
/=
	public void start(Settings settings, Properties properties) throws CacheException {
		this.settings = settings;
		if ( manager != null ) {
/ NEE
			LOG.attemptToRestartAlreadyStartedEhCacheProvider();
/ NIET
		try {
			String configurationResourceName = null;
			if ( properties != null ) {
				configurationResourceName = (String) properties.get( NET_SF_EHCACHE_CONFIGURATION_RESOURCE_NAME );
null
			if ( configurationResourceName == null || configurationResourceName.length() == 0 ) {
				final Configuration configuration = ConfigurationFactory.parseConfiguration();
/s
/ Ehcache's
ConfigurationFactory.parseConfiguration() line: 123	
        ClassLoader standardClassloader = ClassLoaderUtil.getStandardClassLoader();
sun.misc.Launcher$AppClassLoader@5511e28
        URL url = null;
        if (standardClassloader != null) {
            url = standardClassloader.getResource(DEFAULT_CLASSPATH_CONFIGURATION_FILE);
DEFAULT_CLASSPATH_CONFIGURATION_FILE="/ehcache.xml"
null
/ TODO ("/ehcache.xml" vindt hij niet, "ehcache.xml" vindt hij wel)

       if (url == null) {
            url = ConfigurationFactory.class.getResource(DEFAULT_CLASSPATH_CONFIGURATION_FILE);
/s
/ Java's
    public java.net.URL getResource(String name) {
        name = resolveName(name);
        ClassLoader cl = getClassLoader0();
cl	Launcher$AppClassLoader  (id=83)	

        if (cl==null) {
/ NEE
            // A system class.
            return ClassLoader.getSystemResource(name);
/ NIET
        }
        return cl.getResource(name);

/t
ConfigurationFactory.parseConfiguration() line: 131	
           url = ConfigurationFactory.class.getResource(DEFAULT_CLASSPATH_CONFIGURATION_FILE);
/ D
file:/home/eric/Devel/Java/Ehcache/hibernate_xml_1_N_ehcache/target/classes/ehcache.xml

        Configuration configuration = parseConfiguration(url);
/s
/ Ehcache's
ConfigurationFactory.parseConfiguration(URL) line: 98	
    public static Configuration parseConfiguration(final URL url) throws CacheException {
            input = url.openStream();
            configuration = parseConfiguration(input);
/s
/ Ehcache's
ConfigurationFactory.parseConfiguration(InputStream) line: 150	
        Configuration configuration = new Configuration();
        try {
            InputStream translatedInputStream = translateSystemProperties(inputStream);
/s
ConfigurationFactory.translateSystemProperties(InputStream) line: 200	
        Reader reader = new InputStreamReader(inputStream, "UTF-8");
        while ((c = reader.read()) != -1) {
            sb.append((char) c);
        }
        String configuration = sb.toString();
<?xml version="1.0" encoding="UTF-8"?>

<ehcache 	
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    		xsi:noNamespaceSchemaLocation="ehcache.xsd" 
    		updateCheck="true"
    		monitoring="autodetect" 
    		dynamicConfig="true">
 	
    <diskStore path="java.io.tmpdir/ehcache" />
 
 
  <defaultCache 
    		maxBytesLocalHeap="100M" 
			eternal="true"
  			maxBytesLocalDisk="100M" 
  			statistics="true">
 			<persistence strategy="localTempSwap" />
    </defaultCache>   
    
    <cache 
    		name="my.test.own.hibernate_xml_1_N_ehcache.Employee"
   			maxBytesLocalHeap="100M" 
			eternal="true"
  			maxBytesLocalDisk="100M" 
   	>
 			<persistence strategy="localTempSwap" />

      </cache>
      
      <cache 
      		name="my.test.own.hibernate_xml_1_N_ehcache.Address"
   			maxBytesLocalHeap="100M" 
			eternal="true"
  			maxBytesLocalDisk="100M" 
  		>
 			<persistence strategy="localTempSwap" />

      </cache>
      
      <cache 
      		name="my.test.own.hibernate_xml_1_N_ehcache.Address.employees"
   			maxBytesLocalHeap="100M" 
			eternal="true"
  			maxBytesLocalDisk="100M" 
  		>
 			<persistence strategy="localTempSwap" />

      </cache>
        
    
</ehcache>

        Set tokens = extractPropertyTokens(configuration);
[]
        for (Object tokenObject : tokens) {
/ NEE

       return new ByteArrayInputStream(configuration.getBytes("UTF-8"));
/t
ConfigurationFactory.parseConfiguration(InputStream) line: 155	
            InputStream translatedInputStream = translateSystemProperties(inputStream);
/ D
inputStream	BufferedInputStream  (id=368)	
translatedInputStream	ByteArrayInputStream  (id=407)	

            final SAXParser parser = SAXParserFactory.newInstance().newSAXParser();
            final BeanHandler handler = new BeanHandler(configuration);

/ Ehcache's
final class BeanHandler extends DefaultHandler {
/ DefaultHandler is een SAX class type	,
           parser.parse(translatedInputStream, handler);
/ sets configuration in handler,	

configuration	Configuration  (id=385)	
	cacheConfigurations	ConcurrentHashMap<K,V>  (id=386)	
		entrySet	ConcurrentHashMap$EntrySet  (id=573)	
		hashSeed	0	
		keySet	null	
		keySet	null	
		segmentMask	15	
		segments	ConcurrentHashMap$Segment<K,V>[16]  (id=499)	
			[0]	ConcurrentHashMap$Segment<K,V>  (id=502)	
			[4]	ConcurrentHashMap$Segment<K,V>  (id=503)	
				count	1	
				loadFactor	0.75	
				modCount	1	
				sync	ReentrantLock$NonfairSync  (id=538)	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=539)	
					[0]	ConcurrentHashMap$HashEntry<K,V>  (id=541)	
						hash	1083188208	
						key	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=543)	
						next	null	
						value	CacheConfiguration  (id=544)	
							bootstrapCacheLoaderFactoryConfiguration	null	
							cacheDecoratorConfigurations	ArrayList<E>  (id=546)	
							cacheEventListenerConfigurations	ArrayList<E>  (id=547)	
							cacheExceptionHandlerFactoryConfiguration	null	
							cacheExtensionConfigurations	ArrayList<E>  (id=548)	
							cacheLoaderConfigurations	ArrayList<E>  (id=549)	
							cacheLoaderTimeoutMillis	0	
							cacheWriterConfiguration	CacheWriterConfiguration  (id=478)	
							clearOnFlush	true	
							conflictingEternalValuesWarningLogged	false	
							copyOnRead	null	
							copyOnWrite	null	
							copyStrategyConfiguration	CopyStrategyConfiguration  (id=552)	
							diskAccessStripes	1	
							diskExpiryThreadIntervalSeconds	120	
							diskPersistent	null	
							diskSpoolBufferSizeMB	30	
							dynamicSearchListeners	CopyOnWriteArraySet<E>  (id=553)	
							elementValueComparatorConfiguration	ElementValueComparatorConfiguration  (id=554)	
							eternal	true	
							flexIndexer	null	
							frozen	false	
							listeners	CopyOnWriteArraySet<E>  (id=555)	
							logging	false	
							maxBytesLocalDisk	Long  (id=556)	
							maxBytesLocalDiskExplicitlySet	true	
							maxBytesLocalDiskInput	"100M" (id=558)	
							maxBytesLocalDiskPercentage	null	
							maxBytesLocalHeap	Long  (id=560)	
							maxBytesLocalHeapInput	"100M" (id=561)	
							maxBytesLocalHeapPercentage	null	
							maxBytesLocalOffHeap	null	
							maxBytesLocalOffHeapExplicitlySet	false	
							maxBytesLocalOffHeapInput	null	
							maxBytesLocalOffHeapPercentage	null	
							maxElementsOnDisk	0	
							maxEntriesLocalDiskExplicitlySet	false	
							maxEntriesLocalHeap	null	
							memoryStoreEvictionPolicy	MemoryStoreEvictionPolicy  (id=493)	
							name	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=543)	
							offHeapPoolUsage	null	
							onDiskPoolUsage	null	
							onHeapPoolUsage	null	
							overflowToDisk	null	
							overflowToOffHeap	null	
							persistenceConfiguration	PersistenceConfiguration  (id=565)	
							pinningConfiguration	null	
							searchable	null	
							sizeOfPolicyConfiguration	null	
							statistics	false	
							terracottaConfiguration	null	
							timeToIdleSeconds	0	
							timeToLiveSeconds	0	
							transactionalMode	null	
				threshold	1	
			[14]	ConcurrentHashMap$Segment<K,V>  (id=506)	
				count	1	
				loadFactor	0.75	
				modCount	1	
				sync	ReentrantLock$NonfairSync  (id=507)	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=510)	
					[0]	ConcurrentHashMap$HashEntry<K,V>  (id=515)	
						hash	-381176262	
						key	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=516)	
						next	null	
						value	CacheConfiguration  (id=517)	
							bootstrapCacheLoaderFactoryConfiguration	null	
							cacheDecoratorConfigurations	ArrayList<E>  (id=518)	
							cacheEventListenerConfigurations	ArrayList<E>  (id=519)	
							cacheExceptionHandlerFactoryConfiguration	null	
							cacheExtensionConfigurations	ArrayList<E>  (id=520)	
							cacheLoaderConfigurations	ArrayList<E>  (id=521)	
							cacheLoaderTimeoutMillis	0	
							cacheWriterConfiguration	CacheWriterConfiguration  (id=478)	
							clearOnFlush	true	
							conflictingEternalValuesWarningLogged	false	
							copyOnRead	null	
							copyOnWrite	null	
							copyStrategyConfiguration	CopyStrategyConfiguration  (id=522)	
							diskAccessStripes	1	
							diskExpiryThreadIntervalSeconds	120	
							diskPersistent	null	
							diskSpoolBufferSizeMB	30	
							dynamicSearchListeners	CopyOnWriteArraySet<E>  (id=523)	
							elementValueComparatorConfiguration	ElementValueComparatorConfiguration  (id=524)	
							eternal	true	
							flexIndexer	null	
							frozen	false	
							listeners	CopyOnWriteArraySet<E>  (id=525)	
							logging	false	
							maxBytesLocalDisk	Long  (id=526)	
							maxBytesLocalDiskExplicitlySet	true	
							maxBytesLocalDiskInput	"100M" (id=527)	
							maxBytesLocalDiskPercentage	null	
							maxBytesLocalHeap	Long  (id=528)	
							maxBytesLocalHeapInput	"100M" (id=529)	
							maxBytesLocalHeapPercentage	null	
							maxBytesLocalOffHeap	null	
							maxBytesLocalOffHeapExplicitlySet	false	
							maxBytesLocalOffHeapInput	null	
							maxBytesLocalOffHeapPercentage	null	
							maxElementsOnDisk	0	
							maxEntriesLocalDiskExplicitlySet	false	
							maxEntriesLocalHeap	null	
							memoryStoreEvictionPolicy	MemoryStoreEvictionPolicy  (id=493)	
							name	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=516)	
							offHeapPoolUsage	null	
							onDiskPoolUsage	null	
							onHeapPoolUsage	null	
							overflowToDisk	null	
							overflowToOffHeap	null	
							persistenceConfiguration	PersistenceConfiguration  (id=530)	
							pinningConfiguration	null	
							searchable	null	
							sizeOfPolicyConfiguration	null	
							statistics	false	
							terracottaConfiguration	null	
							timeToIdleSeconds	0	
							timeToLiveSeconds	0	
							transactionalMode	null	
				threshold	1	
		segmentShift	28	
		values	null	
		values	null	
	cacheManagerEventListenerFactoryConfiguration	null	
	cacheManagerName	null	
	cacheManagerPeerListenerFactoryConfiguration	ArrayList<E>  (id=387)	
	cacheManagerPeerProviderFactoryConfiguration	ArrayList<E>  (id=388)	
	cfg	null	
	configurationSource	null	
	defaultCacheConfiguration	CacheConfiguration  (id=470)				/ !
	defaultTransactionTimeoutInSeconds	15	
	diskStoreConfiguration	DiskStoreConfiguration  (id=472)				/ !	
		originalPath	"java.io.tmpdir/ehcache" (id=497)	
		path	"/tmp/ehcache" (id=498)	
	dynamicConfig	true	
	managementRESTService	null	
	maxBytesLocalDisk	null	
	maxBytesLocalDiskInput	null	
	maxBytesLocalHeap	null	
	maxBytesLocalHeapInput	null	
	maxBytesLocalOffHeap	null	
	maxBytesLocalOffHeapInput	null	
	monitoring	Configuration$Monitoring  (id=390)	
	propertyChangeListeners	CopyOnWriteArrayList<E>  (id=392)	
	sizeOfPolicyConfiguration	null	
	terracottaConfigConfiguration	null	
	transactionManagerLookupConfiguration	null	
	updateCheck	true	

        configuration.setSource(ConfigurationSource.getConfigurationSource(inputStream));
/ TODO

/t
EhCacheRegionFactory.start(Settings, Properties) line: 86	
				final Configuration configuration = ConfigurationFactory.parseConfiguration();
/ D
				manager = new CacheManager( configuration );
/s
CacheManager.<init>(Configuration) line: 258	
    public CacheManager(Configuration configuration) throws CacheException {
        status = Status.STATUS_UNINITIALISED;
        init(configuration, null, null, null);
    }
/s
CacheManager.init(Configuration, String, URL, InputStream) line: 366	
/=
   protected synchronized void init(Configuration initialConfiguration, String configurationFileName, URL configurationURL,
...
/s
CacheManager.doInit(Configuration) line: 411	

        // do this last
        addConfiguredCaches(configurationHelper);
/ TODO

/t
EhCacheRegionFactory.start(Settings, Properties) line: 110	
				manager = new CacheManager( configuration );
/ D
/t
CacheImpl.<init>(SessionFactoryImplementor) line: 71	
		regionFactory.start( settings, sessionFactory.getProperties() );
/ D
		if ( settings.isQueryCacheEnabled() ) {
/NEE

/t
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 254	
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/ D
			registerService( serviceBinding, service );
/ sets service in serviceBinding	,
serviceBinding	ServiceBinding<R>  (id=240)	
	service	CacheImpl  (id=244)	
	serviceRole	Class<T> (org.hibernate.engine.spi.CacheImplementor) (id=239)	

/t
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 209	
			service = initializeService( serviceBinding );
/ D
/ In initializeService alleen PHASE 1 (misschien 2)	, 3 en 4 doen niets	,

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 274	
		this.cacheAccess = this.serviceRegistry.getService( CacheImplementor.class );
/ D
/ PARSED EHCACHE
this	SessionFactoryImpl  (id=229)	
	cacheAccess	CacheImpl  (id=244)	
		allCacheRegions	ConcurrentHashMap<K,V>  (id=273)	
		regionFactory	EhCacheRegionFactory  (id=219)	
			accessStrategyFactory	NonstopAccessStrategyFactory  (id=267)	
				actualFactory	EhcacheAccessStrategyFactoryImpl  (id=852)	
			manager	CacheManager  (id=706)	
				defaultCache	Cache  (id=818)	
				ehcaches	ConcurrentHashMap<K,V>  (id=825)	
					segments	ConcurrentHashMap$Segment<K,V>[16]  (id=879)	
						[0]	ConcurrentHashMap$Segment<K,V>  (id=886)	
						[4]	ConcurrentHashMap$Segment<K,V>  (id=887)	
						[14]	ConcurrentHashMap$Segment<K,V>  (id=888)	

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 340	

		///////////////////////////////////////////////////////////////////////
		// Prepare persisters and link them up with their cache
		// region/access-strategy

		final RegionFactory regionFactory = cacheAccess.getRegionFactory();
regionFactory	EhCacheRegionFactory  (id=249)	

		entityPersisters = new HashMap();
		Map entityAccessStrategies = new HashMap();
		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
		classes = cfg.getClassMappings();
		while ( classes.hasNext() ) {
			final PersistentClass model = (PersistentClass) classes.next();
			model.prepareTemporaryTables( mapping, getDialect() );
			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
cacheRegionName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=2812)	
model	RootClass  (id=50)	
	cacheRegionName	null	

			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
null
/ want	net nieuw,
entityAccessStrategies={}	

			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
				final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
model.getCacheConcurrencyStrategy()="read-write'
accessType	AccessType  (id=2831)	
	externalName	"read-write" (id=2837)	
	name	"READ_WRITE" (id=2838)	
	ordinal	1	

				if ( accessType != null ) {
					EntityRegion entityRegion = regionFactory.buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
///////////////////////////////////////////////////////
/ Dit gaan we doen 	,
/ Het wordt een EhcacheEntityRegion inst	,

/s
CacheDataDescriptionImpl.decode(PersistentClass) line: 82	
/s
	public CacheDataDescriptionImpl(boolean mutable, boolean versioned, Comparator versionComparator) {
		this.mutable = mutable;
true
		this.versioned = versioned;
false
		this.versionComparator = versionComparator;
null
	}

/t
/s

/ Intermezzo

public class EhCacheRegionFactory extends AbstractEhcacheRegionFactory {
	public void start(Settings settings, Properties properties) throws CacheException {
			if ( properties != null ) {
				configurationResourceName = (String) properties.get( NET_SF_EHCACHE_CONFIGURATION_RESOURCE_NAME );
			}
			if ( configurationResourceName == null || configurationResourceName.length() == 0 ) {
				final Configuration configuration = ConfigurationFactory.parseConfiguration();
				manager = new CacheManager( configuration );
			}

/ Het is al gedaan	,

/ alles zit in de factory	,

this	EhCacheRegionFactory  (id=249)	
	manager	CacheManager  (id=2794)	
		defaultCache	Cache  (id=2857)	
		ehcaches	ConcurrentHashMap<K,V>  (id=2859)	
			segments	ConcurrentHashMap$Segment<K,V>[16]  (id=2863)	
				[0]	ConcurrentHashMap$Segment<K,V>  (id=2864)	
					table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=2917)	
						[0]	ConcurrentHashMap$HashEntry<K,V>  (id=2919)	
							key	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=2921)	
							value	Cache  (id=2922)	
				[4]	ConcurrentHashMap$Segment<K,V>  (id=2865)	
					table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=2952)	
						[0]	ConcurrentHashMap$HashEntry<K,V>  (id=2956)	
							key	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=2959)	
							value	Cache  (id=2960)	
				[14]	ConcurrentHashMap$Segment<K,V>  (id=2866)	
					table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=2965)	
						[0]	ConcurrentHashMap$HashEntry<K,V>  (id=2967)	
							key	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=2969)	
							value	Cache  (id=2970)	

/ Er is ook	,

package net.sf.ehcache;
public class CacheManager {
...


/ Einde Intermezzo

...
/s
EhCacheRegionFactory(AbstractEhcacheRegionFactory).buildEntityRegion(String, Properties, CacheDataDescription) line: 127	
		return new EhcacheEntityRegion( accessStrategyFactory, getCache( regionName ), settings, metadata, properties );
/s
EhCacheRegionFactory(AbstractEhcacheRegionFactory).getCache(String) line: 177	
			Ehcache cache = manager.getEhcache( name );
/s
CacheManager.getEhcache(String) line: 1091	
        return ehcaches.get(name);
this	CacheManager  (id=2794)	
	defaultCache	Cache  (id=2857)	
	ehcaches	ConcurrentHashMap<K,V>  (id=2859)	
{my.test.own.hibernate_xml_1_N_ehcache.Address.employees=[ name = my.test.own.hibernate_xml_1_N_ehcache.Address.employees status = STATUS_ALIVE eternal = true overflowToDisk = true maxEntriesLocalHeap = 0 maxEntriesLocalDisk = 0 memoryStoreEvictionPolicy = LRU timeToLiveSeconds = 0 timeToIdleSeconds = 0 persistence = LOCALTEMPSWAP diskExpiryThreadIntervalSeconds = 120 cacheEventListeners: net.sf.ehcache.statistics.LiveCacheStatisticsWrapper  hitCount = 0 memoryStoreHitCount = 0 diskStoreHitCount = 0 missCountNotFound = 0 missCountExpired = 0 maxBytesLocalHeap = 104857600 overflowToOffHeap = false maxBytesLocalOffHeap = 0 maxBytesLocalDisk = 104857600 pinned = false ]

 my.test.own.hibernate_xml_1_N_ehcache.Address=[ name = my.test.own.hibernate_xml_1_N_ehcache.Address status = STATUS_ALIVE eternal = true overflowToDisk = true maxEntriesLocalHeap = 0 maxEntriesLocalDisk = 0 memoryStoreEvictionPolicy = LRU timeToLiveSeconds = 0 timeToIdleSeconds = 0 persistence = LOCALTEMPSWAP diskExpiryThreadIntervalSeconds = 120 cacheEventListeners: net.sf.ehcache.statistics.LiveCacheStatisticsWrapper  hitCount = 0 memoryStoreHitCount = 0 diskStoreHitCount = 0 missCountNotFound = 0 missCountExpired = 0 maxBytesLocalHeap = 104857600 overflowToOffHeap = false maxBytesLocalOffHeap = 0 maxBytesLocalDisk = 104857600 pinned = false ]

 my.test.own.hibernate_xml_1_N_ehcache.Employee=[ name = my.test.own.hibernate_xml_1_N_ehcache.Employee status = STATUS_ALIVE eternal = true overflowToDisk = true maxEntriesLocalHeap = 0 maxEntriesLocalDisk = 0 memoryStoreEvictionPolicy = LRU timeToLiveSeconds = 0 timeToIdleSeconds = 0 persistence = LOCALTEMPSWAP diskExpiryThreadIntervalSeconds = 120 cacheEventListeners: net.sf.ehcache.statistics.LiveCacheStatisticsWrapper  hitCount = 0 memoryStoreHitCount = 0 diskStoreHitCount = 0 missCountNotFound = 0 missCountExpired = 0 maxBytesLocalHeap = 104857600 overflowToOffHeap = false maxBytesLocalOffHeap = 0 maxBytesLocalDisk = 104857600 pinned = false ]}

/t
EhCacheRegionFactory(AbstractEhcacheRegionFactory).buildEntityRegion(String, Properties, CacheDataDescription) line: 127	
		return new EhcacheEntityRegion( accessStrategyFactory, getCache( regionName ), settings, metadata, properties );
/t
/s
EhcacheEntityRegion.<init>(EhcacheAccessStrategyFactory, Ehcache, Settings, CacheDataDescription, Properties) line: 64	
		super( accessStrategyFactory, underlyingCache, settings, metadata, properties );
/s
	/**
	 * Construct an transactional Hibernate cache region around the given Ehcache instance.
	 */
EhcacheEntityRegion(EhcacheTransactionalDataRegion).<init>(EhcacheAccessStrategyFactory, Ehcache, Settings, CacheDataDescription, Properties) line: 71	
/s
EhcacheEntityRegion(EhcacheDataRegion).<init>(EhcacheAccessStrategyFactory, Ehcache, Properties) line: 71	
		this.accessStrategyFactory = accessStrategyFactory;
		this.cache = cache;
		final String timeout = properties.getProperty(
				CACHE_LOCK_TIMEOUT_PROPERTY,
				Integer.toString( DEFAULT_CACHE_LOCK_TIMEOUT )
		);
		this.cacheLockTimeout = Timestamper.ONE_MS * Integer.decode( timeout );
/t
EhcacheEntityRegion(EhcacheTransactionalDataRegion).<init>(EhcacheAccessStrategyFactory, Ehcache, Settings, CacheDataDescription, Properties) line: 72	
		super( accessStrategyFactory, cache, properties );
/ D
		this.settings = settings;
		this.metadata = metadata;

		final Object context = cache.getInternalContext();
context	DiskStore$DiskStoreStripedReadWriteLock  (id=3276)	
		if ( context instanceof CacheLockProvider ) {
			this.lockProvider = (CacheLockProvider) context;

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 365	
					EntityRegion entityRegion = regionFactory.buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
/ D
entityRegion	EhcacheEntityRegion  (id=3236)	
	accessStrategyFactory	NonstopAccessStrategyFactory  (id=254)	
	cache	Cache  (id=2960)	
	cacheLockTimeout	245760000	
	lockProvider	DiskStore$DiskStoreStripedReadWriteLock  (id=3276)	
	metadata	CacheDataDescriptionImpl  (id=2847)	
	settings	Settings  (id=186)	

/ Dan	,
					accessStrategy = entityRegion.buildAccessStrategy( accessType );
/s
EhcacheEntityRegion.buildAccessStrategy(AccessType) line: 69	
		return getAccessStrategyFactory().createEntityRegionAccessStrategy( this, accessType );
/s
EhcacheEntityRegion(EhcacheDataRegion).getAccessStrategyFactory() line: 93	
		return accessStrategyFactory;
this	EhcacheEntityRegion  (id=3236)	
	accessStrategyFactory	NonstopAccessStrategyFactory  (id=254)	
/t
/s
NonstopAccessStrategyFactory.createEntityRegionAccessStrategy(EhcacheEntityRegion, AccessType) line: 59	
		return new NonstopAwareEntityRegionAccessStrategy(
				actualFactory.createEntityRegionAccessStrategy( entityRegion, accessType ),
				HibernateNonstopCacheExceptionHandler.getInstance()
		);
/s
EhcacheAccessStrategyFactoryImpl.createEntityRegionAccessStrategy(EhcacheEntityRegion, AccessType) line: 61	
			case READ_WRITE:
				return new ReadWriteEhcacheEntityRegionAccessStrategy( entityRegion, entityRegion.getSettings() );
/s
ReadWriteEhcacheEntityRegionAccessStrategy.<init>(EhcacheEntityRegion, Settings) line: 50	
		super( region, settings );
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).<init>(T, Settings) line: 65	
		super( region, settings );
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractEhcacheAccessStrategy<T>).<init>(T, Settings) line: 49	
		this.region = region;
		this.settings = settings;
region	EhcacheEntityRegion  (id=3236)	
	accessStrategyFactory	NonstopAccessStrategyFactory  (id=254)	
	cache	Cache  (id=2960)	
	cacheLockTimeout	245760000	
	lockProvider	DiskStore$DiskStoreStripedReadWriteLock  (id=3276)	
	metadata	CacheDataDescriptionImpl  (id=2847)	
	settings	Settings  (id=186)	

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 367	
					accessStrategy = entityRegion.buildAccessStrategy( accessType );
/ D
					entityAccessStrategies.put( cacheRegionName, accessStrategy );
					cacheAccess.addCacheRegion( cacheRegionName, entityRegion );
cacheRegionName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=2812)	

/ Dan	,
			EntityPersister cp = persisterFactory.createEntityPersister(
					model,
					accessStrategy,
					naturalIdAccessStrategy,
					this,
					mapping
			);
...
/s
SingleTableEntityPersister(AbstractEntityPersister).<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor) line: 520	
		this.entityMetamodel = new EntityMetamodel( persistentClass, this, factory );
/s
EntityMetamodel.<init>(PersistentClass, AbstractEntityPersister, SessionFactoryImplementor) line: 403	
		if ( tuplizerClassName == null ) {
			entityTuplizer = entityTuplizerFactory.constructDefaultTuplizer( entityMode, this, persistentClass );
...
/s
PojoEntityTuplizer.<init>(EntityMetamodel, PersistentClass) line: 80	
		super( entityMetamodel, mappedEntity );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).<init>(EntityMetamodel, PersistentClass) line: 196	

		if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );

		Iterator itr = mappingInfo.getPropertyClosureIterator();
		boolean foundCustomAccessor=false;
		int i=0;
		while ( itr.hasNext() ) {
			//TODO: redesign how PropertyAccessors are acquired...
			Property property = (Property) itr.next();
			getters[i] = buildPropertyGetter(property, mappingInfo);
			setters[i] = buildPropertySetter(property, mappingInfo);

/ t
SingleTableEntityPersister(AbstractEntityPersister).<init>(PersistentClass, EntityRegionAccessStrategy, NaturalIdRegionAccessStrategy, SessionFactoryImplementor) line: 794	
		this.cacheAccessStrategy = cacheAccessStrategy;
/D
...
		this.cacheEntryHelper = buildCacheEntryHelper();
/s
SingleTableEntityPersister(AbstractEntityPersister).buildCacheEntryHelper() line: 809	
		return factory.getSettings().isStructuredCacheEntriesEnabled()
false
				? new StructuredCacheEntryHelper( this )
				: new StandardCacheEntryHelper( this );
/s
AbstractEntityPersister$StandardCacheEntryHelper.<init>(EntityPersister) line: 5235	
			this.persister = persister;




/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 424	

		Iterator collections = cfg.getCollectionMappings();
		while ( collections.hasNext() ) {
			Collection model = (Collection) collections.next();
			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
			final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
			CollectionRegionAccessStrategy accessStrategy = null;
			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
				CollectionRegion collectionRegion = regionFactory.buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl
						.decode( model ) );
/s
EhCacheRegionFactory(AbstractEhcacheRegionFactory).buildCollectionRegion(String, Properties, CacheDataDescription) line: 148	
		return new EhcacheCollectionRegion(
				accessStrategyFactory,
				getCache( regionName ),
				settings,
				metadata,
				properties
		);
/s
EhCacheRegionFactory(AbstractEhcacheRegionFactory).getCache(String) line: 177	
		try {
			Ehcache cache = manager.getEhcache( name );
name	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3353)	
cache	Cache  (id=3354)	
/t
/s
EhcacheCollectionRegion.<init>(EhcacheAccessStrategyFactory, Ehcache, Settings, CacheDataDescription, Properties) line: 65	
		super( accessStrategyFactory, underlyingCache, settings, metadata, properties );
/s
EhcacheCollectionRegion(EhcacheTransactionalDataRegion).<init>(EhcacheAccessStrategyFactory, Ehcache, Settings, CacheDataDescription, Properties) line: 71	
		super( accessStrategyFactory, cache, properties );
/s
EhcacheCollectionRegion(EhcacheDataRegion).<init>(EhcacheAccessStrategyFactory, Ehcache, Properties) line: 71	

/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 426	
				CollectionRegion collectionRegion = regionFactory.buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl
						.decode( model ) );
/D
				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
accessStrategy	NonstopAwareCollectionRegionAccessStrategy  (id=3374)	

				cacheAccess.addCacheRegion( cacheRegionName, collectionRegion );
this	SessionFactoryImpl  (id=229)	
	cacheAccess	CacheImpl  (id=244)	
/s
		allCacheRegions.put( name, region );

/ Einde HIBERNATE CONFIG

/ HIBERNATE & EHCACHE

/ SAMENVATTING

/ 7	. 


/ In hibernate_xml4 (N_1, bidir) zijn er 3 entityinsertaction en 1 collectionrecreateaction	,
/ TODO

/ 7	.

/ In het kort	,

/ de ehcache entries worden create onder .commit	, 
/ spedifieker: onflush, performExecutions, action queue.prepare actions: lock in coll region, action queue.execute actions:  

	.save(address)
/ address in pc,  
/ en de collection in address in pc	,
/ creates entityinsertaction	,
	.save(employee)
/ employee in pc,  
	.save(employee2)
/ employee2 in pc,  

JdbcTransaction(AbstractTransactionImpl).commit() line: 171	
		beforeTransactionCommit();
/s
		flush();
/s
				flushEverythingToExecutions( event );
/s
			int entityCount = flushEntities( event, persistenceContext );
/ creates entityupdateaction if dirty (als na .seve(obj) obj.set...(...) is gedaan)	,
/ set docreate on collectionentry
			int collectionCount = flushCollections( session, persistenceContext );
/ creates collectionrecreateaction omdat de CollectionEntry's doRecreate=true	, 

/t
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
/s
			session.getActionQueue().prepareActions();
/ prepare(collectionCreations): ReadWriteEhcacheCollectionRegionAccessStrategy.lockItem(Object, Object)	, creates Lock en puts in ehcache onder CacheKey Long 12	, TODO 
/ er is in session, actionQueue, collectionCreations=[CollectionRecreateAction[my.test.own.hibernate_xml_1_N_ehcache.Address.employees#12]], wat heeft deze met de Lock in de ehcache te maken?

			session.getActionQueue().executeActions();
/s
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
/ insert entities:
/ persist entities naar db, WH met de oude loadedState uit de entityEntry	, dus NIET met de current state	, 
/ create ehcache entry, di. disassebles de state in de entityinsertaction, dit is WH de loaded state uit den entityentry, en dat is iha NIET de current state van het Address obj (TODO), set in entityinsertaction.cacheEntry=StandardCacheEntryImpl, met de disassembledState,		,
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess()==e=entityInsertAction );

/ maar bij flush hierboven zijn er entityupdateaction's create	, er wordt een CacheEntry in de entityupdateaction set, die later wordt process	, zodat de ehcache wordt update (een lock die nu al wordt put in ehcache -> de entity insert action's cacheentry komt NIET in ehcache	)	,
/ update entities: update dml naar db, creates entityUpdateAction.cacheEntry , di. wordt disassemble de current properties in de Address obj (met getters set in flush hierboven), wordt later processed	,
/ In hibernate_xml_1_N_ehcache doen we een update van het obj na .save voor .commit	,

/ TODO
			doCommit();
			afterTransactionCompletion( Status.STATUS_COMMITTED );

/ collection:

/ Als we NIET <set lazy="false"  ...> in Address's hbm.xml	, dan is onvolledig in een volgende session	,
	        address=(Address)session.get(Address.class, 12l);
/ De employees zitten er niet in	,

/ we zien dat als we WEL <set lazy="false" ...>	, dan 
	        address=(Address)session.get(Address.class, 12l);
/ geeft ook een put in de ehcache	, 
/ TODO (zijn dat de 2 id's van de Employee's?)


/ In detail	,

	.save(address)
/ address heeft een coll	,
/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 273	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
		Type[] types = persister.getPropertyTypes();

		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/s
DefaultSaveEventListener(AbstractSaveEventListener).visitCollectionsBeforeSave(Object, Serializable, Object[], Type[], EventSource) line: 372	
		WrapVisitor visitor = new WrapVisitor( source );
		visitor.processEntityPropertyValues( values, types );
/s
	public void processEntityPropertyValues(Object[] values, Type[] types) throws HibernateException {
		for ( int i=0; i<types.length; i++ ) {
				processValue( i, values, types );
/s
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 109	
				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
/ H properties is een Object[], en collection is een HashSet	, met de 2 Employee's	
/ persistentCollectionn =PersistentSet	,
	set=HashSet					/ onze eigen HashSet	,
	storedSnapshot=null
/s
SetType.wrap(SessionImplementor, Object) line: 58	
		return new PersistentSet( session, (java.util.Set) collection );
/t
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 109	
				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
/ D
				persistenceContext.addNewCollection( persister, persistentCollection );
/s
StatefulPersistenceContext.addCollection(PersistentCollection, CollectionPersister) line: 840	
		final CollectionEntry ce = new CollectionEntry( persister, collection );
/ collection=PersistentSet
	storedSnapshot=null
/ ce wordt CollectionEntry
	snapshot=dezelfde HashMap	,
/s
CollectionEntry.<init>(CollectionPersister, PersistentCollection) line: 91	
/ this=CollectionEntry	,
/ collection=PersistentSet	,
		this.snapshot = persister.isMutable() ?
				collection.getSnapshot(persister) :
				null;
////////////////////////////////////
/ maakt CollectionEntry's snapshot, is een HashMap met de 2 Employee's	,
/s
PersistentSet.getSnapshot(CollectionPersister) line: 97	
/=
	public Serializable getSnapshot(CollectionPersister persister) throws HibernateException {
/ this = PersistentSet	, this.set is een HashSet (de oorspronkelijke die we hebben create)	,met de 2 Employee's	, H gaat een HashMap maken	,
		final HashMap clonedSet = new HashMap( set.size() );
		for ( Object aSet : set ) {
/ aSet is een Employee	,
			final Object copied = persister.getElementType().deepCopy( aSet, persister.getFactory() );
/ s
ManyToOneType(EntityType).deepCopy(Object, SessionFactoryImplementor) line: 331	
/=
	public Object deepCopy(Object value, SessionFactoryImplementor factory) {
		return value; //special case ... this is the leaf of the containment graph, even though not immutable
	}

			clonedSet.put( copied, copied );

/t
CollectionEntry.<init>(CollectionPersister, PersistentCollection) line: 94	
		snapshot = persister.isMutable() ?
				collection.getSnapshot(persister) :
				null;
/ snapshot=HashMap met 2 Employee
		collection.setSnapshot(loadedKey, role, snapshot);
////////////////////////
/ Ook in de PersistentSet,	 PersistentSet.storedSnapshot=dezelfde HashMap	,
/t
StatefulPersistenceContext.addCollection(PersistentCollection, CollectionPersister) line: 841	
		final CollectionEntry ce = new CollectionEntry( persister, collection );
/ D
/ ce=CollectionEntry met de snapshot=HashMap met de 2 Employee's	,
/ collection=PersistenSet, collection.storedSnapshot=ce.snapShot=dezelfde HashMap 

		collectionEntries.put( collection, ce );

/ Klopt	, in collectionEntries is de PersistentSet de key, de CollectionEntry de value	,  beide hebben de HashMap met de 2 Employee, PersistentSet heeft zelfs nog de originele HashSet met de 2 Employee	,

persistenceContext	StatefulPersistenceContext  (id=2907)	
	collectionEntries	IdentityMap<K,V>  (id=2951)	
		map	LinkedHashMap<K,V>  (id=3056)	
			table	HashMap$Entry<K,V>[8]  (id=3067)	
				[1]	LinkedHashMap$Entry<K,V>  (id=3071)	
					key	IdentityMap$IdentityKey<K>  (id=3075)	
						key	PersistentSet  (id=3207)	
							set	HashSet<E>  (id=2925)	
							storedSnapshot	HashMap<K,V>  (id=3092)	
					value	CollectionEntry  (id=3079)	
						snapshot	HashMap<K,V>  (id=3092)	

				return persistentCollection; //Force a substitution!
/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 276	
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/ values[3]=PersistenSet	, met HashSet set en HashMap storedSnapshot	, beide met de 2 Employee's	,

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);


this	SessionImpl  (id=2993)	
	persistenceContext	StatefulPersistenceContext  (id=3003)	
		collectionEntries	IdentityMap<K,V>  (id=3007)	
			map	LinkedHashMap<K,V>  (id=3021)	
				size	1	
				table	HashMap$Entry<K,V>[8]  (id=3025)	
					[2]	LinkedHashMap$Entry<K,V>  (id=3029)	
						hash	1136487282	
						value	CollectionEntry  (id=3034)	
							snapshot	HashMap<K,V>  (id=3038)	
								size	2	
								table	HashMap$Entry<K,V>[2]  (id=3040)	
									[0]	HashMap$Entry<K,V>  (id=3060)	
										value	Employee  (id=3063)	
									[1]	HashMap$Entry<K,V>  (id=3061)	
										value	Employee  (id=3065)	
/ collectionsByKey is leeg	,
/ de Employees in deze coll zijn precies dezelfde als in entityEntryContext	, see boven	,


	protected void beforeTransactionCommit() {
/s
			flush();
/s
				flushEverythingToExecutions( event );
/s
			int entityCount = flushEntities( event, persistenceContext );
/s
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
		event.setPropertyValues( values );
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
			substitute = scheduleUpdate( event ) || substitute;
/ creates entityupdateaction

			if ( persister.hasCollections() ) {
///////////////////////////////////
/ bij .save ook	 , maar daar een WrapVisitor	,
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/s
FlushVisitor.processCollection(Object, CollectionType) line: 62	
			Collections.processReachableCollection( coll, type, owner, getSession() );
/s
		prepareCollectionForUpdate( collection, ce, factory );
/s
			// if either its role changed, or its key changed
			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );
			if ( ownerChanged ) {
				if ( currentPersister != null ) {
					entry.setDorecreate( true );
entry	CollectionEntry  (id=2968)	
/ dorecreate=true

			int entityCount = flushEntities( event, persistenceContext );
/ D
			int collectionCount = flushCollections( session, persistenceContext );
/s
			if ( ce.isDorecreate() ) {
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
								ce.getCurrentKey(),
								session
							)
					);
			}
/ creates collectionrecreateaction	,




				performExecutions( source );
/s
			session.getActionQueue().prepareActions();
/s
this	ActionQueue  (id=3016)	
		prepareActions( collectionCreations );
/ collectionCreations is 1 van de queues	,
/s
CollectionRecreateAction(CollectionAction).beforeExecutions() line: 101	
		if ( persister.hasCache() ) {
this	CollectionRecreateAction  (id=3042)	
	persister	OneToManyPersister  (id=3025)	
		keyType	LongType  (id=3079)	
		role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=3044)	


			final CacheKey ck = session.generateCacheKey(
					key,
					persister.getKeyType(),
					persister.getRole()
			);
			final SoftLock lock = persister.getCacheAccessStrategy().lockItem( ck, null );
///////////////
/ Meteen	,
/s
			return actualStrategy.lockItem( key, version );
/s
ReadOnlyEhcacheCollectionRegionAccessStrategy.lockItem(Object, Object) line: 77	
		return null;
/ of	,
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).lockItem(Object, Object) line: 142	

this	ReadWriteEhcacheCollectionRegionAccessStrategy  (id=3127)	
	region	EhcacheCollectionRegion  (id=3131)	
		cache	Cache  (id=3135)	
			configuration	CacheConfiguration  (id=3144)	
				name	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3170)	


		region().writeLock( key );

		try {
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=85)	
Lock Source-UUID:9797d764-c766-4fe1-9cd5-065e8f989dd0 Lock-ID:0
			final long timeout = region().nextTimestamp() + region().getTimeout();
			final Lock lock = (item == null) ? new Lock( timeout, uuid, nextLockId(), version ) : item.lock(
					timeout,
					uuid,
					nextLockId()
			);
			region().put( key, lock );
			return lock;
		}
		finally {
			region().writeUnlock( key );
		}



/t
			session.getActionQueue().prepareActions();
/D
			session.getActionQueue().executeActions();
/s
EntityInsertAction.execute() line: 127	

			persister.insert( id, getState(), instance, session );
///////////////////////
/db
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 72	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/t
EntityInsertAction.execute() line: 127	
			this.cacheEntry = persister.getCacheEntryStructure().structure( ce );
/puts cacheentry in de entityinsertaction

			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
			final boolean put = cacheInsert( persister, ck );
false
/ NIETS, want asynchr	, dus later , na commit,	 in  afterTransactionCompletion( Status.STATUS_COMMITTED )	, 


/t
EntityInsertAction.execute() line: 127	
/D
/t
ActionQueue.executeActions(ExecutableList<E>) line: 466	
			for ( E e : list ) {
				try {
					e.execute();
/ D
				}
				finally {
					beforeTransactionProcesses.register( e.getBeforeTransactionCompletionProcess() );
/ NIETS
					this.afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );
this	ActionQueue  (id=34)	
	afterTransactionProcesses	ActionQueue$AfterTransactionCompletionProcessQueue  (id=38)	
		processes	ConcurrentLinkedQueue<E>  (id=3181)	
[EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Address#12], EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Employee#1]]
e	EntityInsertAction  (id=3200)	
e.getAfterTransactionCompletionProcess()==e
////////////////////////////////////////////
/ Hierdoor asynch ehcache will be processed later	,

/ volgende queue

/ In hibernate_xml_1_N_ehcache doen we een update van het obj na .save voor .commit	,

EntityUpdateAction.execute() line: 146	

////////////
/  step 1	, 
/ lock ehcache bij de cachekey van de Address, 2 Employee	,  
/  step 2	, 
/ update db	,
/  step 3	, 
/ create cacheentry (met Address's state), schedule , ook voor 2 Employee	,
////////////
/  step 1	, 
		if ( persister.hasCache() ) {
			ck = session.generateCacheKey(
					id, 
					persister.getIdentifierType(), 
					persister.getRootEntityName()
			);
/ In de ck zit de id	, voor een Employee is deze 1 of 2	, dat zijn verschillende locks	,

			lock = persister.getCacheAccessStrategy().lockItem( ck, previousVersion );
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).lockItem(Object, Object) line: 133	

/ de region is die van Address	,

this	ReadWriteEhcacheEntityRegionAccessStrategy  (id=3343)	
	region	EhcacheEntityRegion  (id=3344)	
		cache	Cache  (id=3351)	
			configuration	CacheConfiguration  (id=3362)	
				name	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3432)	

			final Lock lock = (item == null) ? new Lock( timeout, uuid, nextLockId(), version ) : item.lock(
					timeout,
					uuid,
					nextLockId()
			);
			region().put( key, lock );

/ t
EntityUpdateAction.execute() line: 159	

///////////
/ step 2	, 
			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
/ state in de entityupdateaction is wel de meest recente state	,

/s
/ TODO

this	EntityUpdateAction  (id=3338)	
	dirtyFields	(id=3474)	
		[0]	2	
	state	Object[4]  (id=3129)	
		[0]	"foostreet" (id=3130)	
		[1]	"12 foo" (id=3131)	
		[2]	"FooCityA" (id=3132)	
		[3]	PersistentSet  (id=3133)	

		else {
			// For the case of dynamic-update="false", or no snapshot, we use the static SQL
			updateStrings = getUpdateStrings(
					rowId != null,
					hasUninitializedLazyProperties( object )
			);
[update address set address_line1__=?, zipcoce__=?, city_=? where id__=?]

			propsToUpdate = getPropertyUpdateability( object );
[true,true,true,false]

		final int span = getTableSpan();
1
		for ( int j = 0; j < span; j++ ) {
			// Now update only the tables with dirty properties (and the table with the version number)
			if ( tableUpdateNeeded[j] ) {

				updateOrInsert(
						id,
						fields,
						oldFields,
						j == 0 ? rowId : null,
						propsToUpdate,
						j,
						oldVersion,
						object,
						updateStrings[j],
						session
					);

Hibernate: update address set address_line1__=?, zipcoce__=?, city_=? where id__=?
HibernateLog --> 11:51:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 11:51:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 11:51:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCityA]
HibernateLog --> 11:51:05 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

/t
EntityUpdateAction.execute() line: 172	

/////////////
/ step 3	, 

		if ( persister.hasCache() ) {
			if ( persister.isCacheInvalidationRequired() || entry.getStatus()!= Status.MANAGED ) {
/ NEE
			else {
				//TODO: inefficient if that cache is just going to ignore the updated state!
				final CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
/ disassemble state	,
/ NIEUWE state	,
/ WH state uit de entityupdateaction, set in flush in het begin	,
				cacheEntry = persister.getCacheEntryStructure().structure( ce );
/ entityUpdateAction.cacheEntry=ce	,
				final boolean put = cacheUpdate( persister, previousVersion, ck );
/ NIETS, later pas	,

/t
ActionQueue.executeActions(ExecutableList<E>) line: 467	
			for ( E e : list ) {
				try {
					e.execute();
/ D
e=entityupdateaction
				}
				finally {
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );
/ e.getAfterTransactionCompletionProcess()==e==entityupdateaction

/ volgende entity update in deze queue	,

ActionQueue.executeActions(ExecutableList<E>) line: 463	
			for ( E e : list ) {
				try {
					e.execute();
/s
EntityUpdateAction.execute() line: 152	
		final CacheKey ck;
		if ( persister.hasCache() ) {
			ck = session.generateCacheKey(
					id, 
					persister.getIdentifierType(), 
					persister.getRootEntityName()
			);
			lock = persister.getCacheAccessStrategy().lockItem( ck, previousVersion );

//////////////////////////////////////////////////////////////
/ Een updateaction puts een lock in de ehcache,	 zodat na de commit een entityinsertaction GEEN put kan doen, wat ook niet de bedoeling is: een put in de ehcache is WH altijd ALLE properties	,

/s
NonstopAwareEntityRegionAccessStrategy.lockItem(Object, Object) line: 130	
			return actualStrategy.lockItem( key, version );
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).lockItem(Object, Object) line: 133	
this	ReadWriteEhcacheEntityRegionAccessStrategy  (id=3558)	
	region	EhcacheEntityRegion  (id=3559)	
		cache	Cache  (id=3562)	
			configuration	CacheConfiguration  (id=3570)	
				name	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3588)	

			final Lock lock = (item == null) ? new Lock( timeout, uuid, nextLockId(), version ) : item.lock(
					timeout,
					uuid,
					nextLockId()
			);
			region().put( key, lock );

/t
EntityUpdateAction.execute() line: 172	
			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
Hibernate: update employee set name_=?, salary_=? where id_=?
HibernateLog --> 12:15:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1A]
HibernateLog --> 12:15:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 12:15:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]

		if ( persister.hasCache() ) {
			if ( persister.isCacheInvalidationRequired() || entry.getStatus()!= Status.MANAGED ) {
/ NEE
			else {
				//TODO: inefficient if that cache is just going to ignore the updated state!
				final CacheEntry ce = persister.buildCacheEntry( instance,this.state, nextVersion, getSession() );
/ this =EntityUpdateAction	,
/ disassemble this.state	,
				cacheEntry = persister.getCacheEntryStructure().structure( ce );

/ we hebben nu gehad: de inserts en de updates	,
HibernateLog --> 16:17:46 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 16:17:46 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]
HibernateLog --> 16:17:46 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 16:17:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]
HibernateLog --> 16:17:48 DEBUG org.hibernate.SQL - update address set address_line1__=?, zipcoce__=?, city_=? where id__=?
Hibernate: update address set address_line1__=?, zipcoce__=?, city_=? where id__=?
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCityA]
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 16:17:48 DEBUG org.hibernate.SQL - update employee set name_=?, salary_=? where id_=?
Hibernate: update employee set name_=?, salary_=? where id_=?
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1A]
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [1]
HibernateLog --> 16:17:48 DEBUG org.hibernate.SQL - update employee set name_=?, salary_=? where id_=?
Hibernate: update employee set name_=?, salary_=? where id_=?
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2A]
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 16:17:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [2]

/ volgende queue	,

ActionQueue.executeActions() line: 349	
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
/s
CollectionRecreateAction.execute() line: 64	
this	CollectionRecreateAction  (id=68)	

		// or when an existing (non-null) collection is moved to a new owner
		final PersistentCollection collection = getCollection();
/ PersistentSet met 2 current Employee's	,


/ Blijkbaar zit de coll in de collectionrecreateaction	,

		preRecreate();
/ NIETS
		getPersister().recreate( collection, getKey(), getSession() );
/s
OneToManyPersister.recreate(PersistentCollection, Serializable, SessionImplementor) line: 184	
		super.recreate( collection, id, session );
/s
OneToManyPersister(AbstractCollectionPersister).recreate(PersistentCollection, Serializable, SessionImplementor) line: 1253	
this	OneToManyPersister  (id=55)	

		if ( !isInverse && isRowInsertEnabled() ) {
/ NEE
/ in hibernate_xml4	, 
/ JA	, 
/ in hibernate_xml_1_N_ehcache	,
/ TODO

					while ( entries.hasNext() ) {
						final Object entry = entries.next();
						if ( collection.entryExists( entry, i ) ) {
							PreparedStatement st = null;
							String sql = getSQLInsertRowString();
update employee set address_=? where id_=?
							if ( useBatch ) {
								if ( recreateBatchKey == null ) {
									recreateBatchKey = new BasicBatchKey(
											getRole() + "#RECREATE",
											expectation
											);
								}
								st = session.getTransactionCoordinator()
										.getJdbcCoordinator()
										.getBatch( recreateBatchKey )
										.getBatchStatement( sql, callable );
							}
/ we zien	,
HibernateLog --> 16:29:02 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
							try {
								offset += expectation.prepare( st );

								// TODO: copy/paste from insertRows()
								int loc = writeKey( st, id, offset, session );
/ we zien	,
HibernateLog --> 16:30:29 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
								loc = writeElement( st, collection.getElement( entry ), loc, session );
/ we zien	,
HibernateLog --> 16:31:18 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

								if ( useBatch ) {
									session.getTransactionCoordinator()
											.getJdbcCoordinator()
											.getBatch( recreateBatchKey )
											.addToBatch();
/ WH to db	,


		getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
/s
CollectionEntry.afterAction(PersistentCollection) line: 246	
this	CollectionEntry  (id=48)	
	currentPersister	OneToManyPersister  (id=55)	

		loadedKey = getCurrentKey();
		setLoadedPersister( getCurrentPersister() );
/s
		loadedPersister = persister;
		setRole( persister == null ? null : persister.getRole() );
this	CollectionEntry  (id=48)	
	currentPersister	OneToManyPersister  (id=55)	
		role	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=78)	


		boolean resnapshot = collection.wasInitialized() &&
				( isDoremove() || isDorecreate() || isDoupdate() );
		if ( resnapshot ) {
			this.snapshot = this.loadedPersister==null || !this.loadedPersister.isMutable() ?
					null :
					collection.getSnapshot(this.loadedPersister); //re-snapshot
		}
/t
CollectionRecreateAction.execute() line: 64	
		evict();
s
CollectionRecreateAction(CollectionAction).evict() line: 152	
		if ( persister.hasCache() ) {
			final CacheKey ck = session.generateCacheKey(
					key, 
					persister.getKeyType(), 
					persister.getRole()
			);
			persister.getCacheAccessStrategy().remove( ck );
/s
ReadOnlyEhcacheCollectionRegionAccessStrategy(AbstractEhcacheAccessStrategy<T>).remove(Object) line: 120	
/ of
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractEhcacheAccessStrategy<T>).remove(Object) line: 120	
	/**
	 * A no-op since this is an asynchronous cache access strategy.
	 *
	 * @see org.hibernate.cache.spi.access.EntityRegionAccessStrategy#remove(java.lang.Object)
	 * @see org.hibernate.cache.spi.access.CollectionRegionAccessStrategy#remove(java.lang.Object)
	 */
	public void remove(Object key) throws CacheException {
	}

/t
CollectionRecreateAction.execute() line: 70	
		postRecreate();
/ NIETS

/t
ActionQueue.executeActions(ExecutableList<E>) line: 467	
			for ( E e : list ) {
				try {
					e.execute();
				}
/ D
				finally {
					beforeTransactionProcesses.register( e.getBeforeTransactionCompletionProcess() );
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );
/s
CollectionRecreateAction(CollectionAction).getAfterTransactionCompletionProcess() line: 116	
		return afterTransactionProcess;
afterTransactionProcess	CollectionAction$CacheCleanupProcess  (id=69)	

/////////////////
/ bij entityinsertaction, entityupdateaction is e.getAfterTransactionCompletionProcess()==e	, maar bij collectionrecreateaction  NIET	,


/t
JdbcTransaction(AbstractTransactionImpl).commit() line: 180	
			doCommit();
			afterTransactionCompletion( Status.STATUS_COMMITTED );
/s
		getTransactionContext().afterTransactionCompletion( hibernateTransaction, success );
/s
SessionImpl.afterTransactionCompletion(TransactionImplementor, boolean) line: 529	
		this.actionQueue.afterTransactionCompletion( successful );
/ Deze queue is nu inderdaad NIET leeg	,
[EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Address#12]
/ TODO
[EntityInsertAction[my.test.own.hibernate_xml_1_N_ehcache.Address#12] 
 EntityInsertAction[my.test.own.hibernate_xml_1_N_ehcache.Employee#1]
 EntityInsertAction[my.test.own.hibernate_xml_1_N_ehcache.Employee#2]
 EntityUpdateAction[my.test.own.hibernate_xml_1_N_ehcache.Address#12]
 EntityUpdateAction[my.test.own.hibernate_xml_1_N_ehcache.Employee#1]
 EntityUpdateAction[my.test.own.hibernate_xml_1_N_ehcache.Employee#2]
 org.hibernate.action.internal.CollectionAction$CacheCleanupProcess@707594ad]
/s
ActionQueue$AfterTransactionCompletionProcessQueue.afterTransactionCompletion(boolean) line: 744	
				try {
					processes.poll().doAfterTransactionCompletion( success, session );
/s
EntityInsertAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 226	
/s
			final CacheKey ck = getSession().generateCacheKey( getId(), persister.getIdentifierType(), persister.getRootEntityName() );
			final boolean put = cacheAfterInsert( persister, ck );
/s
			return persister.getCacheAccessStrategy().afterInsert( ck, cacheEntry, version );
/s
ReadOnlyEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 101	
		region().put( key, value );
/s
ReadWriteEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 75	

this	ReadWriteEhcacheEntityRegionAccessStrategy  (id=116)	
	region	EhcacheEntityRegion  (id=120)	
		cache	Cache  (id=151)	
			configuration	CacheConfiguration  (id=184)	
				copyStrategyConfiguration	CopyStrategyConfiguration  (id=197)	
				name	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=210)	

		try {
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=127)	

			if ( item == null ) {
/ NEE
			else {
				return false;


/ een entityinsertaction heeft wel een CacheEntry, maar deze wordt niet put in de ehcache: er zit al een lock	, deze heeft de entityupdateaction er in put om deze insert te verhinderen	,
/ Hieronder zal de lock in de ehcache gewoon worden overwrite met de nieuwe state entry	, 

/ dan 	,
ActionQueue$AfterTransactionCompletionProcessQueue.afterTransactionCompletion(boolean) line: 744	
			while ( !processes.isEmpty() ) {
				try {
					processes.poll().doAfterTransactionCompletion( success, session );
/s
EntityUpdateAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 335	
			final CacheKey ck = getSession().generateCacheKey(
					getId(),
					persister.getIdentifierType(), 
					persister.getRootEntityName()
			);
			
			if ( success && cacheEntry!=null /*!persister.isCacheInvalidationRequired()*/ ) {
				final boolean put = cacheAfterUpdate( persister, ck );
...
/s
ReadWriteEhcacheEntityRegionAccessStrategy.afterUpdate(Object, Object, Object, Object, SoftLock) line: 113	
		try {
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=3863)	

			if ( item != null && item.isUnlockable( lock ) ) {
				final Lock lockItem = (Lock) item;
				if ( lockItem.wasLockedConcurrently() ) {
/ NEE
					decrementLock( key, lockItem );
					return false;
/ NIET
				}
				else {
/ JA
					region().put( key, new Item( value, currentVersion, region().nextTimestamp() ) );
/ H overwrites de lock met deze item	,
value	StandardCacheEntryImpl  (id=3436)	
	disassembledState	Serializable[4]  (id=3438)	
		[0]	"foostreet" (id=3445)	
		[1]	"12 foo" (id=3446)	
		[2]	"FooCityA" (id=3447)	
		[3]	Long  (id=94)	

					return true;

/ t
/ volgende,	
ReadWriteEhcacheEntityRegionAccessStrategy.afterUpdate(Object, Object, Object, Object, SoftLock) line: 125	

this	ReadWriteEhcacheEntityRegionAccessStrategy  (id=3426)	
	region	EhcacheEntityRegion  (id=3427)	
		cache	Cache  (id=3432)	
			configuration	CacheConfiguration  (id=3560)	
				name	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3756)	

value	StandardCacheEntryImpl  (id=3493)	
	disassembledState	Serializable[3]  (id=3502)	
		[0]	"Foo1A" (id=3784)	
		[1]	Double  (id=3792)	
		[2]	BackrefPropertyAccessor$1  (id=3793)	


					region().put( key, new Item( value, currentVersion, region().nextTimestamp() ) );

/ we kunnen hierna met de hand	,
"region().get(key)"	 org.hibernate.cache.ehcache.internal.strategy.AbstractReadWriteEhcacheAccessStrategy$Item@6d6a8f6d
	timestamp	5771492528967680	
	value	StandardCacheEntryImpl  (id=3866)	
		disassembledState	Serializable[3]  (id=3875)	
			[0]	"Foo2A" (id=3876)	
			[1]	Double  (id=3877)	
			[2]	BackrefPropertyAccessor$1  (id=3793)	
		lazyPropertiesAreUnfetched	false	
		subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3496)	
		version	null	
	version	null	

/ volgende	,
				try {
					processes.poll().doAfterTransactionCompletion( success, session );
/s
CollectionAction$CacheCleanupProcess.doAfterTransactionCompletion(boolean, SessionImplementor) line: 189	
			final CacheKey ck = session.generateCacheKey(
					key,
					persister.getKeyType(),
					persister.getRole()
			);
			persister.getCacheAccessStrategy().unlockItem( ck, lock );
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).unlockItem(Object, SoftLock) line: 157	

		try {
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=3933)	

			if ( (item != null) && item.isUnlockable( lock ) ) {
/ JA
				decrementLock( key, (Lock) item );
/ De item is nog wel in de ehcache	,
/ TODO








/ 7	. 

/ Statistics	,


second level region name=my.test.own.hibernate_xml_1_N_ehcache.Address
second level region name=my.test.own.hibernate_xml_1_N_ehcache.Employee
second level region name=my.test.own.hibernate_xml_1_N_ehcache.Address.employees


/ 7	.

/ in een nieuwe session	,

		  	employee = (Employee) session.get(Employee.class, 1l);
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	

		entity = loadFromSecondLevelCache( event, persister, options );
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 598	

		final CacheKey ck = source.generateCacheKey(
				event.getEntityId(),
				persister.getIdentifierType(),
				persister.getRootEntityName()
		);

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 77	

this	ReadWriteEhcacheEntityRegionAccessStrategy  (id=3331)	
	region	EhcacheEntityRegion  (id=3370)	
		cache	Cache  (id=3379)	
			configuration	CacheConfiguration  (id=3462)	
				name	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3738)	

item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3332)	
	timestamp	5771501273915392	
	value	StandardCacheEntryImpl  (id=3334)	
		disassembledState	Serializable[3]  (id=3336)	
			[0]	"Foo1A" (id=3340)	
			[1]	Double  (id=3341)	
			[2]	BackrefPropertyAccessor$1  (id=3342)	

			final boolean readable = item != null && item.isReadable( txTimestamp );
			if ( readable ) {
				return item.getValue();
/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 599	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/ D
	ce StandardCacheEntryImpl  (id=3334)	
		disassembledState	Serializable[3]  (id=3336)	
			[0]	"Foo1A" (id=3340)	
			[1]	Double  (id=3341)	
			[2]	BackrefPropertyAccessor$1  (id=3342)	

		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 707	
		else {
			subclassPersister = factory.getEntityPersister( entry.getSubclass() );
			final Object optionalObject = event.getInstanceToLoad();
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
/ Met new	,
					: optionalObject;
		}
		else {
			final Type[] types = subclassPersister.getPropertyTypes();
			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/s
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 158	

		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 107	

types	Type[3]  (id=3844)	
	[0]	StringType  (id=3846)	
	[1]	DoubleType  (id=3847)	
	[2]	LongType  (id=3848)	

		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ JA, 3de	,
				assembled[i] = row[i];
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );

assembled	Object[3]  (id=3845)	
	[0]	"Foo1A" (id=3340)	
	[1]	Double  (id=3341)	
	[2]	BackrefPropertyAccessor$1  (id=3342)	

		persister.setPropertyValues( instance, assembledProps );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 713	

		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
			if ( setAll || values[j] != LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
				setters[j].set( entity, values[j], getFactory() );
			}
		}
/s
/ de laatste	,
		public void set(Object target, Object value, SessionFactoryImplementor factory) {
			// this page intentionally left blank :)
		}
/ Klopt	, er is geen property bij deze H property	,

/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 189	

		persister.setPropertyValues( instance, assembledProps );
/ D
instance	Employee  (id=3825)	
	id	1	
	name	"Foo1A" (id=3340)	
	salary	1.0	
	
		return assembledProps;
/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 710	
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ D
values	Object[3]  (id=3845)	
	[0]	"Foo1A" (id=3340)	
	[1]	Double  (id=3341)	
	[2]	BackrefPropertyAccessor$1  (id=3342)	

		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
		persistenceContext.initializeNonLazyCollections();
/ TODO


/t
Main.testBasicUsage() line: 168	
		  	employee = (Employee) session.get(Employee.class, 1l);
/ D

	        address=(Address)session.get(Address.class, 12l);
...
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 617	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 81	
this	ReadWriteEhcacheEntityRegionAccessStrategy  (id=3997)	

			final Lockable item = (Lockable) region().get( key );
key	CacheKey  (id=3995)	
item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3998)	
	timestamp	5771501273874432	
	value	StandardCacheEntryImpl  (id=3999)	
		disassembledState	Serializable[4]  (id=4000)	
			[0]	"foostreet" (id=4004)	
			[1]	"12 foo" (id=4005)	
			[2]	"FooCityA" (id=4008)	
			[3]	Long  (id=4011)	
		subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=4001)	

/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 617	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/ D
		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );

		else {
			subclassPersister = factory.getEntityPersister( entry.getSubclass() );
			final Object optionalObject = event.getInstanceToLoad();
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
/s
		if ( result == null ) {
			result = persister.instantiate( id, this );
/s
		return getEntityTuplizer().instantiate( id, session );
/s
		Object result = getInstantiator().instantiate( id );
/s
PojoInstantiator.instantiate() line: 124	
			try {
				return constructor.newInstance( (Object[]) null );
/t
PojoEntityTuplizer(AbstractEntityTuplizer).instantiate(Serializable, SessionImplementor) line: 739	
		if ( id != null ) {
			setIdentifier( result, id, session );
/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 685	
					? session.instantiate( subclassPersister, entityId )
/ D
entity	Address  (id=3338)	
	addressLine1	null	
	city	null	
	employees	HashSet<E>  (id=3340)	
[]
	id	12	
	zipcode	null	

			final Type[] types = subclassPersister.getPropertyTypes();
types	Type[4]  (id=3357)	
	[0]	StringType  (id=3358)	
	[1]	StringType  (id=3358)	
	[2]	StringType  (id=3358)	
	[3]	SetType  (id=3359)	
			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 113	
	for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ NEE
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/s
/ Alleen laatste interessamt	,
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 296	
		else {
			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
/ Gewoon Long 12	,
			return resolveKey( key, session, owner );
/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 163	
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
assembledProps	Object[4]  (id=3353)	
	[0]	"foostreet" (id=3345)	
	[1]	"12 foo" (id=3346)	
	[2]	"FooCityA" (id=3347)	
	[3]	PersistentSet  (id=3357)	
		owner	Address  (id=3341)	
			addressLine1	null	
			city	null	
			employees	HashSet<E>  (id=3354)	
[]
			id	12	
			zipcode	null	
		role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3349)	
		set	HashSet<E>  (id=3371)			
null
		storedSnapshot	HashMap<K,V>  (id=3373)		
null

		persister.setPropertyValues( instance, assembledProps );
/ met setters	,

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 710	
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ values[3]=PersistentSet , met set=null	, storedSnapshot=null
/ in entity alle fields set, employees=PersistentSet (dezelfde)	,

		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
		persistenceContext.initializeNonLazyCollections();
/ TODO

/ t
Main.testBasicUsage() line: 169	
	        address=(Address)session.get(Address.class, 12l);
/ D
/ Onvolledig	, de address.employees is leeg	,



/ Einde SAMENVATTING

/ 7	.

/ hibernate_xml_1_N_ehcache

/ In Address' xml: <set lazy="true" ...>
/ Als we in een nieuwe session	,

	        address=(Address)session.get(Address.class, 12l);
	        Set<Employee>employees=address.getEmployees();
	        Iterator< Employee>iterator=employees.iterator();

/ dan is na
	        address=(Address)session.get(Address.class, 12l);
/ address onvolledig: de set employees is leeg	, 
/ we zien	, 
HibernateLog --> 07:39:00 TRACE org.hibernate.type.CollectionType - Created collection wrapper: [my.test.own.hibernate_xml_1_N_ehcache.Address.employees#12]
/ address.employees=wel een PersistentSet ,maar deze is leeg	, 

/ na employees.iterator() is de set employees in address filled	, er wordt 1 keer een collection-query gedaan	,

/ we kunnen ook: <set lazy="false" ...> , dan is meteen employees in address wel OK	, er wordt 1 keer een query gedaan	, na	,
	        address=(Address)session.get(Address.class, 12l);

/ HIER HIER
 


/ 7	.

				tx.commit();
/s
JdbcTransaction(AbstractTransactionImpl).commit() line: 177	
		beforeTransactionCommit();
/s
	protected void beforeTransactionCommit() {
			transactionCoordinator().getTransactionContext().managedFlush();
/s
		flush();
/s
...
/s
	public void onFlush(FlushEvent event) throws HibernateException {
				flushEverythingToExecutions( event );
/ D
				performExecutions( source );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 349	
			session.getActionQueue().prepareActions();
/s
			session.getActionQueue().executeActions();
/ STRAKS	,

/s
ActionQueue.
	public void prepareActions() throws HibernateException {
		prepareActions( collectionRemovals );
		prepareActions( collectionUpdates );
/D
		prepareActions( collectionCreations );
/s
ActionQueue.
	private void prepareActions(ExecutableList<?> queue) throws HibernateException {
		for ( Executable executable : queue ) {
			executable.beforeExecutions();
/s
CollectionRecreateAction(CollectionAction).beforeExecutions() line: 101	

		if ( persister.hasCache() ) {
this	CollectionRecreateAction  (id=3063)	
	persister	OneToManyPersister  (id=3113)	

			final CacheKey ck = session.generateCacheKey(
					key,
					persister.getKeyType(),
					persister.getRole()
			);
ck	CacheKey  (id=3070)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3073)	
	hashCode	372	
	key	Long  (id=3074)	
12
	type	LongType  (id=3083)	

			final SoftLock lock = persister.getCacheAccessStrategy().lockItem( ck, null );
/ persister.getCacheAccessStrategy()=org.hibernate.cache.ehcache.internal.nonstop.NonstopAwareCollectionRegionAccessStrategy@12c7d5cf
/s
NonstopAwareCollectionRegionAccessStrategy.lockItem(Object, Object) line: 96	
		try {
			return actualStrategy.lockItem( key, version );
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).lockItem(Object, Object) line: 142	
		region().writeLock( key );
		try {
			final Lockable item = (Lockable) region().get( key );
null
			final long timeout = region().nextTimestamp() + region().getTimeout();
			final Lock lock = (item == null) ? new Lock( timeout, uuid, nextLockId(), version ) : item.lock(
					timeout,
					uuid,
					nextLockId()
			);
lock	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=3077)	
Lock Source-UUID:3b574016-3f21-49d1-942b-1e2f801584eb Lock-ID:0
			region().put( key, lock );

/s
EhcacheCollectionRegion(EhcacheTransactionalDataRegion).put(Object, Object) line: 143	
/=
	public final void put(Object key, Object value) throws CacheException {
		try {
			final Element element = new Element( key, value );

			getCache().put( element );

/ 7	.

DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	

			session.getActionQueue().executeActions();
...
/s
EntityInsertAction.execute() line: 126	

			persister.insert( id, getState(), instance, session );
/ D
		if ( isCachePutEnabled( persister, session ) ) {

			final CacheEntry ce = persister.buildCacheEntry(
					instance,
Address inst	,
					getState(),
[foostreet, 12 foo, FooCity12, [my.test.own.hibernate_xml_1_N_ehcache.Employee@373d7b4a, my.test.own.hibernate_xml_1_N_ehcache.Employee@28d898bd]]
					version,
					session
			);
...
/s
AbstractEntityPersister$StandardCacheEntryHelper.buildCacheEntry(Object, Object[], Object, SessionImplementor) line: 5245	
			return new StandardCacheEntryImpl(
					state,
					persister,
					persister.hasUninitializedLazyProperties( entity ),
					version,
					session,
					entity
			);
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 74	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 145	
		Serializable[] disassembled = new Serializable[row.length];
		for ( int i = 0; i < row.length; i++ ) {
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
/ types[i]=StringType	, gebeurt niets	,
/s
SetType(CollectionType).disassemble(Object, SessionImplementor, Object) line: 280	
value	PersistentSet  (id=3285)	
[my.test.own.hibernate_xml_1_N_ehcache.Employee@2c3ba12f, my.test.own.hibernate_xml_1_N_ehcache.Employee@4a030114]
owner	Address  (id=3282)	

		final Serializable key = getKeyOfOwner(owner, session);
/s
SetType(CollectionType).getKeyOfOwner(Object, SessionImplementor) line: 387	
		EntityEntry entityEntry = session.getPersistenceContext().getEntry( owner );
		if ( foreignKeyPropertyName == null ) {
/ JA
			return entityEntry.getId();
12
/t
SetType(CollectionType).disassemble(Object, SessionImplementor, Object) line: 285	
		final Serializable key = getKeyOfOwner(owner, session);
/ D
		if (key==null) {
/ NEE
		else {
			return getPersister(session)
/s
SetType(CollectionType).getPersister(SessionImplementor) line: 326	
		return session.getFactory().getCollectionPersister( role );
this	SetType  (id=3284)	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3323)	

					.getKeyType()
/s
OneToManyPersister(AbstractCollectionPersister).getKeyType() line: 820	
this	OneToManyPersister  (id=3305)	
	keyType	LongType  (id=3327)	
		dictatedSize	Size  (id=3329)	
			length	255	
			precision	19	
			scale	2	
		javaTypeDescriptor	LongTypeDescriptor  (id=3330)	
		sqlTypeDescriptor	BigIntTypeDescriptor  (id=3331)	
		sqlTypes	(id=3332)	
			[0]	-5	
					.disassemble( key, session, owner );
/s
LongType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	
		return getMutabilityPlan().disassemble( (T) value );
/s
ImmutableMutabilityPlan<T>.disassemble(T) line: 48	
/=
	public Serializable disassemble(T value) {
		return (Serializable) value;
value	Long  (id=3300)	
	value	12	

/t
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 81	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/ D
this	StandardCacheEntryImpl  (id=3276)	
	disassembledState	Serializable[4]  (id=3283)	
		[0]	"foostreet" (id=3288)	
		[1]	"12 foo" (id=3412)	
		[2]	"FooCity12" (id=3413)	
		[3]	Long  (id=3300)	

/ Hij persist NIET de coll, maar de id van de owner	,
/ H persist ook nooit een Set naar de db	,

		subclass = persister.getEntityName();
this	StandardCacheEntryImpl  (id=3212)	
	disassembledState	Serializable[4]  (id=3214)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3223)	


/t
EntityInsertAction.execute() line: 133	
		if ( isCachePutEnabled( persister, session ) ) {
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/ D
ce	StandardCacheEntryImpl  (id=3212)	
	disassembledState	Serializable[4]  (id=3214)	
	lazyPropertiesAreUnfetched	false	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3223)	
	version	null	

			cacheEntry = persister.getCacheEntryStructure().structure( ce );
/ cacheEntry=ce

			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
persister	SingleTableEntityPersister  (id=3259)	
persister.getIdentifierType()=LongType inst	,
persister.getRootEntityName() =Address	,
/s
SessionImpl(AbstractSessionImpl).generateCacheKey(Serializable, Type, String) line: 332	
		return new CacheKey( id, type, entityOrRoleName, getTenantIdentifier(), getFactory() );
/ D
ck	CacheKey  (id=3463)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3339)	
	key	Long  (id=3300)	
12
	type	LongType  (id=3327)	

			final boolean put = cacheInsert( persister, ck );
/ Doet NIETS	,
/ TODO
/s
EntityInsertAction.cacheInsert(EntityPersister, CacheKey) line: 156	
			return persister.getCacheAccessStrategy().insert( ck, cacheEntry, version );
/s
NonstopAwareEntityRegionAccessStrategy.insert(Object, Object, Object) line: 119	
			return actualStrategy.insert( key, value, version );
/s
	/**
	 * {@inheritDoc}
	 * <p/>
	 * This cache is asynchronous hence a no-op
	 */
	@Override
ReadWriteEhcacheEntityRegionAccessStrategy.insert(Object, Object, Object) line: 65	
		return false;

/t
EntityInsertAction.execute() line: 143	
			final boolean put = cacheInsert( persister, ck );
/ D

/t
ActionQueue.executeActions(ExecutableList<E>) line: 463	
		try {
			for ( E e : list ) {
				try {
					e.execute();
e	EntityInsertAction  (id=3275)	
	entityName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3277)	
	id	Long  (id=3280)	
	state	Object[3]  (id=3143)	
		[0]	"Foo1" (id=3291)	
		[1]	Double  (id=3293)	
		[2]	Long  (id=3162)	

/ we rm b	,
SessionFactoryServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 199

/Intermezzo

/ in een read-only cache kunnen we maar 1 keer insert	, daarna alleen read	, dus geen updates	,
/ in hibernate_xml4 is de fk kant de owner, en hebben we .commit na .save geen updates	, 
/ in hibernate_xml_1_N_ehcache is de set kant de owner, en komen er wel updates na .save	, .commit	, dus daar kan de cache NIET read-only	, 
/ TODO (welke dmls worden er gedaan in beide gevallen, en waarom een verschil?)

ReadOnlyEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 101	


	/**
	 * {@inheritDoc}
	 * <p/>
	 * Throws UnsupportedOperationException since this cache is read-only
	 *
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean update(Object key, Object value, Object currentVersion, Object previousVersion)
			throws UnsupportedOperationException {
		throw new UnsupportedOperationException( "Can't write to a readonly object" );
	}

	/**
	 * {@inheritDoc}
	 * <p/>
	 * Throws UnsupportedOperationException since this cache is read-only
	 *
	 * @throws UnsupportedOperationException always
	 */
	@Override
	public boolean afterUpdate(Object key, Object value, Object currentVersion, Object previousVersion, SoftLock lock)
			throws UnsupportedOperationException {
		throw new UnsupportedOperationException( "Can't write to a readonly object" );
	}
}

/ Einde Intermezzo

/ later	,

JdbcTransaction(AbstractTransactionImpl).commit() line: 182	
		beforeTransactionCommit();
			doCommit();
/ D
			afterTransactionCompletion( Status.STATUS_COMMITTED );
/s
		transactionCoordinator().afterTransaction( this, status );
/s
TransactionCoordinatorImpl.afterTransaction(TransactionImplementor, int) line: 150	
		getTransactionContext().afterTransactionCompletion( hibernateTransaction, success );
/s
SessionImpl.afterTransactionCompletion(TransactionImplementor, boolean) line: 529	
		actionQueue.afterTransactionCompletion( successful );
/s
ActionQueue.afterTransactionCompletion(boolean) line: 379	
			afterTransactionProcesses.afterTransactionCompletion( success );
/s
ActionQueue$AfterTransactionCompletionProcessQueue.afterTransactionCompletion(boolean) line: 744	

this	ActionQueue$AfterTransactionCompletionProcessQueue  (id=3030)	
	processes	ConcurrentLinkedQueue<E>  (id=3075)	
[EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Employee#1], EntityInsertAction[my.test.own.ehcache_hibernate_xml4.Employee#2], org.hibernate.action.internal.CollectionAction$CacheCleanupProcess@49df83b5]

					processes.poll().doAfterTransactionCompletion( success, session );
/s
EntityInsertAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 228	
		final EntityPersister persister = getPersister();
/ persister zit in de entityinsertaction	,
		if ( success && isCachePutEnabled( persister, getSession() ) ) {
			final CacheKey ck = getSession().generateCacheKey( getId(), persister.getIdentifierType(), persister.getRootEntityName() );
ck	CacheKey  (id=3073)	
	entityOrRoleName	"my.test.own.ehcache_hibernate_xml4.Address" (id=3089)	
	hashCode	372	
	key	Long  (id=3090)	
		value	12	
	tenantId	null	
	type	LongType  (id=3091)	
			final boolean put = cacheAfterInsert( persister, ck );
/s
EntityInsertAction.cacheAfterInsert(EntityPersister, CacheKey) line: 241	
			return persister.getCacheAccessStrategy().afterInsert( ck, cacheEntry, version );
/s
NonstopAwareEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 65	
			return actualStrategy.afterInsert( key, value, version );
/s
ReadOnlyEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 101	
		region().put( key, value );

/ uiteindelijk komen key, value in segments in [4] bijv,	

this	ReadOnlyEhcacheEntityRegionAccessStrategy  (id=3361)	
	region	EhcacheEntityRegion  (id=3362)	
		cache	Cache  (id=3326)	
			cacheManager	CacheManager  (id=3121)	
				ehcaches	ConcurrentHashMap<K,V>  (id=3291)	
					segments	ConcurrentHashMap$Segment<K,V>[16]  (id=3297)	
						[0]	ConcurrentHashMap$Segment<K,V>  (id=3302)	
/ TODO
						[4]	ConcurrentHashMap$Segment<K,V>  (id=3303)	
							table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3319)	
								[1]	ConcurrentHashMap$HashEntry<K,V>  (id=3322)	
									value	Cache  (id=3326)	
										compoundStore	DiskBackedMemoryStore  (id=3374)	
											cache	MemoryStore  (id=3544)	
												map	SelectableConcurrentHashMap  (id=3549)	
													segments	SelectableConcurrentHashMap$Segment[128]  (id=3555)	
														[0...99]	
														[100...127]	
							threshold	1	
						[7]	ConcurrentHashMap$Segment<K,V>  (id=3304)	
							count	1	
							loadFactor	0.75	
							modCount	1	
							sync	ReentrantLock$NonfairSync  (id=3417)	
							table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3418)	
								[1]	ConcurrentHashMap$HashEntry<K,V>  (id=3427)	
									hash	2025917297	
									key	"my.test.own.ehcache_hibernate_xml4.Address.employees" (id=3429)	
									next	null	
									value	Cache  (id=3430)	
							threshold	1	
						[13]	ConcurrentHashMap$Segment<K,V>  (id=3306)	
							count	1	
							loadFactor	0.75	
							modCount	1	
							sync	ReentrantLock$NonfairSync  (id=3342)	
							table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3344)	
								[0]	ConcurrentHashMap$HashEntry<K,V>  (id=3347)	
									hash	-567905940	
									key	"my.test.own.ehcache_hibernate_xml4.Address" (id=3349)	
									next	null	
									value	Cache  (id=3116)	
							threshold	1	

/s
EhcacheEntityRegion(EhcacheTransactionalDataRegion).put(Object, Object) line: 142	
this	EhcacheEntityRegion  (id=3113)	
	cache	Cache  (id=3116)	

			final Element element = new Element( key, value );
key	CacheKey  (id=3073)	
value	StandardCacheEntryImpl  (id=3111)	
CacheEntry(my.test.own.ehcache_hibernate_xml4.Address)[foostreet,12 foo,FooCity12,12]
			getCache().put( element );

/ we rm b 	,
SelectableConcurrentHashMap$Segment.put(Object, int, Element, long, boolean, boolean, boolean) line: 813	

/t
EntityInsertAction.doAfterTransactionCompletion(boolean, SessionImplementor) line: 231	
			final boolean put = cacheAfterInsert( persister, ck );
/ D
			if ( put && getSession().getFactory().getStatistics().isStatisticsEnabled() ) {
/ JA
				getSession().getFactory().getStatisticsImplementor()
						.secondLevelCachePut( getPersister().getCacheAccessStrategy().getRegion().getName() );
/t
ActionQueue$AfterTransactionCompletionProcessQueue.afterTransactionCompletion(boolean) line: 744	

/ volgende	,
			while ( !processes.isEmpty() ) {
				try {
					processes.poll().doAfterTransactionCompletion( success, session );


/ 7	.

/ hibernate_xml4	,

/ N_1, bidir	, 

/ als we een Address .save	, dan wordt niet alleen de Address 

/ 7	.

/ COLLECTION IN PC

/ Einde COLLECTION IN PC

/ 7	.

/ ITERATOR 

/ 7	.

ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 129	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {

			Object logicalRow = rowReader.readRow( resultSet, context );
...
/s
EntityReferenceInitializerImpl.readIdentifierHydratedState(ResultSet, ResultSetProcessingContext) line: 117	
			return entityReference.getEntityPersister().getIdentifierType().hydrate(
					resultSet,
					entityReferenceAliases.getColumnAliases().getSuffixedKeyAliases(),
					context.getSession(),
					null
			);
...
/s
BigIntTypeDescriptor$2.doExtract(ResultSet, String, WrapperOptions) line: 74	
	public <X> ValueExtractor<X> getExtractor(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicExtractor<X>( javaTypeDescriptor, this ) {
			@Override
			protected X doExtract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
				return javaTypeDescriptor.wrap( rs.getLong( name ), options );
			}

/ Hier staat de resultSet.next()	, en vervolgens doet .readRow rs.getLong, etc.

/ 7	.

/ we zien de Employee-persister	,

this	CollectionFetchableElementEntityGraph  (id=3387)	
	bidirectionalEntityReferences	null	
	collectionReference	CollectionReturnImpl  (id=3389)	
	fetches	null	
	identifierDescription	SimpleEntityIdentifierDescriptionImpl  (id=3390)	
	propertyPath	PropertyPath  (id=3391)	
	querySpace	EntityQuerySpaceImpl  (id=3392)	
		canJoinsBeRequired	true	
		disposition	QuerySpace$Disposition  (id=3407)	
		joins	null	
		persister	SingleTableEntityPersister  (id=3408)	
SingleTableEntityPersister(my.test.own.hibernate_xml_1_N_ehcache.Employee)	/////////////////////////// !
		querySpaces	QuerySpacesImpl  (id=3374)	
		uid	"<gen:1>" (id=3412)	

/ 7	.

/ we doen de coll-query	, en WH creates 2 new Employee, en hydrates values uit rs (city, salary)	, 
/ haalt ze NIET uit de pc	, 
/ WH omdat ze daar niet in hoeven te zitten: Nu zit alleen Address er in	, en niet de 2 Employee	, 
/ Address zit er in, want anders hadden we niets om over te iterate	, we hebben eerst .get(Address.class,12l) gedaan	, anders kunnen we NIET iterate	,
/ we 2 Employee zitten WEL in de ehcache, maar daar hydrates H de 2 Employee ook NIET uit	,
/ TODO 

/ dan wordt address gevraagd, de fk	,

ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 129	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
/ we zitten nog steeds in deze	,
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 125	

			// 	1) allow entity references to resolve identifiers (in 2 steps)
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateIdentifier( resultSet, context );
/ Uit rs van de coll-query	,
/ Kan niet anders: anders weet je niet in de pc of eh waar je naar zoeken moet; je gaat gewoon alle id's uit de rs af	,
...
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				resolveEntityKey(
						resultSet,
						context,
						entityReferenceInitializer,
						initializerByEntityReference
				);
			}
...
/s
EntityReferenceInitializerImpl.resolveEntityKey(ResultSet, ResultSetProcessingContextImpl) line: 164	
			processingState.registerEntityKey(
					context.getSession().generateEntityKey( resolvedId, entityReference.getEntityPersister() )
			);

/t
			// 2) allow entity references to resolve their non-identifier hydrated state and entity instance
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateEntityState( resultSet, context );
/s
EntityReferenceInitializerImpl.hydrateEntityState(ResultSet, ResultSetProcessingContextImpl) line: 212	
		// In getting here, we know that:
		// 		1) We need to hydrate the entity state
		//		2) We have a valid EntityKey for the entity

		// see if we have an existing entry in the session for this EntityKey
		final Object existing = context.getSession().getEntityUsingInterceptor( entityKey );
/ NEE
		// Otherwise, we need to load it from the ResultSet...
/////////////////////////////////////////////////
/ Waarom niet van de eh?
/ WH, de query is toch al gedaan, en of we nu hydrate de resultset of de ehcache entry maakt niet uit; als hij in de pc zou zijn geweest, hoefden we niet de hydrate, en dat had winst geweest	,

		final Object entityInstance = optionalEntityInstance != null
				: context.getSession().instantiate( concreteEntityTypeName, entityKey.getIdentifier() );

		loadFromResultSet(
				resultSet,
				context,
				entityInstance,
				concreteEntityTypeName,
				entityKey,
				lockModeToAcquire
		);
/s
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 310	
/ hydrates values uit rs	,
			context.getProcessingState( entityReference ).registerHydratedState( values );

		TwoPhaseLoad.postHydrate(
				concreteEntityPersister,
				id,
				values,
				rowId,
				entityInstance,
				lockModeToAcquire,
				!context.getLoadPlan().areLazyAttributesForceFetched(),
				context.getSession()
		);
/ puts Employee in pc	,
/ WH values-> entityEntry.loadedState	,
		context.registerHydratedEntity( entityReference, entityKey, entityInstance );
 

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 124	

/ De laatste value bij de Employee is nog Backref.UNKNOWN	, dat moet 12 worden	,
		if ( collectionReferenceInitializers != null ) {
			for ( CollectionReferenceInitializer collectionReferenceInitializer : collectionReferenceInitializers ) {
				collectionReferenceInitializer.finishUpRow( resultSet, context );
/s
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 87	
				Object collectionOwner = findCollectionOwner( collectionRowKey, resultSet, context );
...
/s
StatefulPersistenceContext.getCollectionOwner(Serializable, CollectionPersister) line: 694	
		final EntityPersister ownerPersister = collectionPersister.getOwnerEntityPersister();
		if ( ownerPersister.getIdentifierType().getReturnedClass().isInstance( key ) ) {
			return getEntity( session.generateEntityKey( key, collectionPersister.getOwnerEntityPersister() ) );
		}
/ Address WEL uit de pc	,

/t
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 87	
				PersistentCollection rowCollection = persistenceContext.getLoadContexts()
						.getCollectionLoadContext( resultSet )
						.getLoadingCollection( collectionReference.getCollectionPersister(), collectionRowKey );
/s
CollectionLoadContext.getLoadingCollection(CollectionPersister, Serializable) line: 111	
/=
	public PersistentCollection getLoadingCollection(final CollectionPersister persister, final Serializable key) {
/ persister=OneToManyPersister
/ key=12
		final CollectionKey collectionKey = new CollectionKey( persister, key, em );
		final LoadingCollectionEntry loadingCollectionEntry = loadContexts.locateLoadingCollectionEntry( collectionKey );
/s
		final LoadingCollectionEntry rtn = xrefLoadingCollectionEntries.get( key );
/t
			return loadingCollectionEntry.getCollection();
/t
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 94	
				PersistentCollection rowCollection = persistenceContext.getLoadContexts()
						.getCollectionLoadContext( resultSet )
						.getLoadingCollection( collectionReference.getCollectionPersister(), collectionRowKey );
/ D
/ De PersistentSet	, set==storedSnapshot==null	,
				if ( rowCollection != null ) {
					rowCollection.readFrom(
							resultSet,
							collectionReference.getCollectionPersister(),
							aliases.getCollectionColumnAliases(),
							collectionOwner
					);
/ Wat is rol collectionOwner	?
/s
PersistentSet.readFrom(ResultSet, CollectionPersister, CollectionAliases, Object) line: 329	
		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
/ descriptor.getSuffixedElementAliases()=[id_1_1_0_]/[id_1_1_1_]	,
/s
		return getElementType().nullSafeGet( rs, aliases, session, owner );
/ this=Employee-persister, een OneToManyPersister	, die geeft getElementType()==ManyToOneType inst 	, of Element
/s
ManyToOneType(EntityType).nullSafeGet(ResultSet, String[], SessionImplementor, Object) line: 308	
		return resolve( hydrate(rs, names, session, owner), session, owner );
/s
		final Serializable id = (Serializable) getIdentifierOrUniqueKeyType( session.getFactory() )
				.nullSafeGet( rs, names, session, null );
/ names=[id_1_1_0_]
/ Hij gaat dus uit de rs de id lezen: 1/2
/t
		return resolve( hydrate(rs, names, session, owner), session, owner );
/s
ManyToOneType(EntityType).resolve(Object, SessionImplementor, Object) line: 496	
				return resolveIdentifier( (Serializable) value, session );
/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 716	
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/ Vindt Employee in pc	,
/ Dit is de Employee die na de coll-query was create met new, staat alleen id in	, de rest null	,

/t
PersistentSet.readFrom(ResultSet, CollectionPersister, CollectionAliases, Object) line: 329	
		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
			tempList.add( element );
/ Dit is waar element in komt	,
/////////////////////////////////////////
/ Er is nog niets in set of storedSnaphot in deze PersistentSet, maar wel in tempList	,










/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 135	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
...
/ volgende	,














/ Einde ITERATOR 

/ .GET

/ 7	.

/ De class die we geven in .get(Address.class,12l) wordt used om de persister te vinden	,

/s
	public Object get(Class entityClass, Serializable id) throws HibernateException {
		return this.byId( entityClass ).load( id );
/s
SessionImpl.byId(Class) line: 1043	
		return new IdentifierLoadAccessImpl( entityClass );
/s
SessionImpl$IdentifierLoadAccessImpl.<init>(SessionImpl, Class) line: 2508	
	private class IdentifierLoadAccessImpl implements IdentifierLoadAccess {
		private final EntityPersister entityPersister;
		private LockOptions lockOptions;

		private IdentifierLoadAccessImpl(Class entityClass) {
			this( entityClass.getName() );
/s
		private IdentifierLoadAccessImpl(String entityName) {
			this( locateEntityPersister( entityName ) );
/s
SessionImpl.locateEntityPersister(String) line: 2565	
		final EntityPersister entityPersister = factory.getEntityPersister( entityName );
/s
		EntityPersister result = entityPersisters.get(entityName);
/t
		private IdentifierLoadAccessImpl(String entityName) {
			this( locateEntityPersister( entityName ) );
/s
SessionImpl$IdentifierLoadAccessImpl.<init>(SessionImpl, EntityPersister) line: 2499	
/=
		private IdentifierLoadAccessImpl(EntityPersister entityPersister) {
			this.entityPersister = entityPersister;
/t
SessionImpl.get(Class, Serializable) line: 955	
/=
	public Object get(Class entityClass, Serializable id) throws HibernateException {
		return this.byId( entityClass ).load( id );
/s
SessionImpl$IdentifierLoadAccessImpl.load(Serializable) line: 2551	
			LoadEvent event = new LoadEvent( id, entityPersister.getEntityName(), false, SessionImpl.this );
/ we set de type name my.test.own.hibernate_xml_1_N_ehcache.Address in de event	, als entityClassName	,
...
/s
DefaultLoadEventListener.onLoad(LoadEvent, LoadEventListener$LoadType) line: 100	
		else {
			persister = source.getFactory().getEntityPersister( event.getEntityClassName() );
/ Eig. weer, voor de 2de keer	,

		final EntityKey keyToLoad = source.generateEntityKey( event.getEntityId(), persister );
...
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	

		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 617	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=3340)	
	disassembledState	Serializable[4]  (id=3341)	
		[0]	"foostreet" (id=3342)	
		[1]	"12 foo" (id=3343)	
		[2]	"FooCityA" (id=3344)	
		[3]	Long  (id=3345) 	12

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
/ entry=ce
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/ event.getEntityId()=12l, door ons opgegeven in .get	,
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 678	
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
entity	Address  (id=3359)	
	addressLine1	null	
	city	null	
	employees	HashSet<E>  (id=3360)	
	id	12	
	zipcode	null	

		final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );


			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/s
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 163	
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/ de 4de entry heeft als type SetType	, de Long 12 wordt resolved: new PersistentSet, en wordt in sc set onder collectionEntries	, 
this	StandardCacheEntryImpl  (id=3340)	
instance	Address  (id=3359)	
id	Long  (id=64)	
persister	SingleTableEntityPersister  (id=40)	
	entityMetamodel	EntityMetamodel  (id=3446)	
		propertyTypes	Type[4]  (id=3421)	
			[0]	StringType  (id=3511)	
			[1]	StringType  (id=3511)	
			[2]	StringType  (id=3511)	
			[3]	SetType  (id=3430)	
				foreignKeyPropertyName	null	
				isEmbeddedInXML	true	
				role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3431)	
				typeScope	TypeFactory$TypeScopeImpl  (id=3432)	
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 113	
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ NEE
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/s
/ De laatste	, 
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 303	
			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
Long 12
/ de 4de prpp uit disassembled Address	,
			return resolveKey( key, session, owner );
/s
			getCollection( key, session, owner );
/s
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 748	
		CollectionPersister persister = getPersister( session );
/s
		return session.getFactory().getCollectionPersister( this.role );
/ this.role= "my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3431)	

/t
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 748	
                CollectionPersister persister = getPersister( session );
/ D
OneToManyPerister	,
				collection = instantiate( session, persister, key );
/ new PersistentSet	,
				persistenceContext.addUninitializedCollection( persister, collection, key );
/ coll in sc	, als 1ste	,

/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	

		persister.setPropertyValues( instance, assembledProps );
/ de lege HashSet van instance wordt de PersistentSet (ook leeg)	,

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 733	
		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
/ Nu pas de Address naar sc	,

/ Einde .GET

/ 7	.

/ COLLECTION TO EHCACHE

/ hibernate_xml_1_N_ehcache	, 


/ na PersisnentSet.iterator ehcache van de Set	,

/ Als we 	,

	        Set<Employee>employees=address.getEmployees();
	        Iterator< Employee>iterator=employees.iterator();

/ Dan komen we in PersistenSet.iterator	, NIET in HashSet.iterator	, en deze calls 
						session.initializeCollection( AbstractPersistentCollection.this, writing );
/ Dus wordt de coll initialized	, 

 
Thread [main] (Suspended)	
	AbstractReadWriteEhcacheAccessStrategy$Item.<init>(Object, Object, long) line: 265	

value	CollectionCacheEntry  (id=3517)	
	state	Serializable[2]  (id=3563)	
		[0]	Long  (id=3478)	
			value	1	
		[1]	Long  (id=3368)	
			value	2	

/ vervolgens	,

SelectableConcurrentHashMap$Segment.put(Object, int, Element, long, boolean, boolean, boolean) line: 847	
/=
        protected Element put(Object key, int hash, Element value, long sizeOf, boolean onlyIfAbsent, boolean pinned, boolean fire) {
key	CacheKey  (id=3516)	
my.test.own.hibernate_xml_1_N_ehcache.Address.employees#12
hash	1765703378	
value	Element  (id=3618)	
	key	CacheKey  (id=3516)	
	value	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3561)	
		value	CollectionCacheEntry  (id=3517)	
			state	Serializable[2]  (id=3563)	
				[0]	Long  (id=3478)	
					value	1	
				[1]	Long  (id=3368)	
					value	2	







	Main.main(String[]) line: 57	
/s
	Main.<init>() line: 63	
/s
	Main.testBasicUsage() line: 173	
/s
	PersistentSet.iterator() line: 180	
/s
	PersistentSet(AbstractPersistentCollection).read() line: 142	
/s
	PersistentSet(AbstractPersistentCollection).initialize(boolean) line: 554	
/s
	PersistentSet(AbstractPersistentCollection).withTemporarySessionIfNeeded(LazyInitializationWork<T>) line: 260	
/s
	AbstractPersistentCollection$4.doWork() line: 558	

				new LazyInitializationWork<Object>() {
					@Override
					public Object doWork() {
->						session.initializeCollection( AbstractPersistentCollection.this, writing );
/ AbstractPersistentCollection.this= PersistenSet employees uit de Address inst	,
/s
	SessionImpl.initializeCollection(PersistentCollection, boolean) line: 1897	

		InitializeCollectionEvent event = new InitializeCollectionEvent( collection, this );
		for ( InitializeCollectionEventListener listener : listeners( EventType.INIT_COLLECTION ) ) {
			listener.onInitializeCollection( event );
/s
	DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 92	

		PersistentCollection collection = event.getCollection();
/ Klopt, de PersistenSet employees was in event set	,
		SessionImplementor source = event.getSession();

		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry( collection );
/ Deze is er inderdaad	, .get(Address, 12l) deed dat	,

			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
/ loadedKey=Long 12 =laatste prop uit Address-cache entry in ehcache onder key Long 12 die we gaven in Main bij .get	, 
/ persister=Address.employees-persister, deze heeft Address.employees-region in ehcache	,
persister	OneToManyPersister  (id=3338)	
	cacheAccessStrategy	NonstopAwareCollectionRegionAccessStrategy  (id=3350)	
		actualStrategy	ReadWriteEhcacheCollectionRegionAccessStrategy  (id=3391)	
			region	EhcacheCollectionRegion  (id=3394)	
				cache	Cache  (id=3416)	
					configuration	CacheConfiguration  (id=3428)	
						name	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3455)	

false
/ De coll is niet in de ehcache	,
/ want	,
/ er staat een lock in de ehcache bij deze key (Long 12, maar hij gaat een CacheKey create (TODO))	, in de Address.employees-region	, en deze is NIET readable (TODO, see unlockItem hierboven ), dus geeft hij null terug	,	
/s
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 139	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 81	
		try {
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=3496)	
			final boolean readable = item != null && item.isReadable( txTimestamp );
			if ( readable ) {
/ NEE
/ een lock is niet readable	,
				return item.getValue();
			}
			else {
/ JA
				return null;

/t
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 139	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
null
		if ( ce == null ) {
			return false;

/t
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 83	
			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
/ D
false
/ De coll is niet in de ehcache	,

////////////////////////////////////////////////////////////
/ De coll is er dus niet	, dus moet hij hem initialize	, dat doet hij door de coll-query naar de db te exec , 
	select*from employee where employee.address=12 
/ Deze coll-query werkt met foreign keys	,


			if ( foundInCache ) {
			else {
				ce.getLoadedPersister().initialize( ce.getLoadedKey(), source );
/s
	OneToManyPersister(AbstractCollectionPersister).initialize(Serializable, SessionImplementor) line: 693	

		getAppropriateInitializer( key, session ).initialize( key, session );
/s
CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 87	


this	CollectionLoader  (id=3356)	
	collectionPersister	OneToManyPersister  (id=3338)	
	columnNameCache	null	
	factory	SessionFactoryImpl  (id=3339)	
	staticLoadQuery	OneToManyLoadQueryDetails  (id=3358)	
		collectionReferenceAliases	CollectionReferenceAliasesImpl  (id=3363)	
		keyColumnNames	String[1]  (id=3365)	
		loadPlan	LoadPlanImpl  (id=3367)	
		queryProcessor	LoadQueryJoinAndFetchProcessor  (id=3369)	
		readerCollector	AbstractCollectionLoadQueryDetails$CollectionLoaderReaderCollectorImpl  (id=3371)	
		resultSetProcessor	ResultSetProcessorImpl  (id=3373)	
		rootReturn	CollectionReturnImpl  (id=3375)	
		sqlStatement	"select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?" (id=3377)	
id	Long  (id=3337)	
session	SessionImpl  (id=3334)	

/ this.collectionPersister.initializer=this
/ TODO( als deze persister created, dan ook deze initializer?)

		final Serializable[] ids = new Serializable[]{id};
/ Long 12
////////////////////////////////////////////
/ = prop disassembledState[3] uit Address-region bij Long 12, gegeven aan .get	, en deze prop corresp.de met de coll uit de Address inst uit de 1ste session	,  en deze wordt nu used in de coll-query als fk value	, klopt precies	,

			final QueryParameters qp = new QueryParameters();
			qp.setPositionalParameterTypes( new Type[]{ collectionPersister.getKeyType() } );
	[0]	LongType  (id=3431)	
		dictatedSize	Size  (id=3433)	
		javaTypeDescriptor	LongTypeDescriptor  (id=3434)	
		sqlTypeDescriptor	BigIntTypeDescriptor  (id=3435)	
		sqlTypes	(id=3438)	
			qp.setPositionalParameterValues( ids );
[Long 12]
			qp.setCollectionKeys( ids );

			executeLoad(
					session,
					qp,
					this.staticLoadQuery,
					true,
					null

			);
this	CollectionLoader  (id=3356)	
	staticLoadQuery	OneToManyLoadQueryDetails  (id=3358)	
		collectionReferenceAliases	CollectionReferenceAliasesImpl  (id=3363)	
		keyColumnNames	String[1]  (id=3365)	
[address_]
		loadPlan	LoadPlanImpl  (id=3367)	
		queryProcessor	LoadQueryJoinAndFetchProcessor  (id=3369)	
		readerCollector	AbstractCollectionLoadQueryDetails$CollectionLoaderReaderCollectorImpl  (id=3371)	
		resultSetProcessor	ResultSetProcessorImpl  (id=3373)	
		rootReturn	CollectionReturnImpl  (id=3375)	
		sqlStatement	"select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?" (id=3377)	
id	Long  (id=3337)	

/ TODO (Wanneer is created  staticLoadQuery OneToManyLoadQueryDetails  (id=3358) ?)

/s
CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer) line: 102	
		final List<AfterLoadAction> afterLoadActions = new ArrayList<AfterLoadAction>();
		return executeLoad(
				session,
				queryParameters,
				loadQueryDetails,
				returnProxies,
				forcedResultTransformer,
				afterLoadActions
		);
/s
CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 119	
		else {
			// The read-only/modifiable setting for the query was not initialized.
			// Use the default read-only/modifiable from the persistence context instead.
			queryParameters.setReadOnly( persistenceContext.isDefaultReadOnly() );
false

			final String sql = loadQueryDetails.getSqlStatement();
sql	"select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?" (id=3377)	

				wrapper = executeQueryStatement( sql, queryParameters, false, afterLoadActions, session );
/ we debug niet	,
wrapper	AbstractLoadPlanBasedLoader$SqlStatementWrapper  (id=3608)	
	resultSet	Jdbc4ResultSet  (id=3606)	
	statement	Jdbc4PreparedStatement  (id=3587)	

/ EERSTE 
				results = loadQueryDetails.getResultSetProcessor().extractResults(
						wrapper.getResultSet(),
						session,
						queryParameters,
						new NamedParameterContext() {
							@Override
							public int[] getNamedParameterLocations(String name) {
								return AbstractLoadPlanBasedLoader.this.getNamedParameterLocs( name );
							}
						},
						returnProxies,
						queryParameters.isReadOnly(),
						forcedResultTransformer,
						afterLoadActions
				);
/s
	ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	

		handlePotentiallyEmptyCollectionRootReturns( this.loadPlan, queryParameters.getCollectionKeys(), resultSet, session );

this	ResultSetProcessorImpl  (id=3552)	
	hadSubselectFetches	false	
	loadPlan	LoadPlanImpl  (id=3545)	
		areLazyAttributesForceFetched	false	
		disposition	LoadPlan$Disposition  (id=3578)	
		querySpaces	QuerySpacesImpl  (id=3600)	
			implicitUidBase	2	
			querySpaceByUid	ConcurrentHashMap<K,V>  (id=3619)	
			roots	ArrayList<E>  (id=3620)	
				elementData	Object[10]  (id=3648)	
					[0]	CollectionQuerySpaceImpl  (id=3602)	
						canJoinsBeRequired	true	
						disposition	QuerySpace$Disposition  (id=3607)	
						joins	ArrayList<E>  (id=3608)	
						persister	OneToManyPersister  (id=3338)	
						querySpaces	QuerySpacesImpl  (id=3600)	
						uid	"<gen:0>" (id=3612)	
				modCount	1	
				size	1	
			sessionFactory	SessionFactoryImpl  (id=3340)	
		returns	Collections$SingletonList<E>  (id=3601)	
			element	CollectionReturnImpl  (id=3555)	
				collectionQuerySpace	CollectionQuerySpaceImpl  (id=3602)	
				element	CollectionFetchableElementEntityGraph  (id=3603)	
					bidirectionalEntityReferences	null	
					collectionReference	CollectionReturnImpl  (id=3555)	
						collectionQuerySpace	CollectionQuerySpaceImpl  (id=3602)	
						element	CollectionFetchableElementEntityGraph  (id=3603)	
						index	null	
						propertyPath	PropertyPath  (id=3604)	
					fetches	null	
					identifierDescription	SimpleEntityIdentifierDescriptionImpl  (id=3663)	
					propertyPath	PropertyPath  (id=3664)	
					querySpace	EntityQuerySpaceImpl  (id=3665)	
				index	null	
				propertyPath	PropertyPath  (id=3604)	
			modCount	0	
	rowReader	AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader  (id=3562)	


/s
ResultSetProcessorImpl.handlePotentiallyEmptyCollectionRootReturns(LoadPlan, Serializable[], ResultSet, SessionImplementor) line: 173	
			session.getPersistenceContext()
					.getLoadContexts()
					.getCollectionLoadContext( resultSet )
					.getLoadingCollection( persister, key );
/s
CollectionLoadContext.getLoadingCollection(CollectionPersister, Serializable) line: 144	
		final EntityMode em = persister.getOwnerEntityPersister().getEntityMetamodel().getEntityMode();
pojo
		final CollectionKey collectionKey = new CollectionKey( persister, key, em );

		final LoadingCollectionEntry loadingCollectionEntry = loadContexts.locateLoadingCollectionEntry( collectionKey );
null
		if ( loadingCollectionEntry == null ) {
			// look for existing collection as part of the persistence context
			PersistentCollection collection = loadContexts.getPersistenceContext().getCollection( collectionKey );
			if ( collection != null ) {
/ JA
				if ( collection.wasInitialized() ) {
/ NEE

				LOG.trace( "Collection not yet initialized; initializing" );
/ TODO LOG

/ TODO (Afmaken)

/ t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 92	
		handlePotentiallyEmptyCollectionRootReturns( loadPlan, queryParameters.getCollectionKeys(), resultSet, session );
/ D

		final ResultSetProcessingContextImpl context = new ResultSetProcessingContextImpl(
				resultSet,
				session,
				loadPlan,
				readOnly,
				shouldUseOptionalEntityInstance,
				forceFetchLazyAttributes,
				returnProxies,
				queryParameters,
				namedParameterContext,
				hadSubselectFetches
		);
/ TODO

		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			LOG.debugf( "Starting ResultSet row #%s", count );

			Object logicalRow = rowReader.readRow( resultSet, context );
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 89	
		final boolean hasEntityReferenceInitializers = CollectionHelper.isNotEmpty( entityReferenceInitializers );
true
		if ( hasEntityReferenceInitializers ) {
			// 	1) allow entity references to resolve identifiers (in 2 steps)
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateIdentifier( resultSet, context );
/s
EntityReferenceInitializerImpl.hydrateIdentifier(ResultSet, ResultSetProcessingContextImpl) line: 100	

		final EntityReferenceProcessingState processingState = context.getProcessingState( entityReference );

		// get any previously registered identifier hydrated-state
		Object identifierHydratedForm = processingState.getIdentifierHydratedForm();
		if ( identifierHydratedForm == null ) {
/ JA
			// if there is none, read it from the result set
			identifierHydratedForm = readIdentifierHydratedState( resultSet, context );
Long 1

/ we zien	,
HibernateLog --> 09:40:22 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_1_] : [BIGINT]) - [1]

			// broadcast the fact that a hydrated identifier value just became associated with
			// this entity reference
			processingState.registerIdentifierHydratedForm( identifierHydratedForm );
processingState	ResultSetProcessingContextImpl$1  (id=3357)	
identifierHydratedForm	Long  (id=3361)	
	value	1	

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 91	

			// 	1) allow entity references to resolve identifiers (in 2 steps)
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateIdentifier( resultSet, context );
			}
/ D
			final Map<EntityReference,EntityReferenceInitializer> initializerByEntityReference =
					new HashMap<EntityReference, EntityReferenceInitializer>( entityReferenceInitializers.size() );
			for ( EntityReferenceInitializer entityReferenceInitializerFromMap : entityReferenceInitializers ) {
				initializerByEntityReference.put( entityReferenceInitializerFromMap.getEntityReference(), entityReferenceInitializerFromMap );
			}
/ TODO(Afmaken)
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				resolveEntityKey(
						resultSet,
						context,
						entityReferenceInitializer,
						initializerByEntityReference
				);
			}
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).resolveEntityKey(ResultSet, ResultSetProcessingContextImpl, EntityReferenceInitializer, Map<EntityReference,EntityReferenceInitializer>) line: 148	

		entityReferenceInitializer.resolveEntityKey( resultSet, context );
/s
EntityReferenceInitializerImpl.resolveEntityKey(ResultSet, ResultSetProcessingContextImpl) line: 157	

		final EntityReferenceProcessingState processingState = context.getProcessingState( entityReference );
processingState	ResultSetProcessingContextImpl$1  (id=3587)	

/ Intermezzo

/ als we bijv hier zijn	,
ResultSetProcessingContextImpl$1.registerEntityInstance(Object) line: 228	

public class ResultSetProcessingContextImpl implements ResultSetProcessingContext {
			context = new EntityReferenceProcessingState() {
				private boolean wasMissingIdentifier;
				private Object identifierHydratedForm;
				private EntityKey entityKey;
				private Object[] hydratedState;
				private Object entityInstance;

				public void registerEntityInstance(Object entityInstance) {
					this.entityInstance = entityInstance;
				}





/ Einde Intermezzo

		final EntityKey entityKey = processingState.getEntityKey();
null
		final Object identifierHydratedForm = processingState.getIdentifierHydratedForm();
Long 1
		final Type identifierType = this.entityReference.getEntityPersister().getIdentifierType();
LongType inst	,
/ want	,
this	EntityReferenceInitializerImpl  (id=3346)	
	entityReference	CollectionFetchableElementEntityGraph  (id=3501)	
		bidirectionalEntityReferences	null	
		collectionReference	CollectionReturnImpl  (id=3519)	
			collectionQuerySpace	CollectionQuerySpaceImpl  (id=3619)	
				canJoinsBeRequired	true	
				disposition	QuerySpace$Disposition  (id=3623)	
				joins	ArrayList<E>  (id=3624)	
				persister	OneToManyPersister  (id=3336)	
				querySpaces	QuerySpacesImpl  (id=3625)	
				uid	"<gen:0>" (id=3626)	
			element	CollectionFetchableElementEntityGraph  (id=3501)	
			index	null	
			propertyPath	PropertyPath  (id=3620)	
PropertyPath[[my.test.own.hibernate_xml_1_N_ehcache.Address.employees]]
		fetches	null	
		identifierDescription	SimpleEntityIdentifierDescriptionImpl  (id=3522)	
		propertyPath	PropertyPath  (id=3525)	
PropertyPath[[my.test.own.hibernate_xml_1_N_ehcache.Address.employees].<elements>]
		querySpace	EntityQuerySpaceImpl  (id=3528)	
/s
SingleTableEntityPersister(AbstractEntityPersister).getIdentifierType() line: 4922	
		return entityMetamodel.getIdentifierProperty().getType();

/t
EntityReferenceInitializerImpl.resolveEntityKey(ResultSet, ResultSetProcessingContextImpl) line: 158	

		final Type identifierType = entityReference.getEntityPersister().getIdentifierType();
/ D
		final Serializable resolvedId = (Serializable) identifierType.resolve(
				identifierHydratedForm,
				context.getSession(),
				null
		);
/ TODO
Long 1




/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 107	

			// 2) allow entity references to resolve their non-identifier hydrated state and entity instance
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateEntityState( resultSet, context );
/s
EntityReferenceInitializerImpl.hydrateEntityState(ResultSet, ResultSetProcessingContextImpl) line: 251	

		// make sure we have the EntityKey
		final EntityKey entityKey = processingState.getEntityKey();
Long 1
processingState	ResultSetProcessingContextImpl$1  (id=3587)	
	entityKey	EntityKey  (id=3758)	
EntityKey[my.test.own.hibernate_xml_1_N_ehcache.Employee#1]

		final String concreteEntityTypeName = getConcreteEntityTypeName( resultSet, context, entityKey );
concreteEntityTypeName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3358)	


		final Object entityInstance = optionalEntityInstance != null
				? optionalEntityInstance
				: context.getSession().instantiate( concreteEntityTypeName, entityKey.getIdentifier() );
entityInstance	Employee  (id=3772)	
	id	1	
	name	null	
	salary	0.0	
/ via de persister van Employee, tuplicer, new	,



		processingState.registerEntityInstance( entityInstance );
/s
ResultSetProcessingContextImpl$1.registerEntityInstance(Object) line: 228	
/=
			context = new EntityReferenceProcessingState() {
				public void registerEntityInstance(Object entityInstance) {
->					this.entityInstance = entityInstance;
				}

		loadFromResultSet(
				resultSet,
				context,
				entityInstance,
				concreteEntityTypeName,
				entityKey,
				lockModeToAcquire
		);

/ we use de hele tijd de resultSet van de query	,
Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?

/s
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 291	

		// Get the persister for the _subclass_
		final Loadable concreteEntityPersister = (Loadable) context.getSession().getFactory().getEntityPersister( concreteEntityTypeName );
/ persister van Employee	,

			values = concreteEntityPersister.hydrate(
					resultSet,
					id,
					entityInstance,
					(Loadable) entityReference.getEntityPersister(),
					concreteEntityPersister == rootEntityPersister
							? entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases()
							: entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases( concreteEntityPersister ),
					context.getLoadPlan().areLazyAttributesForceFetched(),
					context.getSession()
			);
/ we use de hele tijd de resultSet van de query	,
Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?

/s
SingleTableEntityPersister(AbstractEntityPersister).hydrate(ResultSet, Serializable, Object, Loadable, String[][], boolean, SessionImplementor) line: 2900	

		final AbstractEntityPersister rootPersister = (AbstractEntityPersister) rootLoadable;
/ van Employee

			final String[] propNames = getPropertyNames();
[name, salary, _my.test.own.hibernate_xml_1_N_ehcache.Address.employeesBackref]
			final Type[] types = getPropertyTypes();
[org.hibernate.type.StringType@59a8a1a3, org.hibernate.type.DoubleType@1bfdbab5, org.hibernate.type.LongType@391ba64d]
			final Object[] values = new Object[types.length];
			final boolean[] laziness = getPropertyLaziness();
[false, false, false]

			for ( int i = 0; i < types.length; i++ ) {
				if ( !propertySelectable[i] ) {
					values[i] = BackrefPropertyAccessor.UNKNOWN;
/ JA, laatste	,
				}
				else if ( allProperties || !laziness[i] ) {
					//decide which ResultSet to get the property value from:
					else {
						final ResultSet propertyResultSet = propertyIsDeferred ? sequentialResultSet : rs;
rs
						final String[] cols = propertyIsDeferred ? propertyColumnAliases[i] : suffixedPropertyColumns[i];
[name_2_1_1_]
/ of	,
[salary_3_1_1_]
						values[i] = types[i].hydrate( propertyResultSet, cols, session, object );
/s
/ hydrate=unmarshall	,
StringType(AbstractStandardBasicType<T>).hydrate(ResultSet, String[], SessionImplementor, Object) line: 338	
		return nullSafeGet(rs, names, session, owner);
/s
	public final T nullSafeGet(ResultSet rs, String name, final SessionImplementor session) throws SQLException {

		return nullSafeGet( rs, name, options );
/'s
	protected final T nullSafeGet(ResultSet rs, String name, WrapperOptions options) throws SQLException {
		return remapSqlTypeDescriptor( options ).getExtractor( javaTypeDescriptor ).extract( rs, name, options );
/s
DoubleTypeDescriptor$2(BasicExtractor<J>).extract(ResultSet, String, WrapperOptions) line: 64	
/ of	,
VarcharTypeDescriptor$2(BasicExtractor<J>).extract(ResultSet, String, WrapperOptions) line: 64	
/=
public abstract class BasicExtractor<J> implements ValueExtractor<J> {
	public J extract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
		final J value = doExtract( rs, name, options );
/s
DoubleTypeDescriptor$2.doExtract(ResultSet, String, WrapperOptions) line: 74	
/=
public class DoubleTypeDescriptor implements SqlTypeDescriptor {
	public <X> ValueExtractor<X> getExtractor(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicExtractor<X>( javaTypeDescriptor, this ) {
			@Override
			protected X doExtract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
				return javaTypeDescriptor.wrap( rs.getDouble( name ), options );
///////////////
/ Hier basic: rs.getDouble	,
/ of	,
public class VarcharTypeDescriptor implements SqlTypeDescriptor {
	public <X> ValueExtractor<X> getExtractor(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicExtractor<X>( javaTypeDescriptor, this ) {
			@Override
			protected X doExtract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
				return javaTypeDescriptor.wrap( rs.getString( name ), options );
			}
///////////////////
/ Hier basic: rs.getString

/t
DoubleTypeDescriptor$2(BasicExtractor<J>).extract(ResultSet, String, WrapperOptions) line: 85	
		final J value = doExtract( rs, name, options );
Double 1.0
/ of
"Foo1A"
/ D
		else {
			if ( traceEnabled ) {
				log.tracef(
						"extracted value ([%s] : [%s]) - [%s]",
						name,
						JdbcTypeNameMapper.getTypeName( getSqlDescriptor().getSqlType() ),
						getJavaDescriptor().extractLoggableRepresentation( value )
				);
			}
HibernateLog --> 10:15:55 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([name_2_1_1_] : [VARCHAR]) - [Foo2A]
/ of	,
HibernateLog --> 10:25:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([salary_3_1_1_] : [DOUBLE]) - [2.0]

			return value;

/t
SingleTableEntityPersister(AbstractEntityPersister).hydrate(ResultSet, Serializable, Object, Loadable, String[][], boolean, SessionImplementor) line: 2956	

			for ( int i = 0; i < types.length; i++ ) {
/ Volgende	,
/ this.propertySelectable=[true,true,false]
				if ( !propertySelectable[i] ) {
					values[i] = BackrefPropertyAccessor.UNKNOWN;

/t
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 336	
		try {
			values = concreteEntityPersister.hydrate(
					resultSet,
					id,
					entityInstance,
					(Loadable) entityReference.getEntityPersister(),
					concreteEntityPersister == rootEntityPersister
							? entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases()
							: entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases( concreteEntityPersister ),
					context.getLoadPlan().areLazyAttributesForceFetched(),
					context.getSession()
			);
/ D
values=[Foo2A, 2.0, <unknown>]

			context.getProcessingState( this.entityReference ).registerHydratedState( values );

this	EntityReferenceInitializerImpl  (id=3346)	
	entityReference	CollectionFetchableElementEntityGraph  (id=3501)	
context	ResultSetProcessingContextImpl  (id=3561)	
	identifierResolutionContextMap	IdentityHashMap<K,V>  (id=3578)	
		size	1	
		table	Object[64]  (id=3584)	
			[34]	CollectionFetchableElementEntityGraph  (id=3350)	
/=key
			[35]	ResultSetProcessingContextImpl$1  (id=3575)	
/=value
				entityInstance	Employee  (id=3361)	
				entityKey	EntityKey  (id=3565)	
				hydratedState	Object[3]  (id=3397)	
[Foo2A, 2.0, <unknown>]
				identifierHydratedForm	Long  (id=3359)	
				this$0	ResultSetProcessingContextImpl  (id=3561)	
				val$entityReference	CollectionFetchableElementEntityGraph  (id=3350)	
				wasMissingIdentifier	false	
/s
ResultSetProcessingContextImpl.getProcessingState(EntityReference) line: 169	
		EntityReferenceProcessingState context = this.identifierResolutionContextMap.get( entityReference );
/ we vragen hier de value [35] bij key hierboven [34]	,

/t
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 336	
			context.getProcessingState( entityReference ).registerHydratedState( values );
/s
ResultSetProcessingContextImpl$1.registerHydratedState(Object[]) line: 219	
/=
			context = new EntityReferenceProcessingState() {
				private boolean wasMissingIdentifier;
				private Object identifierHydratedForm;
				private EntityKey entityKey;
				private Object[] hydratedState;
				private Object entityInstance;

				public void registerHydratedState(Object[] hydratedState) {
					this.hydratedState = hydratedState;

/t
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 347	

			context.getProcessingState( entityReference ).registerHydratedState( values );
/ D

		TwoPhaseLoad.postHydrate(
				concreteEntityPersister,
				id,
				values,
				rowId,
				entityInstance,
				lockModeToAcquire,
				!context.getLoadPlan().areLazyAttributesForceFetched(),
				context.getSession()
		);
/ TODO

/ we zijn nog in	,
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 396	
this	EntityReferenceInitializerImpl  (id=3347)	

		context.registerHydratedEntity( entityReference, entityKey, entityInstance );
/s
ResultSetProcessingContextImpl.registerHydratedEntity(EntityReference, EntityKey, Object) line: 271	
		if ( currentRowHydratedEntityRegistrationList == null ) {
/ JA
			currentRowHydratedEntityRegistrationList = new ArrayList<HydratedEntityRegistration>();
		}
		currentRowHydratedEntityRegistrationList.add(
				new HydratedEntityRegistration(
						entityReference,
						entityKey,
						entityInstance
				)
		);
/t
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 397	
		context.registerHydratedEntity( entityReference, entityKey, entityInstance );
/ D
context	ResultSetProcessingContextImpl  (id=3561)	
	currentRowHydratedEntityRegistrationList	ArrayList<E>  (id=3676)	
		elementData	Object[10]  (id=3677)	
			[0]	HydratedEntityRegistration  (id=3680)	
				entityReference	CollectionFetchableElementEntityGraph  (id=3350)	
				instance	Employee  (id=3361)	
					id	2	
					name	null	
					salary	0.0	
				key	EntityKey  (id=3565)	
		modCount	1	
		size	1	

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 114	

			// 2) allow entity references to resolve their non-identifier hydrated state and entity instance
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateEntityState( resultSet, context );
			}
		}
/ D

		// 3) read the logical row

		Object logicalRow = readLogicalRow( resultSet, context );
null
/ want	,
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader.readLogicalRow(ResultSet, ResultSetProcessingContextImpl) line: 205	
			return rootReturnReader.read( resultSet, context );
/s
CollectionReturnReader.read(ResultSet, ResultSetProcessingContext) line: 45	
		return null;  //To change body of implemented methods use File | Settings | File Templates.

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 118	

		// 4) allow arrays, entities and collections after row callbacks
		if ( hasEntityReferenceInitializers ) {
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.finishUpRow( resultSet, context );
/s
EntityReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 510	
	}
/ NIETS dus	,

/t
		if ( this.collectionReferenceInitializers != null ) {
			for ( CollectionReferenceInitializer collectionReferenceInitializer : collectionReferenceInitializers ) {
				collectionReferenceInitializer.finishUpRow( resultSet, context );
/s
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 66	

this	CollectionReferenceInitializerImpl  (id=3349)	
	collectionReference	CollectionReturnImpl  (id=3519)	

			// read the collection key for this reference for the current row.
			final PersistenceContext persistenceContext = context.getSession().getPersistenceContext();
			final Serializable collectionRowKey = (Serializable) this.collectionReference.getCollectionPersister().readKey(
					resultSet,
					aliases.getCollectionColumnAliases().getSuffixedKeyAliases(),
					context.getSession()
			);
Long 12
/ want	,
/ this.collectionReference.getCollectionPersister()=this.collectionReference.collectionQuerySpace.getCollectionPersister()
/s
OneToManyPersister(AbstractCollectionPersister).readKey(ResultSet, String[], SessionImplementor) line: 878	
		return getKeyType().nullSafeGet( rs, aliases, session, null );
/s
LongType(AbstractStandardBasicType<T>).nullSafeGet(ResultSet, String[], SessionImplementor, Object) line: 253	
		return nullSafeGet( rs, names[0], session );
/ we zien	,
HibernateLog --> 11:04:53 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([address_4_0_0_] : [BIGINT]) - [12]

/t
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 87	

				Object collectionOwner = findCollectionOwner( collectionRowKey, resultSet, context );
/s
CollectionReferenceInitializerImpl.findCollectionOwner(Serializable, ResultSet, ResultSetProcessingContextImpl) line: 141	

		final Object collectionOwner = context.getSession().getPersistenceContext().getCollectionOwner(
				collectionRowKey,
				collectionReference.getCollectionPersister()
		);
/s
StatefulPersistenceContext.getCollectionOwner(Serializable, CollectionPersister) line: 694	

		final EntityPersister ownerPersister = collectionPersister.getOwnerEntityPersister();
collectionPersister	OneToManyPersister  (id=3336)	
/ ownerPersister is de persister van Address	,

		if ( ownerPersister.getIdentifierType().getReturnedClass().isInstance( key ) ) {
/ JA
/ key=Long 12
			return getEntity( session.generateEntityKey( key, collectionPersister.getOwnerEntityPersister() ) );
session.generateEntityKey( key, collectionPersister.getOwnerEntityPersister() )= EntityKey[my.test.own.hibernate_xml_1_N_ehcache.Address#12]
/s
StatefulPersistenceContext.getEntity(EntityKey) line: 393	

		return entitiesByKey.get( key );
collectionOwner	Address  (id=3775)	
/ set heeft size 0
/t
CollectionReferenceInitializerImpl.findCollectionOwner(Serializable, ResultSet, ResultSetProcessingContextImpl) line: 147	
		final Object collectionOwner = context.getSession().getPersistenceContext().getCollectionOwner(
				collectionRowKey,
				collectionReference.getCollectionPersister()
		);
/ D
collectionOwner	Address  (id=3775)	
/ set heeft size 0

/ De Set in de PersistentSet van Address inst is niet null meer, is een HashSet, maar deze is leeg	, geen entries	,

/t
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 89	
				Object collectionOwner = findCollectionOwner( collectionRowKey, resultSet, context );
/ D
Address inst	,
/ set heeft size 0
				PersistentCollection rowCollection = persistenceContext.getLoadContexts()
						.getCollectionLoadContext( resultSet )
						.getLoadingCollection( collectionReference.getCollectionPersister(), collectionRowKey );
/s
LoadContexts.getCollectionLoadContext(ResultSet) line: 168	
		else {
			context = collectionLoadContexts.get(resultSet);
{org.postgresql.jdbc4.Jdbc4ResultSet@71564def=org.hibernate.engine.loading.internal.CollectionLoadContext@751a35b2<rs=org.postgresql.jdbc4.Jdbc4ResultSet@71564def>}/t
/s
CollectionLoadContext.getLoadingCollection(CollectionPersister, Serializable) line: 111	
/=
	public PersistentCollection getLoadingCollection(final CollectionPersister persister, final Serializable key) {
/ persister=OneToManyPersister	, 
/ key=Long 12	,
/ TODO(Afmaken)

/t
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 93	
				PersistentCollection rowCollection = persistenceContext.getLoadContexts()
						.getCollectionLoadContext( resultSet )
						.getLoadingCollection( collectionReference.getCollectionPersister(), collectionRowKey );
/ rowCollection = de set PersistentSet uit de Address inst	, 
/ heeft size 0	,

				if ( rowCollection != null ) {
					rowCollection.readFrom(
							resultSet,
							this.collectionReference.getCollectionPersister(),
							this.aliases.getCollectionColumnAliases(),
							collectionOwner
					);
				}
/ this.collectionReference.getCollectionPersister()=this.collectionReference.collectionQuerySpace.getCollectionPersister()
/s
PersistentSet.readFrom(ResultSet, CollectionPersister, CollectionAliases, Object) line: 327	

		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
/s
OneToManyPersister(AbstractCollectionPersister).readElement(ResultSet, Object, String[], SessionImplementor) line: 844	

		return getElementType().nullSafeGet( rs, aliases, session, owner );
/s
ManyToOneType(EntityType).nullSafeGet(ResultSet, String[], SessionImplementor, Object) line: 308	

		return resolve( hydrate(rs, names, session, owner), session, owner );
////////////////////////////
/s
ManyToOneType.hydrate(ResultSet, String[], SessionImplementor, Object) line: 190	
		final Serializable id = (Serializable) getIdentifierOrUniqueKeyType( session.getFactory() )
				.nullSafeGet( rs, names, session, null );
Long 1
/ we zien	,
HibernateLog --> 11:58:03 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([id_1_1_0_] : [BIGINT]) - [1]

/t
/s
ManyToOneType(EntityType).resolve(Object, SessionImplementor, Object) line: 502	
/=
	public Object resolve(Object value, SessionImplementor session, Object owner) throws HibernateException {
/ value=Long 1
		if ( value != null && !isNull( owner, session ) ) {
			if ( isReferenceToPrimaryKey() ) {
				return resolveIdentifier( (Serializable) value, session );
/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 716	
/=
	protected final Object resolveIdentifier(Serializable id, SessionImplementor session) throws HibernateException {

this	ManyToOneType  (id=3351)	
	associatedEntityName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3358)	
	associatedEntityPersister	SingleTableEntityPersister  (id=3348)	
	associatedIdentifierType	LongType  (id=3359)	
	eager	true	
	ignoreNotFound	false	
	isEmbeddedInXML	true	
	isLogicalOneToOne	false	
	referenceToPrimaryKey	true	
	returnedClass	null	
	scope	TypeFactory$TypeScopeImpl  (id=3366)	
	uniqueKeyPropertyName	null	
	unwrapProxy	false	

		boolean isProxyUnwrapEnabled = unwrapProxy &&
				getAssociatedEntityPersister( session.getFactory() )
						.isInstrumented();
true
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				this.eager,
true
				isNullable() && !isProxyUnwrapEnabled
		);
/s
SessionImpl.internalLoad(String, Serializable, boolean, boolean) line: 989	
		// todo : remove
		LoadEventListener.LoadType type = nullable
				? LoadEventListener.INTERNAL_LOAD_NULLABLE
				: eager
->						? LoadEventListener.INTERNAL_LOAD_EAGER
						: LoadEventListener.INTERNAL_LOAD_LAZY;
		LoadEvent event = new LoadEvent(id, entityName, true, this);
		fireLoad( event, type );
...
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	

		Object entity = loadFromSessionCache( event, keyToLoad, options );
keyToLoad	EntityKey  (id=3382)	
entity	Employee  (id=3383)	
	id	2	
	name	null	
	salary	0.0	

/ Hierboven er in set	,

/t
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 723	
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/ D
/t
PersistentSet.readFrom(ResultSet, CollectionPersister, CollectionAliases, Object) line: 328	

		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
/ D
		if ( element != null ) {
			this.tempList.add( element );

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 134	
		if ( collectionReferenceInitializers != null ) {
			for ( CollectionReferenceInitializer collectionReferenceInitializer : collectionReferenceInitializers ) {
				collectionReferenceInitializer.finishUpRow( resultSet, context );
			}
		}
/ D
		return logicalRow;
/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 133	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			LOG.debugf( "Starting ResultSet row #%s", count );

			Object logicalRow = rowReader.readRow( resultSet, context );
null
/ D
			loadResults.add( logicalRow );
			context.finishUpRow();
/s
ResultSetProcessingContextImpl.finishUpRow() line: 299	
		// managing the running list of registrations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( this.hydratedEntityRegistrationList == null ) {
			this.hydratedEntityRegistrationList = new ArrayList<HydratedEntityRegistration>();
		}
		this.hydratedEntityRegistrationList.addAll( this.currentRowHydratedEntityRegistrationList );

this	ResultSetProcessingContextImpl  (id=3484)	
	hydratedEntityRegistrationList	ArrayList<E>  (id=3503)	
		elementData	Object[10]  (id=3565)	
			[0]	HydratedEntityRegistration  (id=3499)	
				entityReference	CollectionFetchableElementEntityGraph  (id=3501)	
				instance	Employee  (id=3383)	
					id	2	
					name	null	
					salary	0.0	
				key	EntityKey  (id=3502)	
			[1]	HydratedEntityRegistration  (id=3852)	
				entityReference	CollectionFetchableElementEntityGraph  (id=3501)	
				instance	Employee  (id=3772)	
					id	1	
					name	null	
					salary	0.0	
				key	EntityKey  (id=3758)	
		modCount	2	
		size	2	


/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {

			Object logicalRow = rowReader.readRow( resultSet, context );
			loadResults.add( logicalRow );

			context.finishUpRow();
		}
/ D

		rowReader.finishUp( context, afterLoadActionList );
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 195	

		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/ sets in de Employee's in hydratedEntityRegistrations de hydrated state
/ tries to put them in ehcache, maar version!=null; zijn de values in de cached entry wel gelijk aan de hydrated state?
/ vergl met eerdere update cache	,
/ TODO EHCACHE 
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).performTwoPhaseLoad(PreLoadEvent, ResultSetProcessingContextImpl, List<HydratedEntityRegistration>) line: 244	

		for ( HydratedEntityRegistration registration : hydratedEntityRegistrations ) {
			TwoPhaseLoad.initializeEntity(
					registration.getInstance(),
					context.isReadOnly(),
					context.getSession(),
					preLoadEvent
			);
		}
/s
TwoPhaseLoad.initializeEntity(Object, boolean, SessionImplementor, PreLoadEvent) line: 144	

		doInitializeEntity( entity, entityEntry, readOnly, session, preLoadEvent );
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 200	

		final Object[] hydratedState = entityEntry.getLoadedState();

		final Type[] types = persister.getPropertyTypes();
		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
				hydratedState[i] = types[i].resolve( value, session, entity );
			}
		}

		//Must occur after resolving identifiers!
		if ( session.isEventSource() ) {
			preLoadEvent.setEntity( entity ).setState( hydratedState ).setId( id ).setPersister( persister );

			final EventListenerGroup<PreLoadEventListener> listenerGroup = session
					.getFactory()
					.getServiceRegistry()
					.getService( EventListenerRegistry.class )
					.getEventListenerGroup( EventType.PRE_LOAD );
			for ( PreLoadEventListener listener : listenerGroup.listeners() ) {
				listener.onPreLoad( preLoadEvent );
/ Er is een listener, maar EmptyInterceptor doet NIETS	,

		persister.setPropertyValues( entity, hydratedState );
////////////////////
/ WAS: entity met new create, alleen id set	,
/ sets hydratedState in entity

		if ( persister.hasCache() && session.getCacheMode().isPutEnabled() ) {
/ JA
			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
hydratedState	Object[3]  (id=3996)	
	[0]	"Foo2A" (id=3998)	
	[1]	Double  (id=3999)	
	[2]	BackrefPropertyAccessor$1  (id=4001)	
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 74	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 136	
		Serializable[] disassembled = new Serializable[row.length];
		for ( int i = 0; i < row.length; i++ ) {
			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ JA, bij laatste	,
				disassembled[i] = (Serializable) row[i];
			}
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );

		return disassembled;

/t
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 202	
			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
/s
SessionImpl(AbstractSessionImpl).generateCacheKey(Serializable, Type, String) line: 332	
id	Long  (id=3355)	
2
type	LongType  (id=3359)	
entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3358)	
		return new CacheKey( id, type, entityOrRoleName, getTenantIdentifier(), getFactory() );


			// explicit handling of caching for rows just inserted and then somehow forced to be read
			// from the database *within the same transaction*.  usually this is done by
			// 		1) Session#refresh, or
			// 		2) Session#clear + some form of load
			//
			// we need to be careful not to clobber the lock here in the cache so that it can be rolled back if need be
			if ( session.getPersistenceContext().wasInsertedDuringTransaction( persister, id ) ) {
/ NEE
/ TODO (Waneer hier?)
				persister.getCacheAccessStrategy().update(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						version,
						version
				);
/ NIET
			}
			else {
/ JA
					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
							cacheKey,
							persister.getCacheEntryStructure().structure( entry ),
							session.getTimestamp(),
							version,
							useMinimalPuts( session, entityEntry )
					);
/s
TwoPhaseLoad.useMinimalPuts(SessionImplementor, EntityEntry) line: 332	
		return ( session.getFactory().getSettings().isMinimalPutsEnabled()
true
				&& session.getCacheMode()!=CacheMode.REFRESH )
true (NORMAL!=REFRESH)
				|| ( entityEntry.getPersister().hasLazyProperties()
false
				&& entityEntry.isLoadedWithLazyPropertiesUnfetched()
true
				&& entityEntry.getPersister().isLazyPropertiesCacheable() );
true

/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 109	
/=
	@Override
	public final boolean putFromLoad(
			Object key,
			Object value,
			long txTimestamp,
			Object version,
			boolean minimalPutOverride)
this	ReadWriteEhcacheEntityRegionAccessStrategy  (id=4073)	
key	CacheKey  (id=4163)	
value	StandardCacheEntryImpl  (id=4161)	
txTimestamp	5771815009763328	
version	null	
minimalPutOverride	true	

/ er staat nu een item in de ehcache bij deze cache key	,
/ TODO

		region().writeLock( key );
/s
EhcacheEntityRegion(EhcacheTransactionalDataRegion).writeLock(Object) line: 222	
		try {
			lockProvider.getSyncForKey( key ).lock( LockType.WRITE );
/s
DiskStore$DiskStoreStripedReadWriteLock.getSyncForKey(Object) line: 1189	
        public net.sf.ehcache.concurrent.ReadWriteLockSync getSyncForKey(final Object key) {

this	DiskStore$DiskStoreStripedReadWriteLock  (id=4173)	
	locks	ReadWriteLockSync[64]  (id=4175)	
		[0]	ReadWriteLockSync  (id=4180)	
		[1]	ReadWriteLockSync  (id=4181)	
...

            return locks[indexFor(key)];
/s
        private int indexFor(final Object key) {
            return hash(key.hashCode()) >>> segmentShift;
/ key.hashCode()==31
"hash(31)" -146603592	
/ hash(key.hashCode()) >>> segmentShift == 61

"this.locks[61]"	 (pending)	
	rrwl	ReentrantReadWriteLock  (id=4249)	
		readerLock	ReentrantReadWriteLock$ReadLock  (id=4254)	
		sync	ReentrantReadWriteLock$NonfairSync  (id=4257)	
		writerLock	ReentrantReadWriteLock$WriteLock  (id=4260)	

/t
ReadWriteLockSync.lock(LockType) line: 50	
/=
    public void lock(final LockType type) {

this	ReadWriteLockSync  (id=4248)	

        this.getLock(type).lock();

/t
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 112	
		region().writeLock( key );
/ D
/ TODO
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=4305)	
	timestamp	5771815000449024	
	value	StandardCacheEntryImpl  (id=4306)	
		disassembledState	Serializable[3]  (id=4307)	
			[0]	"Foo1A" (id=4308)	
			[1]	Double  (id=4309)	
			[2]	BackrefPropertyAccessor$1  (id=4001)	
		lazyPropertiesAreUnfetched	false	
		subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3358)	
		version	null	
	version	null	

			final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
/s
		public boolean isWriteable(long txTimestamp, Object newVersion, Comparator versionComparator) {
			return version != null && versionComparator.compare( version, newVersion ) < 0;
false
/ version==null
			if ( writeable ) {
/ NEE
				region().put( key, new Item( value, version, region().nextTimestamp() ) );
/ NIET
				return true;
			}
			else {
/ JA
				return false;

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 218	

		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/ D
		// now we can finalize loading collections
		finishLoadingCollections( context );
/////////////////////////////////////////
/ Hier coll -> ehcache	,
/ COLLECTION TO 2C
/ In 	,
CollectionLoadContext.endLoadingCollection(LoadingCollectionEntry, CollectionPersister) line: 262	


/ Intermezzo

ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
		}
		rowReader.finishUp( context, afterLoadActionList );
/s
		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/ Employee->ehcache fails!

		// now we can finalize loading collections
		finishLoadingCollections( context );
/ coll->ehcache




/ Einde Intermezzo

/ Intermezzo

/ Overzicht stack op zijn kop, tot nu toe	,

Thread [main] (Suspended)	
	AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 221	
		// now we can finalize loading collections
		finishLoadingCollections( context );
//////////////////////////////////
/ Hierin write naar ehcache 

	ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	

	CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 138	

		rowReader.finishUp( context, afterLoadActionList );

	CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer) line: 102	

				results = loadQueryDetails.getResultSetProcessor().extractResults(
						wrapper.getResultSet(),
						session,
...
	CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 100	

			executeLoad(
					session,
					qp,
					staticLoadQuery,
					true,
					null

			);

	OneToManyPersister(AbstractCollectionPersister).initialize(Serializable, SessionImplementor) line: 693	
	DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 92	

				ce.getLoadedPersister().initialize( ce.getLoadedKey(), source );

	SessionImpl.initializeCollection(PersistentCollection, boolean) line: 1897	

		for ( InitializeCollectionEventListener listener : listeners( EventType.INIT_COLLECTION ) ) {
			listener.onInitializeCollection( event );

	AbstractPersistentCollection$4.doWork() line: 558	

		withTemporarySessionIfNeeded(
				new LazyInitializationWork<Object>() {
					@Override
					public Object doWork() {
->						session.initializeCollection( AbstractPersistentCollection.this, writing );
						return null;
					}
				}
		);

	PersistentSet(AbstractPersistentCollection).withTemporarySessionIfNeeded(LazyInitializationWork<T>) line: 260	

			return lazyInitializationWork.doWork();

	PersistentSet(AbstractPersistentCollection).initialize(boolean) line: 554	
	PersistentSet(AbstractPersistentCollection).read() line: 142	

		initialize( false );

	PersistentSet.iterator() line: 180	

		read();

	Main.testBasicUsage() line: 175	
	Main.<init>() line: 63	
	Main.main(String[]) line: 57	

/ Einde Intermezzo 

/ verder met debug	, nu gaan we naar ehcache write	,

AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 218	
		// now we can finalize loading collections
		finishLoadingCollections( context );
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishLoadingCollections(ResultSetProcessingContextImpl) line: 254	
		for ( CollectionReferenceInitializer collectionReferenceInitializer : collectionReferenceInitializers ) {
			collectionReferenceInitializer.endLoading( context );
/s
CollectionReferenceInitializerImpl.endLoading(ResultSetProcessingContextImpl) line: 168	
		context.getSession().getPersistenceContext()
				.getLoadContexts()
				.getCollectionLoadContext( context.getResultSet() )
				.endLoadingCollections( collectionReference.getCollectionPersister() );
/s
LoadContexts.getCollectionLoadContext(ResultSet) line: 168	
			context = collectionLoadContexts.get(resultSet);
/t
/s
CollectionReturnImpl(AbstractCollectionReference).getCollectionPersister() line: 164	
		return this.collectionQuerySpace.getCollectionPersister();
/t
/s
CollectionLoadContext.endLoadingCollections(CollectionPersister) line: 168	

		final Iterator itr = localLoadingCollectionKeys.iterator();
		while ( itr.hasNext() ) {
			final CollectionKey collectionKey = (CollectionKey) itr.next();
			final LoadingCollectionEntry lce = loadContexts.locateLoadingCollectionEntry( collectionKey );
/s
LoadContexts.locateLoadingCollectionEntry(CollectionKey) line: 263	
		final LoadingCollectionEntry rtn = xrefLoadingCollectionEntries.get( key );
key	CollectionKey  (id=3462)	
	entityMode	EntityMode  (id=3465)	
	factory	SessionFactoryImpl  (id=3466)	
	hashCode	1219356531	
	key	Long  (id=3427)	
12
	keyType	LongType  (id=3366)	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3469)	

		return rtn;
/t
CollectionLoadContext.endLoadingCollections(CollectionPersister) line: 168	
			final LoadingCollectionEntry lce = loadContexts.locateLoadingCollectionEntry( collectionKey );
/ D
			else if ( lce.getResultSet() == resultSet && lce.getPersister() == persister ) {
/ JA
/ TODO

/ lce in matches	,

		endLoadingCollections( persister, matches );
/s
CollectionLoadContext.endLoadingCollections(CollectionPersister, List<LoadingCollectionEntry>) line: 224	

		final int count = matchedCollectionEntries.size();
1 
/ 1 coll	,
		for ( LoadingCollectionEntry matchedCollectionEntry : matchedCollectionEntries ) {
			endLoadingCollection( matchedCollectionEntry, persister );
/s
////////////////////////////////////////////////////
CollectionLoadContext.endLoadingCollection(LoadingCollectionEntry, CollectionPersister) line: 247	
		// warning: can cause a recursive calls! (proxy initialization)
		final boolean hasNoQueuedAdds = lce.getCollection().endRead();
/s
PersistentSet.endRead() line: 344	

		set.addAll( tempList );
/ IS AL een HashSet, maar size=0	,
/ NU: size=2, 
		tempList = null;
		setInitialized();
/s
		this.initializing = false;
		this.initialized = true;
/t
		return true;

/t
CollectionLoadContext.endLoadingCollection(LoadingCollectionEntry, CollectionPersister) line: 247	
		final boolean hasNoQueuedAdds = lce.getCollection().endRead();
/ D
true
		CollectionEntry ce = getLoadContext().getPersistenceContext().getCollectionEntry( lce.getCollection() );
/ coll entry uit de pc	,

		else {
			ce.postInitialize( lce.getCollection() );
/s
CollectionEntry.postInitialize(PersistentCollection) line: 214	

		this.snapshot = getLoadedPersister().isMutable() ?
				collection.getSnapshot( getLoadedPersister() ) :
/= clone van PersistentSet.set	,
/ getLoadedPersister()=coll persister	,
/s
PersistentSet.getSnapshot(CollectionPersister) line: 95	

		final HashMap clonedSet = new HashMap( set.size() );
		for ( Object aSet : set ) {
/ Zojuist is set set met hydrated values (uit templist)	,
			final Object copied = persister.getElementType().deepCopy( aSet, persister.getFactory() );
			clonedSet.put( copied, copied );
		}
		return clonedSet;
/t
/ dit is nu de coll entry's snapshot	,

		collection.setSnapshot(loadedKey, role, snapshot);

		// add to cache if:
		boolean addToCache =
				// there were no queued additions
				hasNoQueuedAdds
true 
/ hierboven set	,
				// and the role has a cache
				&& persister.hasCache()

				// and this is not a forced initialization during flush
				&& session.getCacheMode().isPutEnabled() && !ce.isDoremove();
/ cacheMode=NORMAL, getEnabled==putEnabled==true	,
		if ( addToCache ) {
true
			addCollectionToCache( lce, persister );
/s
CollectionLoadContext.addCollectionToCache(LoadingCollectionEntry, CollectionPersister) line: 299	

		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
/ de coll is de key ipv de entity	,
/s
CollectionCacheEntry.<init>(PersistentCollection, CollectionPersister) line: 47	
		this.state = collection.disassemble( persister );
/s
PersistentSet.disassemble(CollectionPersister) line: 359	
		final Serializable[] result = new Serializable[ set.size() ];
		final Iterator itr = set.iterator();
		int i=0;
		while ( itr.hasNext() ) {
			result[i++] = persister.getElementType().disassemble( itr.next(), getSession(), null );

this	OneToManyPersister  (id=3336)	
	collectionType	SetType  (id=3441)	
		foreignKeyPropertyName	null	
		isEmbeddedInXML	true	
		role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3387)	
		typeScope	TypeFactory$TypeScopeImpl  (id=3467)	
	elementType	ManyToOneType  (id=3351)	
		associatedEntityName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3431)	
		associatedEntityPersister	SingleTableEntityPersister  (id=3348)	
SingleTableEntityPersister(my.test.own.hibernate_xml_1_N_ehcache.Employee)
		associatedIdentifierType	LongType  (id=3432)	
		eager	true	
		ignoreNotFound	false	
		isEmbeddedInXML	true	
		isLogicalOneToOne	false	
		referenceToPrimaryKey	true	
		returnedClass	null	
		scope	TypeFactory$TypeScopeImpl  (id=3467)	
		uniqueKeyPropertyName	null	
		unwrapProxy	false	

/s
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 239	

/ per Employee	, dus deze meth wordt multiple called	,

		else {
			// cache the actual id of the object, not the value of the
			// property-ref, which might not be initialized
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
					getAssociatedEntityName(),
my.test.own.hibernate_xml_1_N_ehcache.Employee
					value,
/ Employee, met hydrated values	,
					session
			);
/s
ForeignKeys.getEntityIdentifierIfNotUnsaved(String, Object, SessionImplementor) line: 284	

		else {
			Serializable id = session.getContextEntityIdentifier( object );
Long 2

/t
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 239	
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
...
/D
Long 2
			return getIdentifierType( session ).disassemble( id, session, owner );
/s
ManyToOneType(EntityType).getIdentifierType(SessionImplementor) line: 651	
		final Type type = associatedIdentifierType;
LongType inst	,
/ type van pk van Employee WH	,
/t
/s
LongType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	
		return getMutabilityPlan().disassemble( (T) value );
Long 2

/t
PersistentSet.disassemble(CollectionPersister) line: 362	
		while ( itr.hasNext() ) {
			result[i++] = persister.getElementType().disassemble( itr.next(), getSession(), null );
/ D
/ ook de volgende	,
result	Serializable[2]  (id=3428)	
	[0]	Long  (id=3551)	
		value	2	
	[1]	Long  (id=3559)	
		value	1	

/t
CollectionLoadContext.addCollectionToCache(LoadingCollectionEntry, CollectionPersister) line: 352	
		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
/ D
entry	CollectionCacheEntry  (id=3427)	
	state	Serializable[2]  (id=3428)	
		[0]	Long  (id=3551)	
			value	2	
		[1]	Long  (id=3559)	
			value	1	

		final CacheKey cacheKey = session.generateCacheKey( lce.getKey(), persister.getKeyType(), persister.getRole() );
lce.getKey()=Long 12
persister.getKeyType()=LongType inst	,
perister=OneToManyPersister	,
persister.getRole() =my.test.own.hibernate_xml_1_N_ehcache.Address.employees
///////////////////////////////////////
/ Dit wordt de key waaronder de coll cache entry de ehcache ingaat	, dus met id=12, de id van de ownner, Address	, TODO

		if ( persister.getElementType().isAssociationType() ) {
/ persister=OneToManyPersister	,
/ persister.getElementType()=org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_1_N_ehcache.Employee)
/s
ManyToOneType(EntityType).isAssociationType() line: 173	
		return true;

			for ( Serializable id : entry.getState() ) {
Long 2
Long 1
				EntityPersister entityPersister = ( (QueryableCollection) persister ).getElementPersister();
persister=OneToManyPersister
entityPersister=SingleTableEntityPersister(my.test.own.hibernate_xml_1_N_ehcache.Employee)
				if ( session.getPersistenceContext().wasInsertedDuringTransaction( entityPersister, id ) ) {
/ NEE

		// CollectionRegionAccessStrategy has no update, so avoid putting uncommitted data via putFromLoad
		if (isPutFromLoad) {
/ JA
			try {
				session.getEventListenerManager().cachePutStart();
				final boolean put = persister.getCacheAccessStrategy().putFromLoad(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						session.getTimestamp(),
						version,
						factory.getSettings().isMinimalPutsEnabled() && session.getCacheMode()!= CacheMode.REFRESH
				);

cacheKey	CacheKey  (id=3422)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3385)	
	hashCode	372	
	key	Long  (id=3383)	
12
	tenantId	null	
	type	LongType  (id=3351)	
entry	CollectionCacheEntry  (id=3427)	
	state	Serializable[2]  (id=3428)	
		[0]	Long  (id=3551)	
			value	2	
		[1]	Long  (id=3559)	
			value	1	
persister.getCacheEntryStructure().structure( entry )==entry	,
/s
NonstopAwareCollectionRegionAccessStrategy.putFromLoad(Object, Object, long, Object, boolean) line: 119	
			return actualStrategy.putFromLoad( key, value, txTimestamp, version, minimalPutOverride );
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 109	
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=3748)	

			final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
true
/ want,	
/s
AbstractReadWriteEhcacheAccessStrategy$Lock.isWriteable(long, Object, Comparator) line: 327	
			return version == null
					? txTimestamp > unlockTimestamp
true
/ Eerder was .unlockItem gedaan	, 
// TODO (Wanneer precies?)
/t
			if ( writeable ) {
/ JA
				region().put( key, new Item( value, version, region().nextTimestamp() ) );
/ hierin	,
key	CacheKey  (id=3633)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3387)	
	key Long 12
value	CollectionCacheEntry  (id=3427)	
	state	Serializable[2]  (id=3428)	
		[0]	Long  (id=3551)	
		[1]	Long  (id=3559)	

/t
CollectionLoadContext.endLoadingCollections(CollectionPersister) line: 219	
		if ( this.localLoadingCollectionKeys.isEmpty() ) {
			// todo : hack!!!
			// NOTE : here we cleanup the load context when we have no more local
			// LCE entries.  This "works" for the time being because really
			// only the collection load contexts are implemented.  Long term,
			// this cleanup should become part of the "close result set"
			// processing from the (sandbox/jdbc) jdbc-container code.
			this.loadContexts.cleanup( resultSet );
/s
LoadContexts.cleanup(ResultSet) line: 97	
		if ( collectionLoadContexts != null ) {
{org.postgresql.jdbc4.Jdbc4ResultSet@18619470=org.hibernate.engine.loading.internal.CollectionLoadContext@10d5008d<rs=org.postgresql.jdbc4.Jdbc4ResultSet@18619470>}
			final CollectionLoadContext collectionLoadContext = collectionLoadContexts.remove( resultSet );
/ TODO

/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 141	
		rowReader.finishUp( context, afterLoadActionList );
/ D
		session.getPersistenceContext().initializeNonLazyCollections();
/s
StatefulPersistenceContext.initializeNonLazyCollections() line: 878	
		if ( loadCounter == 0 ) {
/ NEE

/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 141	
		return loadResults;
[null,null]

/t
CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 156	

				results = loadQueryDetails.getResultSetProcessor().extractResults(
						wrapper.getResultSet(),
						session,
						queryParameters,
						new NamedParameterContext() {
							@Override
							public int[] getNamedParameterLocations(String name) {
								return AbstractLoadPlanBasedLoader.this.getNamedParameterLocs( name );
							}
						},
						returnProxies,
						queryParameters.isReadOnly(),
						forcedResultTransformer,
						afterLoadActions
				);
/ D
[null,null]
/ TODO

/t
CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 116	
			executeLoad(
					session,
					qp,
					staticLoadQuery,
					true,
					null

			);
/ D

/t
SessionImpl.initializeCollection(PersistentCollection, boolean) line: 1899	
		for ( InitializeCollectionEventListener listener : listeners( EventType.INIT_COLLECTION ) ) {
			listener.onInitializeCollection( event );
		}
/ D

/t
PersistentSet.iterator() line: 181	
		read();
/ D
		return new IteratorProxy( set.iterator() );

/t
Main.testBasicUsage() line: 176	
	        Iterator< Employee>iterator=employees.iterator();
/ D
	        while(iterator.hasNext()){
	        	String name=iterator.next().getName();
/s
AbstractPersistentCollection$IteratorProxy.hasNext() line: 784	
			return itr.hasNext();



/ Einde COLLECTION TO EHCACHE 


/ COLLECTION TO EHCACHE 

$ vi Main.java

		session = sessionFactory.openSession();
		tx=session.beginTransaction();

	        address=(Address)session.get(Address.class, 12l);
	        Set<Employee>employees=address.getEmployees();
/ employees is lege PersistentSet	,
	        Iterator< Employee>iterator=employees.iterator();
/=
		read();
		return new IteratorProxy( set.iterator() );
/ hij doet eerst read(): queries en fills PersistentSet employees , 
/ en is in ehcache write, niet voor deze loop, maar voor volgende WH TOOD
	        while(iterator.hasNext()){
	        	String name=iterator.next().getName();


/ Einde COLLECTION TO EHCACHE 

/ IN JAVA, SC, 2C, DB

/ Hoe zien Address, Employee er uit in Java, sc, 2c, db	?

/ Address, laatste property	, 
/ in Java: met HashSet	,
/ In sc: met PersistentSet om HashSet heen	,
/ In 2c: Long 12
/ In db: NIET	,

/ Employee	,  laatste property	,
/ in Java: NIET	,
/ In sc: NIET	,
/ In 2c: Backref
/ In db: fk	, 

/ coll, Address (met coll ook ) in sc	,
		persistenceContext	StatefulPersistenceContext  (id=3043)	
			collectionEntries	IdentityMap<K,V>  (id=3110)	
				map	LinkedHashMap<K,V>  (id=3117)	
					table	HashMap$Entry<K,V>[8]  (id=3119)	
						[1]	LinkedHashMap$Entry<K,V>  (id=3120)	
							key	IdentityMap$IdentityKey<K>  (id=3121)	
								key	PersistentSet  (id=3094)	
									set	HashSet<E>  (id=3039)	
										map	HashMap<K,V>  (id=3051)	
											table	HashMap$Entry<K,V>[16]  (id=3061)	
												[12]	HashMap$Entry<K,V>  (id=3065)	
													key	Employee  (id=3156)	
														id	1	
														name	"Foo1" (id=3157)	
														salary	1.0	
													value	Object  (id=3155)	
												[14]	HashMap$Entry<K,V>  (id=3066)	
													key	Employee  (id=3069)	
														id	2	
														name	"Foo2" (id=3158)	
														salary	2.0	
													value	Object  (id=3155)	
			entityEntryContext	EntityEntryContext  (id=3114)	
				count	1	
				dirty	true	
				head	EntityEntryContext$ManagedEntityImpl  (id=3147)	
					entityEntry	EntityEntry  (id=3153)	
					entityInstance	Address  (id=3036)	
						addressLine1	"foostreet" (id=3037)	
						city	"FooCity12" (id=3038)	
						employees	PersistentSet  (id=3094)	
						id	12	
						zipcode	"12 foo" (id=3040)	
				nonEnhancedEntityXref	IdentityHashMap<K,V>  (id=3151)	
				reentrantSafeEntries	Map$Entry<K,V>[0]  (id=3152)	

entity	Employee  (id=3156)	 in sc	,
	id	1	
	name	"Foo1" (id=3157)	
	salary	1.0	

/ H prop Employee inst	,	 in 2c	,
values	Object[3]  (id=3394)	
	[0]	"Foo1" (id=3157)	
	[1]	Double  (id=3415)	
	[2]	Long  (id=3046)	 1.0

/ In getters/setters Backref, 

/ coll	in 2c	,
ce	CollectionCacheEntry  (id=3394)	
	state	Serializable[2]  (id=3395)	
		[0]	Long  (id=3396)	
			value	2	
		[1]	Long  (id=3397)	
			value	1	
/ Employee in 2c	,
ce	StandardCacheEntryImpl  (id=3458)	
	disassembledState	Serializable[3]  (id=3461)	
		[0]	"Foo2A" (id=3463)	
		[1]	Double  (id=3464)	
		[2]	BackrefPropertyAccessor$1  (id=3466)	==  BackrefPropertyAccessor.UNKNOWN

/ Address in 2c	,
this	StandardCacheEntryImpl  (id=232)	
	disassembledState	Serializable[4]  (id=254)	
		[0]	"foostreet" (id=97)	
		[1]	"12 foo" (id=106)	
		[2]	"FooCity12" (id=109)	
		[3]	Long  (id=133)	
/ SetType.disassemble skips de PersistenSet, en disassembles Long 12	, de id van de owner, de Address inst	,


/ Einde IN JAVA, SC, 2C, DB

/ COLLECTION FROM EHCACHE

/ 7	.



/ 1ste, 2de	, 
/ .get(Address.class, 12l) is hetzelfde:  calls ehcache, dus : new Address, ehcache props worden disassembled: de 4de, Long 12 heeft type SetType, en wordt resolved tot een lege PersistentSet	, 

/ 1ste keer	,
/ coll-query: Moet, want in Employee obj in pc of in disassembled state in ehcache staat de fk 12 NIET, 
/ In Address obj uit ehcache staat alleen 12 op plaats van coll	, dus daar ook niets	,


/ Bij 2de keer	,
/ Het verschil is dat de coll-query er NIET is	, 


/ 7	. 

/ we doen in een nieuwe session precies hetzelfde	,
			
		session = sessionFactory.openSession();
		tx=session.beginTransaction();
		
		address=(Address)session.get(Address.class, 12l);
	        employees=address.getEmployees();
	        iterator=employees.iterator();

/ Let op dat we doen	,
		address=(Address)session.get(Address.class, 12l);
/ anders oude address, en die heeft al filled employees	,

/ we zien dat die collection query NIET meer wordt gedaan	,
Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?

/ deze query vraagt precies de collectie	, 
/ hij moet deze query doen; De Employee's 1 en 2 zitten al in de ehcache, maar H moet weten welke Employee's in de Set zijn van address ! Vandaar deze collection query	, 

/ 7	. 

/ debug	 .get	,

/ see ook .GET	,

		address=(Address)session.get(Address.class, 12l);

/ .get kijkt eerst in de 1ste cache	, maar is leeg	,
/ .get vindt de properties in de cache in de Address-region in ehcache	onder key met Long 12	, die we opgeven in Main met .get	,	 de laatste prop die corresp met de Set prop is ook  Long 12	,  
/ de 1ste Long 12, die we opgeven in Main met .get wordt de key in de de session cache	,
/ de 2de Long 12	, de laatste prop corresp. met de Set prop,  uit ehcache , uit de Long 12-entry (de Long 12 de we opgaven in Main) in de Address-region	,

/ H maakt een new Address, en sets in pc, in entity cache met key Long 12	, die we opgaven in Main	,  
/ maar H maakt straks ook een new PersistentSet	, en sets in pc in coll cache , ook met key Long 12	,  maar deze komt uit de ehcache , is de laatste prop die corresp. met Set, gevonden met key Long 12 uit Main, gevonden in de Address-cache	, 

///////////////////////////////////////////////////////////////////////////////////////////
/ de Long 12 die we opgeven in Main wordt de entity key in de pc	,  komt in EntityKey in entityEntryContext in de pc	,
/ de Long 12 = laatste prop in Address-region gevonden met Long 12 uit .get in Main, corresp met de Set uit Address, wordt de coll key in de pc	, komt in CollectionKey in de collectionsByKey  

/ we zien in de pc de entry=new Address inst	, met de new PersistenSet	, 
/ deze PersistentSet zie we ook in de loadedState in de entity entry   
/ deze PersistentSet zie we ook in de collection entry in coll cachen in pc	, 

/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	

		Object entity = loadFromSessionCache( event, keyToLoad, options );
keyToLoad	EntityKey  (id=3371)	
	hashCode	641	
	identifier	Long  (id=3372)	
	persister	SingleTableEntityPersister  (id=3363)	
entity 		null

/ keyToLoad=Long 12	, deze hebben we gegeven in Main	, session.get(Address.class, 12l) 

		entity = loadFromSecondLevelCache( event, persister, options );
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 598	

		final CacheKey ck = source.generateCacheKey(
				event.getEntityId(),
				persister.getIdentifierType(),
				persister.getRootEntityName()
		);
ck	CacheKey  (id=3376)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3374)	
	hashCode	372	
	key	Long  (id=3372)				/ opgegeven key Long 12 in Main	, 
	tenantId	null	
	type	LongType  (id=3377)	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );

/ Intermezzo

persister	SingleTableEntityPersister  (id=3363)	
	cacheAccessStrategy	NonstopAwareEntityRegionAccessStrategy  (id=3368)	
			region	EhcacheEntityRegion  (id=3412)	
				cache	Cache
					configuration	CacheConfiguration  (id=3553)	
						name	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3592)	
	entityMetamodel	EntityMetamodel  (id=3428)	
		name	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3374)	

/ we zien dat we de Address-persister hebben	, en dat de Address-region via cacheAccessStrategy er in zit	, dus we komen inderdaad op de Address region uit	,

/ Einde Intermezzo

/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 79	

			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3626)	
	timestamp	5772463933775872	
	value	StandardCacheEntryImpl  (id=3627)	
		disassembledState	Serializable[4]  (id=3636)	
			[0]	"foostreet" (id=3639)	
			[1]	"12 foo" (id=3641)	
			[2]	"FooCityA" (id=3643)	
			[3]	Long  (id=3645)	
		lazyPropertiesAreUnfetched	false	
		subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3374)	
		version	null	
	version	null	


/ Intermezzo

/////////////////////////////////////////

/ Er is later ook de Address.employees-region, (Address.employees-persister TODO), daar store we de coll onder de 12-cache key	, TODO EHCACHE LATER
/ Eig zijn de keys anders: de entityOrRoleName is verschillend	,

key	CacheKey  (id=3380)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3377)	
	hashCode	372	
	key	Long  (id=3364)	
	tenantId	null	
	type	LongType  (id=3379)	

/ Einde Intermezzo

/t
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 81	

	return item.getValue();

/t
CacheHelper.fromSharedCache(SessionImplementor, Object, RegionAccessStrategy) line: 58	

			cachedValue = (Serializable) cacheAccessStrategy.get( cacheKey, session.getTimestamp() );
/ D
cachedValue	StandardCacheEntryImpl  (id=3526)	
	disassembledState	Serializable[4]  (id=3527)	
		[0]	"foostreet" (id=3528)	
		[1]	"12 foo" (id=3529)	
		[2]	"FooCityA" (id=3530)	
		[3]	Long  (id=3531)	 	12
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3374)	


/t
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 618	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=76)	
	disassembledState	Serializable[4]  (id=79)	
		[0]	"foostreet" (id=85)	
		[1]	"12 foo" (id=86)	
		[2]	"FooCityA" (id=87)	
		[3]	Long  (id=88)	 	12

/ D
		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
/ entry==ce
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/////////////////////////////
/ event.getEntityId()=door ons opgegeven id=Long 12, in Main	,

/ Intermezzo

/ de id van Address komt dus uit de event	, Long 12	,
/ de id is geen property in ehcache	,

/ Einde Intermezzo

/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 678	
/=
	private Object convertCacheEntryToEntity(
			CacheEntry entry,
			Serializable entityId,
			EntityPersister persister,
			LoadEvent event) {

/ entityId=door ons opgegeven id=Long 12	,

		else {
			subclassPersister = factory.getEntityPersister( entry.getSubclass() );
/ entry.subclass="my.test.own.hibernate_xml_1_N_ehcache.Address"	, zo de Address-persister	,

/ creates eerst een Address inst	,

			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
////////////////////////////////////////
/ met new	, sets id=entityId er in	, = door ons opgegeven id=Long 12	, wordt EntityKey  in EntitiesByKey de de pc	,
/ id is geen property	in ehcache	, id staat in de key TODO EHCACHE LATER

/ H maakt een new Address, en sets in pc, in entity cache met key Long 12	, die we opgaven in Main	,  
/ maar H maakt straks ook een new PersistentSet	, en sets in pc in coll cache , ook met key Long 12	,  maar deze komt uit de ehcache , is de laatste prop die corresp. met Set, gevonden met key Long 12 uit Main, gevonden in de Address-cache	, 

		// make it circular-reference safe
		final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );
		TwoPhaseLoad.addUninitializedCachedEntity(
				entityKey,
				entity,
				subclassPersister,
				LockMode.NONE,
				entry.areLazyPropertiesUnfetched(),
				entry.getVersion(),
				session
		);
/ De entityId=door ons opgegeven id=Long 12 komt in de entity key in pc	,


		else {
			final Type[] types = subclassPersister.getPropertyTypes();
[StringType, StringType, StringType, SetType]

			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
/ De entityId=door ons opgegeven id=Long 12 komt in de entity key in pc	,

/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 113	

 		Object[] assembled = new Object[row.length];
4
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );

/ Does not use entityId	,

/ de laatste disassembled, row[3] is Long 12	, usage exactly TODO
/ s
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 303	
		else {
			final Serializable key = (Serializable) getPersister(session)
/=
		return session.getFactory().getCollectionPersister( role );

					.getKeyType()
					.assemble( cached, session, owner);
/ cached=Long 12, =disassembled[3]	,
/ owner is zojuist created new Address	, met opgegeven Long 12 er in	,  TODO
/ key=onveranderd cached=Long 12, =disassembled[3]	, komt in CollectionKey in CollectionsByKey in de pc	,

			return resolveKey( key, session, owner );
/ key=onveranderd cached=Long 12, =disassembled[3]	,

/ er wordt een new PersistenSet create, en in pc set , maar geen resolve
/ TODO
/ de key komt in de CollectionKey in de pc,	 maar wat is nu echt de role van key Long 12	?
/ TODO

/s
SetType(CollectionType).resolveKey(Serializable, SessionImplementor, Object) line: 466	
		return key == null ? null : // TODO: can this case really occur??
			getCollection( key, session, owner );
/s
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 749	
this	SetType  (id=3681)	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3683)	

		CollectionPersister persister = getPersister( session );
/s
SetType(CollectionType).getPersister(SessionImplementor) line: 326	
		return session.getFactory().getCollectionPersister( role );

/t
persister	OneToManyPersister  (id=3689)	
	cacheAccessStrategy	NonstopAwareCollectionRegionAccessStrategy  (id=3690)	
		actualStrategy	ReadWriteEhcacheCollectionRegionAccessStrategy  (id=3714)	
				cache	Cache  (id=3721)	
					configuration	CacheConfiguration  (id=3741)	
						name	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3776)	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3683)	

/ Intermezzo

public abstract class AbstractEntityPersister
                implements OuterJoinLoadable, Queryable, ClassMetadata, UniqueKeyLoadable,
                SQLLoadable, LazyPropertyInitializer, PostInsertIdentityPersister, Lockable {
        public String toString() {
                return StringHelper.unqualify( getClass().getName() ) +
                                '(' + entityMetamodel.getName() + ')';
        }


public abstract class AbstractCollectionPersister
                implements CollectionMetadata, SQLLoadableCollection {
        public String toString() {
                return StringHelper.unqualify( getClass().getName() ) + '(' + role + ')';
        }


/ Einde Intermezzo


		// check if collection is currently being loaded
		PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );
/ TODO
null
		if ( collection == null ) {
			// check if it is already completely loaded, but unowned
			collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );
null
			if ( collection == null ) {
				// create a new collection wrapper, to be initialized later
				collection = instantiate( session, persister, key );
/s
		return new PersistentSet(session);

/t
/ collection.set=collection.storedSnapshot=null

				collection.setOwner(owner);
				persistenceContext.addUninitializedCollection( persister, collection, key );

/////////////////////////////////////
/ persister=Address.employees-persister	,
/ key=Long 12, is de laatste disassembled uit de Address properties uit ehcache	, de type is SetType	,

//////////////////////////////////////////
/ TODO key=disassembled[3]=Long 12 in collectionkey in de pc , opgegeven key Long 12 in entitykey in de pc		,

owner	Address  (id=3563)	
	addressLine1	null	
	city	null	
	employees	HashSet<E>  (id=3629)	
		map	HashMap<K,V>  (id=3632)	
			entrySet	HashMap$EntrySet  (id=3640)	
			hashSeed	0	
			keySet	HashMap$KeySet  (id=3641)	
			loadFactor	0.75	
			modCount	0	
			size	0	
			table	HashMap$Entry<K,V>[0]  (id=3633)	
			threshold	16	
			values	null	
	id	12	
	zipcode	null	

collection	PersistentSet  (id=3625)	
	allowLoadOutsideTransaction	false	
	cachedSize	-1	
	directlyAccessible	false	
	dirty	false	
	initialized	false	
	initializing	false	
	key	null	
	operationQueue	null	
	owner	Address  (id=3563)	
	role	null	
	session	SessionImpl  (id=3362)	
	sessionFactoryUuid	null	
	set	null	
	storedSnapshot	null	
	tempList	null	

/s
StatefulPersistenceContext.addUninitializedCollection(CollectionPersister, PersistentCollection, Serializable) line: 788	

		final CollectionEntry ce = new CollectionEntry( collection, persister, id, flushing );
/ id=Long 12, is de laatste disassembled uit de Address properties uit ehcache	, de type is SetType	,
ce	CollectionEntry  (id=3873)	
	currentKey	null	
	currentPersister	null	
	dorecreate	false	
	doremove	false	
	doupdate	false	
	fromMerge	false	
	ignore	false	
	loadedKey	Long  (id=3645)	 12
	loadedPersister	OneToManyPersister  (id=3689)	
	processed	false	
	reached	false	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3683)	
	snapshot	null	

/ we zien de loadedKey, Long 12, uit de disassembled state uit de ehcache	,

		addCollection( collection, ce, id );
/s
	private void addCollection(PersistentCollection coll, CollectionEntry entry, Serializable key) {
		collectionEntries.put( coll, entry );
		final CollectionKey collectionKey = new CollectionKey( entry.getLoadedPersister(), key );
collectionKey	CollectionKey  (id=3919)	
	entityMode	EntityMode  (id=3518)	
	factory	SessionFactoryImpl  (id=3375)	
	hashCode	1219356531	
	key	Long  (id=3645)	 	12
	keyType	LongType  (id=3377)	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3683)	

		final PersistentCollection old = collectionsByKey.put( collectionKey, coll );

/t
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 790	
				persistenceContext.addUninitializedCollection( persister, collection, key );
/ D
		collection.setOwner(owner);
		return collection.getValue();
/=collection	,

/t
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 116	
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ NEE bij coll	,
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/ D
		return assembled;
assembled	Object[4]  (id=3680)	
	[0]	"foostreet" (id=3639)	
	[1]	"12 foo" (id=3641)	
	[2]	"FooCityA" (id=3643)	
	[3]	PersistentSet  (id=3860)	
/ set==storedSnapshot==null

/ Long 12 is vervangen door de PeristentSet	,


/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 172	
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/ D

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 733	

			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ D

		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);

		return entity;

/t
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 453	

		entity = loadFromSecondLevelCache( event, persister, options );
/ D

/ 7	.

/ debug	,
	        iterator=employees.iterator();
/ 2de keer	,

/s
AbstractPersistentCollection$4.doWork() line: 558	
		withTemporarySessionIfNeeded(
				new LazyInitializationWork<Object>() {
					@Override
					public Object doWork() {
->						session.initializeCollection( AbstractPersistentCollection.this, writing );
/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	

			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
/s
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 136	
/ persister=OneToManyPersister	,
		final CacheKey ck = source.generateCacheKey( id, persister.getKeyType(), persister.getRole() );
/ id=Long 12	,
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 81	
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3392)	
	value	CollectionCacheEntry  (id=3394)	
		state	Serializable[2]  (id=3395)	
			[0]	Long  (id=3396)	
				value	2	
			[1]	Long  (id=3397)	
				value	1	

/t
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 139	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
/ D
ce	CollectionCacheEntry  (id=3394)	
	state	Serializable[2]  (id=3395)	
		[0]	Long  (id=3396)	
			value	2	
		[1]	Long  (id=3397)	
			value	1	

/ cacheEntry=ce
		final PersistenceContext persistenceContext = source.getPersistenceContext();
		cacheEntry.assemble( collection, persister, persistenceContext.getCollectionOwner( id, persister ) );
/ id=Long 12	,
/ collection is de PersistentSet created in .get(Address.class,12l)	, set=storedSnapshot=null	,
/s
StatefulPersistenceContext.getCollectionOwner(Serializable, CollectionPersister) line: 694	
		final EntityPersister ownerPersister = collectionPersister.getOwnerEntityPersister();
/s
		return ownerPersister;
SingleTableEntityPersister(my.test.own.hibernate_xml_1_N_ehcache.Address)

		if ( ownerPersister.getIdentifierType().getReturnedClass().isInstance( key ) ) {
			return getEntity( session.generateEntityKey( key, collectionPersister.getOwnerEntityPersister() ) );
/ uit sc	,
Address	,
/ De coll kwam uit de 2c	, de owner uit de sc	, 
/ Klopt, zojuist .get(Address.class, 12l)
/t
/s
CollectionCacheEntry.assemble(PersistentCollection, CollectionPersister, Object) line: 75	
		collection.initializeFromCache( persister, state, owner );
/s
PersistentSet.initializeFromCache(CollectionPersister, Serializable, Object) line: 141	

		final Serializable[] array = (Serializable[]) disassembled;
[2,1]
		final int size = array.length;
		beforeInitialize( persister, size );
/s
PersistentSet.beforeInitialize(CollectionPersister, int) line: 134	
		this.set = (Set) persister.getCollectionType().instantiate( anticipatedSize );
/ persister.getCollectionType()=org.hibernate.type.SetType(my.test.own.hibernate_xml_1_N_ehcache.Address.employees)
/s
SetType.instantiate(int) line: 62	

	public Object instantiate(int anticipatedSize) {
		return anticipatedSize <= 0
		       ? new HashSet()
->		       : new HashSet( anticipatedSize + (int)( anticipatedSize * .75f ), .75f );
	}

/t
PersistentSet.initializeFromCache(CollectionPersister, Serializable, Object) line: 144	
		beforeInitialize( persister, size );
/ D
/ this (PersistentSet) heeft nu een set HashSet, 	en storedSnapshot=null

		for ( Serializable arrayElement : array ) {
/ eerst 2, dan 1	,
			final Object assembledArrayElement = persister.getElementType().assemble( arrayElement, getSession(), owner );
 persister	OneToManyPersister(my.test.own.hibernate_xml_1_N_ehcache.Address.employees)
	elementType	 org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_1_N_ehcache.Employee)
this	PersistentSet  (id=3350)	


/ Intermezzo

public abstract class AbstractEntityPersister
                implements OuterJoinLoadable, Queryable, ClassMetadata, UniqueKeyLoadable,
                SQLLoadable, LazyPropertyInitializer, PostInsertIdentityPersister, Lockable {
        public String toString() {
                return StringHelper.unqualify( getClass().getName() ) +
                                '(' + entityMetamodel.getName() + ')';
        }


public abstract class AbstractCollectionPersister
                implements CollectionMetadata, SQLLoadableCollection {
        public String toString() {
                return StringHelper.unqualify( getClass().getName() ) + '(' + role + ')';
        }


/ Einde Intermezzo

/s
ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 272	
			return resolveIdentifier( id, session );
/ id=2/1
/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 712	
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
Employee
				id,
2/1
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/s
essionImpl.internalLoad(String, Serializable, boolean, boolean) line: 989	
		LoadEventListener.LoadType type = nullable
				? LoadEventListener.INTERNAL_LOAD_NULLABLE
				: eager
true
->						? LoadEventListener.INTERNAL_LOAD_EAGER
						: LoadEventListener.INTERNAL_LOAD_LAZY;
		LoadEvent event = new LoadEvent(id, entityName, true, this);
entityName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3427)	
id	Long  (id=3385)	
	value	2	
		fireLoad( event, type );
/s
		for ( LoadEventListener listener : listeners( EventType.LOAD ) ) {
			listener.onLoad( event, loadType );
/s
DefaultLoadEventListener.onLoad(LoadEvent, LoadEventListener$LoadType) line: 100	
			persister = source.getFactory().getEntityPersister( event.getEntityClassName() );
SingleTableEntityPersister(my.test.own.hibernate_xml_1_N_ehcache.Employee)

		final EntityKey keyToLoad = source.generateEntityKey( event.getEntityId(), persister );
					event.setResult( proxyOrLoad( event, persister, keyToLoad, loadType ) );
...
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 618	
...
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ck	CacheKey  (id=3457)	
ce	StandardCacheEntryImpl  (id=3458)	
	disassembledState	Serializable[3]  (id=3461)	
		[0]	"Foo2A" (id=3463)	
		[1]	Double  (id=3464)	
		[2]	BackrefPropertyAccessor$1  (id=3466)	
	lazyPropertiesAreUnfetched	false	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3427)	
	version	null	
		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 678	
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
entity	Employee  (id=3493)	
	id	2	
	name	null	
	salary	0.0	

			final Type[] types = subclassPersister.getPropertyTypes();
			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
[org.hibernate.type.StringType@35b4e829, org.hibernate.type.DoubleType@3830b652, org.hibernate.type.LongType@a22ee8c]

/////////////////////////////////////
/ Address heeft als laatste type een SetType, Employee  een LongType	,

/ De Backref blijft onveranderd	, 
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
			}
	return assembled;
/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
assembledProps	Object[3]  (id=3581)	
	[0]	"Foo2A" (id=3463)	
	[1]	Double  (id=3464)	
	[2]	BackrefPropertyAccessor$1  (id=3466)	

		persister.setPropertyValues( instance, assembledProps );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 713	
		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
			if ( setAll || values[j] != LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
				setters[j].set( entity, values[j], getFactory() );
[BasicSetter(my.test.own.hibernate_xml_1_N_ehcache.Employee.name), BasicSetter(my.test.own.hibernate_xml_1_N_ehcache.Employee.salary), org.hibernate.property.BackrefPropertyAccessor$BackrefSetter@3b2d38f6]
/ De laatste	,
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
			// this page intentionally left blank :)
		}
/ Doet NIETS	,

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 710	
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ D
entity	Employee  (id=3493)	
	id	2	
	name	"Foo2A" (id=3463)	
	salary	2.0	

		final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );
		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
/ Employee in de sc	,

/t
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	
		entity = loadFromSecondLevelCache( event, persister, options );
/ D
/t
PersistentSet.initializeFromCache(CollectionPersister, Serializable, Object) line: 147	
		for ( Serializable arrayElement : array ) {
			final Object assembledArrayElement = persister.getElementType().assemble( arrayElement, getSession(), owner );
/D
			if ( assembledArrayElement != null ) {
				set.add( assembledArrayElement );
/t
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 161	
		cacheEntry.assemble( collection, persister, persistenceContext.getCollectionOwner( id, persister ) );
this	DefaultInitializeCollectionEventListener  (id=3363)	
id	Long  (id=3365)	
persister	OneToManyPersister  (id=3369)	
collection	PersistentSet  (id=27)	
	set	HashSet<E>  (id=3404)	
		map	HashMap<K,V>  (id=3852)	
			entrySet	HashMap$EntrySet  (id=3877)	
			hashSeed	0	
			keySet	HashMap$KeySet  (id=3879)	
			loadFactor	0.75	
			modCount	2	
			size	2	
			table	HashMap$Entry<K,V>[4]  (id=3853)	
				[3]	HashMap$Entry<K,V>  (id=3854)	
					hash	1945640143	
					key	Employee  (id=3858)	
						id	1	
						name	"Foo1A" (id=3864)	
						salary	1.0	
					next	HashMap$Entry<K,V>  (id=3859)	
						hash	400191631	
						key	Employee  (id=3493)	
							id	2	
							name	"Foo2A" (id=3463)	
							salary	2.0	
						next	null	
						value	Object  (id=3861)	
					value	Object  (id=3861)	
			threshold	3	
			values	null	
	storedSnapshot	null	

		persistenceContext.getCollectionEntry( collection ).postInitialize( collection );
/s
CollectionEntry.postInitialize(PersistentCollection) line: 214	
		this.snapshot = getLoadedPersister().isMutable() ?
				collection.getSnapshot( getLoadedPersister() ) :
/s
PersistentSet.getSnapshot(CollectionPersister) line: 95	
		final HashMap clonedSet = new HashMap( set.size() );
		for ( Object aSet : set ) {
			final Object copied = persister.getElementType().deepCopy( aSet, persister.getFactory() );
			clonedSet.put( copied, copied );
		}
		return clonedSet;
/t
CollectionEntry.postInitialize(PersistentCollection) line: 214	
		collection.setSnapshot(loadedKey, role, snapshot);

/t
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	
			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);

/t
PersistentSet.iterator() line: 180	
		read();
/D
		return new IteratorProxy( set.iterator() );
/ TODO

/ Einde COLLECTION FROM EHCACHE

/ SESSIONIMPL.<INIT>

/ COLLECTIONS TO 1C, 2C

/ 7	.

	.save(address)

DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 273	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/ Met getters	,
		Type[] types = persister.getPropertyTypes();

		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
...
/s
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 109	
				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
PersistentSet om onze HashSet	, met 2 Employee	,
				persistenceContext.addNewCollection( persister, persistentCollection );
/ in sc	,

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 273	
			persister.setPropertyValues( entity, values );
/ PersistentSet ipv. HashSet	,
		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
			source.getActionQueue().addAction( insert );
/s
ActionQueue.addResolvedEntityInsertAction(AbstractEntityInsertAction) line: 199	
			insertions.add( insert );
		insert.makeEntityManaged();
/s
EntityInsertAction(AbstractEntityInsertAction).makeEntityManaged() line: 143	
		getSession().getPersistenceContext().addEntity(
				getInstance(),
				( getPersister().isMutable() ? Status.MANAGED : Status.READ_ONLY ),
				getState(),
				getEntityKey(),
				version,
				LockMode.WRITE,
				isExecuted,
				getPersister(),
				isVersionIncrementDisabled,
				false
		);

/ 7	.

	.save(employee)
/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
entity	Employee  (id=3156)	
	id	1	
	name	"Foo1" (id=3157)	
	salary	1.0	
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 624	
		for ( int j = 0; j < span; j++ ) {
/ span==3
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
[BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Employee.name), BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Employee.salary), org.hibernate.property.BackrefPropertyAccessor$BackrefGetter@41a6547b]

///////////////////////////////////////////////
/ We zien Backref in getters/setters	, maar de type van laatste prop is LongType	,
/ TODO

/ de laatste	,
/s
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 125	
		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
			if ( session == null ) {
/ NEE
				return UNKNOWN;
			}
			else {
				return session.getPersistenceContext().getOwnerId( entityName, propertyName, target, mergeMap );

/ Backref krijgt 12 als value, klopt	,

this	BackrefPropertyAccessor$BackrefGetter  (id=3304)	
	this$0	BackrefPropertyAccessor  (id=3312)	
		entityName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3313)	
		getter	BackrefPropertyAccessor$BackrefGetter  (id=3304)	
		propertyName	"employees" (id=3314)	
		setter	BackrefPropertyAccessor$BackrefSetter  (id=3315)	
/s
StatefulPersistenceContext.getOwnerId(String, String, Object, Map) line: 1085	
/=
	public Serializable getOwnerId(String entityName, String propertyName, Object childEntity, Map mergeMap) {

		final String collectionRole = entityName + '.' + propertyName;
collectionRole	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3323)	

		final EntityPersister persister = session.getFactory().getEntityPersister( entityName );
Address-persister
		final CollectionPersister collectionPersister = session.getFactory().getCollectionPersister( collectionRole );

	// iterate all the entities currently associated with the persistence context.
		for ( Entry<Object,EntityEntry> me : reentrantSafeEntityEntries() ) {
			final EntityEntry entityEntry = me.getValue();
Address inst's entry in sc	,
			// does this entity entry pertain to the entity persister in which we are interested (owner)?
			if ( persister.isSubclassEntityName( entityEntry.getEntityName() ) ) {
/ JA
/ Address-pst	,
				final Object entityEntryInstance = me.getKey();
Address inst	,
				//check if the managed object is the parent
				boolean found = isFoundInParent(
						propertyName,
employees
						childEntity,
Employee inst	,
						persister,
Address-pst
						collectionPersister,
Address.employees-pst
						entityEntryInstance
Address inst	,
				);
true
/ want	,
/s
StatefulPersistenceContext.isFoundInParent(String, Object, EntityPersister, CollectionPersister, Object) line: 1175	
/=
	private boolean isFoundInParent(
			String property,
			Object childEntity,
			EntityPersister persister,
			CollectionPersister collectionPersister,
			Object potentialParent) {

		final Object collection = persister.getPropertyValue( potentialParent, property );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValue(Object, String) line: 641	
		index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
3
		final Object baseValue = getPropertyValue( entity, index );
PersistentSet
/t
StatefulPersistenceContext.isFoundInParent(String, Object, EntityPersister, CollectionPersister, Object) line: 1175	
		return collection != null
				&& Hibernate.isInitialized( collection )
				&& collectionPersister.getCollectionType().contains( collection, childEntity, session );
/collectionPersister.getCollectionType()=SetType	,
/s
SetType(CollectionType).contains(Object, Object, SessionImplementor) line: 122	
		Iterator elems = getElementsIterator( collection, session );
		while ( elems.hasNext() ) {
			Object element = elems.next();
			if ( element == childObject ) return true;
/ JA
/ Employee inst	,

/t
StatefulPersistenceContext.getOwnerId(String, String, Object, Map) line: 1099	
				boolean found = isFoundInParent(
						propertyName,
						childEntity,
						persister,
						collectionPersister,
						entityEntryInstance
				);
true
				if ( found ) {
					return entityEntry.getId();
12

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 268	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/D
values	Object[3]  (id=3394)	
	[0]	"Foo1" (id=3157)	
	[1]	Double  (id=3415)	
	[2]	Long  (id=3046)	 1.0

/ We zien een extra prop, dat de fk gaat worden	,
		Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@1576f881, org.hibernate.type.DoubleType@3db6fb5d, org.hibernate.type.LongType@13066a26]

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/ values gaan -> 2c	,
/s
			EntityInsertAction insert = new EntityInsertAction(
					id, values, entity, version, persister, isVersionIncrementDisabled(), source
			);
			source.getActionQueue().addAction( insert );
/s
			addResolvedEntityInsertAction( insert );
/s
			insertions.add( insert );
		}
		insert.makeEntityManaged();


/ 7	.

	.commit
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 102	
			int entityCount = flushEntities( event, persistenceContext );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 225	
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
/ Address inst, 2 Employee inst	,
					listener.onFlushEntity( entityEvent );
/ case Address inst	,
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 172	

		final Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@353e58cd, org.hibernate.type.StringType@353e58cd, org.hibernate.type.StringType@353e58cd, org.hibernate.type.SetType(my.test.own.hibernate_xml_1_N_ehcache.Address.employees)]
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/ Met getters	,
values	Object[4]  (id=3136)	
	[0]	"foostreet" (id=3141)	
	[1]	"12 foo" (id=3144)	
	[2]	"FooCityA" (id=3147)	
	[3]	PersistentSet  (id=3150)	


			if ( persister.hasCollections() ) {
/ JA, Address-pst	,
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/s
		for ( int i=0; i<types.length; i++ ) {
			if ( includeEntityProperty(values, i) ) {
				processValue( i, values, types );
/s
FlushVisitor.processCollection(Object, CollectionType) line: 46	
			Collections.processReachableCollection( coll, type, owner, getSession() );
/s
		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );
		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
employees-pst	,
		ce.setCurrentPersister( persister );
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
12
		prepareCollectionForUpdate( collection, ce, factory );
/s
					entry.setDorecreate( true );

/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 225	
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
					listener.onFlushEntity( entityEvent );
/ case Employee inst	,
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 154	
		final Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@63ec239f, org.hibernate.type.DoubleType@9d1649f, org.hibernate.type.LongType@17965791]
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/s
			values = persister.getPropertyValues( entity );
entity	Employee  (id=3229)	
	id	1	
	name	"Foo1A" (id=3234)	
	salary	1.0	
values	Object[3]  (id=3233)	
	[0]	"Foo1A" (id=3234)	
	[1]	Double  (id=3235)	
	[2]	BackrefPropertyAccessor$1  (id=3236)	
/ want	,
/s
		return getEntityTuplizer().getPropertyValues( object );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValues(Object) line: 605	
		for ( int j = 0; j < span; j++ ) {
			NonIdentifierAttribute property = entityMetamodel.getProperties()[j];
				result[j] = getters[j].get( entity );
/s
BackrefPropertyAccessor$BackrefGetter.get(Object) line: 136	
			return UNKNOWN;
/ Klopt	, in de Employee inst is deze er NIET	,

/5
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 102	
/s
			int collectionCount = flushCollections( session, persistenceContext );
/s
			if ( ce.isDorecreate() ) {
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
								ce.getCurrentKey(),
								session
							)
					);
/t
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/D
				performExecutions( source );
/s
			session.getActionQueue().prepareActions();
/s
		prepareActions( collectionCreations );
/s
		if ( persister.hasCache() ) {
			final CacheKey ck = session.generateCacheKey(
					key,
					persister.getKeyType(),
					persister.getRole()
			);
			final SoftLock lock = persister.getCacheAccessStrategy().lockItem( ck, null );

/t
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
			session.getActionQueue().prepareActions();
/D
			session.getActionQueue().executeActions();
/s
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );
/s
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
s	SingleTableEntityPersister  (id=67)	
id	Long  (id=133)	
fields	Object[4]  (id=107)	
	[0]	"foostreet" (id=97)	
	[1]	"12 foo" (id=106)	
	[2]	"FooCity12" (id=109)	
	[3]	PersistentSet  (id=101)	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/ 1ste 	,
/s
StringType(AbstractStandardBasicType<T>).nullSafeSet(PreparedStatement, Object, int, WrapperOptions) line: 286	
		remapSqlTypeDescriptor( options ).getBinder( javaTypeDescriptor ).bind( st, ( T ) value, index, options );
/s
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setString( index, javaTypeDescriptor.unwrap( value, String.class, options ) );
/s
StringTypeDescriptor.unwrap(String, Class<X>, WrapperOptions) line: 60	
		if ( String.class.isAssignableFrom( type ) ) {
			return (X) value;
		}

/ laatste	,
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/s
SetType(CollectionType).nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 183	
		//NOOP
	}

/t
EntityInsertAction.execute() line: 127	
			persister.insert( id, getState(), instance, session );
/D
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
	state	Object[4]  (id=107)	
		[0]	"foostreet" (id=97)	
		[1]	"12 foo" (id=106)	
		[2]	"FooCity12" (id=109)	
		[3]	PersistentSet  (id=101)	

/ Intermezzo

/ Voor naar db heet dehydrate, voor naar 2c heet disassemble	,

SetType.nullSafeSet{
}
SetType.disassemble{
/ vervang de PersistentSet door de id van de owner, Address inst, Long 12	, 
}
/ persist Address: PersistentSet wordt overgeslagen	, ->2c Address: PersistentSet wordt vervangen door Long 12	,


/ dehydrate calls nullSafeSet	, StringType.nullSafeSet calls javaTypeDescriptor.unwrap	, TODO

/ Einde Intermezzo

/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 74	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 141	
			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				disassembled[i] = (Serializable) row[i];
			}
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
			}
/ laatste	,
/s
SetType(CollectionType).disassemble(Object, SessionImplementor, Object) line: 280	
		final Serializable key = getKeyOfOwner(owner, session);
12
			return getPersister(session)
					.getKeyType()
					.disassemble( key, session, owner );
//////////////////////////////////
/ Hij vergeet de PersistentSet helemaal en gaat disassemble de Long 12	,
/s
SetType(CollectionType).getPersister(SessionImplementor) line: 326	
		return session.getFactory().getCollectionPersister( role );
/t
/s
LongType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	
		return getMutabilityPlan().disassemble( (T) value );

/t
/ Volgende	,
EntityInsertAction.execute() line: 90	
			persister.insert( id, getState(), instance, session );
	state	Object[3]  (id=280)	
		[0]	"Foo1" (id=284)	
		[1]	Double  (id=285)	
		[2]	Long  (id=133)	
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3568	
/s
				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/s
		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/ niets bijzonders	,

/t
EntityInsertAction.execute() line: 111	
			persister.insert( id, getState(), instance, session );
/D
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/s
		// disassembled state gets put in a new array (we write to cache by value!)
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);

/t


/t
TransactionCoordinatorImpl.afterTransaction(TransactionImplementor, int) line: 150	
		getTransactionContext().afterTransactionCompletion( hibernateTransaction, success );
/s
ActionQueue$AfterTransactionCompletionProcessQueue.afterTransactionCompletion(boolean) line: 744	
			while ( !processes.isEmpty() ) {
				try {
					processes.poll().doAfterTransactionCompletion( success, session );
/s
ReadWriteEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 75	
/=
	public boolean afterInsert(Object key, Object value, Object version) throws CacheException {
value	StandardCacheEntryImpl  (id=90)	
	disassembledState	Serializable[4]  (id=99)	
		[0]	"foostreet" (id=104)	
		[1]	"12 foo" (id=105)	
		[2]	"FooCity12" (id=106)	
		[3]	Long  (id=107)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=101)	
/ Doet niets, want er zit in 2c	, 
item	AbstractReadWriteEhcacheAccessStrategy$Lock  (id=138)	

/ volgende	,
value	StandardCacheEntryImpl  (id=169)	
	disassembledState	Serializable[3]  (id=172)	
		[0]	"Foo2" (id=173)	
		[1]	Double  (id=175)	
		[2]	Long  (id=107)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=147)	

/ dan	,
ReadWriteEhcacheEntityRegionAccessStrategy.afterUpdate(Object, Object, Object, Object, SoftLock) line: 113	
value	StandardCacheEntryImpl  (id=217)	
	disassembledState	Serializable[4]  (id=218)	
		[0]	"foostreet" (id=104)	
		[1]	"12 foo" (id=105)	
		[2]	"FooCityA" (id=224)	
		[3]	Long  (id=107)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=101)	

/ volgende	,
ReadWriteEhcacheEntityRegionAccessStrategy.afterUpdate(Object, Object, Object, Object, SoftLock) line: 113	
/=
	public boolean afterUpdate(Object key, Object value, Object currentVersion, Object previousVersion, SoftLock lock)
value	StandardCacheEntryImpl  (id=263)	
	disassembledState	Serializable[3]  (id=265)	
		[0]	"Foo1A" (id=266)	
		[1]	Double  (id=268)	
		[2]	BackrefPropertyAccessor$1  (id=269)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=147)	

/ 7	.

			session = sessionFactory.openSession();
			tx=session.beginTransaction();
		  	employee = (Employee) session.get(Employee.class, 1l);
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 599	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=76)	
	disassembledState	Serializable[3]  (id=79)	
		[0]	"Foo1A" (id=85)	
		[1]	Double  (id=86)	
		[2]	BackrefPropertyAccessor$1  (id=89)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=81)	

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
			subclassPersister = factory.getEntityPersister( entry.getSubclass() );
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
/ entityId==1
			final Type[] types = subclassPersister.getPropertyTypes();
[org.hibernate.type.StringType@77f5f74a, org.hibernate.type.DoubleType@611de50, org.hibernate.type.LongType@7b5b2e86]

			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ entry==ce hierboven	, dus met disassembled state er in	,
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 109	
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/ t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	
		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/D
		persister.setPropertyValues( instance, assembledProps );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 709	
		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
				setters[j].set( entity, values[j], getFactory() );
/s
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
			// this page intentionally left blank :)
		}

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 733	

			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/D
		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);

/ 7	. 

/ we doen in Main3.java geen updates	,

/ er zijn dus alleen entityinsertaction's en geen entityupdateaction	, 
/ Als er een entityUpdateAction is, wordt de entityInsertAction NIET processed, vanwege de Lock in de 2c	, maar als er geen updates zijn na de .save, dan niet	, 
/ Maar we komen in de 
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
/ en deze doet niets met Long 12	,

/ In een entityinsertaction zijn 

/ we doen in nieuwe session	,

		  	employee = (Employee) session.get(Employee.class, 1l);
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 618	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
/ entry==ce
ce	StandardCacheEntryImpl  (id=3325)	
	disassembledState	Serializable[3]  (id=3331)	
		[0]	"Foo1" (id=3333)	
		[1]	Double  (id=3334)	
		[2]	Long  (id=3335) 	12	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3336)	

DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 705	
			final Type[] types = subclassPersister.getPropertyTypes();
[org.hibernate.type.StringType@682d490b, org.hibernate.type.DoubleType@259f1b1d, org.hibernate.type.LongType@18aaa1c3]

			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 109	
	for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
			}
/ we hebben nu geen BackrefPropertyAccessor.UNKNOWN als laatste disassembled	, dus	,
assembledProps	Object[3]  (id=3363)	
	[0]	"Foo1" (id=3333)	
	[1]	Double  (id=3334)	
	[2]	Long  (id=3335)	

/ Maar	,
/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	

		//assembled state gets put in a new array (we read from cache by value!)
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/D
/=values
		persister.setPropertyValues( instance, assembledProps );
/s
		getEntityTuplizer().setPropertyValues( object, values );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 709	
		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
				setters[j].set( entity, values[j], getFactory() );
/s
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
			// this page intentionally left blank :)
		}

/ 7	. 

/ we deden in Main wel updates 	,


/ 13	,

	.save(address)

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s
		return getEntityTuplizer().getPropertyValuesToInsert( object, mergeMap, session );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 620	
		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );

this	PojoEntityTuplizer  (id=3040)	
	getters	Getter[4]  (id=3042)	
		[0]	BasicPropertyAccessor$BasicGetter  (id=3043)	
BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Address.addressLine1)
		[1]	BasicPropertyAccessor$BasicGetter  (id=3068)	
BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Address.zipcode)
		[2]	BasicPropertyAccessor$BasicGetter  (id=3069)	
BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Address.city)
		[3]	BasicPropertyAccessor$BasicGetter  (id=3070)	
BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Address.employees)

/ de laatste	, 
/s
BasicPropertyAccessor$BasicGetter.getForInsert(Object, Map, SessionImplementor) line: 204	
			return get( target );
/s
				return method.invoke( target, (Object[]) null );

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 277	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/D
values	Object[4]  (id=3187)	
	[0]	"foostreet" (id=3150)	
	[1]	"12 foo" (id=3154)	
	[2]	"FooCity12" (id=3151)	
	[3]	HashSet<E>  (id=3152)	

		Type[] types = persister.getPropertyTypes();
		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/s
WrapVisitor(AbstractVisitor).processValue(Object, Type) line: 121	
		if ( type.isCollectionType() ) {
			return processCollection( value, (CollectionType) type );
/s
WrapVisitor.processArrayOrNewCollection(Object, CollectionType) line: 108	
				PersistentCollection persistentCollection = collectionType.wrap( session, collection );
PersistentSet	,
				persistenceContext.addNewCollection( persister, persistentCollection );
//////////////////////
/ Dus creates PersistentSet en set meteen in sc	, 
/s
StatefulPersistenceContext.addCollection(PersistentCollection, CollectionPersister) line: 841	
		final CollectionEntry ce = new CollectionEntry( persister, collection );
ce	CollectionEntry  (id=3041)	
	currentKey	null	
	currentPersister	null	
	dorecreate	false	
	doremove	false	
	doupdate	false	
	fromMerge	false	
	ignore	false	
	loadedKey	null	
	loadedPersister	null	
	processed	false	
	reached	false	
	role	null	
	snapshot	HashMap<K,V>  (id=3049)	

		collectionEntries.put( collection, ce );
		final CollectionKey collectionKey = new CollectionKey( entry.getLoadedPersister(), key );
/ key=Long 12	,
		final PersistentCollection old = collectionsByKey.put( collectionKey, coll );

/ Dus de PersistentSet is de key, en de value ... (TODO)
/ We zien loadedPersister==currentPersister==null	, maar worden later set bij FlushVisitor	,


/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 277	
		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
/D
values	Object[4]  (id=3032)	
	[0]	"foostreet" (id=3053)	
	[1]	"12 foo" (id=3056)	
	[2]	"FooCity12" (id=3059)	
	[3]	PersistentSet  (id=3071)	

			persister.setPropertyValues( entity, values );
/////////////////
/ Geen id	,
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 712	
		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
				setters[j].set( entity, values[j], getFactory() );
/ de laatste	,
BasicPropertyAccessor$BasicSetter.set(Object, Object, SessionFactoryImplementor) line: 68	
				method.invoke( target, value );

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 288	
		if ( substitute ) {
			persister.setPropertyValues( entity, values );
/D
/ In flush wordt weer persister.getPrppertyValues 	, en vindt dus PersistentSet	, ipv HashSet	,

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);


/ 13	.

	.save(employee)

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s
		return getEntityTuplizer().getPropertyValuesToInsert( object, mergeMap, session );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 620	
		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );

this	PojoEntityTuplizer  (id=3074)	
	getters	Getter[3]  (id=3075)	
		[0]	BasicPropertyAccessor$BasicGetter  (id=3076)	
BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Employee.name)
		[1]	BasicPropertyAccessor$BasicGetter  (id=3077)	
BasicGetter(my.test.own.hibernate_xml_1_N_ehcache.Employee.salary)
		[2]	BackrefPropertyAccessor$BackrefGetter  (id=3078)	

/s
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 121	
			else {
				return session.getPersistenceContext().getOwnerId( this.entityName, this.propertyName, target, mergeMap );
////////////////////////////////////////////////////////////////////

this	BackrefPropertyAccessor$BackrefGetter  (id=3214)	
	this$0	BackrefPropertyAccessor  (id=3215)	
		entityName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3216)	
		getter	BackrefPropertyAccessor$BackrefGetter  (id=3214)	
		propertyName	"employees" (id=3217)	
		setter	BackrefPropertyAccessor$BackrefSetter  (id=3218)	

/ we save een employee, niet een member van address.employees	, 
/ Maar Employee heeft via de Backref een rel met Address, en later hieronder wordt check op deze employee wel in address.employees is	,
/s
StatefulPersistenceContext.getOwnerId(String, String, Object, Map) line: 1063	
		for ( Entry<Object,EntityEntry> me : reentrantSafeEntityEntries() ) {
			final EntityEntry entityEntry = me.getValue();
EntityEntry bij de Address inst	,
			if ( persister.isSubclassEntityName( entityEntry.getEntityName() ) ) {
/ JA
				final Object entityEntryInstance = me.getKey();
Address inst	,
				//check if the managed object is the parent
				boolean found = isFoundInParent(
						propertyName,
						childEntity,
						persister,
						collectionPersister,
						entityEntryInstance
				);
/s
		final Object collection = persister.getPropertyValue( potentialParent, property );
/s
		return getEntityTuplizer().getPropertyValue( object, propertyName );
/s
		index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
this	PojoEntityTuplizer  (id=3040)	
	entityMetamodel	EntityMetamodel  (id=3041)	
		propertyIndexes	HashMap<K,V>  (id=3252)	
{zipcode=1, addressLine1=0, employees=3, city=2}
		final Object baseValue = getPropertyValue( entity, index );
/t
		final Object collection = persister.getPropertyValue( potentialParent, property );
/D
address.employees	,
		return collection != null
				&& Hibernate.isInitialized( collection )
				&& collectionPersister.getCollectionType().contains( collection, childEntity, session );

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/D
values	Object[3]  (id=3196)	
	[0]	"Foo1" (id=3213)	
	[1]	Double  (id=3216)	
	[2]	Long  (id=3083)	 12

		AbstractEntityInsertAction insert = addInsertAction(
				values, id, entity, persister, useIdentityColumn, source, shouldDelayIdentityInserts
		);
/s
StatefulPersistenceContext.addEntity(Object, Status, Object[], EntityKey, Object, LockMode, boolean, EntityPersister, boolean, boolean) line: 462	

/ In entitiesByKey is {id,persister} de key, en entity de value, 
/ in entityEntryContext is entity de key en de entityEntry met de H values (loadedState) de value	,

/ bij een Employee is de laatste value Long 12	, 

		addEntity( entityKey, entity );
/s
		entitiesByKey.put( key, entity );

		return addEntry(
				entity,
				status,
				loadedState,
				null,
				entityKey.getIdentifier(),
				version,
				lockMode,
				existsInDatabase,
				persister,
				disableVersionIncrement,
				lazyPropertiesAreUnfetched
		);
/s
		entityEntryContext.addEntityEntry( entity, e );


/ 7	.

/ als we wel een update doen op een Employee na .save 	, 
			tx.commit();

/ flushEntities, flushCollections (via FlushEverythingToExecutions )  en performExecutions loop over entities (en collections)	,

/s
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/s
			int entityCount = flushEntities( event, persistenceContext );
/ Maakt EntityUpdateAction's met values	, bijv PersistentSet in een Address	, performExecutions zal deze PersistentSet disassemble tot de ownerId , Long 12	,
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 229	

/ Hij flush de entities in sc	,
//////////////////////////////
		EntityEntry entry = me.getValue();
		final FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );
/ Dus de entityEntry zit in de event	, dus ook de entity, 	de H values	,

		final Map.Entry<Object,EntityEntry>[] entityEntries = persistenceContext.reentrantSafeEntityEntries();
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
/ 'n Address	,
			listener.onFlushEntity( entityEvent );
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 152	
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/s
DefaultFlushEntityEventListener.getValues(Object, EntityEntry, boolean, SessionImplementor) line: 179	
			// grab its current state
			values = persister.getPropertyValues( entity );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValues(Object) line: 601	
		for ( int j = 0; j < span; j++ ) {
				result[j] = getters[j].get( entity );
/t
values	Object[4]  (id=524)	
	[0]	"foostreet" (id=493)	
	[1]	"12 foo" (id=529)	
	[2]	"FooCityA" (id=494)	
	[3]	PersistentSet  (id=495)	

		if ( isUpdateNecessary( event, mightBeDirty ) ) {
			substitute = scheduleUpdate( event ) || substitute;
/s
DefaultFlushEntityEventListener.scheduleUpdate(FlushEntityEvent) line: 313	
		session.getActionQueue().addAction(
				new EntityUpdateAction(
						entry.getId(),
						values,
/ Hierboven	,
						dirtyProperties,
[2]
						event.hasDirtyCollection(),
						( status == Status.DELETED && !entry.isModifiableEntity() ?
								persister.getPropertyValues( entity ) :
								entry.getLoadedState() ),
						entry.getVersion(),
						nextVersion,
						entity,
						entry.getRowId(),
						persister,
						session
				)
		);
/ Zet de values er in	, verder niets	,

			if ( persister.hasCollections() ) {
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/ laatste	,
/s
FlushVisitor.processCollection(Object, CollectionType) line: 46	
			Collections.processReachableCollection( coll, type, owner, getSession() );
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 165	
		collection.setOwner( entity );
/entity=Address inst	,
		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );
		ce.setReached( true );

		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
/type=org.hibernate.type.SetType(my.test.own.hibernate_xml_1_N_ehcache.Address.employees)
		ce.setCurrentPersister( persister );
		//TODO: better to pass the id in as an argument?
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
/entity=Address inst	,
/s
SetType(CollectionType).getKeyOfOwner(Object, SessionImplementor) line: 382	
		EntityEntry entityEntry = session.getPersistenceContext().getEntry( owner );
			return entityEntry.getId();

/t
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 250	
		entry.setProcessed( true );

		final CollectionPersister loadedPersister = entry.getLoadedPersister();
null
		final CollectionPersister currentPersister = entry.getCurrentPersister();

			// if either its role changed, or its key changed
			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );
			if ( ownerChanged ) {
/ TODO
				// do the work
				if ( currentPersister != null ) {
					entry.setDorecreate( true );

/ volgende	,
/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 229	
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 154	
		final Object[] values = getValues( entity, entry, mightBeDirty, session );

/ Intermezzo

/ insert action deed	,
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );

/ Einde Intermezzo

/s
DefaultFlushEntityEventListener.getValues(Object, EntityEntry, boolean, SessionImplementor) line: 180	
		final Object[] loadedState = entry.getLoadedState();
loadedState	Object[3]  (id=3189)	
	[0]	"Foo1" (id=3190)	
	[1]	Double  (id=3191)	
	[2]	Long  (id=3134)	
/= .getValues bij insert action	,

			// grab its current state
			values = persister.getPropertyValues( entity );
/s
		return getEntityTuplizer().getPropertyValues( object );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValues(Object) line: 601	
		for ( int j = 0; j < span; j++ ) {
			NonIdentifierAttribute property = entityMetamodel.getProperties()[j];
				result[j] = getters[j].get( entity );
/s
BackrefPropertyAccessor$BackrefGetter.get(Object) line: 136	
			return UNKNOWN;

/t
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 160	
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/D
		if ( isUpdateNecessary( event, mightBeDirty ) ) {
			substitute = scheduleUpdate( event ) || substitute;
/s
		session.getActionQueue().addAction(
				new EntityUpdateAction(
						entry.getId(),
						values,
						dirtyProperties,
						event.hasDirtyCollection(),
						( status == Status.DELETED && !entry.isModifiableEntity() ?
								persister.getPropertyValues( entity ) :
								entry.getLoadedState() ),
						entry.getVersion(),
						nextVersion,
						entity,
						entry.getRowId(),
						persister,
						session
				)
		);
/ Zet de values er in	, verder niets	,



/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	
			int entityCount = flushEntities( event, persistenceContext );
/D
			int collectionCount = flushCollections( session, persistenceContext );
/s
(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 273	
		for ( Map.Entry<PersistentCollection,CollectionEntry> me : IdentityMap.concurrentEntries( (Map<PersistentCollection,CollectionEntry>) persistenceContext.getCollectionEntries() )) {
			PersistentCollection coll = me.getKey();
			CollectionEntry ce = me.getValue();

			if ( ce.isDorecreate() ) {
				session.getInterceptor().onCollectionRecreate( coll, ce.getCurrentKey() );
/ CREATE COLLECTIONRECREATEACTION 
				actionQueue.addAction(
						new CollectionRecreateAction(
								coll,
								ce.getCurrentPersister(),
currentPersister	OneToManyPersister  (id=3037)	
								ce.getCurrentKey(),
12
								session
							)
					);

/t
DefaultFlushEventListener.onFlush(FlushEvent) line: 55	
				flushEverythingToExecutions( event );
/D
				performExecutions( source );
/s
			session.getActionQueue().prepareActions();
/s
CollectionRecreateAction(CollectionAction).beforeExecutions() line: 103	
/ created  in flushCollections	, omdat in flushEntiteis bij address doRecreate=true was set	,
/ see CREATE COLLECTIONRECREATEACTION 
/ HIER HIER
		if ( persister.hasCache() ) {
			final CacheKey ck = session.generateCacheKey(
					key,
					persister.getKeyType(),
					persister.getRole()
			);
			final SoftLock lock = persister.getCacheAccessStrategy().lockItem( ck, null );
			// the old behavior used key as opposed to getKey()
			afterTransactionProcess = new CacheCleanupProcess( key, persister, lock );
/ Deze zien we inderdaad later	,	

/t
			session.getActionQueue().executeActions();
/s
		for ( ExecutableList<?> l : executableLists ) {
			executeActions( l );
/s
			for ( E e : list ) {
				try {
					e.execute();
/ een Address	,
/s
EntityInsertAction.execute() line: 90	
this	EntityInsertAction  (id=3265)	
	id	Long  (id=3266)	
	persister	SingleTableEntityPersister  (id=3269)	
	state	Object[4]  (id=3272)	
		[0]	"foostreet" (id=3273)	
		[1]	"12 foo" (id=3274)	
		[2]	"FooCity12" (id=3275)	
		[3]	PersistentSet  (id=3276)	

			persister.insert( id, getState(), instance, session );

/ H persists the id en state , not the instance	,

/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
			for ( int j = 0; j < span; j++ ) {
/ span=1
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3069	
/=
	protected void insert(
			final Serializable id,
			final Object[] fields,
			final boolean[] notNull,
			final int j,
			final String sql,
			final Object object,
			final SessionImplementor session) throws HibernateException {
id	Long  (id=3266)	12
fields	Object[4]  (id=3272)	
	[0]	"foostreet" (id=3273)	
	[1]	"12 foo" (id=3274)	
	[2]	"FooCity12" (id=3275)	
	[3]	PersistentSet  (id=3276)	
sql	"insert into address (address_line1__, zipcoce__, city_, id__) values (?, ?, ?, ?)" (id=3294)	
/ De id zit in sql	,

				insert = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );

				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/s
	for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
/ Dit gaat op types	,
/ 1ste	,
/s
	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
		return new BasicBinder<X>( javaTypeDescriptor, this ) {
			@Override
			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
				st.setString( index, javaTypeDescriptor.unwrap( value, String.class, options ) );
/ TODO
/ laatste	,
/s
	public final void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable,
			SessionImplementor session) throws HibernateException, SQLException {
		//NOOP
	}

/t
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2849	
		if ( !isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );
/ Moet er ook bij	,

/t
EntityInsertAction.execute() line: 111	
			persister.insert( id, getState(), instance, session );
/ to db, maar nog niet commit	,

		if ( isCachePutEnabled( persister, session ) ) {
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
			this.cacheEntry = persister.getCacheEntryStructure().structure( ce );
/ set in de action, net als persister	, id, state	,
/s
AbstractEntityPersister$StandardCacheEntryHelper.buildCacheEntry(Object, Object[], Object, SessionImplementor) line: 5245	
			return new StandardCacheEntryImpl(
					state,
					persister,
					persister.hasUninitializedLazyProperties( entity ),
					version,
					session,
					entity
			);
/ entity=Address inst	,
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 72	
/=
	public StandardCacheEntryImpl(
			final Object[] state,
			final EntityPersister persister,
			final boolean unfetched,
			final Object version,
			final SessionImplementor session,
			final Object owner)
/ entity heet hier owner,	
/ state is zoals in de entity insert action	, dus voor de updates	, de loadedState	,
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 137	
		for ( int i = 0; i < row.length; i++ ) {
			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				disassembled[i] = (Serializable) row[i];
			}
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
			}
/s
SetType(CollectionType).disassemble(Object, SessionImplementor, Object) line: 280	
		final Serializable key = getKeyOfOwner(owner, session);
/s
SetType(CollectionType).getKeyOfOwner(Object, SessionImplementor) line: 387	
		EntityEntry entityEntry = session.getPersistenceContext().getEntry( owner );
			return entityEntry.getId();
/ Geen state	, maar id	,
/ owner=entty wordt alleen used als key	, dus de id wordt NIET uit de entity gehaald,	
////////////////////////////////////////////


/ id van entity==Address inst	,
/ this SetType 
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3165)	

			return getPersister(session)
/s
		return session.getFactory().getCollectionPersister( this.role );

					.getKeyType()
					.disassemble( key, session, owner );

/t
/ volgende,	 een Employee	,
/s
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3580	
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3115	
/=
	protected void insert(
			final Serializable id,
			final Object[] fields,
			final boolean[] notNull,
			final int j,
			final String sql,
			final Object object,
			final SessionImplementor session) throws HibernateException {
id	Long  (id=3173)	
fields	Object[3]  (id=3174)	
	[0]	"Foo1" (id=3177)	
	[1]	Double  (id=3178)	
	[2]	Long  (id=3159)	 12	
sql	"insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)" (id=3184)	

/ we zien in de sql address_	, en dat is laatste state,	 Long 12	,

/ dehydrate doet niets eig, OK

/ t
EntityInsertAction.execute() line: 126	
			persister.insert( id, getState(), instance, session );
/D
		if ( isCachePutEnabled( persister, session ) ) {
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/ state is met Long 12	, (wat in de db de fk wordt)	, 
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 74	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
state	Object[3]  (id=3174)	
	[0]	"Foo1" (id=3177)	
	[1]	Double  (id=3178)	
	[2]	Long  (id=3159)	
owner	Employee  (id=3172)	
	id	1	
	name	"Foo1A" (id=3182)	
	salary	1.0	
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 141	
		for ( int i = 0; i < row.length; i++ ) {
			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				disassembled[i] = (Serializable) row[i];
			}
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
/t
/s
EntityUpdateAction.execute() line: 147	

/ Van een Address inst	,

		if ( persister.hasCache() ) {
			ck = session.generateCacheKey(
					id, 
					persister.getIdentifierType(), 
					persister.getRootEntityName()
			);
			this.lock = persister.getCacheAccessStrategy().lockItem( ck, previousVersion );
/ Zodat de entity insert action niets zal doen -> 2c

			persister.update( 
					id, 
Long 12
					state, 
	[0]	"foostreet" (id=3140)	
	[1]	"12 foo" (id=3141)	
	[2]	"FooCityA" (id=3156)	
	[3]	PersistentSet  (id=3153)	
					dirtyFields, 
[2]
					hasDirtyCollection, 
false
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
/s
SingleTableEntityPersister(AbstractEntityPersister).update(Serializable, Object[], int[], boolean, Object[], Object, Object, Object, SessionImplementor) line: 3525	
			// For the case of dynamic-update="false", or no snapshot, we use the static SQL
			updateStrings = getUpdateStrings(
					rowId != null,
					hasUninitializedLazyProperties( object )
			);
[update address set address_line1__=?, zipcoce__=?, city_=? where id__=?]
/ state & id	,
/ dirty is alleen column, index 2, 	maar hij update alle state	,
/ TODO 
				updateOrInsert(
						id,
						fields,
						oldFields,
						j == 0 ? rowId : null,
						propsToUpdate,
						j,
						oldVersion,
						object,
						updateStrings[j],
						session
				);
/ gewoon met dehydrate	,

/t
EntityUpdateAction.execute() line: 202	

			else {
				//TODO: inefficient if that cache is just going to ignore the updated state!
				final CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 74	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 145	
		Serializable[] disassembled = new Serializable[row.length];
		for ( int i = 0; i < row.length; i++ ) {
			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				disassembled[i] = (Serializable) row[i];
			}
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
/ de laatste	,
/s 
SetType(CollectionType).disassemble(Object, SessionImplementor, Object) line: 280	
		final Serializable key = getKeyOfOwner(owner, session);
Long 12	,
		else {
			return getPersister(session)
					.getKeyType()
					.disassemble( key, session, owner );

/t
ActionQueue.executeActions(ExecutableList<E>) line: 467	
					e.execute();
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );
/ Na db commit	, processed	,
/ TODO

/t
/ volgende	,
ActionQueue.executeActions(ExecutableList<E>) line: 463	
			for ( E e : list ) {
				try {
					e.execute();
/s
EntityUpdateAction.execute() line: 207	

/ een Employee	,

/s
EntityUpdateAction.execute() line: 158	

			ck = session.generateCacheKey(
					id, 
					persister.getIdentifierType(), 
					persister.getRootEntityName()
			);
			lock = persister.getCacheAccessStrategy().lockItem( ck, previousVersion );

			persister.update( 
					id, 
					state, 
		[0]	"Foo1A" (id=3182)	
		[1]	Double  (id=3309)	
		[2]	BackrefPropertyAccessor$1  (id=3332)	
					dirtyFields, 
[0]
					hasDirtyCollection, 
					previousState, 
[0]	"Foo1" (id=3177)	
[1]	Double  (id=3178)	
[2]	Long  (id=3159)	
					previousVersion, 
					instance, 
instance	Employee  (id=3172)	
/ key om entityEntry te krijgen	,
					rowId, 
					session 
			);
/s
		}
		else {
			// For the case of dynamic-update="false", or no snapshot, we use the static SQL
			updateStrings = getUpdateStrings(
					rowId != null,
					hasUninitializedLazyProperties( object )
			);
[update employee set name_=?, salary_=? where id_=?]
/ we zien GEEN address_	,
/ Die zien we hieronder bij recreate collection action	,
//////////////////////////////////////////////////

			propsToUpdate = getPropertyUpdateability( object );
[true, true, false]
/s
SingleTableEntityPersister(AbstractEntityPersister).update(Serializable, Object[], Object[], Object, boolean[], int, Object, Object, String, SessionImplementor) line: 3211	
				index = dehydrate( id, fields, rowId, includeProperty, propertyColumnUpdateable, j, update, session, index, true );
fields Object[]
[0]	"Foo1A" (id=3182)	
[1]	Double  (id=3309)	
[2]	BackrefPropertyAccessor$1  (id=3332)	

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j )
/ NEE voor UNKNOWN	,
					&& !lobProperties.contains( i )) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );

/t
EntityUpdateAction.execute() line: 207	

				final CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 74	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
state	Object[3]  (id=3180)	
	[0]	"Foo1A" (id=3178)	
	[1]	Double  (id=3186)	
	[2]	BackrefPropertyAccessor$1  (id=3188)	

		for ( int i = 0; i < row.length; i++ ) {
			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				disassembled[i] = (Serializable) row[i];
			}
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );

/t
/ volgende	,
CollectionRecreateAction.execute() line: 67	

/ updates db	, en schedules Cleanup 	,

		getPersister().recreate( collection, getKey(), getSession() );
/ collection=PersistentSet met 2 Employee	,
getKey()=this.key=Long 12
/ TODO (Hoe in deze action set)
/s
OneToManyPersister(AbstractCollectionPersister).recreate(PersistentCollection, Serializable, SessionImplementor) line: 1301	
					while ( entries.hasNext() ) {
							int offset = 1;
						final Object entry = entries.next();
							String sql = getSQLInsertRowString();
update employee set address_=? where id_=?

							try {
								// TODO: copy/paste from insertRows()
								int loc = writeKey( st, id, offset, session );
/s
/ offset=1
		getKeyType().nullSafeSet( st, key, i, session );
		return i + keyColumnAliases.length;
								loc = writeElement( st, collection.getElement( entry ), loc, session );
/ loc=2
/s
OneToManyPersister(AbstractCollectionPersister).writeElement(PreparedStatement, Object, int, SessionImplementor) line: 899	
		getElementType().nullSafeSet( st, elt, i, elementColumnIsSettable, session );
this	OneToManyPersister  (id=3424)	
	elementType	ManyToOneType  (id=3467)	
		associatedEntityName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3321)	
		associatedEntityPersister	SingleTableEntityPersister  (id=3171)	
		associatedIdentifierType	LongType  (id=3236)	
	entityName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3489)	
/s
ManyToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 165	
		getIdentifierOrUniqueKeyType( session.getFactory() )
/=LongType	,
/ s
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
			return getIdentifierType(factory);
/=
		associatedIdentifierType	LongType  (id=3236)	
/ hierboven	,
/t
				.nullSafeSet( st, getIdentifier( value, session ), index, settable, session );
/s
ManyToOneType(EntityType).getIdentifier(Object, SessionImplementor) line: 537	
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
			return ForeignKeys.getEntityIdentifierIfNotUnsaved( getAssociatedEntityName(), value, session ); //tolerates nulls
/s
ForeignKeys.getEntityIdentifierIfNotUnsaved(String, Object, SessionImplementor) line: 284	
/=
	public static Serializable getEntityIdentifierIfNotUnsaved(
			final String entityName,
Employee
			final Object object,
Employee inst	,
			final SessionImplementor session) throws TransientObjectException {
		else {
			Serializable id = session.getContextEntityIdentifier( object );
/s
			EntityEntry entry = persistenceContext.getEntry(object);
			return entry != null ? entry.getId() : null;
/t
/s
LongType(AbstractSingleColumnStandardBasicType<T>).nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 56	
/ value=1

/ we zien	,
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 16:57:12 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 17:31:26 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/t

/ alle 2c entries hebben locks	, die van de coll is set in prepareactions	, die van de address, 2 employee in executeactions, bij de entityupdateaction	,

	db commit
	after commit=2c schedules	,

/s
ReadWriteEhcacheEntityRegionAccessStrategy.afterInsert(Object, Object, Object) line: 75	
			final Lockable item = (Lockable) region().get( key );
			if ( item == null ) {
/ NEE
				region().put( key, new Item( value, version, region().nextTimestamp() ) );

/ dus ReadWriteEhcacheEntityRegionAccessStrategy.afterInsert doet niets als er al iets staat , in dit geval een lock	,
/ dit voor address, 2 employee	,

/t
/s
ReadWriteEhcacheEntityRegionAccessStrategy.afterUpdate(Object, Object, Object, Object, SoftLock) line: 113	
			if ( item != null && item.isUnlockable( lock ) ) {
				final Lock lockItem = (Lock) item;
				if ( lockItem.wasLockedConcurrently() ) {
/ NEE
/ TODO
				else {
					region().put( key, new Item( value, currentVersion, region().nextTimestamp() ) );

key	CacheKey  (id=3182)	
	entityOrRoleName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3193)	
	hashCode	372	
	key	Long  (id=3157)	
	tenantId	null	
	type	LongType  (id=3202)	
value	StandardCacheEntryImpl  (id=3183)	
	disassembledState	Serializable[4]  (id=3187)	
		[0]	"foostreet" (id=3194)	
		[1]	"12 foo" (id=3195)	
		[2]	"FooCityA" (id=3196)	
		[3]	Long  (id=3157)	
			value	12	
	lazyPropertiesAreUnfetched	false	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3193)	

/ volgende	,
ReadWriteEhcacheEntityRegionAccessStrategy.afterUpdate(Object, Object, Object, Object, SoftLock) line: 113	



/ Einde COLLECTIONS TO 1C, 2C

/ COLLECTIONS FROM 1C, 2C

/ 7	. 

	.get(Employee.class,1l)
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
/s

ce	StandardCacheEntryImpl  (id=3323)	
	disassembledState	Serializable[3]  (id=3324)	
		[0]	"Foo1A" (id=3326)	
		[1]	Double  (id=3327)	
		[2]	BackrefPropertyAccessor$1  (id=3328)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3325)	

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 707	

			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )

			final Type[] types = subclassPersister.getPropertyTypes();
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
/ set ook assembled props (=values) in entity	, de disassembledState is in entry	,
/s
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);

/ Bij Employee assembledProps = disassembledState, ander Object[], dezelfde content	,

		persister.setPropertyValues( instance, assembledProps );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 709	
		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
				setters[j].set( entity, values[j], getFactory() );
/s
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
			// this page intentionally left blank :)
		}

////////////////////////////

/ obj (getters)-> 1c=H id, props (disassemble)-> 2c 
/ 2c (assemble)-> 1c-H id,props (setters)->obj

/ TypeHelper.assemble laat de BackrefPropertyAccessor.UNKNOWN onveranderd	,
/ TypeHelper.assemble uses types	,
/ Maar de setter bij deze prop doet niets met deze value	, dus de entity krijgt hem niet	,
/ setPropertyValues uses setters

/ .assemble hieronder ook (setters) H props->obj, maar geeft de H props=values , want moet nog in de 1c,	

/ verwarrend: de fct .assemble hieronder doet assemble & setters 	, de H props worden daarna in de 1c set	,

/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 733	

			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/D
/ geeft values=H props terug, want moeten nog in 1c	,
 
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
/ set in sc	,

/ 7	.

	.get(Address.class, 12l)
/s
DefaultLoadEventListener.loadFromSessionCache(LoadEvent, EntityKey, LoadEventListener$LoadType) line: 541	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=3334)	
	disassembledState	Serializable[4]  (id=3335)	
		[0]	"foostreet" (id=3337)	
		[1]	"12 foo" (id=3338)	
		[2]	"FooCityA" (id=3339)	
		[3]	Long  (id=3340)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3336)	

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 637	
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session

/ verwarrend: de fct .assemble hieronder doet assemble & setters 	, de H props worden daarna in de 1c set	,
/ set ook assembled props (=values) in entity	, de disassembledState is in entry	,
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 108	
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ NEE
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/ laatste	,
/s
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 296	
			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
/ Long 12
			return resolveKey( key, session, owner );
/s
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 748	

				collection = instantiate( session, persister, key );
				collection.setOwner(owner);
				persistenceContext.addUninitializedCollection( persister, collection, key );
/ coll in 1c	,
ce	CollectionEntry  (id=3336)	
	currentKey	null	
	currentPersister	null	
	dorecreate	false	
	doremove	false	
	doupdate	false	
	fromMerge	false	
	ignore	false	
	loadedKey	Long  (id=3337)	 			12
	loadedPersister	OneToManyPersister  (id=3338)	
	processed	false	
	reached	false	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3339)	
	snapshot 	null	

/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 172	
		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/D
		persister.setPropertyValues( instance, assembledProps );
/ De PersistentSet wordt gewoon set in de Address inst	,

/t
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/D
/ H props, for in 1c	,
		persistenceContext.addEntry(
				entity,
				( isReadOnly ? Status.READ_ONLY : Status.MANAGED ),
				values,
				null,
				entityId,
				version,
				LockMode.NONE,
				true,
				subclassPersister,
				false,
				entry.areLazyPropertiesUnfetched()
		);
/t
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 733	
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/D
/ assemble & setters	,

/ 7	. 

	        Iterator< Employee>iterator=employees.iterator();
/s
AbstractPersistentCollection$4.doWork() line: 558	
						session.initializeCollection( AbstractPersistentCollection.this, writing );
/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	

		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry( collection );
/ collection is set in deze event, want eerder wat collection this	, nl de call is employees.iterator	,

			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
/ Long 12	,
					ce.getLoadedPersister(),
/ OneToManyPersister	,
					collection,
					source
			);
false
/ from 2c 
/ want	,
/s
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 139	
		final CacheKey ck = source.generateCacheKey( id, persister.getKeyType(), persister.getRole() );
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
null

/t
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	
				ce.getLoadedPersister().initialize( ce.getLoadedKey(), source );

/ ce.getLoadedKey() = Long 12 die laatste disass state van de address (in 2c)	,
/ ce.getLoadedPersister=ce.initializer	, een CollectionLoader	,

s	OneToManyPersister  (id=3342)	
	initializer	CollectionLoader  (id=3343)	
		collectionPersister	OneToManyPersister  (id=3342)	
		columnNameCache	null	
		factory	SessionFactoryImpl  (id=3385)	
		staticLoadQuery	OneToManyLoadQueryDetails  (id=3350)	
			collectionReferenceAliases	CollectionReferenceAliasesImpl  (id=3352)	
			keyColumnNames	String[1]  (id=3353)	
			loadPlan	LoadPlanImpl  (id=3360)	
			queryProcessor	LoadQueryJoinAndFetchProcessor  (id=3359)	
			readerCollector	AbstractCollectionLoadQueryDetails$CollectionLoaderReaderCollectorImpl  (id=3358)	
			resultSetProcessor	ResultSetProcessorImpl  (id=3355)	
			rootReturn	CollectionReturnImpl  (id=3356)	
			sqlStatement	"select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_ from employee employees0_ where employees0_.address_=?" (id=3357)	

/s
CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 100	

			qp.setPositionalParameterTypes( new Type[]{ collectionPersister.getKeyType() } );
			qp.setPositionalParameterValues( ids );
			qp.setCollectionKeys( ids );
/ Long 12 komt ook in de coll-query	,

			executeLoad(
					session,
					qp,
					staticLoadQuery,
					true,
					null

			);

/ Intermezzo

/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).resolveEntityKey(ResultSet, ResultSetProcessingContextImpl, EntityReferenceInitializer, Map<EntityReference,EntityReferenceInitializer>) line: 148	

/ er is een entity initializer	,
		entityReferenceInitializer.resolveEntityKey( resultSet, context );
/s
EntityReferenceInitializerImpl.resolveEntityKey(ResultSet, ResultSetProcessingContextImpl) line: 136	

		final EntityReferenceProcessingState processingState = context.getProcessingState( entityReference );

this	EntityReferenceInitializerImpl  (id=3559)	

context	ResultSetProcessingContextImpl  (id=3555)	
	identifierResolutionContextMap	IdentityHashMap<K,V>  (id=3599)	
		table	Object[64]  (id=3600)	
			[52]	CollectionFetchableElementEntityGraph  (id=3409)	
			[53]	ResultSetProcessingContextImpl$1  (id=3560)	

/ de ResultSetProcessingContextImpl context, die een identifierResolutionContextMap heeft, met key=entityReference	, value=EntityReferenceProcessingState	,

/ er is ook een collectionReferenceInitializer=	CollectionReferenceInitializerImpl  (id=3777)	, die uses context ook	,

				collectionReferenceInitializer.finishUpRow( resultSet, context );

/ een collectionReference is een CollectionReturnImpl	,
/ een entityReference is een CollectionFetchableElementEntityGraph  (id=3409)	

/ Einde Intermezzo

/s
EntityReferenceInitializerImpl.hydrateEntityState(ResultSet, ResultSetProcessingContextImpl) line: 220	

		final Object existing = context.getSession().getEntityUsingInterceptor( entityKey );
		if ( existing != null ) {
/ JA, als de Employee in 1c,	 
			return;
		}
/ NEE, als niet	Employee in 1c	,
		final String concreteEntityTypeName = getConcreteEntityTypeName( resultSet, context, entityKey );
Employee
		final Object entityInstance = optionalEntityInstance != null
				: context.getSession().instantiate( concreteEntityTypeName, entityKey.getIdentifier() );

		loadFromResultSet(
				resultSet,
				context,
				entityInstance,
				concreteEntityTypeName,
				entityKey,
				lockModeToAcquire
		);
/s
SingleTableEntityPersister(AbstractEntityPersister).hydrate(ResultSet, Serializable, Object, Loadable, String[][], boolean, SessionImplementor) line: 2900	
	public Object[] hydrate(
			final ResultSet rs,
			final Serializable id,
2
			final Object object,
			final Loadable rootLoadable,
			final String[][] suffixedPropertyColumns,
[[name_2_1_1_], [salary_3_1_1_], [address_4_1_1_]]
			final boolean allProperties,
			final SessionImplementor session) throws SQLException, HibernateException {

			final String[] propNames = getPropertyNames();
[name, salary, _my.test.own.hibernate_xml_1_N_ehcache.Address.employeesBackref]

			final Type[] types = getPropertyTypes();
[org.hibernate.type.StringType@8492b68, org.hibernate.type.DoubleType@26b2e7b4, org.hibernate.type.LongType@7c75b5b9]

/ ook	,
				this.propertySelectable
[true,true,false]

			for ( int i = 0; i < types.length; i++ ) {
				if ( !this.propertySelectable[i] ) {
/ JA, als laatste	,
					values[i] = BackrefPropertyAccessor.UNKNOWN;
				}
					else {
						final ResultSet propertyResultSet = propertyIsDeferred ? sequentialResultSet : rs;
rs
						final String[] cols = propertyIsDeferred ? propertyColumnAliases[i] : suffixedPropertyColumns[i];
[name_2_1_1_]
						values[i] = types[i].hydrate( propertyResultSet, cols, session, object );

			context.getProcessingState( entityReference ).registerHydratedState( values );

/later, in 
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 67	
			final Serializable collectionRowKey = (Serializable) collectionReference.getCollectionPersister().readKey(
					resultSet,
					aliases.getCollectionColumnAliases().getSuffixedKeyAliases(),
[address_4_0_0_]
					context.getSession()
			);
12
/ TODO (Waarom eerst UNKNOWN, en dan nu toch [address_4_0_0_] -> Long 12	?)

				PersistentCollection rowCollection = persistenceContext.getLoadContexts()
						.getCollectionLoadContext( resultSet )
						.getLoadingCollection( collectionReference.getCollectionPersister(), collectionRowKey );
/ PersistentContext
/ TODO (Wat staat hier?)

				if ( rowCollection != null ) {
					rowCollection.readFrom(
							resultSet,
							collectionReference.getCollectionPersister(),
							aliases.getCollectionColumnAliases(),
							collectionOwner
					);
				}
/s
		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
/ descriptor.getSuffixedElementAliases()]=[id_1_1_0_]	,
/ Moet eerst de id uit de rs halen	, en daarna wordt de element resolved	,

/s
OneToManyPersister(AbstractCollectionPersister).readElement(ResultSet, Object, String[], SessionImplementor) line: 844	
		return getElementType().nullSafeGet( rs, aliases, session, owner );
/ getElementType()=org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_1_N_ehcache.Employee)
/s
ManyToOneType(EntityType).nullSafeGet(ResultSet, String[], SessionImplementor, Object) line: 308	
		return resolve( hydrate(rs, names, session, owner), session, owner );
/////////////////////////////////
/ calls load, vindt null-Employee met id=2 in 1c	, 
/s
			if ( isReferenceToPrimaryKey() ) {
				return resolveIdentifier( (Serializable) value, session );
/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
...
		}
/D
		rowReader.finishUp( context, afterLoadActionList );
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 195	
		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).performTwoPhaseLoad(PreLoadEvent, ResultSetProcessingContextImpl, List<HydratedEntityRegistration>) line: 244	
		for ( HydratedEntityRegistration registration : hydratedEntityRegistrations ) {
/ 1 entry, nl Employee#2	,  is null-Employee met id=2	,
/ Employee#1 hadden we uit 1c gehaald, is al init	,
			TwoPhaseLoad.initializeEntity(
					registration.getInstance(),
					context.isReadOnly(),
					context.getSession(),
					preLoadEvent
			);
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 158	
		final Object[] hydratedState = entityEntry.getLoadedState();
hydratedState	Object[3]  (id=3463)	
	[0]	"Foo2A" (id=3464)	
	[1]	Double  (id=3465)	
	[2]	BackrefPropertyAccessor$1  (id=3466)	

		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
/ NEE , laatste	,
				hydratedState[i] = types[i].resolve( value, session, entity );
/ Gebeurt niets	,
			}

		persister.setPropertyValues( entity, hydratedState );
/ met setters	,
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 712	
		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
				setters[j].set( entity, values[j], getFactory() );
/s
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
			// this page intentionally left blank :)
		}

/ de entity Employee#2 heeft nu ook z'n props	,
entity	Employee  (id=3456)	
	id	2	
	name	"Foo2A" (id=3464)	
	salary	2.0	

			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
entry	StandardCacheEntryImpl  (id=3889)	
	disassembledState	Serializable[3]  (id=3891)	
		[0]	"Foo2A" (id=3464)	
		[1]	Double  (id=3465)	
		[2]	BackrefPropertyAccessor$1  (id=3466)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3454)	

			final CacheKey cacheKey = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
							cacheKey,
							persister.getCacheEntryStructure().structure( entry ),
							session.getTimestamp(),
							version,
							useMinimalPuts( session, entityEntry )
					);
/ Doet NIET	, er staat al een entry, en we zijn inderdaad aan het load	, dus hoeft hij de 2c niet te update	,
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 109	
                       final Lockable item = (Lockable) region().get( key );
                        final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
                        if ( writeable ) {
/ NEE
                                region().put( key, new Item( value, version, region().nextTimestamp() ) );
/ NIET

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 218	

		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/ D
/ H props -> Employee#2	, NIET -> 2c, want daar is al entry, en we zijn aan het load	, 
/ De HashSet set in PersistentSet collection is er, maar is leeg	, initialized=false, storedSnapshot=null	,

		// now we can finalize loading collections
		finishLoadingCollections( context );
/s
CollectionLoadContext.endLoadingCollections(CollectionPersister) line: 168	

		endLoadingCollections( persister, matches );
/s
			endLoadingCollection( matchedCollectionEntry, persister );
/s
CollectionLoadContext.endLoadingCollection(LoadingCollectionEntry, CollectionPersister) line: 247	

		final boolean hasNoQueuedAdds = lce.getCollection().endRead();
////////////////////////////
/ sets the set in de PersistentSet met de 2 Employee	, initialized=true	,
/ Vanaf nu kunnen we iterate in Main	,

		CollectionEntry ce = getLoadContext().getPersistenceContext().getCollectionEntry( lce.getCollection() );
			ce.postInitialize( lce.getCollection() );
/ set snapshot in ce, en in collection	,
/ TODO

			addCollectionToCache( lce, persister );
/s
CollectionLoadContext.addCollectionToCache(LoadingCollectionEntry, CollectionPersister) line: 299	

		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
/s
		this.state = collection.disassemble( persister );
/s
PersistentSet.disassemble(CollectionPersister) line: 363	
		final Serializable[] result = new Serializable[ set.size() ];
		final Iterator itr = set.iterator();
		int i=0;
		while ( itr.hasNext() ) {
/ Dit kan nu	, want hierboven was tempList ->set	,
///////////////////////////////////
			result[i++] = persister.getElementType().disassemble( itr.next(), getSession(), null );
this	PersistentSet  (id=3328)	
persister	OneToManyPersister  (id=3358)	
	entityName	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=3447)	
	elementType	ManyToOneType  (id=3361)	
		associatedEntityName	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3422)	
		associatedEntityPersister	SingleTableEntityPersister  (id=3350)	
		associatedIdentifierType	LongType  (id=3343)	
		eager	true	
		ignoreNotFound	false	
		isEmbeddedInXML	true	
		isLogicalOneToOne	false	
		referenceToPrimaryKey	true	
		returnedClass	null	
		scope	TypeFactory$TypeScopeImpl  (id=3423)	
		uniqueKeyPropertyName	null	
		unwrapProxy	false	

/ we zien associated...	, dus de associatedIdentifierType is de type van de id van de associatedEntityName	, LongType	, dit is dus de type van de H. id	, te vinden in de entityEntry	,
/s
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 249	

			// property-ref, which might not be initialized
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
					getAssociatedEntityName(),
					value,
					session
			);
/s
ForeignKeys.getEntityIdentifierIfNotUnsaved(String, Object, SessionImplementor) line: 284	

			Serializable id = session.getContextEntityIdentifier( object );
/s
			EntityEntry entry = persistenceContext.getEntry(object);
			return entry != null ? entry.getId() : null;

/t
		return id;
/t
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 254	

			return getIdentifierType( session ).disassemble( id, session, owner );
/=
		final Type type = associatedIdentifierType;
/ en dan gewoon 	,
LongType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	

/t
PersistentSet.disassemble(CollectionPersister) line: 363	
	public Serializable disassemble(CollectionPersister persister) throws HibernateException {
		while ( itr.hasNext() ) {
			result[i++] = persister.getElementType().disassemble( itr.next(), getSession(), null );
/D
/ volgende Employee#2	, ook	,

		return result;
result	Serializable[2]  (id=3419)	
	[0]	Long  (id=3531)	
		value	1	
	[1]	Long  (id=3532)	
		value	2	
///////////////////////////////// 
/ Dit gaat -> 2c	,

/t
CollectionCacheEntry.<init>(PersistentCollection, CollectionPersister) line: 47	
		this.state = collection.disassemble( persister );

/ Bij CacheEntry heette deze disassembledState	,

/t
CollectionLoadContext.addCollectionToCache(LoadingCollectionEntry, CollectionPersister) line: 369	

		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
/ D
		final CacheKey cacheKey = session.generateCacheKey( lce.getKey(), persister.getKeyType(), persister.getRole() );
		if (isPutFromLoad) {
			try {
				session.getEventListenerManager().cachePutStart();
				final boolean put = persister.getCacheAccessStrategy().putFromLoad(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						session.getTimestamp(),
						version,
						factory.getSettings().isMinimalPutsEnabled() && session.getCacheMode()!= CacheMode.REFRESH
				);

/t
Main.testBasicUsage() line: 175	
	        Iterator< Employee>iterator=employees.iterator();
	        while(iterator.hasNext()){
        		Employee e=iterator.next();
/ Dit kan nu	, omdat finishLoadingCollections( context )

/ 7	. 

/ 2de keer .iterator	,

			session = sessionFactory.openSession();
			tx=session.beginTransaction();

			address=(Address)session.get(Address.class, 12l);
	        employees=address.getEmployees();
/ leeg	,
	        iterator=employees.iterator();
/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	

		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry( collection );
/ 1c	,
		if ( !collection.wasInitialized() ) {
/ JA
/ Naar 2c	,
			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
/s
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 159	
		final CacheKey ck = source.generateCacheKey( id, persister.getKeyType(), persister.getRole() );
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	CollectionCacheEntry  (id=3384)	
	state	Serializable[2]  (id=3385)	
		[0]	Long  (id=3388)	
			value	2	
		[1]	Long  (id=3389)	
			value	1	
/ uit 2c	,

		CollectionCacheEntry cacheEntry = (CollectionCacheEntry) persister.getCacheEntryStructure().destructure(
				ce,
				factory
		);
/ ==ce

		final PersistenceContext persistenceContext = source.getPersistenceContext();
		cacheEntry.assemble( collection, persister, persistenceContext.getCollectionOwner( id, persister ) );
id=Long 12	,
/s
StatefulPersistenceContext.getCollectionOwner(Serializable, CollectionPersister) line: 694	


		final EntityPersister ownerPersister = collectionPersister.getOwnerEntityPersister();
		if ( ownerPersister.getIdentifierType().getReturnedClass().isInstance( key ) ) {
			return getEntity( session.generateEntityKey( key, collectionPersister.getOwnerEntityPersister() ) );
/=
		return entitiesByKey.get( key );
/ uit 1c	,

/t
/s
CollectionCacheEntry.assemble(PersistentCollection, CollectionPersister, Object) line: 75	

		collection.initializeFromCache( persister, state, owner );
/s
PersistentSet.initializeFromCache(CollectionPersister, Serializable, Object) line: 146	
/=
	public void initializeFromCache(CollectionPersister persister, Serializable disassembled, Object owner)

/ disassembled=[Long 1, Long 2]

		beforeInitialize( persister, size );
/ coll's set=new HashSet, size 2	,

		for ( Serializable arrayElement : array ) {
			final Object assembledArrayElement = persister.getElementType().assemble( arrayElement, getSession(), owner );
/s
ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 272	

		Serializable id = assembleId( oid, session );
/ TODO

			return resolveIdentifier( id, session );
/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 712	

		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 423	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
/s
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=3423)	
	disassembledState	Serializable[3]  (id=3424)	
		[0]	"Foo1A" (id=3425)	
		[1]	Double  (id=3426)	
		[2]	BackrefPropertyAccessor$1  (id=3427)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Employee" (id=3385)	

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
/==ce
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )

		final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );

			final Type[] types = subclassPersister.getPropertyTypes();
			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ TODO (Afmaken)

/ 7	. 

	.get(Address.class, 12l)
	.iterator

/ wat gebeurt er met de Long 12	, de laatste disassembled ?  Hij komt in de coll entry in de 1c,	 
/ .iterator uses deze coll entry uit de 1c	,


/ hetzelfde als hierboven met de 2 Employee , nadat we de 2 id's uit de 2c (coll entry in 2c)	,

/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	

		entity = loadFromSecondLevelCache( event, persister, options );
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 599	

		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=91)	
	disassembledState	Serializable[4]  (id=94)	
		[0]	"foostreet" (id=100)	
		[1]	"12 foo" (id=101)	
		[2]	"FooCityA" (id=102)	
		[3]	Long  (id=103)	
	subclass	"my.test.own.hibernate_xml_1_N_ehcache.Address" (id=96)	

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
/ ==ce
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 678	

			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )

		final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );
/ for in 1c	,

			final Type[] types = subclassPersister.getPropertyTypes();
			// initializes the entity by (desired) side-effect
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/s
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 163	

		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 109	

			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/s
SetType(CollectionType).assemble(Serializable, SessionImplementor, Object) line: 296	

			final Serializable key = (Serializable) getPersister(session)
					.getKeyType()
					.assemble( cached, session, owner);
Long 12
			return resolveKey( key, session, owner );
/s
			getCollection( key, session, owner );
/s
SetType(CollectionType).getCollection(Serializable, SessionImplementor, Object) line: 748	

				collection = instantiate( session, persister, key );
/ dus de laatste disassembled , Long 12	, verschijnt in de coll	,

				persistenceContext.addUninitializedCollection( persister, collection, key );
/ 1c	,
/ dus de laatste disassembled , Long 12	, verschijnt in de coll	entry in 1c,
/ Deze wordt used in .iterator	,
/////////////////////////////////////////////////////////////

/t
StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 187	

		final Object[] assembledProps = TypeHelper.assemble(
				disassembledState,
				persister.getPropertyTypes(),
				session, instance
		);
/D
/ De laatste is de PersistentSet, initialized=false

		persister.setPropertyValues( instance, assembledProps );
/ gewoon	, de coll wordt set	,

/ 	.iterator	,

/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 92	

		CollectionEntry ce = source.getPersistenceContext().getCollectionEntry( collection );
ce	CollectionEntry  (id=3334)	
	loadedKey	Long  (id=3335)	
12
	loadedPersister	OneToManyPersister  (id=3336)	
	role	"my.test.own.hibernate_xml_1_N_ehcache.Address.employees" (id=3337)	
	snapshot	HashMap<K,V>  (id=3355)	
/ TODO

/ we zien de 4de disassembled prop van de 2c van de Address inst	,

			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
/ we zien de 4de disassembled prop van de 2c van de Address inst weer	, ce.getLoadedKey()

				ce.getLoadedPersister().initialize( ce.getLoadedKey(), source );

/ we zien de 4de disassembled prop van de 2c van de Address inst weer	, ce.getLoadedKey()
/s
OneToManyPersister(AbstractCollectionPersister).initialize(Serializable, SessionImplementor) line: 693	
/=
	public void initialize(Serializable key, SessionImplementor session) throws HibernateException {

/ key=de disassembled prop van de 2c van de Address inst weer   ,

		getAppropriateInitializer( key, session ).initialize( key, session );

/ de 1ste key wordt niet echt used	,
/s
CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 87	
/=
	public void initialize(Serializable id, SessionImplementor session)

		final Serializable[] ids = new Serializable[]{id};
		try {
			final QueryParameters qp = new QueryParameters();
			qp.setPositionalParameterTypes( new Type[]{ collectionPersister.getKeyType() } );
			qp.setPositionalParameterValues( ids );
			qp.setCollectionKeys( ids );

/ we zien dat de de disassembled prop van de 2c van de Address inst weer in de coll-query komt als param	,

/ TODO (Afmaken)

/ TODO( Wanneer de coll in 1c update	, want na .get(Address.class,12l) is hij er in 1c, maar is leeg	,)


/ HIER HIER 




/ Einde COLLECTIONS FROM 1C, 2C

/ COLLECTIONS BIDIR TO 1C, 2C

/ de set in address blijft inverse="false"	, 
/ voor bidr moeten aan Employee.class een prop add: Address address	, met getters/setters	, en in Address.hbm.xml 	,
	
	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		insert="false"
		update="false"
	></many-to-one>
/ TODO





/ Einde COLLECTIONS BIDIR TO 1C, 2C

/ N_1 1C, 2C


/ In hibernate_xml_N_1_ehcache	,

/ 7	.

/ Facts	,

/ Main	,

/ 13	.

/ session open	, 
			session.save(address);
			session.save(employee);
/ session close	,

/ 2de session open	, 

		  	employee= (Employee) session.get(Employee.class, 1l);

/ employee.address=proxy, initialized=false, target=null	,

		  	String zip=employee.getAddress().getZipcode();
/ of
		  	address=(Address)session.get(Address.class, 12l);

/ address=deze proxy, maar dan initialized=true	, target=Address inst	,
/ employee.address=deze proxy, 

/ 13	. 

/ we draaien de volgorde om in de 2de session	,

/ 2de session open	, 

		  	address=(Address)session.get(Address.class, 12l);
/ Address inst	,
		  	employee= (Employee) session.get(Employee.class, 1l);
/ Employee inst	, de address prop is GEEN proxy, maar is de Address inst	,

/ 13	. 

/ meer detail	, de 1ste, dus eerst .get employee , dan .get address	,

/ 2de session open	, 

		  	employee= (Employee) session.get(Employee.class, 1l);

employee	Employee  (id=39)	
	address	Address_$$_jvst4d7_1  (id=49)	
		handler	JavassistLazyInitializer  (id=68)	
			id	Long  (id=106) 		12	
			initialized	false
			persistentClass	Class<T> (my.test.own.hibernate_xml_N_1_ehcache.Address) (id=47)	
			target 				null	
	id	1	
	name	"Foo1A" (id=55)	
	salary	1.0	
		  	address=(Address)session.get(Address.class, 12l);

employee	Employee  (id=39)	
	address	Address_$$_jvst4d7_1  (id=49)	
		handler	JavassistLazyInitializer  (id=68)	
			id	Long  (id=106) 		12	
			initialized	true	
			persistentClass	Class<T> (my.test.own.hibernate_xml_N_1_ehcache.Address) (id=47)	
			target 		Address	
	id	1	
	name	"Foo1A" (id=55)	
	salary	1.0	

address is dezelfde proxy	,

/ session close	,

/ 7	. 

/ Source code	,

/ unidir N-1	, de Employee heeft prop address	, de Address has no Set	,

			session.save(address);
/ OK, primitive props	,
			session.save(employee);
/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getPropertyValuesToInsert(Object, Map, SessionImplementor) line: 623	

		for ( int j = 0; j < span; j++ ) {
			result[j] = getters[j].getForInsert( entity, mergeMap, session );
this	PojoEntityTuplizer  (id=3020)	
	getters	Getter[3]  (id=3021)	
		[0]	BasicPropertyAccessor$BasicGetter  (id=3024)	
		[1]	BasicPropertyAccessor$BasicGetter  (id=3025)	
BasicGetter(my.test.own.hibernate_xml_N_1_ehcache.Employee.salary)
		[2]	BasicPropertyAccessor$BasicGetter  (id=3026)	
BasicGetter(my.test.own.hibernate_xml_N_1_ehcache.Employee.address)
/s
/ laatste	,
BasicPropertyAccessor$BasicGetter.getForInsert(Object, Map, SessionImplementor) line: 204	
			return get( target );
/s
		public Object get(Object target) throws HibernateException {
			try {
				return method.invoke( target, (Object[]) null );
/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 268	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
values	Object[3]  (id=3109)	
	[0]	"Foo1" (id=3114)	
	[1]	Double  (id=3117)	
	[2]	Address  (id=2980)	
		addressLine1	"foostreet" (id=3675)	
		city	"FooCity12" (id=3676)	
		id	12	
		zipcode	"12 foo" (id=3677)	
/ -> 1c

		Type[] types = persister.getPropertyTypes();
types	Type[3]  (id=3140)	
	[0]	StringType  (id=2990)	
	[1]	DoubleType  (id=3171)	
	[2]	ManyToOneType  (id=3172)	
		associatedEntityName	"my.test.own.hibernate_xml_N_1_ehcache.Address" (id=3306)	
		associatedEntityPersister	SingleTableEntityPersister  (id=2965)	
		associatedIdentifierType	LongType  (id=3307)	
		eager	false	
		ignoreNotFound	false	
		isEmbeddedInXML	true	
		isLogicalOneToOne	false	
		referenceToPrimaryKey	true	
		returnedClass	null	
		scope	TypeFactory$TypeScopeImpl  (id=3404)	
 		uniqueKeyPropertyName	null	
		unwrapProxy	false	


/ 7	.

	tx.commit()
/s
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	

				flushEverythingToExecutions( event );
/ creates entityupdateaction's op de Address, Employee	,

				performExecutions( source );
/s
			session.getActionQueue().executeActions();
/s
/ eerst insert list	,
			for ( E e : list ) {
					e.execute();
/ eerst Address	,
/s
EntityInsertAction.execute() line: 134	

			persister.insert( id, getState(), instance, session );
/ dehydrate OK,	 alleen primitive types	,

HibernateLog --> 14:17:37 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 14:17:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 14:17:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 14:17:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 14:17:37 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

			final CacheKey ck = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );
/ disassemble OK	, alleen primitive types	,

/ we zien	,
ce	StandardCacheEntryImpl  (id=3845)	
	disassembledState	Serializable[3]  (id=3849)	
		[0]	"foostreet" (id=3675)	
		[1]	"12 foo" (id=3677)	
		[2]	"FooCity12" (id=3676)	
	subclass	"my.test.own.hibernate_xml_N_1_ehcache.Address" (id=3306)	



/ Dan de update list	,
			for ( E e : list ) {
				try {
					e.execute();
/s

/ Eerst Address	update 	,

EntityUpdateAction.execute() line: 147	

			ck = session.generateCacheKey(
					id, 
					persister.getIdentifierType(), 
					persister.getRootEntityName()
			);
			lock = persister.getCacheAccessStrategy().lockItem( ck, previousVersion );

			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
/s
				update = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( updateBatchKey )
						.getBatchStatement( sql, callable );
				index = dehydrate( id, fields, rowId, includeProperty, propertyColumnUpdateable, j, update, session, index, true );
/ fields zijn primitives	,

/ we zien	,
Hibernate: update address set address_line1__=?, zipcode__=?, city__=? where id__=?
HibernateLog --> 15:00:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 15:00:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 15:00:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCityA]
HibernateLog --> 15:00:43 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]

				final CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
ce	StandardCacheEntryImpl  (id=3959)	
	disassembledState	Serializable[3]  (id=3960)	
		[0]	"foostreet" (id=3675)	
		[1]	"12 foo" (id=3677)	
		[2]	"FooCityA" (id=3813)	
	subclass	"my.test.own.hibernate_xml_N_1_ehcache.Address" (id=3306)	


/ De volgende, 	een Employee update	,
/t
EntityUpdateAction.execute() line: 147	

		if ( persister.hasCache() ) {
			ck = session.generateCacheKey(
					id, 
					persister.getIdentifierType(), 
					persister.getRootEntityName()
			);
			lock = persister.getCacheAccessStrategy().lockItem( ck, previousVersion );

			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
/s
SingleTableEntityPersister(AbstractEntityPersister).update(Serializable, Object[], Object[], Object, boolean[], int, Object, Object, String, SessionImplementor) line: 3245	
/=
	protected boolean update(
			final Serializable id,
			final Object[] fields,
			final Object[] oldFields,
			final Object rowId,
			final boolean[] includeProperty,
			final int j,
			final Object oldVersion,
			final Object object,
			final String sql,
			final SessionImplementor session) throws HibernateException {

				update = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( updateBatchKey )
						.getBatchStatement( sql, callable );
			}
				//Now write the values of fields onto the prepared statement
				index = dehydrate( id, fields, rowId, includeProperty, propertyColumnUpdateable, j, update, session, index, true );

/ fields=updateentityaction.state	, 
state	Object[3]  (id=3819)	
	[0]	"Foo1A" (id=3820)	
	[1]	Double  (id=3821)	
	[2]	Address  (id=2980)	
/ Dit is vlak voor de schedule met .getValues() queried aan de obj	,

/s
	for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
this	SingleTableEntityPersister  (id=3019)	
	entityMetamodel	EntityMetamodel  (id=3040)	
		propertyTypes	Type[3]  (id=3140)	
			[0]	StringType  (id=2990)	
			[1]	DoubleType  (id=3171)	
			[2]	ManyToOneType  (id=3172)	
				associatedEntityName	"my.test.own.hibernate_xml_N_1_ehcache.Address" (id=3306)	
				associatedEntityPersister	SingleTableEntityPersister  (id=2965)	
				associatedIdentifierType	LongType  (id=3307)	
				eager	false	
				ignoreNotFound	false	
				isEmbeddedInXML	true	
				isLogicalOneToOne	false	
				referenceToPrimaryKey	true	
				returnedClass	null	
				scope	TypeFactory$TypeScopeImpl  (id=3404)	
				uniqueKeyPropertyName	null	
				unwrapProxy	false	
/s
/ de laatste	,
ManyToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 165	
		getIdentifierOrUniqueKeyType( session.getFactory() )
				.nullSafeSet( st, getIdentifier( value, session ), index, settable, session );
/s
ManyToOneType(EntityType).getIdentifierOrUniqueKeyType(Mapping) line: 672	
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
			return getIdentifierType(factory);
/=
		final Type type = associatedIdentifierType;
type	LongType  (id=3307)	
	dictatedSize	Size  (id=4620)	
	javaTypeDescriptor	LongTypeDescriptor  (id=4622)	
	sqlTypeDescriptor	BigIntTypeDescriptor  (id=4624)	
	sqlTypes	(id=4626	-5

/t
/s

/ Wat dehydrate doet met de Address prop in de Employee: maakt er de id Long 12 van de Address van	,
/ ManyToOne.disassemble doet hetzelfde	, ook ForeignKeys.getEntityIdentifierIfNotUnsaved	,
///////////////////////////////////// 

ManyToOneType(EntityType).getIdentifier(Object, SessionImplementor) line: 532	
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {

			return ForeignKeys.getEntityIdentifierIfNotUnsaved( getAssociatedEntityName(), value, session ); //tolerates nulls

/s
ForeignKeys.getEntityIdentifierIfNotUnsaved(String, Object, SessionImplementor) line: 288	
		else {
			Serializable id = session.getContextEntityIdentifier( object );
/ object=fields[2]	, =entitytupdateaction.state[2] ,
/ is key in entity entries in 1c	,
/s
			EntityEntry entry = persistenceContext.getEntry(object);
			return entry != null ? entry.getId() : null;

/t
ManyToOneType(EntityType).getIdentifier(Object, SessionImplementor) line: 537	
		if ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {
			return ForeignKeys.getEntityIdentifierIfNotUnsaved( getAssociatedEntityName(), value, session ); //tolerates nulls
/t
ManyToOneType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 165	
		getIdentifierOrUniqueKeyType( session.getFactory() )
				.nullSafeSet( st, getIdentifier( value, session ), index, settable, session );
/s
LongType(AbstractSingleColumnStandardBasicType<T>).nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 55	
			nullSafeSet( st, value, index, session );
/ sets a Long in de st	, OK


/t
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2855	
		if ( !isUpdate ) {
/ NEE
			index += dehydrateId( id, rowId, ps, session, index );

		if ( isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );
/ WH voor where id=?	,

/t
EntityUpdateAction.execute() line: 207	

			persister.update( 
					id, 
					state, 
					dirtyFields, 
					hasDirtyCollection, 
					previousState, 
					previousVersion, 
					instance, 
					rowId, 
					session 
			);
/D

				final CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
/s
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/s
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 145	

types	Type[3]  (id=3140)	
	[0]	StringType  (id=2990)	
	[1]	DoubleType  (id=3171)	
	[2]	ManyToOneType  (id=3172)	
		associatedEntityName	"my.test.own.hibernate_xml_N_1_ehcache.Address" (id=3306)	
		associatedEntityPersister	SingleTableEntityPersister  (id=2965)	
		associatedIdentifierType	LongType  (id=3307)	
		eager	false	
		ignoreNotFound	false	
		isEmbeddedInXML	true	
		isLogicalOneToOne	false	
		referenceToPrimaryKey	true	
		returnedClass	null	
		scope	TypeFactory$TypeScopeImpl  (id=3404)	
		uniqueKeyPropertyName	null	
		unwrapProxy	false	

		for ( int i = 0; i < row.length; i++ ) {
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
/s
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 239	

		else {
			// cache the actual id of the object, not the value of the
			// property-ref, which might not be initialized
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
					getAssociatedEntityName(),
					value,
					session
			);
///////////////////////////////////////////
/ Hetzelfde als ManyToOne.dehydrate 	,

			return getIdentifierType( session ).disassemble( id, session, owner );
/s
LongType(AbstractStandardBasicType<T>).disassemble(Object, SessionImplementor, Object) line: 326	
/ OK

/t
EntityUpdateAction.execute() line: 208	
				final CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
/D
				this.cacheEntry = persister.getCacheEntryStructure().structure( ce );
/ zo komt ce in deze update action	,

/t
JdbcTransaction(AbstractTransactionImpl).commit() line: 182	
		beforeTransactionCommit();
/D
			doCommit();
/ db tx commit	,
			afterTransactionCompletion( Status.STATUS_COMMITTED );
/ -> 2c



















 











/ Einde N_1 1C, 2C

/ BIDIR 1C, 2C


/ Main	,
			employee.setAddress(address);
			address.getEmployees().add(employee);
			employee2.setAddress(address);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);

/ 7	.

/ Address.hbm.xml

	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="false"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee.hbm.xml

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"			
	>
	</many-to-one>

/ Let op	,
 		<key
 			not-null="false"
/ is OK	,
/ Wat ook kan is	,
 		<key
 			not-null="true"
/ en dan in Employee's mapping	,
		<many-to-one insert="false" update="false">

/ we zien	,

Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 08:34:23 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]
HibernateLog --> 08:34:23 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]
HibernateLog --> 08:34:23 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
HibernateLog --> 08:34:23 DEBUG org.hibernate.SQL - update employee set address_=? where id_=?
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:34:23 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]


/ als we in Address.hbm.xml's <key not-null="true"> dan	start appl niet eens op	, (in Employee's mapping <key not-null="true"/"false">

org.hibernate.MappingException: Repeated column in mapping for entity: my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee column: address_ (should be mapped with insert="false" update="false")

/ 7	.

/ Address.hbm.xml	,

	<set
 		name="employees"
 		inverse="true"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true/false"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee.hbm.xml	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	>
	</many-to-one>

/ Let op	,
 		<key
 			not-null="true/false"


/ we zien	,

HibernateLog --> 08:51:01 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 08:51:01 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]
HibernateLog --> 08:51:01 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 08:51:01 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]

/ 7	. 

/ Address' mapping	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="alt_address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Let op	,
 		<key
 			column="alt_address_"
			not-null="true"

/ Employee's mapping	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	>
	</many-to-one>

/ Als we	,
 		<key
 			column="alt_address_"
			not-null="false"
/ dan zien we de alt_address_ helemaal niet (zie hieronder)	,

/we zien	,

HibernateLog --> 09:02:39 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 09:02:39 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, alt_address_, id_) values (?, ?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, alt_address_, id_) values (?, ?, ?, ?, ?)
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [BIGINT] - [1]
HibernateLog --> 09:02:39 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, alt_address_, id_) values (?, ?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, alt_address_, id_) values (?, ?, ?, ?, ?)
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [BIGINT] - [2]
HibernateLog --> 09:02:39 DEBUG org.hibernate.SQL - update employee set alt_address_=? where id_=?
Hibernate: update employee set alt_address_=? where id_=?
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]
HibernateLog --> 09:02:39 DEBUG org.hibernate.SQL - update employee set alt_address_=? where id_=?
Hibernate: update employee set alt_address_=? where id_=?
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:02:39 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]

/ als we  in Address' mapping	, <key not-null="false"> 	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="alt_address_"
 			not-null="false"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ dan zien we	,

HibernateLog --> 09:09:42 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, id__) values (?, ?, ?, ?)
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [12]
HibernateLog --> 09:09:42 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]
HibernateLog --> 09:09:42 DEBUG org.hibernate.SQL - insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo2]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [2.0]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [2]
HibernateLog --> 09:09:42 DEBUG org.hibernate.SQL - update employee set alt_address_=? where id_=?
Hibernate: update employee set alt_address_=? where id_=?
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [2]
HibernateLog --> 09:09:42 DEBUG org.hibernate.SQL - update employee set alt_address_=? where id_=?
Hibernate: update employee set alt_address_=? where id_=?
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 09:09:42 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [1]

/ 7	.

/ Address' mapping to H	,
	<set
 		name="employees"
 		inverse="false"				/ (0)
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true" 		/ (1)
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee's mapping to H	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"				/ (2)
	>
	</many-to-one>

/ 13	. 

/ bij (0) false

/ als we bij (1) true	,  (en bij (2) true/false 	,dan 
org.hibernate.MappingException: Repeated column in mapping for entity: my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee column: address_ (should be mapped with insert="false" update="false")
/ we moeten bij 2 insert="false" , update="false"

/ 13	.

/ als we bij (1) false	, en bij (2) zo	, dan OK	,  we zien de gewone owner=set-queries	,

/ 13	.

/ als we bij (1)
 		<key
 			column="alt_address_"
 			not-null="true" 		/ (1)
/ dan OK, we zien de gewone owner=set-queries, maar met extra column alt_address_	,

/ 13	.

/ 7	.

///////////////////////////////////////////////////////////


/ 13	.

/ Address' mapping	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee's mapping	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		update="false"
		insert="false"
	>
	</many-to-one>

/ Main	,

			//employee.setAddress(address);
			//employee2.setAddress(address);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);
/ OK

/ 13	. 

/ Address' mapping	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="false"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee's mapping	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	>
	</many-to-one>


/ Main	,

			//employee.setAddress(address);
			//employee2.setAddress(address);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
/ ERR	,
org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee.address

/ Maar 	,

			employee.setAddress(address);
			employee2.setAddress(address);
//			address.getEmployees().add(employee);
//			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);
/ OK
/ TODO (<set inverse="false"	, maar toch als <set inverse="true")

/ 13		,

/ Address' mapping	,
	<set
 		name="employees"
 		inverse="true"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

Employee's mapping	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
	>
	</many-to-one>

Main	,

			employee.setAddress(address);
			employee2.setAddress(address);
//			address.getEmployees().add(employee);
//			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);
/ OK

/ Het maakt niet uit of <many-to-one not-null="true"/"false">	, wel is het zo dat er dan in de employee tbl de constraint er wel/niet is	, maar voor H maakt het niet uit	,


/ maar	,

                        //employee.setAddress(address);
                        //employee2.setAddress(address);
                      	address.getEmployees().add(employee);
                      	address.getEmployees().add(employee2);

                        session.save(address);
                        session.save(employee);
/ ERR	,
org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee.address



/ Einde BIDIR 1C, 2C

/ DEBUG 1_N BIDIR 1C, 2C OK

/ 7	.

/ Address' mapping	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>
	
/ Employee's mapping	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		update="false"
		insert="false"
	>
	</many-to-one>

/ Main	,

/*			employee.setAddress(address);
			employee2.setAddress(address);
*/			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);

/ Debug	,

/ 13	,

Main.setUp() line: 72	

        	Configuration configuration=new Configuration().configure();
/ WH hbm.xml files niet parsed	,
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
/ Step over	,
    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);


/ SECONDPASSCOMPILE
/ Beneden: DOUBLE ROLE <KEY NOT-NULL="TRUE">
/ Beneden: SAMENVATTING ROOTCLASS 


	HbmBinder$CollectionSecondPass.secondPass(Map, Map) line: 2815	
		HbmBinder.bindCollectionSecondPass(
					node,
					collection,
					persistentClasses,
					mappings,
					inheritedMetas
		);
	HbmBinder$CollectionSecondPass(CollectionSecondPass).doSecondPass(Map) line: 70	
	Configuration.originalSecondPassCompile() line: 1695	
	Configuration.secondPassCompile() line: 1424	
	Configuration.buildSessionFactory(ServiceRegistry) line: 1844	
	Main.setUp() line: 75	
	Main.<init>() line: 63	
	Main.main(String[]) line: 58	


/s
ConnectionProviderInitiator.initiateService(Map, ServiceRegistryImplementor) line: 140	
		if ( connectionProvider == null ) {
			if ( configurationValues.get( Environment.URL ) != null ) {
				connectionProvider = new DriverManagerConnectionProviderImpl();

A connection provider that uses the java.sql.DriverManager directly to open connections and provides a very rudimentary connection pool.

IMPL NOTE : not intended for production use!

Thanks to Oleg Varaksin and his article on object pooling using the java.util.concurrent package, from which much of the pooling code here is derived. See http://ovaraksin.blogspot.com/2013/08/simple-and-lightweight-pool.html

/ 13	,

Configuration.buildSessionFactory(ServiceRegistry) line: 1844	

		buildTypeRegistrations( serviceRegistry );
/ Niet xml parsings	,
		secondPassCompile();
/s
Configuration.secondPassCompile() line: 1410	
/ eerst	,
			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/ dan	,
			originalSecondPassCompile();

/ 13	. 

                        metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/s
Configuration$MetadataSourceQueue.processMetadata(List<MetadataSourceType>) line: 3739	

					processHbmXmlQueue();
/s
HbmBinder.bindPersistentClassCommonValues(Element, PersistentClass, Mappings, Map) line: 667	

		Attribute dynamicNode = node.attribute( "dynamic-update" );
		entity.setDynamicUpdate(
				dynamicNode != null && "true".equals( dynamicNode.getValue() )
		);

/ WH PersistentClass entity -> perister	,


/ 13	.

HbmBinder.bindRootClass(Element, RootClass, Mappings, Map) line: 326	
		bindRootPersistentClassCommonValues( node, inheritedMetas, mappings, rootClass );
/s
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 382	
/ WH parse hbm.xml	,

/ 13	.

HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1131	

			if ( column.isUnique() && ManyToOne.class.isInstance( simpleValue ) ) {
				( (ManyToOne) simpleValue ).markAsLogicalOneToOne();
			}
/ TODO

/ 13	.

HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 411	

		Iterator subnodes = node.elementIterator();
		while ( subnodes.hasNext() ) {

			Element subnode = (Element) subnodes.next();
			String name = subnode.getName();

			if ( "id".equals( name ) ) {
				// ID
				bindSimpleId( subnode, entity, mappings, inheritedMetas );
			}
/D
/ parses id	,
		createClassProperties( node, entity, mappings, inheritedMetas );
/ parses properties	, ...
/s
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2246	

/s
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1193	
		bindSimpleValueType( node, simpleValue, mappings );
/ NIETS	, we geven in xml nooit type attr	,
		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );

/ 13	.

HbmBinder.bindProperty(Element, Property, Mappings, Map) line: 1350	
 parses property's xml	,

/ 13	.

HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2315	

				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
////////////////////////////////////
/ Hier wordt een H prop create	, die we in de 1c set	,

/s
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2374	

		Property prop = new Property();
		prop.setValue( value );
		bindProperty( subnode, prop, mappings, inheritedMetas );
/ alle attrs	,	


/ 13	.

/ Intermezzo

       <set
                name="employees"
                inverse="false"
                >
                <cache usage="read-write"/>
                <key
                        column="address_"
                        not-null="true"
                ></key>
                <one-to-many class="Employee"/>
        </set>


/ EInde Intermezzo

HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2220	

		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
			String name = subnode.getName();
			String propertyName = subnode.attributeValue( "name" );
name	"set" (id=2248)	
propertyName	"employees" (id=2249)	

			CollectionType collectType = CollectionType.collectionTypeFromString( name );
xmlTagName	"set" (id=1615)	
				Collection collection = collectType.create(
						subnode,
						StringHelper.qualify( entityName, propertyName ),
						persistentClass,
						mappings, inheritedMetas
					);
/s
HbmBinder$CollectionType$2.create(Element, String, PersistentClass, Mappings, Map) line: 2912	
		private static final CollectionType SET = new CollectionType( "set" ) {
			public Collection create(Element node, String path, PersistentClass owner,
					Mappings mappings, java.util.Map inheritedMetas) throws MappingException {

				Set set = new Set( mappings, owner );
/ org.hibernate.mapping.Set extends org.hibernate.mapping.Collection extends Object
				bindCollection( node, set, owner.getEntityName(), path, mappings, inheritedMetas );
/s
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1390	

		collection.setRole(path);
path	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employees" (id=1630)	

		Attribute inverseNode = node.attribute( "inverse" );
		if ( inverseNode != null ) {
			collection.setInverse( "true".equals( inverseNode.getValue() ) );
false
		String nodeName = node.attributeValue( "node" );
null
		if ( nodeName == null ) nodeName = node.attributeValue( "name" );
		collection.setNodeName( nodeName );
nodeName	"employees" (id=1616)	

		// FETCH STRATEGY
		initOuterJoinFetchSetting( node, collection );
/ collection is de Set	,
/s
HbmBinder.initOuterJoinFetchSetting(Element, Fetchable) line: 2094	
				else {
					fetchStyle = FetchMode.DEFAULT;
/ TODO
		model.setFetchMode( fetchStyle );
		model.setLazy(lazy);
/ model is de Set	,

/t
HbmBinder.bindCollection(Element, Collection, String, String, Mappings, Map) line: 1477	
		initOuterJoinFetchSetting( node, collection );
/D
		Element oneToManyNode = node.element( "one-to-many" );
		if ( oneToManyNode != null ) {
			OneToMany oneToMany = new OneToMany( mappings, collection.getOwner() );
			collection.setElement( oneToMany );
			bindOneToMany( oneToManyNode, oneToMany, mappings );
/s
HbmBinder.bindOneToMany(Element, OneToMany, Mappings) line: 1766	

/ herinner	,
                <one-to-many class="Employee"/>

		oneToMany.setReferencedEntityName( getEntityName( node, mappings ) );
/=
		return entityName == null ? getClassName( elem.attribute( "class" ), model ) : entityName;
referencedEntityName	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Employee" (id=1737)	

		else {
			mappings.addSecondPass( new CollectionSecondPass( node, mappings, collection, inheritedMetas ) );
/s
				secondPasses.add( sp );
sp	HbmBinder$CollectionSecondPass  (id=1743)	
	collection	Set  (id=1632)	
	localInheritedMetas	HashMap<K,V>  (id=1621)	
	mappings	Configuration$MappingsImpl  (id=1618)	
	node	DefaultElement  (id=1614)	


		collection.setReferencedPropertyName( node.element( "key" ).attributeValue( "property-ref" ) );
null

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2315	
				Collection collection = collectType.create(
						subnode,
						StringHelper.qualify( entityName, propertyName ),
						persistentClass,
						mappings, inheritedMetas
					);
/D
				mappings.addCollection( collection );
				value = collection;
				final Property property = createProperty(
						value,
Set
						propertyName,
employees
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
/s
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2350	

		value.setTypeUsingReflection( className, propertyName );
/s 
Set(Collection).setTypeUsingReflection(String, String) line: 441	
}
/ NIETS

		if ( value instanceof ToOne ) {
/ NEE
		else if ( value instanceof Collection ) {
			Collection coll = (Collection) value;
			String propertyRef = coll.getReferencedPropertyName();
null
			// not necessarily a *unique* property reference
			if ( propertyRef != null ) {
/ NEE

 		value.createForeignKey();
/ NIETS
		Property prop = new Property();
		prop.setValue( value );
/ value is geen SimpleValue, maar een Set	,
		bindProperty( subnode, prop, mappings, inheritedMetas );
/ subnode=<set ...>

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2246	
/D
/t
Configuration$MetadataSourceQueue.processHbmXmlQueue() line: 3751	
			for ( Map.Entry<XmlDocument, Set<String>> entry : hbmMetadataToEntityNamesMap.entrySet() ) {
				processHbmXml( entry.getKey(), entry.getValue() );
/ D
/ volgende	,
/s
Configuration$MetadataSourceQueue.processHbmXml(XmlDocument, Set<String>) line: 3759	
/s
HbmBinder.bindRootPersistentClassCommonValues(Element, Map, Mappings, RootClass) line: 411	
...
		createClassProperties( node, entity, mappings, inheritedMetas );
/s
		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {

        <many-to-one
                name="address"
                column="address_"
                not-null="true"
                insert="false"
                update="false"
        ></many-to-one>

			Element subnode = (Element) iter.next();
			String name = subnode.getName();
			String propertyName = subnode.attributeValue( "name" );
...
			else if ( "many-to-one".equals( name ) ) {
				value = new ManyToOne( mappings, table );
value	ManyToOne  (id=1983)	
	alternateUniqueKey	false	
	attributeConverterDefinition	null	
	cascadeDeleteEnabled	false	
	columns	ArrayList<E>  (id=1987)	
[org.hibernate.mapping.Column(address_)]
	embedded	false	
	fetchMode	FetchMode  (id=1660)	
	foreignKeyName	null	
	identifierGeneratorProperties	null	
	identifierGeneratorStrategy	"assigned" (id=1989)	
	ignoreNotFound	false	
	isLogicalOneToOne	false	
	lazy	true	
	mappings	Configuration$MappingsImpl  (id=1812)	
	nullValue	null	
	referencedEntityName	null	
	referencedPropertyName	null	
	referenceToPrimaryKey	true	
	table	Table  (id=1881)	
	type	null	
	typeName	null	
	typeParameters	null	
	unwrapProxy	false	
				bindManyToOne( subnode, (ManyToOne) value, propertyName, nullable, mappings );
/s
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1639	
		bindColumnsOrFormula( node, manyToOne, path, isNullable, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1126	
		// COLUMN(S)
		Attribute columnAttribute = node.attribute( "column" );
		if ( columnAttribute == null ) {
/ NEE
		else {
			Column column = new Column();
			column.setValue( simpleValue );
/ simpleValue is de ManyToOne	,
			bindColumn( node, column, isNullable );
/s
HbmBinder.bindColumn(Element, Column, boolean) line: 1783	
		Attribute nullNode = node.attribute( "not-null" );
		column.setNullable( nullNode == null ? isNullable : nullNode.getValue().equals( "false" ) );

			simpleValue.addColumn( column );
/ simpleValue is de ManyToOne	,

/t
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1640	
		bindColumnsOrFormula( node, manyToOne, path, isNullable, mappings );
/D
		initOuterJoinFetchSetting( node, manyToOne );
/s
HbmBinder.initOuterJoinFetchSetting(Element, Fetchable) line: 2134	
				else {
					fetchStyle = FetchMode.DEFAULT;
		model.setFetchMode( fetchStyle );
/ model is de ManyToOne	,
		model.setLazy(lazy);
/t
HbmBinder.bindManyToOne(Element, ManyToOne, String, boolean, Mappings) line: 1640	
		initOuterJoinFetchSetting( node, manyToOne );
/D
		initLaziness( node, manyToOne, mappings, true );
/ sets manyToOne.lazy=true

		manyToOne.setReferenceToPrimaryKey( manyToOne.getReferencedPropertyName() == null );
true
		manyToOne.setReferencedEntityName( getEntityName( node, mappings ) );
/ node=<many-to-one ...>
null
/ TODO

/t
HbmBinder.createClassProperties(Element, PersistentClass, Mappings, Map, UniqueKey, boolean, boolean, boolean) line: 2315	
			else if ( "many-to-one".equals( name ) ) {
				value = new ManyToOne( mappings, table );
				bindManyToOne( subnode, (ManyToOne) value, propertyName, nullable, mappings );
			}
/D
				final Property property = createProperty(
						value,
						propertyName,
						persistentClass.getClassName(),
						subnode,
						mappings,
						inheritedMetas
				);
		if ( value instanceof ToOne ) {
			ToOne toOne = (ToOne) value;
			String propertyRef = toOne.getReferencedPropertyName();
null

/t
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2371	

		if ( value instanceof ToOne ) {
/D
		value.createForeignKey();
/s
ManyToOne.createForeignKey() line: 60	
		if (referencedPropertyName==null && !hasFormula() ) {
/ JA
			createForeignKeyOfEntity( ( (EntityType) getType() ).getAssociatedEntityName() );
/s
ManyToOne.getType() line: 47	
/=
	public Type getType() throws MappingException {
		return getMappings().getTypeResolver().getTypeFactory().manyToOne(
				getReferencedEntityName(),
Address
				referenceToPrimaryKey, 
				getReferencedPropertyName(),
null
				isLazy(),
				isUnwrapProxy(),
				isIgnoreNotFound(),
				isLogicalOneToOne
		);
/s
TypeFactory.manyToOne(String, boolean, String, boolean, boolean, boolean, boolean) line: 364	
		return new ManyToOneType(
				typeScope,
				persistentClass,
				referenceToPrimaryKey,
true
				uniqueKeyPropertyName,
null
				lazy,
				unwrapProxy,
				ignoreNotFound,
				isLogicalOneToOne
		);
/t
ManyToOne.createForeignKey() line: 61	
			createForeignKeyOfEntity( ( (EntityType) getType() ).getAssociatedEntityName() );
/ (EntityType) getType() ).getAssociatedEntityName()=Address
/s
ManyToOne(SimpleValue).createForeignKeyOfEntity(String) line: 146	
		if ( !hasFormula() && !"none".equals(getForeignKeyName())) {
/ JA	, "none"!=null
			ForeignKey fk = table.createForeignKey( getForeignKeyName(), getConstraintColumns(), entityName );
/  getForeignKeyName()==null
/ getConstraintColumns()==[org.hibernate.mapping.Column(address_)]
/s
Table.createForeignKey(String, List, String) line: 651	
		return createForeignKey( keyName, keyColumns, referencedEntityName, null );
/s
Table.createForeignKey(String, List, String, List) line: 656	
		Object key = new ForeignKeyKey( keyColumns, referencedEntityName, referencedColumns );
/ keyColumns=[org.hibernate.mapping.Column(address_)]
/  referencedEntityName=Address
/ referencedColumns==null

		ForeignKey fk = (ForeignKey) foreignKeys.get( key );
		if ( fk == null ) {
			fk = new ForeignKey();
/ ForeignKey extends Constrained extends Object	,
			fk.setTable( this );
			fk.setReferencedEntityName( referencedEntityName );
Address
			fk.addColumns( keyColumns.iterator() );
[org.hibernate.mapping.Column(address_)]
			else {
				fk.setName( Constraint.generateName( fk.generatedConstraintNamePrefix(),
						this, keyColumns ) );

			foreignKeys.put( key, fk );
fk	ForeignKey  (id=2082)	
	cascadeDeleteEnabled	false	
	columns	ArrayList<E>  (id=2083)	
	name	"FK_lcwyx1va36145pv0w7f8dxqc8" (id=2085)	
	referencedColumns	ArrayList<E>  (id=2086)	
	referencedEntityName	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Address" (id=1623)	
	referencedTable	null	
	table	Table  (id=1881)	

/t
HbmBinder.createProperty(Value, String, String, Element, Mappings, Map) line: 2372	
		value.createForeignKey();
/D
		Property prop = new Property();
		prop.setValue( value );
/value=ManyToOne
		bindProperty( subnode, prop, mappings, inheritedMetas );
/ subnode=<many-to-one ...>
/s
HbmBinder.bindProperty(Element, Property, Mappings, Map) line: 1293	

		Attribute updateNode = node.attribute( "update" );
		property.setUpdateable( updateNode == null || "true".equals( updateNode.getValue() ) );

		Attribute insertNode = node.attribute( "insert" );
		property.setInsertable( insertNode == null || "true".equals( insertNode.getValue() ) );

////////////////////////////////////////
/ update, insert komen op de Property, maar not-null hierboven op de Column)	,
/ Klopt: not-null wordt een constrained in de db table, daarom op Column, en update, insert zijn voor H	, daarom op de Property	,

persistentClass	RootClass  (id=1822)	
	properties	ArrayList<E>  (id=2106)	
		elementData	Object[10]  (id=2112)	
			[0]	Property  (id=1973)	
			[1]	Property  (id=2113)	
			[2]	Property  (id=2095)	
				cascade	"none" (id=1885)	
				insertable	false						/ !
				lazy	false	
				lob	false	
				metaAttributes	HashMap<K,V>  (id=2114)	
				name	"address" (id=2115)	
				naturalIdentifier	false	
				nodeName	"address" (id=1980)	
				optimisticLocked	true	
				optional	false	
				persistentClass	RootClass  (id=1822)	
				propertyAccessorName	"property" (id=1884)	
				selectable	true	
				updateable	false						/ !
				value	ManyToOne  (id=1983)	
					columns	ArrayList<E>  (id=1987)	
						elementData	Object[10]  (id=2075)	
							[0]	Column  (id=2118)	
								checkConstraint	null	
								comment	null	
								customRead	null	
								customWrite	null	
								defaultValue	null	
								length	255	
								name	"address_" (id=1998)	
								nullable	false		/ !	
								precision	19	
								quoted	false	
								scale	2	
								sqlType	null	
								sqlTypeCode	null	
								typeIndex	0	
								unique	false	
								uniqueInteger	4	
								value	ManyToOne  (id=1983)	
						modCount	1	
						size	1	

/t
Configuration.secondPassCompile() line: 1424	
			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
/D
			originalSecondPassCompile();
/s
Configuration.originalSecondPassCompile() line: 1692	

		Iterator itr = secondPasses.iterator();
		while ( itr.hasNext() ) {
			SecondPass sp = (SecondPass) itr.next();
			if ( ! (sp instanceof QuerySecondPass) ) {
				sp.doSecondPass( classes );
/s
HbmBinder$CollectionSecondPass(CollectionSecondPass).doSecondPass(Map) line: 65	
this	HbmBinder$CollectionSecondPass  (id=1977)	
	collection	Set  (id=1949)	
	localInheritedMetas	HashMap<K,V>  (id=1943)	
	mappings	Configuration$MappingsImpl  (id=1942)	
	node	DefaultElement  (id=1938)	
/ node=<set ...>

		secondPass( persistentClasses, localInheritedMetas ); // using local since the inheritedMetas at this point is not the correct map since it is always the empty map
/s
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2552	

/ BINDCOLLECTIONSECCONDPASS

		if ( collection.isOneToMany() ) {
			OneToMany oneToMany = (OneToMany) collection.getElement();
			String assocClass = oneToMany.getReferencedEntityName();
Employee
			PersistentClass persistentClass = (PersistentClass) persistentClasses.get( assocClass );
RootClass (Employee)
			oneToMany.setAssociatedClass( persistentClass );
			collection.setCollectionTable( persistentClass.getTable() );
employee

		// contained elements:
		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
			Element subnode = (Element) iter.next();
			String name = subnode.getName();

			else if ( "cache".equals( name ) ) {
				collection.setCacheConcurrencyStrategy( subnode.attributeValue( "usage" ) );
read-write
				collection.setCacheRegionName( subnode.attributeValue( "region" ) );
null

/ volgende	,
			if ( "key".equals( name ) ) {
				KeyValue keyVal;
				String propRef = collection.getReferencedPropertyName();
				if ( propRef == null ) {
/ JA
					keyVal = collection.getOwner().getIdentifier();
org.hibernate.mapping.SimpleValue([org.hibernate.mapping.Column(id__)])
/=
keyVal	SimpleValue  (id=2085)	
	alternateUniqueKey	false	
	attributeConverterDefinition	null	
	cascadeDeleteEnabled	false	
	columns	ArrayList<E>  (id=2089)	
		elementData	Object[10]  (id=2094)	
			[0]	Column  (id=2098)	
				checkConstraint	null	
				comment	null	
				customRead	null	
				customWrite	null	
				defaultValue	null	
				length	255	
				name	"id__" (id=2100)	
				nullable	false	
				precision	19	
				quoted	false	
				scale	2	
				sqlType	null	
				sqlTypeCode	null	
				typeIndex	0	
				unique	true	
				uniqueInteger	1	
				value	SimpleValue  (id=2085)	
		modCount	1	
		size	1	
	foreignKeyName	null	
	identifierGeneratorProperties	null	
	identifierGeneratorStrategy	"assigned" (id=2090)	
	mappings	Configuration$MappingsImpl  (id=1942)	
	nullValue	"undefined" (id=2091)	
	table	Table  (id=1966)	
	type	null	
	typeName	"long" (id=2092)	
	typeParameters	null	

////////////////////////////////////////////////////////
/ een SimpleValue heeft de Column	, 

/ we gaan dus blijkbaar de Backref voor Employee in orde maken: pointer back	, naar id__ van Address	,

				SimpleValue key = new DependantValue( mappings, collection.getCollectionTable(), keyVal );
/ 	collection.getCollectionTable()=org.hibernate.mapping.Table(employee)
/ keyVal ~ Column(id___) van Address	,

				bindSimpleValue(
						subnode,
<key ...>
						key,
DependantValue
						collection.isOneToMany(),
						Collection.DEFAULT_KEY_COLUMN_NAME,
						mappings
					);
/s
HbmBinder.bindSimpleValue(Element, SimpleValue, boolean, String, Mappings) line: 1193	
		bindColumnsOrFormula( node, simpleValue, path, isNullable, mappings );
/s
HbmBinder.bindColumns(Element, SimpleValue, boolean, boolean, String, Mappings) line: 1128	
			Column column = new Column();
			column.setValue( simpleValue );
			bindColumn( node, column, isNullable );
/ not-null="true" -> column.nullable=false

			column.setName( columnName );
"address_"
				table.addColumn( column ); // table=null -> an association - fill
///////////////////////////////////////////
/ de db tbl krijgt inderdaad een column erbij	,

			simpleValue.addColumn( column );
/ simpleValue=DependantValue	,
/ column=org.hibernate.mapping.Column(address_)

/t
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2598	

				SimpleValue key = new DependantValue( mappings, collection.getCollectionTable(), keyVal );
				bindSimpleValue(
						subnode,
						key,
						collection.isOneToMany(),
						Collection.DEFAULT_KEY_COLUMN_NAME,
						mappings
					);
/D
				collection.setKey( key );
/ key=fk
////////////////////
key	DependantValue  (id=2248)	
	columns	ArrayList<E>  (id=2251)	
[org.hibernate.mapping.Column(address_)]
	wrappedValue	SimpleValue  (id=2085)	
		columns	ArrayList<E>  (id=2089)	
[org.hibernate.mapping.Column(id__)]

/ DOUBLE ROLE <KEY NOT-NULL="TRUE">

/ een column in een simplevalue heeft een value, maar dat is gewoon een pointer back, de simplevalue waar de column inzit	, 
/ de column in een dependantvalue heeft een wrappedvalue, dat is de simplevalue die de column heeft die point back naar Address	, id__	,

				Attribute notNull = subnode.attribute( "not-null" );
subnode=<key ...>
true
				( (DependantValue) key ).setNullable( notNull == null || notNull.getValue().equals( "false" ) );

node	DefaultElement  (id=1938)	
collection	Set  (id=1949)	
	key	DependantValue  (id=2248)	
		nullable	false	
/ default is WH true	, 
				Attribute updateable = subnode.attribute( "update" );
false
				( (DependantValue) key ).setUpdateable( updateable == null || updateable.getValue().equals( "true" ) );
		updateable 	true 
/ default is WH false

/ we zien dat not-null in <key not-null="true" >  een dubbelfct heeft: in Column , voor in db tbl	, en in de key DependantValue
/ insert, update in <many-to-one insert="false" ...> komen in de property 


/ via een simplevalue kunnen we bij de configuration komen	, 

/' SAMENVATTING ROOTCLASS	, BACKREF
/ in de configuration is classes, de 2 rootclasses, 
/ in de rootclass is de identifierproperty, en de properties	, 
/ in een property en daarin zien de we name, insertable, updatable, en value, 
/ de value is een simplevalue, of een manytoone of een set	, 
/ een simplevalue heeft columns, bij ons altijd 1, en table	,
/ een manytoone heeft columns, table, (net als simplevalue)	, en een fetchMode (DEFAULT) en een referencedEntityName : Address	,
/ een set heeft cacheConcurrencyStrategy=read-write, cacheRegionName=null, collectionTable=Table(employee), element (onetomany), key(=fk) dependantValue, deze heeft columns (fk), table , wrappedValue, deze heeft columns(id__ van referencing table, ref back), table 

/ als klaar	, ga terug naar Main	, 

this	Main  (id=16)	
	configuration	Configuration  (id=17)	
		classes	HashMap<K,V>  (id=37)	
			size	2	
			table	HashMap$Entry<K,V>[16]  (id=244)	
				[13]	HashMap$Entry<K,V>  (id=249)	
					value	RootClass  (id=182)	
						properties	ArrayList<E>  (id=269)	
							elementData	Object[10]  (id=277)	
								[0]	Property  (id=278)	
								[1]	Property  (id=279)	
								[2]	Property  (id=280)	
								[3]	Backref  (id=281)	
							modCount	4	
							size	4	
				[15]	HashMap$Entry<K,V>  (id=251)	
					value	RootClass  (id=386)	
						identifierProperty	Property  (id=388)	
						properties	ArrayList<E>  (id=396)	
							elementData	Object[10]  (id=403)	
								[0]	Property  (id=404)	
								[1]	Property  (id=405)	
								[2]	Property  (id=406)	
								[3]	Property  (id=407)	
							modCount	4	
							size	4	

 
property	
	name
	value=SimpleValue
		Columns	
		Table

property	
	name
	value=Set
		element OneToMany
		key DependantValue
			nullable 
			Columns		/fk
				nullable
			Table
			wrappedValue SimpleValue
				Columns
				Table



/t
HbmBinder.bindCollectionSecondPass(Element, Collection, Map, Mappings, Map) line: 2662	
		// contained elements:
		Iterator iter = node.elementIterator();
		while ( iter.hasNext() ) {
/ D
/ DOUBLE ROLE <KEY NOT-NULL="TRUE">
		if ( collection.isOneToMany()
			&& !collection.isInverse()
			&& !collection.getKey().isNullable() ) {
/ Hier vraagt hij om de not-null in de collection's key, dus in de DependantValue	, 

			String entityName = ( (OneToMany) collection.getElement() ).getReferencedEntityName();
Employee
			PersistentClass referenced = mappings.getClass( entityName );
RootClass(Employee)
			Backref prop = new Backref();
			prop.setName( '_' + collection.getOwnerEntityName() + "." + node.attributeValue( "name" ) + "Backref" );
			prop.setUpdateable( false );
			prop.setSelectable( false );
			prop.setCollectionRole( collection.getRole() );
			prop.setEntityName( collection.getOwner().getEntityName() );
			prop.setValue( collection.getKey() );
			referenced.addProperty( prop );
prop	Backref  (id=2753)	
	cascade	null	
	collectionRole	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employees" (id=1947)	
	entityName	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Address" (id=1899)	
	insertable	true	
	lazy	true	
	lob	false	
	metaAttributes	null	
	name	"_my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employeesBackref" (id=2760)	
	naturalIdentifier	false	
	nodeName	null	
	optimisticLocked	true	
	optional	false	
	persistentClass	null	
	propertyAccessorName	null	
	selectable	false	
	updateable	false	
	value				DependantValue  (id=2248)	 	/ ! == collection.getKey()
	valueGenerationStrategy	null	


/ RootClass(Address) heeft
Property(addressLine1)
	value=SimpleValue
Property(zipcode)
	value=SimpleValue
Property(city)
	value=SimpleValue
Property(employees)
	value=Set

/ RootClass(Employee) heeft
Property(name)
	value=SimpleValue
Property(salary)
	value=SimpleValue
Property(address)
	value=ManyToOne
		Columns address_
		Table	employee
Backref(employeesBackref)
	value=DependantValue
		Columns address_
		Table	employee
		wrappedValue 
			Columns id__ 
			Table	address	

/ Dus properties address en employeesBackref hebben dezelfde table,columns	, maar employeesBackref heeft ook expliciet address,id__ 
/ TODO

/ Intermezzo

/ als we NIET not-null in <set ...><key not-null="true">	, dan wordt de Backref NIET created	, dus ook geen fk in de employee tbl	, dus als we NIET de schema gen, maar zelf maken, en we hebben daar fk not-null, dan moeten we <key not-null="true"> want anders wordt er null insert	, want de Backref wordt niet gen	,

/ Book (292) H moet aannemen bij <set inverse="false"> dat er GEEN <many-to-one ...> is aan de andere kant, dat het dus unidir is	,

/ Einde Intermezzo

/t
HbmBinder$CollectionSecondPass(CollectionSecondPass).doSecondPass(Map) line: 71	
		secondPass( persistentClasses, localInheritedMetas ); // using local since the inheritedMetas at this point is not the correct map since it is always the empty map
/D
		collection.createAllKeys();
/s
Set(Collection).createAllKeys() line: 429	
		createForeignKeys();
/ Is al bij de <mahy-to-one ...>	, dus NIETS nu	,
		if ( !isInverse() ) createPrimaryKey();
/s
Set.createPrimaryKey() line: 104	
		if ( !isOneToMany() ) {
/ NEE
/ NIETS
/ TODO

/t
Configuration.originalSecondPassCompile() line: 1739	
		itr = getTableMappings();
		int uniqueInteger = 0;
		Set<ForeignKey> done = new HashSet<ForeignKey>();
		while ( itr.hasNext() ) {
			Table table = (Table) itr.next();
			table.setUniqueInteger( uniqueInteger++ );
			secondPassCompileForeignKeys( table, done );
/s
Configuration.secondPassCompileForeignKeys(Table, Set<ForeignKey>) line: 1791	
/ NIETS voor Table(address)
		Iterator iter = table.getForeignKeyIterator();
		while ( iter.hasNext() ) {
			ForeignKey fk = (ForeignKey) iter.next();
			if ( !done.contains( fk ) ) {
				done.add( fk );
				final String referencedEntityName = fk.getReferencedEntityName();
Address
				PersistentClass referencedClass = classes.get( referencedEntityName );
				fk.setReferencedTable( referencedClass.getTable() );
fk	ForeignKey  (id=2889)	
	cascadeDeleteEnabled	false	
	columns	ArrayList<E>  (id=2902)	
[org.hibernate.mapping.Column(address_)]
	name	"FK_lcwyx1va36145pv0w7f8dxqc8" (id=2903)	
	referencedColumns	ArrayList<E>  (id=2904)	
[]
	referencedEntityName	"my.test.own.hibernate_xml_1_N_bidir_ehcache.Address" (id=1899)	
	referencedTable	null	
	table	Table  (id=2047)	 
org.hibernate.mapping.Table(employee)

/t
Configuration.secondPassCompile() line: 1426	

			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );

			originalSecondPassCompile();
/D

/ Einde SECONDPASSCOMPILE

/ NEW SESSIONFACTORYIMPL

/ TODO (Welke getters/setters gen)

/ Einde NEW SESSIONFACTORYIMPL

/ MAIN

/ Als <set inverse="false"><key not-null="true"><one-to-many ...>	, dan in configuration, classes, rootclass(Employee), properties, we zien de Backref property	,
/ de getter is WH van deze prop afgeleid	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			
//			employee.setAddress(address);
//			employee2.setAddress(address);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 267	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );

/ 1 van de H properties van is Backref property	, en die gaat nou eenmaal terug naar de coll in address, want hij wil de container id hebben, en gaat kijken of entity=emplolyee wel in de coll zit in address	, 

/ BACKREF IN ACTION 

/ Dit in .save(employee)	, bij getPropertyValuesToInsert	,
/ Er zijn 2 H properties	, address en de backref	, de 1ste getter geeft Address#34l, de 2de Address#12l	, met de 1ste wordt later niets gedaan	,

/s
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 125	
			else {
				return session.getPersistenceContext().getOwnerId( this.entityName, this.propertyName, target, mergeMap );
target=Employee employee (arg van de .save call)
this.entityName=Address
this.propertyName=employees
/s
StatefulPersistenceContext.getOwnerId(String, String, Object, Map) line: 1118	
		final String collectionRole = entityName + '.' + propertyName;
my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employees
		final EntityPersister persister = session.getFactory().getEntityPersister( entityName );
Address-persister
		final CollectionPersister collectionPersister = session.getFactory().getCollectionPersister( collectionRole );
employees-persister

		for ( Entry<Object,EntityEntry> me : reentrantSafeEntityEntries() ) {
			final EntityEntry entityEntry = me.getValue();
			// does this entity entry pertain to the entity persister in which we are interested (owner)?
			if ( persister.isSubclassEntityName( entityEntry.getEntityName() ) ) {
				final Object entityEntryInstance = me.getKey();
Address address	,
				//check if the managed object is the parent
				boolean found = isFoundInParent(
						propertyName,
employees
						childEntity,
Employee employee
						persister,
Address-persister
						collectionPersister,
employees-persister
						entityEntryInstance
Address address
				);
/=
		final Object collection = persister.getPropertyValue( potentialParent, property );
/ potentialParent=entityEntryInstance=address	,
		return collection != null
				&& Hibernate.isInitialized( collection )
				&& collectionPersister.getCollectionType().contains( collection, childEntity, session );
`k

/ Dus employee moet in address.employees zitten	, dan found=true	,

				if ( found ) {
					return entityEntry.getId();
Long 12

/t
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 268	
	Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
values	Object[4]  (id=3916)	
	[0]	"Foo1" (id=3917)	
	[1]	Double  (id=3918)	
	[2]	Address  (id=3919)	
	[3]	Long  (id=3704)	
types	Type[4]  (id=3972)	
	[0]	StringType  (id=3801)	
	[1]	DoubleType  (id=3973)	
	[2]	ManyToOneType  (id=3974)	
	[3]	LongType  (id=3975)	


/ Daarom moeten we in Main	, 
//			employee.setAddress(address);
//			employee2.setAddress(address);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);

/ Einde MAIN

/ Einde DEBUG 1_N BIDIR 1C, 2C OK

/ DEBUG 1_N BIDIR 2C

			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			employee.setAddress(address3);
			employee2.setAddress(address3);
			
			session.save(address);
			session.save(address3);
			session.save(employee);
			session.save(employee2);
			
			tx.commit();



EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], Object, SessionImplementor) line: 3581	
				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
/ getPropertyInsertability()=[true,true,false,true]
/ Precies de bedoeling bij 1_N bidir: de address wordt overgeslagen bij dehydrate	, en de backref gaat wel	,
////////////////////////////////
/ getSQLInsertStrings()=[insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)]
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3102	
/=
	protected void insert(
			final Serializable id,
			final Object[] fields,
			final boolean[] notNull,
[true,true,false,true]
			final int j,
			final String sql,
insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
			final Object object,
			final SessionImplementor session) throws HibernateException {

				insert = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
sql	"insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)" (id=3145)	
/ Hij zal geven address_ value uit de backref	, niet uit address field van de employee	,
/////////////////////////////////////////////

				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/ notNull=[true,true,false,true]
/ propertyColumnInsertable=[[true],[true],[true],[true]]	,
/s
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2841	
/=
	protected int dehydrate(
			final Serializable id,
			final Object[] fields,
			final Object rowId,
			final boolean[] includeProperty,
[true,true,false,true]
			final boolean[][] includeColumns,
[[true],[true],[true],[true]]	
			final int j,
			final PreparedStatement ps,
			final SessionImplementor session,
			int index,
			boolean isUpdate ) throws SQLException, HibernateException {

		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
			if ( includeProperty[i] && isPropertyOfTable( i, j ) && ...
/ NEE voor address prop	,
/ JA voor backref 	,
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );

/ we zien	,
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 13:14:57 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo1]
HibernateLog --> 13:15:00 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [1.0]
HibernateLog --> 13:16:35 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
/ en	,
HibernateLog --> 13:17:09 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [1]

/ en in 2c	,
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
this	StandardCacheEntryImpl  (id=3167)	
state	Object[4]  (id=3154)	
	[0]	"Foo1" (id=3174)	
	[1]	Double  (id=3175)	
	[2]	Address  (id=3173)	
	[3]	Long  (id=3158)	
12
disassembledState	Serializable[4]  (id=3191)	
	[0]	"Foo1" (id=3174)	
	[1]	Double  (id=3175)	
	[2]	Long  (id=3185)	
34
	[3]	Long  (id=3158)	
12

	        employee= (Employee) session.get(Employee.class, 1l);
/s
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor){
}
/ TODO (Afmaken)


/ Einde DEBUG 1_N BIDIR 2C

/ DEBUG 1_N GET

	session.get(Address.class,12l)

/ eerst cache entry.disassembledState=
...
Long 12			// SetType

/ dan	,
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 109	

		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
/ Speelt nu niet	,
				assembled[i] = row[i];
			}
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
SetType.assemble
			final Serializable key = (Serializable) getPersister(session) .getKeyType() .assemble( cached, session, owner);
Long 12
			return resolveKey( key, session, owner );



/ Einde DEBUG 1_N GET

/ DEBUG 1_N BIDIR 2C

	        address=(Address)session.get(Address.class, 12l);
	        Set<Employee>employees=address.getEmployees();
	        Iterator<Employee>iterator=employees.iterator();
/s
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 129	
///////////////////////////////////////
/s
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 107	
//////////////////////////////////////
/ 1	.
				entityReferenceInitializer.hydrateIdentifier( resultSet, context );
				resolveEntityKey(
						resultSet,
						context,
						entityReferenceInitializer,
						initializerByEntityReference
				);
/ 2	.
				entityReferenceInitializer.hydrateEntityState( resultSet, context );
		final Object entityInstance = optionalEntityInstance != null
				: context.getSession().instantiate( concreteEntityTypeName, entityKey.getIdentifier() );
new Employee	, id=1
		loadFromResultSet(
				resultSet,
				context,
				entityInstance,
				concreteEntityTypeName,
				entityKey,
				lockModeToAcquire
		);
/s
			values = concreteEntityPersister.hydrate(
					resultSet,
					id,
					entityInstance,
					(Loadable) entityReference.getEntityPersister(),
					concreteEntityPersister == rootEntityPersister
							? entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases()
							: entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases( concreteEntityPersister ),
					context.getLoadPlan().areLazyAttributesForceFetched(),
					context.getSession()
			);
/s
SingleTableEntityPersister(AbstractEntityPersister).hydrate(ResultSet, Serializable, Object, Loadable, String[][], boolean, SessionImplementor) line: 2955	
this
	propertySelectable	(id=3391)	
[true, true, true, false]
			for ( int i = 0; i < types.length; i++ ) {
				if ( !propertySelectable[i] ) {
					values[i] = BackrefPropertyAccessor.UNKNOWN;
				}
				else if ( allProperties || !laziness[i] ) {
					else {
						final ResultSet propertyResultSet = propertyIsDeferred ? sequentialResultSet : rs;
						final String[] cols = propertyIsDeferred ? propertyColumnAliases[i] : suffixedPropertyColumns[i];
						values[i] = types[i].hydrate( propertyResultSet, cols, session, object );
/ Employee-persister maakt een BackrefPropertyAccessor.UNKNOWN
/ new Employee, id=1: <string>,<string>,Long 12, UNKNOWN -> 1c

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 124	
				collectionReferenceInitializer.finishUpRow( resultSet, context );
/s
				PersistentCollection rowCollection = persistenceContext.getLoadContexts()
						.getCollectionLoadContext( resultSet )
						.getLoadingCollection( collectionReference.getCollectionPersister(), collectionRowKey );
				if ( rowCollection != null ) {
					rowCollection.readFrom(
							resultSet,
							collectionReference.getCollectionPersister(),
							aliases.getCollectionColumnAliases(),
							collectionOwner
					);
/ sets new Employee#1 en new Employee#2 hierboven in new PersistentSet.tempList

/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
/ D
		rowReader.finishUp( context, afterLoadActionList );
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 158	
		final Object[] hydratedState = entityEntry.getLoadedState();
/ initially	,
<string>,<string>,12l,UNKNOWN
		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 221	
///////////////////////////
		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
				hydratedState[i] = types[i].resolve( value, session, entity );
/ 12l -> Address#12 uit 1c	, UNKNOWN laat hij onveranderd	,

		persister.setPropertyValues( entity, hydratedState );
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
			// this page intentionally left blank :)
} 
/ slaat  UNKNOWN over	,

			final Object version = Versioning.getVersion( hydratedState, persister );
/ hydratedState=[0, Foo2, 2.0, my.test.own.hibernate_xml_1_N_bidir_ehcache.Address@2364857, <unknown>]
/ version is dan 0	,

			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
/ we use dus weer de hydratedState	,
<string>,<string>,Address#12,UNKNOWN
/ Deze state gaan we disassemble	,
<string>,<string>,12,UNKNOWN
/ dus disassemble gaat weer terug naar de loaded state	,

			// explicit handling of caching for rows just inserted and then somehow forced to be read
			// from the database *within the same transaction*.  usually this is done by
			// 		1) Session#refresh, or
			// 		2) Session#clear + some form of load
			//
			// we need to be careful not to clobber the lock here in the cache so that it can be rolled back if need be
			if ( session.getPersistenceContext().wasInsertedDuringTransaction( persister, id ) ) {
				persister.getCacheAccessStrategy().update(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						version,
						version
				);
			}

					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
							cacheKey,
							persister.getCacheEntryStructure().structure( entry ),
							session.getTimestamp(),
							version,
							useMinimalPuts( session, entityEntry )
					);
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 112	
			final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
false
/ want	,
item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3593)	
	timestamp	5779187488292864	
	value	StandardCacheEntryImpl  (id=3595)	
		disassembledState	Serializable[4]  (id=3596)	
			[0]	"Foo1" (id=3598)	
			[1]	Double  (id=3599)	
			[2]	Long  (id=3600)	
34
			[3]	Long  (id=3337)	
12
		version	null	
	version	null	
/ en zou moeten worden	,
<string>,<string>,12l,UNKNOWN
/ en dan klopt het	,

/s
			return version != null && versionComparator.compare( version, newVersion ) < 0;
/




/ SAMENVATTING

/ Dus coll-query : loaded state, maar maakt zelf UNKNOWN, dus =<string>,<string>,12l,UNKNOWN 	->1c in entity entry
/ loaded state -> hydrated state =<string>,<string>, Address#12 uit 1c, UNKNOWN, -> entity, waar de Backref.set niets doet	, dus UNKNOWN komt niet in entity	, hydrate calls nullSafeSet, dus setter	 uit ManyToOneType, Backref...	,
/ 
/ hydrated state disassemble	,
 




/ Einde SAMENVATTING




/ Einde DEBUG 1_N BIDIR 2C

/ N_1 BIDIR

/ 7	.

/ in .commit, performExecutions, prepareActions, 
for (coll recreate action <- collectionCreations) 
	ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).lockItem(Object, Object) line: 136	
			final long timeout = region().nextTimestamp() + region().getTimeout();
timeout	5779934685020160	
/ 1ste coll
timeout	5779934970650624	
/ 2de coll
			final Lock lock = (item == null) ? new Lock( timeout, uuid, nextLockId(), version ) : item.lock(
					timeout,
					uuid,
					nextLockId()
			);
			region().put( key, lock );

/ 7	. 

/ .commit, performExecutions	,
EntityInsertAction.execute() line: 136	
			final boolean put = cacheInsert( persister, ck );
false
/ want	,
/s
EntityInsertAction.cacheInsert(EntityPersister, CacheKey) line: 157	
			return persister.getCacheAccessStrategy().insert( ck, cacheEntry, version );
persister	SingleTableEntityPersister  (id=3216)	
/s
NonstopAwareEntityRegionAccessStrategy.insert(Object, Object, Object) line: 119	
			return actualStrategy.insert( key, value, version );
/s
ReadWriteEhcacheEntityRegionAccessStrategy.insert(Object, Object, Object) line: 65	
		return false;
/ Daarna	,
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );

/ 7	.

/ verwissel psets	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address3);

/ new session	,
	        address=(Address)session.get(Address.class, 12l);
	        address3=(Address)session.get(Address.class, 34l); 
	        Set<Employee>employees=address3.getEmployees();
	        Set<Employee>employees2=address3.getEmployees();

	        address.setEmployees(employees);
	        address3.setEmployees(employees2);
	        tx.commit();
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 231	

/ eerst address#12	,	,
			if ( persister.hasCollections() ) {
				new FlushVisitor( session, entity ).processEntityPropertyValues( values, types );
/s
FlushVisitor(AbstractVisitor).processEntityPropertyValues(Object[], Type[]) line: 76	
/ flush visitor processes H props	,
		for ( int i=0; i<types.length; i++ ) {
				processValue( i, values, types );
/s
Collections.processReachableCollection(PersistentCollection, CollectionType, Object, SessionImplementor) line: 165	
		collection.setOwner( entity );
/ coll's owner WAS address#34, nu address#12	,

		final CollectionEntry ce = session.getPersistenceContext().getCollectionEntry( collection );
ce	CollectionEntry  (id=3366)	
	role	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees" (id=3362)	
	currentKey	null	
	currentPersister	null	
	loadedKey	Long  (id=3360)	
34
	loadedPersister	OneToManyPersister  (id=3367)	
/ beide set toen pset werd create, bij .get address#34	, 

		final CollectionPersister persister = factory.getCollectionPersister( type.getRole() );
		ce.setCurrentPersister( persister );
/ dezelfde 	,
		ce.setCurrentKey( type.getKeyOfOwner( entity, session ) );
12l	,
		prepareCollectionForUpdate( collection, ce, factory );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 258	
		final CollectionPersister loadedPersister = entry.getLoadedPersister();
		final CollectionPersister currentPersister = entry.getCurrentPersister();
/=
			final boolean ownerChanged = loadedPersister != currentPersister
/ NEE
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );
/ JA
/ entry.getLoadedKey()=34l
/ entry.getCurrentKey()=12l	,
/ Hier staat: a#12 heeft pset#34 nu	,

				// do the work
				if ( currentPersister != null ) {
/ JA
					entry.setDorecreate( true );
				}

				if ( loadedPersister != null ) {
/ JA
					entry.setDoremove( true );
					if ( entry.isDorecreate() ) {
/ JA
						collection.forceInitialization();
...
/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	
			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
false
/ want	,	
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).get(Object, long) line: 86	
			final Lockable item = (Lockable) region().get( key );
lock	,
			final boolean readable = item != null && item.isReadable( txTimestamp );
false
			if ( readable ) {
			else {
				return null;

/t
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	
				ce.getLoadedPersister().initialize( ce.getLoadedKey(), source );
/s
CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 87	
			executeLoad(
					session,
					qp,
					staticLoadQuery,
					true,
					null

			);
/ s
CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 138	
Hibernate: select employees0_.address_ as address_4_0_0_, employees0_.id_ as id_1_1_0_, employees0_.id_ as id_1_1_1_, employees0_.name_ as name_2_1_1_, employees0_.salary_ as salary_3_1_1_, employees0_.address_ as address_4_1_1_ from employee employees0_ where employees0_.address_=?
HibernateLog --> 08:46:57 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
/ query for employees die address=34l	,
/ Dus use de fk	,
/////////////////////////////////////////////
		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
/ ?<-H props <-rs
/ coll.tempList<-e1/e2	, waar e1/e2 <-1c	,

/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 125	

/ rs  is van de coll-query, dus 2 lines dehydrated employees	,

/ in 1c is address12, met employees=pset{key=12l, owner=self}
/ in 1c is address34, met employees=pset{key=34, owner=self}
/ Dus van na .get	, de wisseling van pset's is nog niet -> 1c	,
/ Er zijn nog geen Employee	, want in Main	,
	        address=(Address)session.get(Address.class, 12l);
	        address3=(Address)session.get(Address.class, 34l); 
	        Set<Employee>employees=address3.getEmployees();
	        Set<Employee>employees2=address3.getEmployees();

	        address.setEmployees(employees);
	        address3.setEmployees(employees2);
/ address.employees=pset{key=12, owner=self}	, dus er is nog geen employee	,
/ de Employee's worden hieronder create	, en filled	,
///////////////////////////////////////////////////////////////////////////////////////

			// 	1) allow entity references to resolve identifiers (in 2 steps)
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateIdentifier( resultSet, context );
			}
...
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				resolveEntityKey(
						resultSet,
						context,
						entityReferenceInitializer,
						initializerByEntityReference
				);
			}

			// 2) allow entity references to resolve their non-identifier hydrated state and entity instance
			for ( EntityReferenceInitializer entityReferenceInitializer : entityReferenceInitializers ) {
				entityReferenceInitializer.hydrateEntityState( resultSet, context );
/ e1/e2=new Employee -> 1c
/  hydratedState -> 1c-entity entry van e1/e2	,
/ In entity entry van employee2 staat nog 34l, ipv Address#34l	, 
/s
EntityReferenceInitializerImpl.hydrateEntityState(ResultSet, ResultSetProcessingContextImpl) line: 239	
		final Object entityInstance = optionalEntityInstance != null
				: context.getSession().instantiate( concreteEntityTypeName, entityKey.getIdentifier() );
/ Dus new Employee	,
		processingState.registerEntityInstance( entityInstance );
/ TODO
		loadFromResultSet(
				resultSet,
				context,
				entityInstance,
				concreteEntityTypeName,
				entityKey,
				lockModeToAcquire
		);
/s
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 310	
			values = concreteEntityPersister.hydrate(
					resultSet,
					id,
					entityInstance,
					(Loadable) entityReference.getEntityPersister(),
					concreteEntityPersister == rootEntityPersister
							? entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases()
							: entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases( concreteEntityPersister ),
					context.getLoadPlan().areLazyAttributesForceFetched(),
					context.getSession()
			);
[Foo2, 2.0, 34l]
			context.getProcessingState( entityReference ).registerHydratedState( values );
/ TODO
		TwoPhaseLoad.postHydrate(
				concreteEntityPersister,
				id,
				values,
				rowId,
				entityInstance,
				lockModeToAcquire,
				!context.getLoadPlan().areLazyAttributesForceFetched(),
				context.getSession()
		);
/  hydratedState -> 1c 
/ In hydratedState in entity entry van employee2 staat nog 34l, ipv Address#34l	, 
/ maar instance={id=2, rest=0}



/ ?<-H props
...
		// 4) allow arrays, entities and collections after row callbacks
/ coll.tempList<-e1/e2, waar e1/e2 <- 1c	,
/ dus sets e1/e2 in coll	, (in tempList weliswaar nog)	,
...
		if ( collectionReferenceInitializers != null ) {
			for ( CollectionReferenceInitializer collectionReferenceInitializer : collectionReferenceInitializers ) {
				collectionReferenceInitializer.finishUpRow( resultSet, context );
/ Dus finish collection	,
/////////
/ coll.tempList<-e1/e2, waar e1/e2 <- 1c	,
/s
CollectionReferenceInitializerImpl.finishUpRow(ResultSet, ResultSetProcessingContextImpl) line: 73	
			final Serializable collectionRowKey = (Serializable) collectionReference.getCollectionPersister().readKey(
					resultSet,
					aliases.getCollectionColumnAliases().getSuffixedKeyAliases(),
[address_4_0_0]
					context.getSession()
			);
/ Dus weer de fk	, uit rs line	(een dehydrated employee)	,
///////////////////////

				Object collectionOwner = findCollectionOwner( collectionRowKey, resultSet, context );
/ address#34 <- 1c	,	found door coll key=#34 te use in enttitiesByKey	,
/ maar coll#34 heeft nu owner address#12
/ TODO

				PersistentCollection rowCollection = persistenceContext.getLoadContexts()
						.getCollectionLoadContext( resultSet )
						.getLoadingCollection( collectionReference.getCollectionPersister(), collectionRowKey );
coll#34, owner=address#12
				if ( rowCollection != null ) {
					rowCollection.readFrom(
							resultSet,
							collectionReference.getCollectionPersister(),
							aliases.getCollectionColumnAliases(),
							collectionOwner
					);
/ e1/e2<-1c -> coll.tempList	,
/ e1/e2 zojuist in 1c set	, dus OK	,
/ Maar e1/e2={id=1/2, rest=0}
/s
		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
/s
OneToManyPersister(AbstractCollectionPersister).readElement(ResultSet, Object, String[], SessionImplementor) line: 844	
		return getElementType().nullSafeGet( rs, aliases, session, owner );
/s
ManyToOneType(EntityType).nullSafeGet(ResultSet, String[], SessionImplementor, Object) line: 308	
		return resolve( hydrate(rs, names, session, owner), session, owner );
/ names=[id_1_1_0]
hydrate(rs, names, session, owner)=2
/ owner=address#34 speelt geen rol	, want rs=select*from employee where address=34	,
/s
ManyToOneType(EntityType).resolve(Object, SessionImplementor, Object) line: 496	
				return resolveIdentifier( (Serializable) value, session );
value=2l
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/ employee, id=2, rest=0 <- 1c	,

/t
PersistentSet.readFrom(ResultSet, CollectionPersister, CollectionAliases, Object) line: 329	
		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
		if ( element != null ) {
			tempList.add( element );
/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).readRow(ResultSet, ResultSetProcessingContextImpl) line: 126	

// 1
// 2
...
		// 4) allow arrays, entities and collections after row callbacks
...
		if ( collectionReferenceInitializers != null ) {
			for ( CollectionReferenceInitializer collectionReferenceInitializer : collectionReferenceInitializers ) {
				collectionReferenceInitializer.finishUpRow( resultSet, context );
			}
		}
/ D
context	ResultSetProcessingContextImpl  (id=3446)	
	identifierResolutionContextMap	IdentityHashMap<K,V>  (id=3629)	
		entrySet	IdentityHashMap$EntrySet  (id=3662)	
		keySet	null	
		modCount	1	
		size	1	
		table	Object[64]  (id=3651)	
			[12]	CollectionFetchableElementEntityGraph  (id=3457)	
			[13]	ResultSetProcessingContextImpl$1  (id=3451)	
				entityInstance	Employee  (id=3462)	
					address	null	
					id	2	
					name	null	
					salary	0.0	
				entityKey	EntityKey  (id=3460)	
					hashCode	631	
					identifier	Long  (id=3458)	
					persister	SingleTableEntityPersister  (id=3463)	
				hydratedState	Object[3]  (id=3477)	
					[0]	"Foo2" (id=3484)	
					[1]	Double  (id=3485)	
					[2]	Long  (id=3486)	
34l
				identifierHydratedForm	Long  (id=3458)	
					value	2	
				this$0	ResultSetProcessingContextImpl  (id=3446)	
				val$entityReference	CollectionFetchableElementEntityGraph  (id=3457)	
				wasMissingIdentifier	false	
		threshold	21	
		values	null	

/ Deze  identifierResolutionContextMap worden later clear	,
/ TODO

/t
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	

		for ( count = 0; count < maxRows && resultSet.next(); count++ ) {
			Object logicalRow = rowReader.readRow( resultSet, context );
/D

/ initialize coll: coll-query : select*from employee where address=34	,
/ 2	:
/ ? <-H props <-rs lines
/ e1/e2 created	, H props,  -> 1c
/ 4	:
/ e1/e2 <- 1c , -> coll.tempList , e1/e2 ={id=1/2,rest=0}

		rowReader.finishUp( context, afterLoadActionList );

/ resolves 34l in H props in entity entry bij employee1/2 tot address#34	, sets prop values in employee1/2 instance	,
/ coll.set <- tempList	, met e1, e2	, met elk ref naar address#34
/ disassemble coll -> 2c


/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 215	
		// now finish loading the entities (2-phase load)
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );

/ Zonet	,
		TwoPhaseLoad.postHydrate(
/ In 1c's employee1's entity entry loadedState is 3de H prop nog Long 34	,

/s
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).performTwoPhaseLoad(PreLoadEvent, ResultSetProcessingContextImpl, List<HydratedEntityRegistration>) line: 244	

/ resolves 34l in H props in entity entry bij employee1/2 tot address#34	, sets prop values in employee1/2 instance	,

		for ( HydratedEntityRegistration registration : hydratedEntityRegistrations ) {
			TwoPhaseLoad.initializeEntity(
					registration.getInstance(),
					context.isReadOnly(),
					context.getSession(),
					preLoadEvent
			);
		}
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 153	
		final Object[] hydratedState = entityEntry.getLoadedState();
[Foo2, 2.0, 34]
		final Type[] types = persister.getPropertyTypes();
		for ( int i = 0; i < hydratedState.length; i++ ) {
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
				hydratedState[i] = types[i].resolve( value, session, entity );
/s
ManyToOneType(EntityType).resolve(Object, SessionImplementor, Object) line: 496	
				return resolveIdentifier( (Serializable) value, session );
/s
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
address#34 <-1c
/ we zien in employee's entity entry's H prop nu Address#34, ipv 34l	,

		persister.setPropertyValues( entity, hydratedState );
/ entity WAS employee={id=2, rest=0}	, wordt nu set	,

			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
/ in disassembled state is het weer Long 34	, 
					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
							cacheKey,
							persister.getCacheEntryStructure().structure( entry ),
							session.getTimestamp(),
							version,
							useMinimalPuts( session, entityEntry )
					);
/ Doet NIETS	, 
/s
ReadWriteEhcacheEntityRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 113	
			final Lockable item = (Lockable) region().get( key );
[Foo2, 2.0, 34l]
/ is er al	,
			final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
false

/ Wat als coll dirty	, als een employee is update	?
/ TODO

/t
AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 218	
		performTwoPhaseLoad( preLoadEvent, context, hydratedEntityRegistrations );

/ resolves Address-ref in de H props van employee's, 	en sets employee entity met H props	, en probeerde employee->2c, maar zijn er al (omdat onveranderd WH)	, 
/D
		// now we can finalize loading collections
		finishLoadingCollections( context );

/ coll.set <- tempList	, met e1, e2	, met elk ref naar address#34
/ disassemble coll -> 2c

/s
...
CollectionLoadContext.endLoadingCollections(CollectionPersister) line: 168	
		final boolean hasNoQueuedAdds = lce.getCollection().endRead();
/s
		set.addAll( tempList );
		tempList = null;
		setInitialized();

/t

		CollectionEntry ce = getLoadContext().getPersistenceContext().getCollectionEntry( lce.getCollection() );
/ ce.snapshot	, lce.collection zitten 2 Employee	, met address=Address#34 
/ ce.currentKey=12, ce.loadedKey=34	, klopt	, we zijn nog steeds flush address#12	,

		boolean addToCache =
				// there were no queued additions
				hasNoQueuedAdds
/ JA
				// and the role has a cache
				&& persister.hasCache()
/ JA
				// and this is not a forced initialization during flush
				&& session.getCacheMode().isPutEnabled() 
/ JA
				&& !ce.isDoremove();
/ NEE
/ Dus de coll wordt NIET -> 2c	,

/ JA
			addCollectionToCache( lce, persister );
/s
		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
entry	CollectionCacheEntry  (id=3400)	
	state	Serializable[2]  (id=3401)	
		[0]	Long  (id=3402)	
		[1]	Long  (id=3403)	
/s
		this.state = collection.disassemble( persister );
/s
PersistentSet.disassemble(CollectionPersister) line: 359	
		final Serializable[] result = new Serializable[ set.size() ];
		final Iterator itr = set.iterator();
		int i=0;
		while ( itr.hasNext() ) {
			result[i++] = persister.getElementType().disassemble( itr.next(), getSession(), null );
/ persister.getElementType()=ManyToOneType	,
/s
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 239	
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
					getAssociatedEntityName(),
					value,
					session
			);
			return getIdentifierType( session ).disassemble( id, session, owner );
1l/2l

/t
CollectionLoadContext.addCollectionToCache(LoadingCollectionEntry, CollectionPersister) line: 369	
				final boolean put = persister.getCacheAccessStrategy().putFromLoad(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						session.getTimestamp(),
						version,
						factory.getSettings().isMinimalPutsEnabled() && session.getCacheMode()!= CacheMode.REFRESH
				);
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 109	
			final Lockable item = (Lockable) region().get( key );
lock
			final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
true
			if ( writeable ) {
				region().put( key, new Item( value, version, region().nextTimestamp() ) );
/ JA

/t
Main.testBasicUsage() line: 273	
	        iterator2=employees2.iterator();
/ D
	        tx.commit();
/ NIETS

/ 7	.

/ 2de keer .iterator



/s
DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	
			final boolean foundInCache = initializeCollectionFromCache(
					ce.getLoadedKey(),
					ce.getLoadedPersister(),
					collection,
					source
			);
/s
DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 139	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	CollectionCacheEntry  (id=3440)	
	state	Serializable[2]  (id=3441)	
		[0]	Long  (id=3402)	
		[1]	Long  (id=3403)	

		cacheEntry.assemble( collection, persister, persistenceContext.getCollectionOwner( id, persister ) );
/s
CollectionCacheEntry.assemble(PersistentCollection, CollectionPersister, Object) line: 75	
		collection.initializeFromCache( persister, state, owner );
/s
PersistentSet.initializeFromCache(CollectionPersister, Serializable, Object) line: 141	
		beforeInitialize( persister, size );
/s
			this.set = (Set) persister.getCollectionType().instantiate( anticipatedSize );

		for ( Serializable arrayElement : array ) {
			final Object assembledArrayElement = persister.getElementType().assemble( arrayElement, getSession(), owner );
/s
ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 272	
		Serializable id = assembleId( oid, session );
2l
			return resolveIdentifier( id, session );
/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 712	
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/ in 1c is alleen address#34, met lege pset	, dus e2 is er niet	,
/s
DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 431	
		Object entity = loadFromSessionCache( event, keyToLoad, options );
null
		entity = loadFromSecondLevelCache( event, persister, options );
/s
DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 598	
		final Object ce = CacheHelper.fromSharedCache( source, ck, persister.getCacheAccessStrategy() );
ce	StandardCacheEntryImpl  (id=3641)	
	disassembledState	Serializable[3]  (id=3642)	
		[0]	"Foo2" (id=3643)	
		[1]	Double  (id=3644)	
		[2]	Long  (id=3388) 	34l	

		CacheEntry entry = (CacheEntry) persister.getCacheEntryStructure().destructure( ce, factory );
		Object entity = convertCacheEntryToEntity( entry, event.getEntityId(), persister, event );
/s
DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 678	
			entity = optionalObject == null
					? session.instantiate( subclassPersister, entityId )
			values = ( (StandardCacheEntryImpl) entry ).assemble(
					entity, entityId, subclassPersister, session.getInterceptor(), session
			);
/ disassembled state is in entry	,
entry	StandardCacheEntryImpl  (id=3641)	
	disassembledState	Serializable[3]  (id=3642)	
		[0]	"Foo2" (id=3643)	
		[1]	Double  (id=3644)	
		[2]	Long  (id=3388)	
/s
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 107	
		for ( int i = 0; i < types.length; i++ ) {
			if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
			else {
				assembled[i] = types[i].assemble( row[i], session, owner );
/s
ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 272	
		Serializable id = assembleId( oid, session );
34l
			return resolveIdentifier( id, session );

/ we zijn voor de 2de keer in ManyToOneType.assemble	,

Thread [main] (Suspended)	
	ManyToOneType(EntityType).getAssociatedEntityName() line: 241	
	ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 716	
	ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 282	
	TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 113	
	StandardCacheEntryImpl.assemble(Object, Serializable, EntityPersister, Interceptor, EventSource) line: 163	
	DefaultLoadEventListener.convertCacheEntryToEntity(CacheEntry, Serializable, EntityPersister, LoadEvent) line: 707	
	DefaultLoadEventListener.loadFromSecondLevelCache(LoadEvent, EntityPersister, LoadEventListener$LoadType) line: 618	
	DefaultLoadEventListener.doLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 452	
	DefaultLoadEventListener.load(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 213	
	DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 275	
	DefaultLoadEventListener.onLoad(LoadEvent, LoadEventListener$LoadType) line: 151	
	SessionImpl.fireLoad(LoadEvent, LoadEventListener$LoadType) line: 1070	
	SessionImpl.internalLoad(String, Serializable, boolean, boolean) line: 989	
	ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 716	
	ManyToOneType.assemble(Serializable, SessionImplementor, Object) line: 282	
	PersistentSet.initializeFromCache(CollectionPersister, Serializable, Object) line: 145	
	CollectionCacheEntry.assemble(PersistentCollection, CollectionPersister, Object) line: 75	
	DefaultInitializeCollectionEventListener.initializeCollectionFromCache(Serializable, CollectionPersister, PersistentCollection, SessionImplementor) line: 160	
	DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 76	
	SessionImpl.initializeCollection(PersistentCollection, boolean) line: 1897	
	AbstractPersistentCollection$4.doWork() line: 558	
	PersistentSet(AbstractPersistentCollection).withTemporarySessionIfNeeded(LazyInitializationWork<T>) line: 260	
	PersistentSet(AbstractPersistentCollection).initialize(boolean) line: 554	
	PersistentSet(AbstractPersistentCollection).read() line: 142	
	PersistentSet.iterator() line: 180	
	Main.testBasicUsage() line: 317	
	Main.<init>() line: 64	
	Main.main(String[]) line: 58	

/s
ManyToOneType(EntityType).resolveIdentifier(Serializable, SessionImplementor) line: 716	
		Object proxyOrEntity = session.internalLoad(
				getAssociatedEntityName(),
				id,
				eager,
				isNullable() && !isProxyUnwrapEnabled
		);
/s
SessionImpl.internalLoad(String, Serializable, boolean, boolean) line: 989	
		LoadEventListener.LoadType type = nullable
				? LoadEventListener.INTERNAL_LOAD_NULLABLE
				: eager
						? LoadEventListener.INTERNAL_LOAD_EAGER
						: LoadEventListener.INTERNAL_LOAD_LAZY;
/ eager=false
		LoadEvent event = new LoadEvent(id, entityName, true, this);
		fireLoad( event, type );
...
/s
DefaultLoadEventListener.proxyOrLoad(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType) line: 271	
		if ( options.isAllowProxyCreation() ) {
/ JA
			return createProxyIfNecessary( event, persister, keyToLoad, options, persistenceContext );

		return load( event, persister, keyToLoad, options );
/ NIET NU
/s
DefaultLoadEventListener.createProxyIfNecessary(LoadEvent, EntityPersister, EntityKey, LoadEventListener$LoadType, PersistenceContext) line: 336	
		Object existing = persistenceContext.getEntity( keyToLoad );
/ in entitiesByKey	,
existing	Address  (id=3565)	
	addressLine1	"foostreet" (id=3489)	
	city	"FooCity34A" (id=3723)	
	employees	PersistentSet  (id=3560)	
/ leeg	,
	id	34	
	zipcode	"34 foo" (id=3724)	

/t
TypeHelper.assemble(Serializable[], Type[], SessionImplementor, Object) line: 116	
		for ( int i = 0; i < types.length; i++ ) {
				assembled[i] = types[i].assemble( row[i], session, owner );
/ D
session	SessionImpl  (id=3563)	
assembled	Object[3]  (id=3704)	
	[0]	"Foo2" (id=3643)	
	[1]	Double  (id=3644)	
	[2]	Address  (id=3565)	

/ SAMENVATTING N_1 BIDIR 2DE KEER ITERATOR
/ SAMENVATTING N_1 BIDIR PERSISTENTSET.ADD, INITIALIZE 

/ DEMO

/' a34=.get(Address,34l)
/ alle primitives, en leget pset (alleen id, persister)	,
.iterator
a34.coll init	,
	1l,2l 					<- coll-2c
	pset.set=new HashSet
	for(i<-1l,2l)ManyToOneType.assemble(i)
/ bijv i=1	,
		[Foo2,1.0,34l]			<- employee-2c	,
		e1=new Employee
		for(H props)
/ bijv voor de laatste	,
			ManyToOneType.assemble
				a34 <- 1c	, helemaal	, staat er gewoon in	,
		e1<-Foo1,1.0,a34	
		e1 -> 1c
	pset<-e1

/ Einde SAMENVATTING N_1 BIDIR 2DE KEER ITERATOR
/ Einde SAMENVATTING N_1 BIDIR PERSISTENTSET.ADD, INITIALIZE 



/ 7	.

/ iterate over pset	, 

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address3);

/ new session	,
			employees2=address3.getEmployees();
	        	iterator2=employees2.iterator();
	        	while(iterator2.hasNext()){
	        		Employee e=iterator2.next();
	        		String s=e.getName();
	        		boolean b=false;
	        	}
/ s
		CollectionEntry ce = getLoadContext().getPersistenceContext().getCollectionEntry( lce.getCollection() );
/ ce.snapshot	, lce.collection zitten 2 Employee	, met address=Address#34 
/ ce.currentKey=12, ce.loadedKey=34	, klopt	, we zijn nog steeds flush address#12	,

		boolean addToCache =
				// there were no queued additions
				hasNoQueuedAdds
/ JA
				// and the role has a cache
				&& persister.hasCache()
/ JA
				// and this is not a forced initialization during flush
				&& session.getCacheMode().isPutEnabled() 
/ JA
				&& !ce.isDoremove();
/ JA
			addCollectionToCache( lce, persister );
/s
		final CollectionCacheEntry entry = new CollectionCacheEntry( lce.getCollection(), persister );
entry	CollectionCacheEntry  (id=3400)	
	state	Serializable[2]  (id=3401)	
		[0]	Long  (id=3402)	
		[1]	Long  (id=3403)	
/s
		this.state = collection.disassemble( persister );
/s
PersistentSet.disassemble(CollectionPersister) line: 359	
		final Serializable[] result = new Serializable[ set.size() ];
		final Iterator itr = set.iterator();
		int i=0;
		while ( itr.hasNext() ) {
			result[i++] = persister.getElementType().disassemble( itr.next(), getSession(), null );
/ persister.getElementType()=ManyToOneType	,
/s
ManyToOneType.disassemble(Object, SessionImplementor, Object) line: 239	
			Object id = ForeignKeys.getEntityIdentifierIfNotUnsaved(
					getAssociatedEntityName(),
					value,
					session
			);
			return getIdentifierType( session ).disassemble( id, session, owner );
1l/2l

/t
CollectionLoadContext.addCollectionToCache(LoadingCollectionEntry, CollectionPersister) line: 369	
				final boolean put = persister.getCacheAccessStrategy().putFromLoad(
						cacheKey,
						persister.getCacheEntryStructure().structure( entry ),
						session.getTimestamp(),
						version,
						factory.getSettings().isMinimalPutsEnabled() && session.getCacheMode()!= CacheMode.REFRESH
				);
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 109	
			final Lockable item = (Lockable) region().get( key );
lock
			final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
true
			if ( writeable ) {
				region().put( key, new Item( value, version, region().nextTimestamp() ) );
/ JA

/t
Main.testBasicUsage() line: 273	
	        iterator2=employees2.iterator();
/ D
	        tx.commit();
/ NIETS


/ SAMENVATTING ITERATOR

/ DEMO

/ initialize coll: coll-query : select*from employee where address=34	,
/ 2	:
/ ? <-H props <-rs lines
/ e1/e2 created	, H props,  -> 1c
/ 4	:
/ e1/e2 <- 1c , -> coll.tempList , e1/e2 ={id=1/2,rest=0}

		rowReader.finishUp( context, afterLoadActionList );

/ resolves 34l in H props in entity entry bij employee1/2 tot address#34	, sets prop values in employee1/2 instance	,
/ coll.set <- tempList	, met e1, e2	, met elk ref naar address#34
/ disassemble coll -> 2c


/ Einde SAMENVATTING ITERATOR

/ N_1 BIDIR COLLECTIONS

/ 7	.

/ Lees	,
http://www.javacodegeeks.com/2012/03/hibernate-performance-tips-dirty.html

/ De set NIET inverse of de many-to-one NIET insert/update="false" kunnen we NIET	,
/ TODO

/ Als we return Collections.unModifiableSet(employees), heeft de PersistenSet key=null
/ TODO
/ Ook zien we dan dat de query steeds opnieuw wordt gedaan, maar de coll is NIET dirty	,
/ TODO

/ 7	

/ nieuwe session	,

	        address=(Address)session.get(Address.class, 34l);
	        employees=address.getEmployees();
	        iterator=employees.iterator();
	        while(iterator.hasNext()){
	        	Employee e=iterator.next();
	        	e.setName(e.getName()+"A");

/ Hiermee maak je geen dirty coll	, de employee's worden dirty, niet de coll	,

/ 7	.

/ Als we .setEmployees	, dan rm hij de coll die hij had	,  uiteindelijk hebben beide address geen set	,

/ Moet de employees een PersistentSet zijn, ipv een HashSet	, hieronder om een dirty set te maken WH wel,
/ TODO

/ nieuwe session	,

	        address=(Address)session.get(Address.class, 12l);
	        address3=(Address)session.get(Address.class, 34l); 
	        employees=address3.getEmployees();
	        employees2=address.getEmployees();

	        address.setEmployees(employees);
	        address3.setEmployees(employees2);

	        printStats( stats);	        
	        tx.commit();
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 264	

			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );

			if ( ownerChanged ) {
/ JA	, de key changed	,
				// do the work
				if ( currentPersister != null ) {
/ JA
					entry.setDorecreate( true );
				}

				if ( loadedPersister != null ) {
/ JA
					// we will need to remove ye olde entries
					entry.setDoremove( true );
					if ( entry.isDorecreate() ) {
/ JA
						LOG.trace( "Forcing collection initialization" );
						collection.forceInitialization();
					}
				}
			}
			else if ( collection.isDirty() ) {
				// the collection's elements have changed
				entry.setDoupdate( true );
			}

/ 7	.

/ We add een employee aan een PersistenSet	, (niet aan een HashSet)	, de coll is dan dirty	,

/ nieuwe session	,
	        address3=(Address)session.get(Address.class, 34l); 
		  	
		employees2=address3.getEmployees();
	        iterator2=employees2.iterator();
/ Dus de coll -> 2c	,


/ nieuwe session	,

	        address3=(Address)session.get(Address.class, 34l); 
		Employee employee3=new Employee(1l,"Foo3",3.00);
		address3.getEmployees().add(employee3);
/s
/ TOOD
	        tx.commit();
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	
			int entityCount = flushEntities( event, persistenceContext );
/s
Collections.prepareCollectionForUpdate(PersistentCollection, CollectionEntry, SessionFactoryImplementor) line: 264	

		if ( loadedPersister != null || currentPersister != null ) {
			// it is or was referenced _somewhere_

			// if either its role changed, or its key changed
			final boolean ownerChanged = loadedPersister != currentPersister
					|| !currentPersister.getKeyType().isEqual( entry.getLoadedKey(), entry.getCurrentKey(), factory );

			if ( ownerChanged ) {
/ NEE
			else if ( collection.isDirty() ) {
/ JA
				// the collection's elements have changed
				entry.setDoupdate( true );
			}
/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEverythingToExecutions(FlushEvent) line: 103	
			int collectionCount = flushCollections( session, persistenceContext );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushCollections(EventSource, PersistenceContext) line: 296	
				session.getInterceptor().onCollectionUpdate( coll, ce.getLoadedKey() );
				actionQueue.addAction(
						new CollectionUpdateAction(
								coll,
								ce.getLoadedPersister(),
								ce.getLoadedKey(),
								ce.isSnapshotEmpty(coll),
								session
							)
					);
/t
DefaultFlushEventListener.onFlush(FlushEvent) line: 56	
				flushEverythingToExecutions( event );
/d
				performExecutions( source );
/s
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 349	
			session.getActionQueue().prepareActions();
/s
		prepareActions( collectionUpdates );
/s
	private void prepareActions(ExecutableList<?> queue) throws HibernateException {
		for ( Executable executable : queue ) {
			executable.beforeExecutions();
/s
		if ( persister.hasCache() ) {
			final CacheKey ck = session.generateCacheKey(
					key,
34l
					persister.getKeyType(),
					persister.getRole()
			);
			final SoftLock lock = persister.getCacheAccessStrategy().lockItem( ck, null );
/s
ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).lockItem(Object, Object) line: 136	
			final Lockable item = (Lockable) region().get( key );
item	AbstractReadWriteEhcacheAccessStrategy$Item  (id=3401)	
	value	CollectionCacheEntry  (id=3403)	
		state	Serializable[2]  (id=3404)	
			[0]	Long  (id=3389)	
1l
			[1]	Long  (id=3405)	
2l
			final long timeout = region().nextTimestamp() + region().getTimeout();
			final Lock lock = (item == null) ? new Lock( timeout, uuid, nextLockId(), version ) : item.lock(
					timeout,
					uuid,
					nextLockId()
			);
			region().put( key, lock );
/ Sets de lock er gewoon overheen	,

			// the old behavior used key as opposed to getKey()
			afterTransactionProcess = new CacheCleanupProcess( key, persister, lock );
		}
/t
DefaultFlushEventListener(AbstractFlushingEventListener).performExecutions(EventSource) line: 350	
			session.getActionQueue().prepareActions();
/d
			session.getActionQueue().executeActions();
/ er is 1 action	,
/s
CollectionUpdateAction.execute() line: 68	
		else if ( collection.needsRecreate( persister ) ) {
/ NEE
		else {
			persister.deleteRows( collection, id, session );
/ NIETS
/ want inverse=true
/ TODO
			persister.updateRows( collection, id, session );
/ NIETS
/ want inverse=true
/ TODO
			persister.insertRows( collection, id, session );
/ NIETS
/ want inverse=true
/ TODO
		getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
/s
CollectionEntry.afterAction(PersistentCollection) line: 251	
		loadedKey = getCurrentKey();
		setLoadedPersister( getCurrentPersister() );

		boolean resnapshot = collection.wasInitialized() &&
				( isDoremove() || isDorecreate() || isDoupdate() );
		if ( resnapshot ) {
/ JA
			snapshot = loadedPersister==null || !loadedPersister.isMutable() ?
					collection.getSnapshot(loadedPersister); //re-snapshot
/ Van 2 -> 3 entries	,

		collection.postAction();
/s
		clearDirty();
/ Inderdaad, de PersistenSet 	,
	dirty 	false

/t
CollectionUpdateAction.execute() line: 106	
		getSession().getPersistenceContext().getCollectionEntry( collection ).afterAction( collection );
		evict();
/ NIETS	, 
/t
					afterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );
/ schedule cleanup	,


/ we zien dat de ehcache entry 'n free lock is	, NIET de nieuwe coll	,
/ TODO


 


/ Einde N_1 BIDIR COLLECTIONS


/ 1_N BIDIR COLLECTIONS

/ 7	.
		  
			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");

			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
			session.save(employee2);
			
			tx.commit();

/ we zien in employee's entry in 1c	,
	foostreet
	12 foo
	null
	Backref... 12

/ 7	.


/ nieuwe sessie	,
	        address=(Address)session.get(Address.class, 12l); 
		Employee employee3=new Employee(3l,"Foo3",3.00);
		address.getEmployees().add(employee3);
		employee3.setAddress(address);
 	        tx.commit();

/ we zien in employee's entry	,
	foostreet
	12 foo
	Long 12
	Backref....UNKNOWN
/ Toch komt 12l niet in 2c en dat zou de oplossing zijn	,
/ TODO

org.hibernate.StaleStateException: Batch update returned unexpected row count from update [0]; actual row count: 0; expected: 1
	at org.hibernate.jdbc.Expectations$BasicExpectation.checkBatched(Expectations.java:81)
	at org.hibernate.jdbc.Expectations$BasicExpectation.verifyOutcome(Expectations.java:73)
	at org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch.addToBatch(NonBatchingBatch.java:63)
	at org.hibernate.persister.collection.AbstractCollectionPersister.insertRows(AbstractCollectionPersister.java:1531)
	at org.hibernate.persister.collection.OneToManyPersister.insertRows(OneToManyPersister.java:191)
	at org.hibernate.action.internal.CollectionUpdateAction.execute(CollectionUpdateAction.java:102)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:463)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:349)
	at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:350)
	at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:56)
	at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:1222)
	at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:425)
	at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.beforeTransactionCommit(JdbcTransaction.java:101)
	at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.commit(AbstractTransactionImpl.java:177)
	at my.test.own.hibernate_xml_1_N_bidir.Main.testBasicUsage(Main.java:240)
	at my.test.own.hibernate_xml_1_N_bidir.Main.<init>(Main.java:64)
	at my.test.own.hibernate_xml_1_N_bidir.Main.main(Main.java:58)


/ H doet	,
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 08:25:34 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 08:26:22 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [3]

/ maar de row is helemaal niet in de employee tbl	,

/ Ook	,
/ we zien dat employee's entry in 1c	,

/ 7	.

	        address=(Address)session.get(Address.class, 12l); 
		Employee employee3=new Employee(3l,"Foo3",3.00);
		session.save(employee3);
		address.getEmployees().add(employee3);
	        tx.commit();
/ we zien	,

org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_1_N_bidir.Employee._my.test.own.hibernate_xml_1_N_bidir.Address.employeesBackref
	at org.hibernate.engine.internal.Nullability.checkNullability(Nullability.java:106)
	at org.hibernate.action.internal.AbstractEntityInsertAction.nullifyTransientReferencesIfNotAlready(AbstractEntityInsertAction.java:132)
	at org.hibernate.action.internal.AbstractEntityInsertAction.makeEntityManaged(AbstractEntityInsertAction.java:141)
	at org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:201)
	at org.hibernate.engine.spi.ActionQueue.addInsertAction(ActionQueue.java:179)
	at org.hibernate.engine.spi.ActionQueue.addAction(ActionQueue.java:166)
	at org.hibernate.event.internal.AbstractSaveEventListener.addInsertAction(AbstractSaveEventListener.java:332)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:288)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:194)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:137)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:209)
	at org.hibernate.event.internal.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:55)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:194)
	at org.hibernate.event.internal.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:49)
	at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:90)
	at org.hibernate.internal.SessionImpl.fireSave(SessionImpl.java:715)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:707)
	at org.hibernate.internal.SessionImpl.save(SessionImpl.java:702)
	at my.test.own.hibernate_xml_1_N_bidir.Main.testBasicUsage(Main.java:235)
	at my.test.own.hibernate_xml_1_N_bidir.Main.<init>(Main.java:64)
	at my.test.own.hibernate_xml_1_N_bidir.Main.main(Main.java:58)
/ want	,
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 268	

entity	Employee  (id=2778)	
	address	null	
	id	3	
	name	"Foo3" (id=2782)	
	salary	3.0	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
values	Object[4]  (id=2781)	
	[0]	"Foo3" (id=2782)	
	[1]	Double  (id=2783)	

types	Type[4]  (id=2795)	
	[0]	StringType  (id=2802)	
	[1]	DoubleType  (id=2806)	
	[2]	ManyToOneType  (id=2809)	
	[3]	LongType  (id=2812)	
...
/ H: de laatste H prop moet er zijn en is er niet	, ( de 3de maakt nu niet uit, want we hebben 1-N bidir)	,
/s
Nullability.checkNullability(Object[], EntityPersister, boolean) line: 106	

this	Nullability  (id=2956)	
values	Object[4]  (id=2781)	
	[0]	"Foo3" (id=2782)	
	[1]	Double  (id=2783)	

nullability	(id=2957)	
	[0]	true	
	[1]	true	
	[2]	false	
	[3]	false	
checkability	(id=2958)	
	[0]	true	
	[1]	true	
	[2]	false	
	[3]	true	
propertyTypes	Type[4]  (id=2795)	
	[0]	StringType  (id=2802)	
	[1]	DoubleType  (id=2806)	
	[2]	ManyToOneType  (id=2809)	
	[3]	LongType  (id=2812)	

			for ( int i = 0; i < values.length; i++ ) {
/ i=3
 				if ( checkability[i] && values[i]!= LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
/ JA
					final Object value = values[i];
null
					if ( !nullability[i] && value == null ) {
/ JA
						//check basic level one nullablilty
						throw new PropertyValueException(
								"not-null property references a null or transient value",
								persister.getEntityName(),
								persister.getPropertyNames()[i]
							);


/ 7	.

	        address=(Address)session.get(Address.class, 12l); 
		Employee employee3=new Employee(3l,"Foo3",3.00);
		address.getEmployees().add(employee3);
		session.save(employee3);
	        tx.commit();
/ OK

/ SAMENVATTING 1_N BIDIR PERSISTENTSET.ADD, INITIALIZE 

/ DEMO

/' a34=.get(Address,34l)
/ alle primitives, en leget pset (alleen id, persister)	,
.iterator
a34.coll init	,
	1l,2l 					<- coll-2c
	pset.set=new HashSet
	for(i<-1l,2l)ManyToOneType.assemble(i)
/ bijv i=1	,
		[Foo2,1.0,null,12l]			<- employee-2c	,
		e1=new Employee
		for(H props)
/ bijv voor de eena laatste	,
			ManyToOneType.assemble
			 	null	
/ bijv voor de laatste	,
			LongType.assemble
			 	12l	
		e1<-Foo1,1.0,null			/ setPropertyValues, Backref....setter doet NIETS	, dus de 12l gaat verloren	, hij komt NIET in de Address-ref in employee	,
		e1, H props -> 1c 	/ Employee{Foo1,1.0,null}, [Foo1,1.0,null,12l] ->1c
	pset<-e1

/ we zien dat	,
	        address=(Address)session.get(Address.class, 12l); 
		Employee employee3=new Employee(3l,"Foo3",3.00);
		address.getEmployees().add(employee3);
/ employee3 in 1c (TODO)	, maar de insert action moet nog scheduled	, en dat doet	,
		session.save(employee3);		/ H calls Backref....getterForInsert	, en die calc 12l 	,

	        tx.commit();
/ H schedules update coll, want is dirty set door Persistent.add hierboven	,
/ H vindt in 2c-coll entry 1l,2l	, hierover heen set hij lock	,
/ H vindt entityinsertaction[e3], en collupdateaction[a.es#12] op de queues	,

/ entityinsertaction[e3]	,
			persister.insert ...
Hibernate: insert into employee (name_, salary_, address_, id_) values (?, ?, ?, ?)
HibernateLog --> 12:02:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [Foo3]
HibernateLog --> 12:02:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [DOUBLE] - [3.0]
HibernateLog --> 12:02:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [BIGINT] - [12]
HibernateLog --> 12:02:46 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [BIGINT] - [3]

			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/ schedules voor insert e3 in 2c	(TODO)

/ collupdateaction[a.es#12]	, 
/ H disassembles de H props	, NIET wat er in inst	, H props van e3=[Foo3,3.0,null,12l]	, disassembled=H props	,
/s
CollectionUpdateAction.execute() line: 102	
			persister.insertRows( collection, id, session );
/s
OneToManyPersister(AbstractCollectionPersister).insertRows(PersistentCollection, Serializable, SessionImplementor) line: 1483	
Hibernate: update employee set address_=? where id_=?
HibernateLog --> 12:18:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [12]
HibernateLog --> 12:18:45 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [BIGINT] - [3]

evict()

/ we zien coll cleanup 	, dus de coll is uit de 2c	, NIET updated	,










/ Einde SAMENVATTING 1_N BIDIR PERSISTENTSET.ADD, INITIALIZE 



 


/ Einde 1_N BIDIR COLLECTIONS




























/t
FlushVisitor.processCollection(Object, CollectionType) line: 62	
			Collections.processReachableCollection( coll, type, owner, getSession() );
/D
/t
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 231	

/ volgende	,
		for ( Map.Entry<Object,EntityEntry> me : entityEntries ) {
					listener.onFlushEntity( entityEvent );

















/ Einde N_1 BIDIR

/ DEBUG N-1 DIDIR 


/ 7	.
			session = sessionFactory.openSession();
			tx=session.beginTransaction();
			employees2=address.getEmployees();
/ lazy init exc	, omdat address NIET managed is	,

/ 7	.


/ Einde DEBUG N-1 DIDIR 

/ 7	.

Thread [main] (Suspended)	
	TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 210	
	TwoPhaseLoad.initializeEntity(Object, boolean, SessionImplementor, PreLoadEvent) line: 144	
	AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).performTwoPhaseLoad(PreLoadEvent, ResultSetProcessingContextImpl, List<HydratedEntityRegistration>) line: 244	
	AbstractCollectionLoadQueryDetails$CollectionLoaderRowReader(AbstractRowReader).finishUp(ResultSetProcessingContextImpl, List<AfterLoadAction>) line: 215	
	ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
	CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer, List<AfterLoadAction>) line: 138	
	CollectionLoader(AbstractLoadPlanBasedLoader).executeLoad(SessionImplementor, QueryParameters, LoadQueryDetails, boolean, ResultTransformer) line: 102	
	CollectionLoader(AbstractLoadPlanBasedCollectionInitializer).initialize(Serializable, SessionImplementor) line: 100	
	OneToManyPersister(AbstractCollectionPersister).initialize(Serializable, SessionImplementor) line: 693	
	DefaultInitializeCollectionEventListener.onInitializeCollection(InitializeCollectionEvent) line: 92	
	SessionImpl.initializeCollection(PersistentCollection, boolean) line: 1897	
	AbstractPersistentCollection$4.doWork() line: 558	
	PersistentSet(AbstractPersistentCollection).withTemporarySessionIfNeeded(LazyInitializationWork<T>) line: 260	
	PersistentSet(AbstractPersistentCollection).initialize(boolean) line: 554	
	PersistentSet(AbstractPersistentCollection).read() line: 142	
	PersistentSet.iterator() line: 180	
	Main.testBasicUsage() line: 267	
	Main.<init>() line: 64	
	Main.main(String[]) line: 58	

			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
			final CacheKey cacheKey = session.generateCacheKey( id, persister.getIdentifierType(), persister.getRootEntityName() );

			// explicit handling of caching for rows just inserted and then somehow forced to be read
			// from the database *within the same transaction*.  usually this is done by
			// 		1) Session#refresh, or
			// 		2) Session#clear + some form of load
			//
			// we need to be careful not to clobber the lock here in the cache so that it can be rolled back if need be
			if ( session.getPersistenceContext().wasInsertedDuringTransaction( persister, id ) ) {
/ TODO

/ 7	.

CollectionLoadContext.endLoadingCollections(CollectionPersister) line: 189	

			final CollectionKey collectionKey = (CollectionKey) itr.next();
			final LoadingCollectionEntry lce = loadContexts.locateLoadingCollectionEntry( collectionKey );
collectionKey	CollectionKey  (id=3528)	
	entityMode	EntityMode  (id=3530)	
	factory	SessionFactoryImpl  (id=3467)	
	hashCode	953424428	
	key	Long  (id=3370)	
34
	keyType	LongType  (id=3445)	
	role	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees" (id=3532)	
lce	LoadingCollectionEntry  (id=3538)	
	collection	PersistentSet  (id=3413)	
	key	Long  (id=3370)	
	persister	OneToManyPersister  (id=3371)	 		/ !
	resultSet	Jdbc4ResultSet  (id=3382)	

txTimestamp	5779666595291136	
unlockTimestamp	5779666524717056	

/ 7	.

ReadWriteEhcacheCollectionRegionAccessStrategy(AbstractReadWriteEhcacheAccessStrategy<T>).putFromLoad(Object, Object, long, Object, boolean) line: 111	

			final Lockable item = (Lockable) region().get( key );
/s
EhcacheCollectionRegion(EhcacheTransactionalDataRegion).get(Object) line: 112	
			final Element element = getCache().get( key );
/ (*)
			final boolean writeable = item == null || item.isWriteable( txTimestamp, version, versionComparator );
			if ( writeable ) {
				region().put( key, new Item( value, version, region().nextTimestamp() ) );


/ Intermezzo

/ in (*)	,
/ we zien 6 caches	,
			defaultCache	Cache  (id=3644)	
				value	Cache  (id=3598) 	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees" (id=3665)	
				value	Cache  (id=3697)	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee" (id=3696)	
				value	Cache  (id=3730)	"org.hibernate.cache.spi.UpdateTimestampsCache" (id=3729)	
				value	Cache  (id=3725)	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Address" (id=3724)	
				value	Cache  (id=3720)	"org.hibernate.cache.internal.StandardQueryCache" (id=3719)	


this	EhcacheCollectionRegion  (id=3595)	
	cache	Cache  (id=3598)	
		configuration	CacheConfiguration  (id=3608)	
			name	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees" (id=3665)	
		cacheManager	CacheManager  (id=3602)	
			defaultCache	Cache  (id=3644)	
			diskStorePathManager	DiskStorePathManager  (id=3645)	
			ehcaches	ConcurrentHashMap<K,V>  (id=3646)	
				entrySet	ConcurrentHashMap$EntrySet  (id=3744)	
				hashSeed	0	
				keySet	ConcurrentHashMap$KeySet  (id=3655)	
				keySet	null	
				segmentMask	15	
				segments	ConcurrentHashMap$Segment<K,V>[16]  (id=3656)	
					[0]	ConcurrentHashMap$Segment<K,V>  (id=3657)	
						count	1	
						loadFactor	0.75	
						modCount	1	
						sync	ReentrantLock$NonfairSync  (id=3662)	
						table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3663)	
							[1]	ConcurrentHashMap$HashEntry<K,V>  (id=3664)	
								hash	48667965	
								key	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Address.employees" (id=3665)	
								next	null	
->								value	Cache  (id=3598)	
						threshold	1	
					[3]	ConcurrentHashMap$Segment<K,V>  (id=3658)	
						count	1	
						loadFactor	0.75	
						modCount	1	
						sync	ReentrantLock$NonfairSync  (id=3693)	
						table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3694)	
							[0]	ConcurrentHashMap$HashEntry<K,V>  (id=3695)	
								hash	814873880	
								key	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Employee" (id=3696)	
								next	null	
->								value	Cache  (id=3697)	
						threshold	1	
					[7]	ConcurrentHashMap$Segment<K,V>  (id=3659)	
						count	1	
						loadFactor	0.75	
						modCount	1	
						sync	ReentrantLock$NonfairSync  (id=3726)	
						table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3727)	
							[1]	ConcurrentHashMap$HashEntry<K,V>  (id=3728)	
								hash	2113082963	
								key	"org.hibernate.cache.spi.UpdateTimestampsCache" (id=3729)	
								next	null	
->								value	Cache  (id=3730)	
						threshold	1	
					[9]	ConcurrentHashMap$Segment<K,V>  (id=3660)	
						count	1	
						loadFactor	0.75	
						modCount	1	
						sync	ReentrantLock$NonfairSync  (id=3721)	
						table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3722)	
							[0]	ConcurrentHashMap$HashEntry<K,V>  (id=3723)	
								hash	-1787584018	
								key	"my.test.own.hibernate_xml_N_1_bidir_ehcache.Address" (id=3724)	
								next	null	
->								value	Cache  (id=3725)	
						threshold	1	
					[12]	ConcurrentHashMap$Segment<K,V>  (id=3661)	
						count	1	
						loadFactor	0.75	
						modCount	1	
						sync	ReentrantLock$NonfairSync  (id=3716)	
						table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=3717)	
							[1]	ConcurrentHashMap$HashEntry<K,V>  (id=3718)	
								hash	-937369541	
								key	"org.hibernate.cache.internal.StandardQueryCache" (id=3719)	
								next	null	
->								value	Cache  (id=3720)	
						threshold	1	
				segmentShift	28	
				values	null	
				values	null	
			featuresManager	null	
			localTransactionsRecoveryThread	CacheManager$1  (id=24)	
			mbeanRegistrationProvider	MBeanRegistrationProviderImpl  (id=3647)	
			nonstopExecutorServiceFactory	CacheManagerExecutorServiceFactory  (id=3648)	
			onDiskPool	null	
			onHeapPool	null	
			registeredMgmtSvrBind	null	
			runtimeCfg	Configuration$RuntimeCfg  (id=3649)	
			shutdownHook	null	
			softLockManagers	ConcurrentHashMap<K,V>  (id=3650)	
			status	Status  (id=3651)	
			terracottaClient	TerracottaClient  (id=3652)	
			transactionController	TransactionController  (id=3653)	
			transactionIDFactory	DelegatingTransactionIDFactory  (id=3654)	
			transactionManagerLookup	DefaultTransactionManagerLookup  (id=3619)	

	cacheLockTimeout	245760000	
	lockProvider	DiskStore$DiskStoreStripedReadWriteLock  (id=3599)	
	metadata	CacheDataDescriptionImpl  (id=3600)	
	settings	Settings  (id=3581)	
key	CacheKey  (id=3582)	

/ we zien ook regions	,

this	NonstopAwareCollectionRegionAccessStrategy  (id=3375)	
	actualStrategy	ReadWriteEhcacheCollectionRegionAccessStrategy  (id=3372)	
		nextLockId	AtomicLong  (id=3817)	
		region	EhcacheCollectionRegion  (id=3595)	
			accessStrategyFactory	NonstopAccessStrategyFactory  (id=3597)	
			cache	Cache  (id=3598)	
			cacheLockTimeout	245760000	
			lockProvider	DiskStore$DiskStoreStripedReadWriteLock  (id=3599)	
			metadata	CacheDataDescriptionImpl  (id=3600)	
			settings	Settings  (id=3581)	

/ Kunnen we vanuit de cache -> region	?
/ TODO

/ Einde Intermezzo

/ we waren hier	,
/s
EhcacheCollectionRegion(EhcacheTransactionalDataRegion).get(Object) line: 112	
			final Element element = getCache().get( key );
/s
Cache.get(Object) line: 1576	
this	Cache  (id=3598)	





/ Einde N_1 BIDIR





/s
SingleTableEntityPersister(AbstractEntityPersister).hydrate(ResultSet, Serializable, Object, Loadable, String[][], boolean, SessionImplementor) line: 2959	

			final String[] propNames = getPropertyNames();
			final Type[] types = getPropertyTypes();
			final Object[] values = new Object[types.length];
			final boolean[] laziness = getPropertyLaziness();
			final String[] propSubclassNames = getSubclassPropertySubclassNameClosure();

propertySelectable	(id=3569)	
[true, true, true, false]

			for ( int i = 0; i < types.length; i++ ) {
				if ( !this.propertySelectable[i] ) {
					values[i] = BackrefPropertyAccessor.UNKNOWN;
				}
				else if ( allProperties || !laziness[i] ) {
/t
EntityReferenceInitializerImpl.loadFromResultSet(ResultSet, ResultSetProcessingContext, Object, String, EntityKey, LockMode) line: 336	
			values = concreteEntityPersister.hydrate(
					resultSet,
					id,
					entityInstance,
					(Loadable) entityReference.getEntityPersister(),
					concreteEntityPersister == rootEntityPersister
							? entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases()
							: entityReferenceAliases.getColumnAliases().getSuffixedPropertyAliases( concreteEntityPersister ),
					context.getLoadPlan().areLazyAttributesForceFetched(),
					context.getSession()
			);
[0]	"Foo1" (id=3620)	
[1]	Double  (id=3621)	
[2]	Long  (id=3617)	 				Long 12	,
[3]	BackrefPropertyAccessor$1  (id=3622)	

/ Later	,
ResultSetProcessorImpl.extractResults(ResultSet, SessionImplementor, QueryParameters, NamedParameterContext, boolean, boolean, ResultTransformer, List<AfterLoadAction>) line: 140	
		rowReader.finishUp( context, afterLoadActionList );
/s
TwoPhaseLoad.doInitializeEntity(Object, EntityEntry, boolean, SessionImplementor, PreLoadEvent) line: 167	

		final Object[] hydratedState = entityEntry.getLoadedState();
/ Initialize hydratedState met loadedState, 
/ straks wordt resolved	, loaded (hydrated) state=Long 12 -> hydrated state Address#12

		final Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@597ea32c, org.hibernate.type.DoubleType@bbf4061, org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_1_N_bidir_ehcache.Address), org.hibernate.type.LongType@4dee4aae]
		for ( int i = 0; i < hydratedState.length; i++ ) {
hydratedState	Object[4]  (id=3542)	
	[0]	"Foo1" (id=3620)	
	[1]	Double  (id=3621)	
	[2]	Long 12 -> Address  (id=3338)	
	[3]	BackrefPropertyAccessor$1  (id=3622)	
			final Object value = hydratedState[i];
			if ( value!=LazyPropertyInitializer.UNFETCHED_PROPERTY && value!=BackrefPropertyAccessor.UNKNOWN ) {
/ NEE, voor de laatste	, dus blijft onveranderd	,
				hydratedState[i] = types[i].resolve( value, session, entity );

entity	Employee  (id=3502)	
	address	null	
	id	1	
	name	null	
	salary	0.0	
		persister.setPropertyValues( entity, hydratedState );
/s
BackrefPropertyAccessor$BackrefSetter.set(Object, Object, SessionFactoryImplementor) line: 110	
}
entity	Employee  (id=3502)	
	address	Address  (id=3338)	
	id	1	
	name	"Foo1" (id=3620)	
	salary	1.0	

/ we zien de H prop met de backref NIET in de entity	, klopt	,

			final CacheEntry entry = persister.buildCacheEntry( entity, hydratedState, version, session );
/ hydratedState=..., Address#12, ...	, is resolved loaded state	,
/ we hadden coll-query gedaan	, een new Employee, Employee#1, en zelf BackRef.UNKNOWN create	, en deze in 1c set als loaded state	, hierin staat ook Long 12, dat is de fk uit db	,
/ toen hydrate  : Long 12 -> Address#12	, Backref.UNKNOWN onveranderd	,
/ toen in Employee#1 set	, waar Backref.UNKNOWN wordt overgeslagen	, 
/ doet disassemble	,
/s
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/ state is hydrated state	, dus met de Address#12, en de Backref.UNKNOWN (de setter is leeg)	,

		Serializable[] disassembled = new Serializable[row.length];
		for ( int i = 0; i < row.length; i++ ) {
			else if ( row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN ) {
				disassembled[i] = (Serializable) row[i];
			}
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
/ Laat Backref.UNKNOWN onveranderd	,
/ Address#12 -> Long 12	,

/ dan	,
					final boolean put = persister.getCacheAccessStrategy().putFromLoad(
							cacheKey,
							persister.getCacheEntryStructure().structure( entry ),
							session.getTimestamp(),
							version,
							useMinimalPuts( session, entityEntry )
					);

















/ Einde DEBUG 1_N BIDIR 2C

/ DEBUG 1_N BIDIR 1C, 2C ERR 


/ Address' mapping	,

	<set
 		name="employees"
 		inverse="false"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>
	
/ Employee's mapping	,

	<many-to-one 
		name="address"
		column="address_"
		not-null="true"
		update="false"
		insert="false"
	>
	</many-to-one>

/ Main	,

			employee.setAddress(address);
			employee2.setAddress(address);
//			address.getEmployees().add(employee);
//			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
/ ERR	,
org.hibernate.PropertyValueException: not-null property references a null or transient value : my.test.own.hibernate_xml_1_N_bidir_ehcache.Employee._my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employeesBackref
/ want	,

/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 270	
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
		Type[] types = persister.getPropertyTypes();
values	Object[4]  (id=3117)	
	[0]	"Foo1" (id=3118)	
	[1]	Double  (id=3119)	
	[2]	Address  (id=3120)	
types	Type[4]  (id=3121)	
	[0]	StringType  (id=3123)	
	[1]	DoubleType  (id=3124)	
	[2]	ManyToOneType  (id=3125)	
	[3]	LongType  (id=3126)	
/ laatste prop == null	, 
/s
EntityInsertAction(AbstractEntityInsertAction).makeEntityManaged() line: 141	

		nullifyTransientReferencesIfNotAlready();

/ hij nullifies niet alleen transients (bij ons niet), maar checks ook of dat toegestaan is (als not-null="true" ERR)	, 
/ TODO TRANSIENT
/ Dat gebeurt bij ons	, bij ons is de backref	value null, terwijl <set ...><key not-null="true">

/s
EntityInsertAction(AbstractEntityInsertAction).nullifyTransientReferencesIfNotAlready() line: 130	
		if ( ! areTransientReferencesNullified ) {
			new ForeignKeys.Nullifier( getInstance(), false, isEarlyInsert(), getSession() )
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object[], Type[]) line: 80	
			for ( int i = 0; i < types.length; i++ ) {
				values[i] = nullifyTransientReferences( values[i], types[i] );
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object, Type) line: 95	

/ voor string, double	,
			else {
				return value;

/ voor many-to-one	,  returns bij ons uiteindelijk ook value	:

			else if ( type.isEntityType() ) {
				final EntityType entityType = (EntityType) type;
				if ( entityType.isOneToOne() ) {
/ NEE
				else {
					final String entityName = entityType.getAssociatedEntityName();
Address
					return isNullifiable( entityName, value ) ? null : value;
/s
ForeignKeys$Nullifier.nullifyTransientReferences(Object, Type) line: 95	
			final EntityEntry entityEntry = session.getPersistenceContext().getEntry( object );
			if ( entityEntry == null ) {
/ NEE
			else {
				return entityEntry.isNullifiable( isEarlyInsert, session );
/s
EntityEntry.isNullifiable(boolean, SessionImplementor) line: 329	
		else {
			return session.getPersistenceContext().getNullifiableEntityKeys().contains( getEntityKey() );
false 
/ want	1c's nullifiableEntityKeys==[]

/t
ForeignKeys$Nullifier.nullifyTransientReferences(Object, Type) line: 95	
					return isNullifiable( entityName, value ) ? null : value;
/ false , dus returns value	,

/t
ForeignKeys$Nullifier.nullifyTransientReferences(Object[], Type[]) line: 80	

voor de Long, die null is	, 
			for ( int i = 0; i < types.length; i++ ) {
				values[i] = nullifyTransientReferences( values[i], types[i] );
/s
		private Object nullifyTransientReferences(final Object value, final Type type) {
			if ( value == null ) {
				return null;

/t
EntityInsertAction(AbstractEntityInsertAction).nullifyTransientReferencesIfNotAlready() line: 132	
			new ForeignKeys.Nullifier( getInstance(), false, isEarlyInsert(), getSession() )
					.nullifyTransientReferences( getState(), getPersister().getPropertyTypes() );
/D
			new Nullability( getSession() ).checkNullability( getState(), getPersister(), false );
/s
Nullability.checkNullability(Object[], EntityPersister, boolean) line: 74	

			final boolean[] nullability = persister.getPropertyNullability();
[true,true,false,false] 
/=tegenovergestelde van not-null	,

/ we hebben inderdaad name, salary not-null="false" (default)	, en many-to-one, backref (via key)  zijn not-null	,

			final boolean[] checkability = isUpdate ?
false
				persister.getPropertyUpdateability() :
->				persister.getPropertyInsertability();
[true,true,false,true]
/ Klopt	, we hebben insert="false" in de <many-to-one ...>	,
/ checkability is insert/update

			for ( int i = 0; i < values.length; i++ ) {
				if ( checkability[i] && values[i]!= LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
/ JA voor 1,2,4
/ NEE voor 3	,
					final Object value = values[i];
					if ( !nullability[i] && value == null ) {
/ nullability is tegenovergestelde van not-null
/ dus hier test of not-null	,
/ NEE voor 1,2
/ JA voor 4	,
						//check basic level one nullablilty
						throw new PropertyValueException(
								"not-null property references a null or transient value",
								persister.getEntityName(),
								persister.getPropertyNames()[i]
							);
					else if ( value != null ) {
/ JA voor 1,2
						//values is not null and is checkable, we'll look deeper
						final String breakProperties = checkSubElementsNullability( propertyTypes[i], value );
						if ( breakProperties != null ) {
/ NEE voor 1,2


/ Einde DEBUG 1_N BIDIR 1C, 2C ERR 

/ DEBUG 1_N BIDIR 1C, 2C ERR 

/ we wilden overbodig 	,
                        employee.setAddress(address2);
                        employee2.setAddress(address2);
/ maar nu is address2 transient,	 dus ERR	,

Address.getId()
HibernateLog --> 09:05:44 WARN  org.hibernate.action.internal.UnresolvedEntityInsertActions - HHH000437: Attempting to save one or more entities that have a non-nullable association with an unsaved transient entity. The unsaved transient entity must be saved in an operation prior to saving these dependent entities.
	Unsaved transient entity: ([my.test.own.hibernate_xml_1_N_bidir_ehcache.Address#21])
	Dependent entities: ([[my.test.own.hibernate_xml_1_N_bidir_ehcache.Employee#1]])
	Non-nullable association(s): ([my.test.own.hibernate_xml_1_N_bidir_ehcache.Employee.address])


/ Main	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address2=new Address(21l,"foostreet", "21 foo", "FooCity21");

			employee.setAddress(address2);
			employee2.setAddress(address2);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(employee);
/s
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 170	

		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();

/ we zien	,
HibernateLog --> 09:29:04 DEBUG org.hibernate.SQL - select address_.id__, address_.address_line1__ as address_2_0_, address_.zipcode__ as zipcode_3_0_, address_.city_ as city_4_0_ from address address_ where address_.id__=?
Hibernate: select address_.id__, address_.address_line1__ as address_2_0_, address_.zipcode__ as zipcode_3_0_, address_.city_ as city_4_0_ from address address_ where address_.id__=?
HibernateLog --> 09:29:04 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [21]

nonNullableTransientDependencies	NonNullableTransientDependencies  (id=3116)	
	propertyPathsByTransientEntity	IdentityHashMap<K,V>  (id=3118)	
{my.test.own.hibernate_xml_1_N_bidir_ehcache.Address@4147fb56=[address]}

/ we debug deze	,
/s
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 176	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
/s
	/**
	 * Find all non-nullable references to entities that have not yet
	 * been inserted in the database, where the foreign key
	 * is a reference to an unsaved transient entity. .

EntityInsertAction(AbstractEntityInsertAction).findNonNullableTransientEntities() line: 107	
		return ForeignKeys.findNonNullableTransientEntities(
				getPersister().getEntityName(),
Employee
				getInstance(),
employee
				getState(),
[Foo1, 1.0, my.test.own.hibernate_xml_1_N_bidir_ehcache.Address@47d5f581, 12]		/ we zien address2	, de transient	,
				isEarlyInsert(),
false
				getSession()
		);
/s
ForeignKeys.findNonNullableTransientEntities(String, Object, Object[], boolean, SessionImplementor) line: 333	

		final Nullifier nullifier = new Nullifier( entity, false, isEarlyInsert, session );
nullifier	ForeignKeys$Nullifier  (id=3163)	
	isDelete	false	
	isEarlyInsert	false	
	self	Employee  (id=3119)	
	session	SessionImpl  (id=3109)	

		final EntityPersister persister = session.getEntityPersister( entityName, entity );

		final String[] propertyNames = persister.getPropertyNames();
[name, salary, address, _my.test.own.hibernate_xml_1_N_bidir_ehcache.Address.employeesBackref]

		final Type[] types = persister.getPropertyTypes();
[org.hibernate.type.StringType@23bd31c0, org.hibernate.type.DoubleType@46432685, org.hibernate.type.ManyToOneType(my.test.own.hibernate_xml_1_N_bidir_ehcache.Address), org.hibernate.type.LongType@31f3f16b]

		final boolean[] nullability = persister.getPropertyNullability();
[true, true, false, false]

		final NonNullableTransientDependencies nonNullableTransientEntities = new NonNullableTransientDependencies();

		for ( int i = 0; i < types.length; i++ ) {
/ voor iedere H prop	,
			collectNonNullableTransientEntities(
					nullifier,
					values[i],
					propertyNames[i],
					types[i],
					nullability[i],
					session,
					nonNullableTransientEntities
			);
/s
ForeignKeys.collectNonNullableTransientEntities(ForeignKeys$Nullifier, Object, String, Type, boolean, SessionImplementor, NonNullableTransientDependencies) line: 367	
/=
	private static void collectNonNullableTransientEntities(
			Nullifier nullifier,
			Object value,
			String propertyName,
			Type type,
			boolean isNullable,
			SessionImplementor session,
			NonNullableTransientDependencies nonNullableTransientEntities) {

/ dus voor String, Double collects hij niets in nonNullableTransientEntities	,
		if ( type.isEntityType() ) {
		else if ( type.isAnyType() ) {
		else if ( type.isComponentType() ) {

/ voor many-to-one	, Employee.address_ =address2	,
isNullable=false	,
		if ( type.isEntityType() ) {

			final EntityType entityType = (EntityType) type;
			if ( !isNullable
/ JA	, <many-to-one not-null="true">
					&& !entityType.isOneToOne()
/JA
					&& nullifier.isNullifiable( entityType.getAssociatedEntityName(), value ) ) {
/ entityType.getAssociatedEntityName()==Address	,
/ value=address2	, de 3de H prop bij employee	,

////////////////////////////////////
/ nullifier is een ForeignKey$Nullifier	, H maakt van een transient null, dus isNullifiable==isTransient	,

/s
ForeignKeys$Nullifier.isNullifiable(String, Object) line: 143	

			final EntityEntry entityEntry = session.getPersistenceContext().getEntry( object );
			if ( entityEntry == null ) {
/ JA
				return isTransient( entityName, object, null, session );
/s
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 229	

/ persistent: na .save	, daarom isTransient==isUnsaved hieronder	, 

		// let the persister inspect the instance to decide
		final EntityPersister persister = session.getEntityPersister( entityName, entity );
Address-persister	,
		isUnsaved = persister.isTransient( entity, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).isTransient(Object, SessionImplementor) line: 4464	

/ persister checks 1c, 2c, vindt null (niets dus)	:
/ hit db	:

		if ( canExtractIdOutOfEntity() ) {
			id = getIdentifier( entity, session );
/s
	public Serializable getIdentifier(Object entity, SessionImplementor session) {
		return getEntityTuplizer().getIdentifier( entity, session );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getIdentifier(Object, SessionImplementor) line: 346	
			else {
                		id = idGetter.get( entity );
Long 21
		// check the id unsaved-value
		Boolean result = entityMetamodel.getIdentifierProperty()
				.getUnsavedValue().isUnsaved( id );
null
/ TODO
		if ( result != null ) {
/ NEE

		// check to see if it is in the second-level cache
		if ( session.getCacheMode().isGetEnabled() && hasCache() ) {
			final CacheKey ck = session.generateCacheKey( id, getIdentifierType(), getRootEntityName() );
			final Object ce = CacheHelper.fromSharedCache( session, ck, getCacheAccessStrategy() );
			if ( ce != null ) {
null
		return null;

/t
ForeignKeys.isTransient(String, Object, Boolean, SessionImplementor) line: 244	

		isUnsaved = persister.isTransient( entity, session );
null
/ 1c, 2c -> null	, is er niet	,
		if ( isUnsaved != null ) {
/ NEE

		// hit the database, after checking the session cache for a snapshot
		final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(
				persister.getIdentifier( entity, session ),
				persister
		);
/s
StatefulPersistenceContext.getDatabaseSnapshot(Serializable, EntityPersister) line: 310	

		final EntityKey key = session.generateEntityKey( id, persister );
/ id=Long 21	,
		final Object cached = entitySnapshotsByKey.get( key );
null
		if ( cached != null ) {
/ NEE
		else {
			final Object[] snapshot = persister.getDatabaseSnapshot( id, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).getDatabaseSnapshot(Serializable, SessionImplementor) line: 1521	

			PreparedStatement ps = session.getTransactionCoordinator()
					.getJdbcCoordinator()
					.getStatementPreparer()
					.prepareStatement( getSQLSnapshotSelectString() );
/ Address-persister.sqlSnapshotSelectString=select address_.id__, address_.address_line1__ as address_2_0_, address_.zipcode__ as zipcode_3_0_, address_.city_ as city_4_0_ from address address_ where address_.id__=?
			try {
				getIdentifierType().nullSafeSet( ps, id, 1, session );
/ 1 is index in pst	,
/s
				st.setLong( index, javaTypeDescriptor.unwrap( value, Long.class, options ) );

/t
					//if there is no resulting row, return null
					if ( !rs.next() ) {
						return null;
/ In address tbl is er GEEN row met id_+=bigint 21	,
/t
StatefulPersistenceContext.getDatabaseSnapshot(Serializable, EntityPersister) line: 317	
			final Object[] snapshot = persister.getDatabaseSnapshot( id, session );
null
			entitySnapshotsByKey.put( key, snapshot == null ? NO_ROW : snapshot );
/ key=EntityKey		, Long 21,	 Address-persister	,
NO_ROW
		return snapshot == null;
/ transient dus	,

/t
ForeignKeys.collectNonNullableTransientEntities(ForeignKeys$Nullifier, Object, String, Type, boolean, SessionImplementor, NonNullableTransientDependencies) line: 364	
			if ( !isNullable
					&& !entityType.isOneToOne()
					&& nullifier.isNullifiable( entityType.getAssociatedEntityName(), value ) ) {
/ JA
/ de H prop is not-null, en hij is door H null te maken want transient	, 
				nonNullableTransientEntities.add( propertyName, value );
/ 
/ propertyName="address"
/ value=address2

	for ( int i = 0; i < types.length; i++ ) {
/ Volgende	, 
/ LongType, bij backref	, 
/ OK
		return nonNullableTransientEntities.isEmpty() ? null : nonNullableTransientEntities;

/t
ActionQueue.addInsertAction(AbstractEntityInsertAction) line: 177	
		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
/D
		if ( nonNullableTransientDependencies == null ) {
/ NEE
/ Tot nu toe altjd 	,
/ maar nu	,
		else {
			unresolvedInsertions.addUnresolvedEntityInsertAction( insert, nonNullableTransientDependencies );
/s
UnresolvedEntityInsertActions.addUnresolvedEntityInsertAction(AbstractEntityInsertAction, NonNullableTransientDependencies) line: 84	

		dependenciesByAction.put( insert, dependencies );
/ Use we hier beneden	, in checkNoUnresolvedActionsAfterOperation	,
		addDependenciesByTransientEntity( insert, dependencies );
/s
UnresolvedEntityInsertActions.addDependenciesByTransientEntity(AbstractEntityInsertAction, NonNullableTransientDependencies) line: 180	

dependencies	NonNullableTransientDependencies  (id=3113)	
	propertyPathsByTransientEntity	IdentityHashMap<K,V>  (id=3115)	
{my.test.own.hibernate_xml_1_N_bidir_ehcache.Address@4f997ee2=[address]}

		for ( Object transientEntity : dependencies.getNonNullableTransientEntities() ) {
my.test.own.hibernate_xml_1_N_bidir_ehcache.Address@4f997ee2

			Set<AbstractEntityInsertAction> dependentActions = dependentActionsByTransientEntity.get( transientEntity );
			if ( dependentActions == null ) {
/ JA
				dependentActions = new IdentitySet();
				dependentActionsByTransientEntity.put( transientEntity, dependentActions );
			}
			dependentActions.add( insert );
		}

/ dus geen entityinsertaction op de queue	,

/t
SessionImpl.fireSave(SaveOrUpdateEvent) line: 717	
			listener.onSaveOrUpdate( event );
/D
		checkNoUnresolvedActionsAfterOperation();
/s
	private void checkNoUnresolvedActionsAfterOperation() {
		if ( persistenceContext.getCascadeLevel() == 0 ) {
			actionQueue.checkNoUnresolvedActionsAfterOperation();
/s
ActionQueue.checkNoUnresolvedActionsAfterOperation() line: 318	
/this=ActionQueue	,
		unresolvedInsertions.checkNoUnresolvedActionsAfterOperation();
/s
	/**
	 * Throws {@link org.hibernate.PropertyValueException} if there are any unresolved
	 * entity insert actions that depend on non-nullable associations with
	 * a transient entity. This method should be called on completion of
	 * an operation (after all cascades are completed) that saves an entity.
	 *
UnresolvedEntityInsertActions.checkNoUnresolvedActionsAfterOperation() line: 121	
		else {
			final AbstractEntityInsertAction firstDependentAction =
					dependenciesByAction.keySet().iterator().next();
firstDependentAction	EntityInsertAction  (id=3115)	
/ van de employee	, waar het allemaal mee begon	,


			logCannotResolveNonNullableTransientDependencies( firstDependentAction.getSession() );
/ we zien	,
HibernateLog --> 12:43:49 WARN  org.hibernate.action.internal.UnresolvedEntityInsertActions - HHH000437: Attempting to save one or more entities that have a non-nullable association with an unsaved transient entity. The unsaved transient entity must be saved in an operation prior to saving these dependent entities.
	Unsaved transient entity: ([my.test.own.hibernate_xml_1_N_bidir_ehcache.Address#21])
	Dependent entities: ([[my.test.own.hibernate_xml_1_N_bidir_ehcache.Employee#1]])
	Non-nullable association(s): ([my.test.own.hibernate_xml_1_N_bidir_ehcache.Employee.address])

			final NonNullableTransientDependencies nonNullableTransientDependencies =
					dependenciesByAction.get( firstDependentAction );

nonNullableTransientDependencies	NonNullableTransientDependencies  (id=3259)	
	propertyPathsByTransientEntity	IdentityHashMap<K,V>  (id=3261)	
{my.test.own.hibernate_xml_1_N_bidir_ehcache.Address@4142991e=[address]}

			final Object firstTransientDependency =
					nonNullableTransientDependencies.getNonNullableTransientEntities().iterator().next();
firstTransientDependency	Address  (id=3195)	
/ address2	,

			final String firstPropertyPath =
					nonNullableTransientDependencies.getNonNullableTransientPropertyPaths( firstTransientDependency ).iterator().next();
firstPropertyPath	"address" (id=3204)	

			throw new TransientPropertyValueException(
					"Not-null property references a transient value - transient instance must be saved before current operation",
					firstDependentAction.getSession().guessEntityName( firstTransientDependency ),
					firstDependentAction.getEntityName(),
					firstPropertyPath
			);


/ Einde DEBUG 1_N BIDIR 1C, 2C ERR 

/ DEBUG 1_N BIDIR 1C, 2C OK 

/ We zien dat alleen de 1-kant wordt persist	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address2=new Address(21l,"foostreet", "21 foo", "FooCity21");

			employee.setAddress(address2);
			employee2.setAddress(address2);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(address2);
			session.save(employee);
			session.save(employee2);

		  	address.setCity("FooCity12A");
		  	employee.setName("Foo1A");
			
		  	printStats(stats);
			tx.commit();

/ we zien	,

foo=> select*from employee\g
 id_ | name_ | salary_ | address_ 
-----+-------+---------+----------
   2 | Foo2  |       2 |       12
   1 | Foo1A |       1 |       12
(2 rows)

foo=> select*from address\g
 id__ | address_line1__ | zipcode__ |   city_    
------+-----------------+-----------+------------
   21 | foostreet       | 21 foo    | FooCity21
   12 | foostreet       | 12 foo    | FooCity12A
(2 rows)

/ we zien weliswaar dat address2 is persist, maar daar gaat het niet om	,
/ we zien dat de fk in de employees 12 is en niet 21	, dus  
			employee.setAddress(address2);
			employee2.setAddress(address2);
/ doen niets	, 
/ TODO


/ Einde DEBUG 1_N BIDIR 1C, 2C OK 

/ N_1 BIDIR 1C, 2C OK 

/ In hibernate_xml_N_1_bidir_ehcache

/ 7	.

/ Address' mapping to H	,
	<set
 		name="employees"
 		inverse="true"
 	>
 		<cache usage="read-write"/>	
 		<key
 			column="address_"
 			not-null="true"
 		></key>
 		<one-to-many class="Employee"/>
 	</set>

/ Employee's mapping to H	,
	<many-to-one 
		name="address"
		column="address_"
		not-null="false"

	>
	</many-to-one>


/ Main	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12");
			Address address2=new Address(21l,"foostreet", "21 foo", "FooCity21");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address3);
			address.getEmployees().add(employee);
			address.getEmployees().add(employee2);
			
			session.save(address);
			session.save(address2);
			session.save(address3);
			session.save(employee);
			session.save(employee2);

/ new session
			
		  	address=(Address)session.get(Address.class, 12l);
	        	Set<Employee>employees=address.getEmployees();
	        	Iterator<Employee>iterator=employees.iterator();
	        	while(iterator.hasNext()){
/ NEE

/ new session

	        address=(Address)session.get(Address.class, 34l);
	        employees=address.getEmployees();
	        iterator=employees.iterator();
	        while(iterator.hasNext()){
/ JA
	        	Employee e=iterator.next();
	        	String s=e.getName();
Foo2/Foo1
	        	boolean b=false;


/ new session	,

		  	Query query=session.createQuery("select a.employees from Address a where a.id=:id");
		  	query.setParameter("id",34l);
		  	List<Employee>employees3=query.list();
	        	iterator=employees3.iterator();
	        		while(iterator.hasNext()){
	        		Employee e=iterator.next();
	        		String s=e.getName();
	        		boolean b=false;
	        	}
/ Ok

/ Als we doen	,
		  	Query query=session.createQuery("select employees from Address where Address.id=:id");
/ ERR
org.hibernate.hql.internal.ast.QuerySyntaxException: Invalid path: 'null.id' [select employees from my.test.own.hibernate_xml_N_1_bidir_ehcache.Address where Address.id=:id]

/ als we doen	,
		  	Query query=session.createQuery("select employees from Address where id=:id");
		  	query.setParameter("id",34l);
		  	List<Employee>employees3=query.list();
/ ERR
/ we zien	,
Hibernate: select employees1_.id_ as id_1_1_, employees1_.name_ as name_2_1_, employees1_.salary_ as salary_3_1_, employees1_.address_ as address_4_1_ from address address0_ inner join employee employees1_ on address0_.id__=employees1_.address_ where id=?
HibernateLog --> 13:56:24 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [BIGINT] - [34]
HibernateLog --> 13:56:24 WARN  org.hibernate.engine.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: 42703
HibernateLog --> 13:56:24 ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - ERROR: column "id" does not exist
/ id hoort nergens bij, dus gaat letterlijk de query in	,


/ Einde N_1 BIDIR 1C, 2C OK 

/ N_1 BIDIR 1C, 2C QUERY C OK 

/ Lees	,
http://tech.puredanger.com/2009/07/10/hibernate-query-cache/

/ In hibernate_xml_N_1_bidir_ehcache

/ we hoeven in ehcache.xml NIETS te doen	, 
/ we kunnen	,
       	<cache
			name="org.hibernate.cache.StandardQueryCache"
			maxEntriesLocalHeap="5"
			eternal="true"
			timeToLiveSeconds="1200"
			>
			<persistence strategy="localTempSwap"/>
	</cache>
/ en hetzelfde voor de timestamp cache, 	maar niet nodig TODO (lees in http://tech.puredanger.com/2009/07/10/hibernate-query-cache/)

/ In hibernate.cfg.xml	,

   <property name="cache.use_second_level_cache">true</property>
  	<property name="cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>

    <property name="cache.use_query_cache">true</property>
/ en nu ook	,

/ In Main	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address3);

/ nieuwe sessie	,
	        	address=(Address)session.get(Address.class, 34l);

/ nieuwe sessie	,

		  	Query query=session.createQuery("select e from Employee e where e.address=:address");
		  	query.setCacheable(true);
		  	query.setParameter("address", address);
		  	List<Employee>employees3=query.list();
	        	iterator=employees3.iterator();
	        	while(iterator.hasNext()){
	        		Employee e=iterator.next();
	        		String s=e.getName();
	        		//e.setName(s+"A");			/ !
	        		boolean b=false;
	        	}
/ resultset zijn 2 Employee	,
	                
	        	tx.commit();
	        	session.close();

			session = sessionFactory.openSession();
			tx=session.beginTransaction();

		  	query=session.createQuery("select e from Employee e where e.address=:address");
		  	query.setCacheable(true);
		  	query.setParameter("address", address);
		  	employees3=query.list();
	        	iterator=employees3.iterator();
	        	while(iterator.hasNext()){
	        		Employee e=iterator.next();
	        		String s=e.getName();
	        		boolean b=false;
	        	}
/ resultset zijn 2 Employee	,
	        
	        	tx.commit();
	        	session.close();


/ we moeten altijd	,
		  	query.setCacheable(true);
/ als we de resultset aanpassen	,
	        	while(iterator.hasNext()){
	        		Employee e=iterator.next();
	        		String s=e.getName();
	        		e.setName(s+"A");			/ !
	        		boolean b=false;
	        	}
/ dan wordt de 2de keer de query opnieuw exec	.

/ ook als we de par in pst veranderen, wordt de query opnieuw exec	,

/ In Main	,

			Employee employee=new Employee(1l,"Foo1",1.00);
			Employee employee2=new Employee(2l,"Foo2",2.00);
			Address address2=new Address(21l,"foostreet", "21 foo", "FooCity21");
			Address address3=new Address(34l,"foostreet", "34 foo", "FooCity34");
			
			employee.setAddress(address3);
			employee2.setAddress(address2);

/ nieuwe sessie	,
	        	address=(Address)session.get(Address.class, 34l);

/ nieuwe sessie	,

		  	Query query=session.createQuery("select e from Employee e where e.address=:address");
		  	query.setCacheable(true);
		  	query.setParameter("address", address);
		  	List<Employee>employees3=query.list();
	        	iterator=employees3.iterator();
	        	while(iterator.hasNext()){
	        		Employee e=iterator.next();
	        		String s=e.getName();
	        		//e.setName(s+"A");			/ !
	        		boolean b=false;
	        	}
/ resultset zijn 1 Employee	,
	                
	        	tx.commit();
	        	session.close();

			session = sessionFactory.openSession();
			tx=session.beginTransaction();


	        	address=(Address)session.get(Address.class, 21l);
		  	query=session.createQuery("select e from Employee e where e.address=:address");
		  	query.setCacheable(true);
		  	query.setParameter("address", address);
		  	employees3=query.list();
	        	iterator=employees3.iterator();
	        	while(iterator.hasNext()){
	        		Employee e=iterator.next();
	        		String s=e.getName();
	        		boolean b=false;
	        	}
/ resultset zijn 1 (andere) Employee	,
	        
	        	tx.commit();
	        	session.close();






/ Einde N_1 BIDIR 1C, 2C QUERY C OK 

/ N_1 UNIDIR 1C, 2C OK 

/ als address geen employees prop heeft,	 kan deze query NIET	,

		  	Query query=session.createQuery("select a.employees from Address a where a.id=:id");
/ ERR
		  	query.setParameter("id",34l);
		  	List<Employee>employees3=query.list();
	        	Iterator<Employee>iterator=employees3.iterator();
	        	while(iterator.hasNext()){
	        		Employee e=iterator.next();
	        		String s=e.getName();
	        		boolean b=false;
	        	}

/ we zien de ERR	,
org.hibernate.QueryException: could not resolve property: employees of: my.test.own.hibernate_xml_N_1_ehcache.Address [select a.employees from my.test.own.hibernate_xml_N_1_ehcache.Address a where a.id=:id]


/ Einde N_1 UNIDIR 1C, 2C OK 



SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 481	
...
		for ( EntityPersister persister : entityPersisters.values() ) {
			persister.postInstantiate();
/ De eerste is	,
/ persister=SingleTableEntityPersister(my.test.own.hibernate_xml_1_N_ehcache.Address)

/s
SingleTableEntityPersister(AbstractEntityPersister).postInstantiate() line: 4017	
		createLoaders();
/s
SingleTableEntityPersister(AbstractEntityPersister).createLoaders() line: 4037	
		final Map loaders = getLoaders();
{}j
		loaders.put( LockMode.NONE, createEntityLoader( LockMode.NONE ) );
/s
SingleTableEntityPersister(AbstractEntityPersister).createEntityLoader(LockMode, LoadQueryInfluencers) line: 2506	
		return BatchingEntityLoaderBuilder.getBuilder( getFactory() )
				.buildLoader( this, batchSize, lockMode, getFactory(), loadQueryInfluencers );
/s
LegacyBatchingEntityLoaderBuilder(BatchingEntityLoaderBuilder).buildLoader(OuterJoinLoadable, int, LockMode, SessionFactoryImplementor, LoadQueryInfluencers) line: 74	
		if ( batchSize <= 1 ) {
1
			// no batching
			return buildNonBatchingLoader( persister, lockMode, factory, influencers );
/s
LegacyBatchingEntityLoaderBuilder(AbstractBatchingEntityLoaderBuilder).buildNonBatchingLoader(OuterJoinLoadable, LockMode, SessionFactoryImplementor, LoadQueryInfluencers) line: 47	
		return EntityLoader.forEntity( persister ).withLockMode( lockMode ).withInfluencers( influencers ).byPrimaryKey();
/s
EntityLoader.forEntity(OuterJoinLoadable) line: 59	
		return new Builder( persister );
/t
/s
EntityLoader$Builder.withLockMode(LockMode) line: 84	
			this.lockMode = lockMode;
			return this;
/t
/s
EntityLoader$Builder.withInfluencers(LoadQueryInfluencers) line: 79	
			this.influencers = influencers;
			return this;
/t
/s
EntityLoader$Builder.byPrimaryKey() line: 94	
			return byUniqueKey( persister.getIdentifierColumnNames(), persister.getIdentifierType() );
/s
SingleTableEntityPersister(AbstractEntityPersister).getIdentifierColumnNames() line: 1382	
		return rootTableKeyColumnNames;
[id__]
/t
/s
SingleTableEntityPersister(AbstractEntityPersister).getIdentifierType() line: 4922	
		return entityMetamodel.getIdentifierProperty().getType();
/t
/s
EntityLoader$Builder.byUniqueKey(String[], Type) line: 98	
			return new EntityLoader(
					persister.getFactory(),
					persister,
					keyColumnNames,
					keyType,
					new QueryBuildingParameters() {
						@Override
						public LoadQueryInfluencers getQueryInfluencers() {
							return influencers;
						}

						@Override
						public int getBatchSize() {
							return batchSize;
						}

						@Override
						public LockMode getLockMode() {
							return lockMode;
						}

						@Override
						public LockOptions getLockOptions() {
							return lockOptions;
						}
					}
			);
/s
EntityLoader.<init>(SessionFactoryImplementor, OuterJoinLoadable, String[], Type, QueryBuildingParameters) line: 134	
		super( persister, factory, uniqueKeyColumnNames, uniqueKeyType, buildingParameters );
/s
EntityLoader(AbstractLoadPlanBasedEntityLoader).<init>(OuterJoinLoadable, SessionFactoryImplementor, String[], Type, QueryBuildingParameters) line: 77	
		super( persister, factory, uniqueKeyColumnNames, uniqueKeyType, buildingParameters );
/s
EntityLoader(AbstractLoadPlanBasedLoader).<init>(SessionFactoryImplementor) line: 81	

/t
EntityLoader(AbstractLoadPlanBasedEntityLoader).<init>(OuterJoinLoadable, SessionFactoryImplementor, String[], Type, QueryBuildingParameters) line: 77	
		this.entityName = entityPersister.getEntityName();
/=
		return entityMetamodel.getName();
my.test.own.hibernate_xml_1_N_ehcache.Address

		if ( buildingParameters.getQueryInfluencers().getFetchGraph() != null ) {
/ NEE
		else if ( buildingParameters.getQueryInfluencers().getLoadGraph() != null ) {
/ NEE
		else {
			strategy = new FetchStyleLoadPlanBuildingAssociationVisitationStrategy(
					factory, buildingParameters.getQueryInfluencers(),buildingParameters.getLockMode()
/s
/**
 * A LoadPlanBuildingAssociationVisitationStrategy is a strategy for building a LoadPlan.
 * LoadPlanBuildingAssociationVisitationStrategy is also a AssociationVisitationStrategy, which is used in
 * conjunction with visiting associations via walking metamodel definitions.
 * <p/>
 * So this strategy defines a AssociationVisitationStrategy that walks the metamodel-defined associations after
 * which is can then build a LoadPlan based on the visited associations. {@link #determineFetchStrategy} is the
 * main decision point that determines if an association is walked.
 *
 * @author Steve Ebersole
 *
 * @see org.hibernate.loader.plan.build.spi.LoadPlanBuildingAssociationVisitationStrategy
 * @see org.hibernate.persister.walking.spi.AssociationVisitationStrategy
 */
public abstract class AbstractLoadPlanBuildingAssociationVisitationStrategy
		implements LoadPlanBuildingAssociationVisitationStrategy, LoadPlanBuildingContext {

/t
/s
/**
 * {@link LoadPlanBuildingAssociationVisitationStrategy} implementation used for building LoadPlans based on metamodel-defined fetching.  Built
 * LoadPlans contain a single root return object, either an {@link EntityReturn} or a {@link CollectionReturn}.
 *
 * @author Steve Ebersole
 */
public class FetchStyleLoadPlanBuildingAssociationVisitationStrategy
		extends AbstractLoadPlanBuildingAssociationVisitationStrategy {

/t
/s
FetchStyleLoadPlanBuildingAssociationVisitationStrategy.<init>(SessionFactoryImplementor, LoadQueryInfluencers, LockMode) line: 69	
		super( sessionFactory );
/s
FetchStyleLoadPlanBuildingAssociationVisitationStrategy(AbstractLoadPlanBuildingAssociationVisitationStrategy).<init>(SessionFactoryImplementor) line: 106	
		this.sessionFactory = sessionFactory;
		this.querySpaces = new QuerySpacesImpl( sessionFactory );

/t
EntityLoader(AbstractLoadPlanBasedEntityLoader).<init>(OuterJoinLoadable, SessionFactoryImplementor, String[], Type, QueryBuildingParameters) line: 99	
			strategy = new FetchStyleLoadPlanBuildingAssociationVisitationStrategy(
					factory, buildingParameters.getQueryInfluencers(),buildingParameters.getLockMode()
			);
/ D
		final LoadPlan plan = MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
/s
MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan(LoadPlanBuildingAssociationVisitationStrategy, EntityPersister) line: 56	
		MetamodelGraphWalker.visitEntity( strategy, persister );
/ Address-persister	,

/ Intermezzo

/ Herinner	, we zijn nog in	,

SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 481	
		for ( EntityPersister persister : entityPersisters.values() ) {
			persister.postInstantiate();

/ Eerst Address-perister	,

/ Einde Intermezzo

		MetamodelGraphWalker.visitEntity( strategy, persister );
/s
	/**
	 * Entry point into walking the model graph of an entity according to its defined metamodel.
	 *
	 * @param strategy The semantics strategy
	 * @param persister The persister describing the entity to start walking from
	 */
MetamodelGraphWalker.visitEntity(AssociationVisitationStrategy, EntityPersister) line: 69	
		strategy.start();
/s
FetchStyleLoadPlanBuildingAssociationVisitationStrategy(AbstractLoadPlanBuildingAssociationVisitationStrategy).start() line: 149	
		propertyPathStack.push( new PropertyPath() );
/s
PropertyPath.<init>() line: 71	
		this( "" );
/s
		this( null, property );

/t
MetamodelGraphWalker.visitEntity(AssociationVisitationStrategy, EntityPersister) line: 71	
		strategy.start();
/D
			new MetamodelGraphWalker( strategy, persister.getFactory() )
					.visitEntityDefinition( persister );
/s
MetamodelGraphWalker.<init>(AssociationVisitationStrategy, SessionFactoryImplementor) line: 102	
		this.strategy = strategy;
		this.factory = factory;

/t
MetamodelGraphWalker.visitEntity(AssociationVisitationStrategy, EntityPersister) line: 71	
			new MetamodelGraphWalker( strategy, persister.getFactory() )
/ D
					.visitEntityDefinition( persister );
/s
MetamodelGraphWalker.visitEntityDefinition(EntityDefinition) line: 108	
		strategy.startingEntity( entityDefinition );
/s
FetchStyleLoadPlanBuildingAssociationVisitationStrategy(AbstractLoadPlanBuildingAssociationVisitationStrategy).startingEntity(EntityDefinition) line: 180	

		final EntityReturnImpl entityReturn = new EntityReturnImpl( entityDefinition, querySpaces );
/ entityDefinition=Address-persister	,
/s
AbstractExpandingFetchSource.<clinit>() line: 63	
/t
/s
EntityReturnImpl.<init>(EntityDefinition, ExpandingQuerySpaces) line: 39	
		super(
				querySpaces.makeRootEntityQuerySpace(
						querySpaces.generateImplicitUid(),
						entityDefinition.getEntityPersister()
				),
				new PropertyPath( entityDefinition.getEntityPersister().getEntityName() )
		);
/s
	public String generateImplicitUid() {
		return "<gen:" + implicitUidBase++ + ">";
<gen:0>
/t
/s
QuerySpacesImpl.makeRootEntityQuerySpace(String, EntityPersister) line: 92	
		final ExpandingEntityQuerySpace space = makeEntityQuerySpace( uid, entityPersister, true );
/s
QuerySpacesImpl.makeEntityQuerySpace(String, EntityPersister, boolean) line: 103	
		final EntityQuerySpaceImpl space = new EntityQuerySpaceImpl(
				entityPersister,
				uid,
				this,
				canJoinsBeRequired && !entityPersister.getEntityMetamodel().hasSubclasses()
		);
/s
EntityQuerySpaceImpl.<init>(EntityPersister, String, ExpandingQuerySpaces, boolean) line: 46	
		super( uid, Disposition.ENTITY, querySpaces, canJoinsBeRequired );
/ canJoinsBeRequired=true	,

/t
QuerySpacesImpl.makeEntityQuerySpace(String, EntityPersister, boolean) line: 125	
		final EntityQuerySpaceImpl space = new EntityQuerySpaceImpl(
				entityPersister,
				uid,
				this,
				canJoinsBeRequired && !entityPersister.getEntityMetamodel().hasSubclasses()
		);
/D
		registerQuerySpace( space );
/s
QuerySpacesImpl.registerQuerySpace(QuerySpace) line: 197	
		final QuerySpace previous = querySpaceByUid.put( querySpace.getUid(), querySpace );

/t
QuerySpacesImpl.makeRootEntityQuerySpace(String, EntityPersister) line: 93	
		final ExpandingEntityQuerySpace space = makeEntityQuerySpace( uid, entityPersister, true );
/D
		roots.add( space );

/t
EntityReturnImpl.<init>(EntityDefinition, ExpandingQuerySpaces) line: 39	
		super(
				querySpaces.makeRootEntityQuerySpace(
						querySpaces.generateImplicitUid(),
						entityDefinition.getEntityPersister()
				),
/D
				new PropertyPath( entityDefinition.getEntityPersister().getEntityName() )
		);
/s
		return entityMetamodel.getName();
pkg.Address
/t
/s
EntityReturnImpl(AbstractEntityReference).<init>(ExpandingEntityQuerySpace, PropertyPath) line: 49	
		super( entityQuerySpace, propertyPath );
		this.identifierDescription = buildIdentifierDescription();
/s
EntityReturnImpl(AbstractEntityReference).buildIdentifierDescription() line: 64	
		final EntityIdentifierDefinition identifierDefinition = getEntityPersister().getEntityKeyDefinition();
/s
EntityReturnImpl(AbstractEntityReference).getEntityPersister() line: 108	
		return expandingEntityQuerySpace().getEntityPersister();
/s
EntityReturnImpl(AbstractEntityReference).expandingEntityQuerySpace() line: 54	
		return (ExpandingEntityQuerySpace) expandingQuerySpace();
/ TODO
/t
EntityQuerySpaceImpl.getEntityPersister() line: 69	
		return expandingEntityQuerySpace().getEntityPersister();
/s
EntityQuerySpaceImpl.getEntityPersister() line: 69	
		return persister;

/t
EntityReturnImpl(AbstractEntityReference).buildIdentifierDescription() line: 64	
		final EntityIdentifierDefinition identifierDefinition = getEntityPersister().getEntityKeyDefinition();
/s
SingleTableEntityPersister(AbstractEntityPersister).getEntityKeyDefinition() line: 5335	
/s
		return entityIdentifierDefinition;

/t
EntityReturnImpl(AbstractEntityReference).buildIdentifierDescription() line: 66	
		final EntityIdentifierDefinition identifierDefinition = getEntityPersister().getEntityKeyDefinition();
/D
identifierDefinition	EntityIdentifierDefinitionHelper$1  (id=2822)	
	attr	EntityIdentifierDefinitionHelper$AttributeDefinitionAdapter  (id=2921)	
<identifier-property:id>
	val$entityPersister	SingleTableEntityPersister  (id=2026)	

			final EncapsulatedEntityIdentifierDefinition encapsulatedIdentifierDefinition = (EncapsulatedEntityIdentifierDefinition) identifierDefinition;
			final Type idAttributeType = encapsulatedIdentifierDefinition.getAttributeDefinition().getType();
/s
			return entityPersister.getEntityMetamodel().getIdentifierProperty().getType();
/ LongType inst	,

			if ( ! CompositeType.class.isInstance( idAttributeType ) ) {
/ JA
				return new SimpleEntityIdentifierDescriptionImpl();

/t
FetchStyleLoadPlanBuildingAssociationVisitationStrategy(AbstractLoadPlanBuildingAssociationVisitationStrategy).startingEntity(EntityDefinition) line: 199	
		final EntityReturnImpl entityReturn = new EntityReturnImpl( entityDefinition, querySpaces );
/D
		addRootReturn( entityReturn );
/s
		this.rootReturn = rootReturn;

		pushToStack( entityReturn );
/s
		propertyPathStack.push( fetchSource.getPropertyPath() );
		fetchSourceStack.addFirst( fetchSource );

		// also add an AssociationKey for the root so we can later on recognize circular references back to the root.
		final Joinable entityPersister = (Joinable) entityDefinition.getEntityPersister();

		associationKeyRegistered(
				new AssociationKey( entityPersister.getTableName(), entityPersister.getKeyColumnNames() )
		);
/s
SingleTableEntityPersister.getTableName() line: 770	
		return qualifiedTableNames[0];

/t
MetamodelGraphWalker.visitEntityDefinition(EntityDefinition) line: 110	
		strategy.startingEntity( entityDefinition );
/ entityDefinition=Address-persister
/D
		visitIdentifierDefinition( entityDefinition.getEntityKeyDefinition() );

...
/t
MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan(LoadPlanBuildingAssociationVisitationStrategy, EntityPersister) line: 57	
		MetamodelGraphWalker.visitEntity( strategy, persister );
/ D
		return strategy.buildLoadPlan();
/s
FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan() line: 94	
		if ( EntityReturn.class.isInstance( rootReturn ) ) {
			return new LoadPlanImpl( (EntityReturn) rootReturn, getQuerySpaces() );
/s
LoadPlanImpl.<init>(EntityReturn, QuerySpaces) line: 70	
		this( Collections.singletonList( rootReturn ), querySpaces, Disposition.ENTITY_LOADER, false );
/s
LoadPlanImpl.<init>(List<Return>, QuerySpaces, Disposition, boolean) line: 58	
		this.returns = returns;
		this.querySpaces = querySpaces;
		this.disposition = disposition;
ENTITY_LOADER
		this.areLazyAttributesForceFetched = areLazyAttributesForceFetched;
false

/t
EntityLoader(AbstractLoadPlanBasedEntityLoader).<init>(OuterJoinLoadable, SessionFactoryImplementor, String[], Type, QueryBuildingParameters) line: 100	
		final LoadPlan plan = MetamodelDrivenLoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
/D
		this.staticLoadQuery = BatchingLoadQueryDetailsFactory.makeEntityLoadQueryDetails(
				plan,
				uniqueKeyColumnNames,
				buildingParameters,
				factory
		);
/s
	 * Returns a EntityLoadQueryDetails object from the given inputs.
	 *
	 * @param loadPlan The load plan
	 * @param keyColumnNames The columns to load the entity by (the PK columns or some other unique set of columns)
	 * @param buildingParameters And influencers that would affect the generated SQL (mostly we are concerned with those
	 * that add additional joins here)
	 * @param factory The SessionFactory
	 *
	 * @return The EntityLoadQueryDetails
	 */
BatchingLoadQueryDetailsFactory.makeEntityLoadQueryDetails(LoadPlan, String[], QueryBuildingParameters, SessionFactoryImplementor) line: 66	

		return new EntityLoadQueryDetails(
				loadPlan,
				keyColumnNamesToUse,
				aliasResolutionContext,
				rootReturn,
				buildingParameters,
				factory
		);
/s
EntityLoadQueryDetails.<init>(LoadPlan, String[], AliasResolutionContextImpl, EntityReturn, QueryBuildingParameters, SessionFactoryImplementor) line: 90	
		super(
				loadPlan,
				aliasResolutionContext,
				buildingParameters,
				keyColumnNames,
				rootReturn,
				factory
		);
/s
EntityLoadQueryDetails(AbstractLoadQueryDetails).<init>(LoadPlan, AliasResolutionContextImpl, QueryBuildingParameters, String[], Return, SessionFactoryImplementor) line: 80	
		this.keyColumnNames = keyColumnNames;
[id__]
		this.rootReturn = rootReturn;
		this.loadPlan = loadPlan;
		this.queryProcessor = new LoadQueryJoinAndFetchProcessor( aliasResolutionContext, buildingParameters, factory );

/t
EntityLoadQueryDetails.<init>(LoadPlan, String[], AliasResolutionContextImpl, EntityReturn, QueryBuildingParameters, SessionFactoryImplementor) line: 90	
               super(
		...
/ D
		this.entityReferenceAliases = aliasResolutionContext.generateEntityReferenceAliases(
				rootReturn.getQuerySpaceUid(),
				rootReturn.getEntityPersister()
		);
this	EntityLoadQueryDetails  (id=3304)	
	entityReferenceAliases	EntityReferenceAliasesImpl  (id=3331)	
		columnAliases	DefaultEntityAliases  (id=3335)	
			rowIdAlias	"rowid_0_" (id=3341)	
			suffix	"0_" (id=3342)	
			suffixedDiscriminatorColumn	null	
			suffixedKeyColumns	String[1]  (id=3344)	
				[0]	"id__1_0_0_" (id=3347)	
			suffixedPropertyColumns	String[4][]  (id=3345)	
				[0]	String[1]  (id=3348)	
					[0]	"address_2_0_0_" (id=3352)	
				[1]	String[1]  (id=3349)	
					[0]	"zipcoce_3_0_0_" (id=3353)	
				[2]	String[1]  (id=3350)	
					[0]	"city_4_0_0_" (id=3356)	
				[3]	String[0]  (id=3351)	
			suffixedVersionColumn	null	
			userProvidedAliases	Collections$EmptyMap<K,V>  (id=3346)	
		tableAlias	"address0_" (id=3338)	
	keyColumnNames	String[1]  (id=2774)	
		[0]	"id__" (id=2775)	

		this.readerCollector = new EntityLoaderReaderCollectorImpl(
				new EntityReturnReader( rootReturn ),
				new EntityReferenceInitializerImpl( rootReturn, entityReferenceAliases, true )
		);
/s
EntityReferenceInitializerImpl.<init>(EntityReference, EntityReferenceAliases, boolean) line: 77	
		this.entityReference = entityReference;
		this.entityReferenceAliases = entityReferenceAliases;
		isReturn = isRoot;
true
	}
/t
/s
EntityLoadQueryDetails.<init>(LoadPlan, String[], AliasResolutionContextImpl, EntityReturn, QueryBuildingParameters, SessionFactoryImplementor) line: 106	
		generate();
/s
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 140	

	/**
	 * Main entry point for properly handling the FROM clause and and joins and restrictions
	 *
	 */
	protected void generate() {

		// There are 2 high-level requirements to perform here:
		// 	1) Determine the SQL required to carry out the given LoadPlan (and fulfill
		// 		{@code LoadQueryDetails#getSqlStatement()}).  SelectStatementBuilder collects the ongoing efforts to
		//		build the needed SQL.
		// 	2) Determine how to read information out of the ResultSet resulting from executing the indicated SQL
		//		(the SQL aliases).  ReaderCollector and friends are where this work happens, ultimately
		//		producing a ResultSetProcessor

		final SelectStatementBuilder select = new SelectStatementBuilder( queryProcessor.getSessionFactory().getDialect() );

		// LoadPlan is broken down into 2 high-level pieces that we need to process here.
		//
		// First is the QuerySpaces, which roughly equates to the SQL FROM-clause.  We'll cycle through
		// those first, generating aliases into the AliasContext in addition to writing SQL FROM-clause information
		// into SelectStatementBuilder.  The AliasContext is populated here and the reused while process the SQL
		// SELECT-clause into the SelectStatementBuilder and then again also to build the ResultSetProcessor

		applyRootReturnTableFragments( select );
/s
EntityLoadQueryDetails.applyRootReturnTableFragments(SelectStatementBuilder) line: 123	
		else if ( getQueryBuildingParameters().getLockMode() != null ) {
			fromTableFragment = getSessionFactory().getDialect().appendLockHint(
					getQueryBuildingParameters().getLockMode(),
					outerJoinLoadable.fromTableFragment( rootAlias )
			);
address address0_

			select.setLockMode( getQueryBuildingParameters().getLockMode() );
		select.appendFromClauseFragment( fromTableFragment + outerJoinLoadable.fromJoinFragment( rootAlias, true, true ) );

/t
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 140	
		applyRootReturnTableFragments( select );
/D
		if ( shouldApplyRootReturnFilterBeforeKeyRestriction() ) {
/ NEE
		else {
			// add restrictions...
			// first, the load key restrictions (which entity(s)/collection(s) do we want to load?)
			applyKeyRestriction(
					select,
					getRootTableAlias(),
					keyColumnNames,
					getQueryBuildingParameters().getBatchSize()
			);
/s
AbstractLoadQueryDetails.applyKeyRestriction(SelectStatementBuilder, String, String[], int) line: 224	
		if ( keyColumnNames.length==1 ) {
			// NOT A COMPOSITE KEY
			// 		for batching, use "foo in (?, ?, ?)" for batching
			//		for no batching, use "foo = ?"
			// (that distinction is handled inside InFragment)
			final InFragment in = new InFragment().setColumn( alias, keyColumnNames[0] );
			for ( int i = 0; i < batchSize; i++ ) {
				in.addValue( "?" );
			}
in	InFragment  (id=3502)	
	columnName	"address0_.id__" (id=3505)	
	values	ArrayList<E>  (id=3507)	
[?]
			select.appendRestrictions( in.toFragmentString() );
address0_.id__=?

/t
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 160	
			applyKeyRestriction(
					select,
					getRootTableAlias(),
					keyColumnNames,
					getQueryBuildingParameters().getBatchSize()
			);
/ D
			applyRootReturnFilterRestrictions( select );
/s
EntityLoadQueryDetails.applyRootReturnFilterRestrictions(SelectStatementBuilder) line: 147	
		selectStatementBuilder.appendRestrictions(
				rootQueryable.filterFragment(
						entityReferenceAliases.getTableAlias(),
						Collections.emptyMap()
				)
""
		);

/t
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 164	
			applyRootReturnFilterRestrictions( select );
/D
		applyRootReturnWhereJoinRestrictions( select );
/ WH niets	,

		applyRootReturnOrderByFragments( select );
/ NIETS

		applyRootReturnSelectFragments( select );
/s
EntityLoadQueryDetails.applyRootReturnSelectFragments(SelectStatementBuilder) line: 192	
		final OuterJoinLoadable outerJoinLoadable = (OuterJoinLoadable) getRootEntityReturn().getEntityPersister();
Address-persister	,
		selectStatementBuilder.appendSelectClauseFragment(
				outerJoinLoadable.selectFragment(
						entityReferenceAliases.getTableAlias(),
						entityReferenceAliases.getColumnAliases().getSuffix()

				)
address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcoce__ as zipcoce_3_0_0_, address0_.city_ as city_4_0_0_
		);

/t
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 164	
		applyRootReturnSelectFragments( select );
/D
		queryProcessor.processQuerySpaceJoins( getRootQuerySpace(), select );
/s
EntityLoadQueryDetails.getRootQuerySpace() line: 177	
		return getQuerySpace( getRootEntityReturn().getQuerySpaceUid() );
/ getRootEntityReturn().getQuerySpaceUid()="<gen:0?"
/s
EntityLoadQueryDetails(AbstractLoadQueryDetails).getQuerySpace(String) line: 88	
		return loadPlan.getQuerySpaces().getQuerySpaceByUid( querySpaceUid );
/t
LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(QuerySpace, SelectStatementBuilder) line: 111	
/=
	public void processQuerySpaceJoins(QuerySpace querySpace, SelectStatementBuilder selectStatementBuilder) {
querySpace	EntityQuerySpaceImpl  (id=2903)	

/t
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 178	

		queryProcessor.processQuerySpaceJoins( getRootQuerySpace(), select );
/ D
		// Next, we process the Returns and Fetches building the SELECT clause and at the same time building
		// Readers for reading the described results out of a SQL ResultSet

		FetchStats fetchStats = null;
		if ( FetchSource.class.isInstance( rootReturn ) ) {
			fetchStats = queryProcessor.processFetches(
					(FetchSource) rootReturn,
					select,
					getReaderCollector()
			);
		}
fetchStats	LoadQueryJoinAndFetchProcessor$FetchStatsImpl  (id=3585)	
	hasSubselectFetch	false	

		LoadPlanTreePrinter.INSTANCE.logTree( loadPlan, queryProcessor.getAliasResolutionContext() );

		this.sqlStatement = select.toStatementString();
this	EntityLoadQueryDetails  (id=3304)	
	entityReferenceAliases	EntityReferenceAliasesImpl  (id=3331)	
	keyColumnNames	String[1]  (id=2774)	
		[0]	"id__" (id=2775)	
	loadPlan	LoadPlanImpl  (id=3131)	
	queryProcessor	LoadQueryJoinAndFetchProcessor  (id=3329)	
	readerCollector	EntityLoadQueryDetails$EntityLoaderReaderCollectorImpl  (id=3403)	
	resultSetProcessor	null	
	rootReturn	EntityReturnImpl  (id=2878)	
	sqlStatement	"select address0_.id__ as id__1_0_0_, address0_.address_line1__ as address_2_0_0_, address0_.zipcoce__ as zipcoce_3_0_0_, address0_.city_ as city_4_0_0_ from address address0_ where address0_.id__=?" (id=3611)	

		this.resultSetProcessor = new ResultSetProcessorImpl(
				loadPlan,
				getReaderCollector().buildRowReader(),
				fetchStats != null && fetchStats.hasSubselectFetches()
		);
	}
/s
EntityLoadQueryDetails$EntityLoaderReaderCollectorImpl.buildRowReader() line: 213	
			return new EntityLoaderRowReader( this );
this	EntityLoadQueryDetails$EntityLoaderReaderCollectorImpl  (id=3403)	
/s
EntityLoadQueryDetails$EntityLoaderRowReader.<init>(EntityLoadQueryDetails$EntityLoaderReaderCollectorImpl) line: 228	
/=
		public EntityLoaderRowReader(EntityLoaderReaderCollectorImpl entityLoaderReaderCollector) {
			super( entityLoaderReaderCollector );
/s
EntityLoadQueryDetails$EntityLoaderRowReader(AbstractRowReader).<init>(ReaderCollector) line: 66	
		this.entityReferenceInitializers = readerCollector.getEntityReferenceInitializers() != null
				? new ArrayList<EntityReferenceInitializer>( readerCollector.getEntityReferenceInitializers() )
				: Collections.<EntityReferenceInitializer>emptyList();
		this.arrayReferenceInitializers = readerCollector.getArrayReferenceInitializers() != null
				? new ArrayList<CollectionReferenceInitializer>( readerCollector.getArrayReferenceInitializers() )
				: Collections.<CollectionReferenceInitializer>emptyList();
		this.collectionReferenceInitializers = readerCollector.getNonArrayCollectionReferenceInitializers() != null
				? new ArrayList<CollectionReferenceInitializer>( readerCollector.getNonArrayCollectionReferenceInitializers() )
				: Collections.<CollectionReferenceInitializer>emptyList();
	}

/t
EntityLoadQueryDetails$EntityLoaderRowReader.<init>(EntityLoadQueryDetails$EntityLoaderReaderCollectorImpl) line: 227	
			super( entityLoaderReaderCollector );
			this.rootReturnReader = entityLoaderReaderCollector.getReturnReader();
this	EntityLoadQueryDetails$EntityLoaderRowReader  (id=3633)	
	arrayReferenceInitializers	Collections$EmptyList<E>  (id=3659)	
	collectionReferenceInitializers	Collections$EmptyList<E>  (id=3659)	
	entityReferenceInitializers	ArrayList<E>  (id=3660)	
		elementData	Object[1]  (id=3682)	
			[0]	EntityReferenceInitializerImpl  (id=3398)	
				entityReference	EntityReturnImpl  (id=2878)	
				entityReferenceAliases	EntityReferenceAliasesImpl  (id=3331)	
				isReturn	true	
		modCount	0	
		size	1	
	rootReturnReader	EntityReturnReader  (id=3405)	
		entityReturn	EntityReturnImpl  (id=2878)	
			bidirectionalEntityReferences	null	
			fetches	null	
			identifierDescription	SimpleEntityIdentifierDescriptionImpl  (id=2946)	
			propertyPath	PropertyPath  (id=2915)	
			querySpace	EntityQuerySpaceImpl  (id=2903)	
				canJoinsBeRequired	true	
				disposition	QuerySpace$Disposition  (id=2911)	
				joins	null	
				persister	SingleTableEntityPersister  (id=2026)	
				querySpaces	QuerySpacesImpl  (id=2804)	
				uid	"<gen:0>" (id=2895)	
entityLoaderReaderCollector	EntityLoadQueryDetails$EntityLoaderReaderCollectorImpl  (id=3403)	
	arrayReferenceInitializers	null	
	collectionReferenceInitializers	null	
	entityReferenceInitializers	ArrayList<E>  (id=3409)	
	entityReturnReader	EntityReturnReader  (id=3405)	
/D

/t
EntityLoadQueryDetails(AbstractLoadQueryDetails).generate() line: 199	
		this.resultSetProcessor = new ResultSetProcessorImpl(
				loadPlan,
				getReaderCollector().buildRowReader(),
/ D
				fetchStats != null && fetchStats.hasSubselectFetches()
		);
/s
ResultSetProcessorImpl.<init>(LoadPlan, RowReader, boolean) line: 61	
		this.loadPlan = loadPlan;
		this.rowReader = rowReader;
		this.hadSubselectFetches = hadSubselectFetches;


/ Helemaal terug naar	,
/t
SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 481	
		for ( EntityPersister persister : entityPersisters.values() ) {
			persister.postInstantiate();
/ Address-persister
/s
SingleTableEntityPersister(AbstractEntityPersister).postInstantiate() line: 4017	
		createLoaders();
/s
SingleTableEntityPersister(AbstractEntityPersister).createLoaders() line: 4037	
		loaders.put( LockMode.NONE, createEntityLoader( LockMode.NONE ) );
/ D
/ TODO (Afmaken)
/ HIER HIER















































Thread [main] (Suspended (breakpoint at line 77 in EntityReferenceInitializerImpl))	
	EntityReferenceInitializerImpl.<init>(EntityReference, EntityReferenceAliases, boolean) line: 77	


	EntityLoadQueryDetails.<init>(LoadPlan, String[], AliasResolutionContextImpl, EntityReturn, QueryBuildingParameters, SessionFactoryImplementor) line: 102	
	BatchingLoadQueryDetailsFactory.makeEntityLoadQueryDetails(LoadPlan, String[], QueryBuildingParameters, SessionFactoryImplementor) line: 73	
	EntityLoader(AbstractLoadPlanBasedEntityLoader).<init>(OuterJoinLoadable, SessionFactoryImplementor, String[], Type, QueryBuildingParameters) line: 100	
	EntityLoader.<init>(SessionFactoryImplementor, OuterJoinLoadable, String[], Type, QueryBuildingParameters) line: 134	
	EntityLoader.<init>(SessionFactoryImplementor, OuterJoinLoadable, String[], Type, QueryBuildingParameters, EntityLoader$1) line: 55	
	EntityLoader$Builder.byUniqueKey(String[], Type) line: 98	
	EntityLoader$Builder.byPrimaryKey() line: 94	
	LegacyBatchingEntityLoaderBuilder(AbstractBatchingEntityLoaderBuilder).buildNonBatchingLoader(OuterJoinLoadable, LockMode, SessionFactoryImplementor, LoadQueryInfluencers) line: 47	
	LegacyBatchingEntityLoaderBuilder(BatchingEntityLoaderBuilder).buildLoader(OuterJoinLoadable, int, LockMode, SessionFactoryImplementor, LoadQueryInfluencers) line: 76	
	SingleTableEntityPersister(AbstractEntityPersister).createEntityLoader(LockMode, LoadQueryInfluencers) line: 2506	
	SingleTableEntityPersister(AbstractEntityPersister).createEntityLoader(LockMode) line: 2528	
	SingleTableEntityPersister(AbstractEntityPersister).createLoaders() line: 4037	
	SingleTableEntityPersister(AbstractEntityPersister).postInstantiate() line: 4017	
	SessionFactoryImpl.<init>(Configuration, Mapping, ServiceRegistry, Settings, SessionFactoryObserver) line: 481	
	Configuration.buildSessionFactory(ServiceRegistry) line: 1857	
	Main.setUp() line: 74	
	Main.<init>() line: 62	
	Main.main(String[]) line: 57	





/ Einde SESSIONIMPL.<INIT>

/ ID GETTERS/SETTERS

/ 7	.

/ hibernate_xml_1_N_ehcache	,


	.save(address)
/s
DefaultSaveEventListener(AbstractSaveEventListener).saveWithGeneratedId(Object, String, Object, EventSource, boolean) line: 117	
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/s
Assigned.generate(SessionImplementor, Object) line: 50	
		final Serializable id = session.getEntityPersister( entityName, obj ).getIdentifier( obj, session );
/s
SingleTableEntityPersister(AbstractEntityPersister).getIdentifier(Object, SessionImplementor) line: 4746	
		return getEntityTuplizer().getIdentifier( entity, session );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).getIdentifier(Object, SessionImplementor) line: 346	
			else {
                		id = idGetter.get( entity );
/s
BasicPropertyAccessor$BasicGetter.get(Object) line: 169	
				return method.invoke( target, (Object[]) null );
/s
Address.getId() line: 58	
	return id;

/t
DefaultSaveEventListener(AbstractSaveEventListener).saveWithGeneratedId(Object, String, Object, EventSource, boolean) line: 137	
		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
/D
			return performSave( entity, generatedId, persister, false, anything, source, true );
/s
DefaultSaveEventListener(AbstractSaveEventListener).performSave(Object, Serializable, EntityPersister, boolean, Object, EventSource, boolean) line: 184	
			persister.setIdentifier( entity, id, source );
/s
SingleTableEntityPersister(AbstractEntityPersister).setIdentifier(Object, Serializable, SessionImplementor) line: 4751	
		getEntityTuplizer().setIdentifier( entity, id, session );
/s
PojoEntityTuplizer(AbstractEntityTuplizer).setIdentifier(Object, Serializable, SessionImplementor) line: 381	
			idSetter.set( entity, id, getFactory() );
/s
BasicPropertyAccessor$BasicSetter.set(Object, Object, SessionFactoryImplementor) line: 68	
				method.invoke( target, value );
/s
Address.setId(long) line: 63	

/ 7	. 

	.commit()
/s
DefaultFlushEventListener(AbstractFlushingEventListener).flushEntities(FlushEvent, PersistenceContext) line: 231	
					listener.onFlushEntity( entityEvent );
/s
DefaultFlushEntityEventListener.onFlushEntity(FlushEntityEvent) line: 152	
		final Object[] values = getValues( entity, entry, mightBeDirty, session );
/s
DefaultFlushEntityEventListener.getValues(Object, EntityEntry, boolean, SessionImplementor) line: 192	
		else {
			checkId( entity, persister, entry.getId(), session );
/s
DefaultFlushEntityEventListener.checkId(Object, EntityPersister, Serializable, SessionImplementor) line: 75	
		if ( persister.canExtractIdOutOfEntity() ) {

			Serializable oid = persister.getIdentifier( object, session );
...

/ 7	. 

/ hibernate_xml_1_N_idgen_ehcache

/ TODO







/ Einde ID GETTERS/SETTERS

/ COMPONENTS TO 1C 2C

/ 7	.

/ we hoeven geen aparte ehcache entry te create voor een component	,

/ Address.xml

<hibernate-mapping 
	package="my.test.own.hibernate_xml_component_ehcache">

<class 
	name="Address" 
	table="address"
>
	<cache 
		usage="read-write"/>
	<id 
		name="id"
		column="id__"
	>	
	<property
		name="addressLine1"
		column="address_line1__"
	/>
	<property 
		name="zipcode" 
		column="zipcode__">
	</property>
	<property 
		name="city"
		column="city__">
	</property>
	
	<component name="employee" class="Employee">
		<property
		name="name"
		column="name_"
		/>
		<property 
			name="salary"
			column="salary_"
		/>
	</component>
 </class>

/ Lees <hibernate-mapping ...> als de mapping van Java obj -> Hibernate	,

/ <component ...> heeft geen table attr	, want komt in address table	,
/ <component ...> heeft geen <id ...> , want de row komt in die van de address	, 

/ Vergeet niet in hibernate.cfg.xml Employee.hbm.xml te rm	,
$ vi hibernate.cfg.xml	,
...
 <mapping resource="my/test/own/hibernate_xml_component_ehcache/Address.hbm.xml"/>

////////////////////////////////
/ Employee.class heeft geen id	,




/ we zien	, bij tx.commit()	,

HibernateLog --> 09:17:41 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, name_, salary_, id__) values (?, ?, ?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, name_, salary_, id__) values (?, ?, ?, ?, ?, ?)
HibernateLog --> 09:17:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 09:17:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 09:17:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 09:17:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [VARCHAR] - [Foo1]
HibernateLog --> 09:17:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [DOUBLE] - [1.0]
HibernateLog --> 09:17:41 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [6] as [BIGINT] - [12]

foo=> select*from address\g
 id__ | address_line1__ | zipcode__ |  city__   | name_ | salary_ 
------+-----------------+-----------+-----------+-------+---------
   12 | foostreet       | 12 foo    | FooCity12 | Foo1  |       1
(1 row)

/ we debug	,

			Employee employee=new Employee("Foo1",1.00);
			Address address=new Address(12l,"foostreet", "12 foo", "FooCity12",employee);
			session.save(address);
/s
DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 270	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
		Type[] types = persister.getPropertyTypes();
values	Object[4]  (id=3018)	
	[0]	"foostreet" (id=3034)	
	[1]	"12 foo" (id=3036)	
	[2]	"FooCity12" (id=3038)	
	[3]	Employee  (id=3039)	
/ Geen probleem, met getters, ook getEmployee()	,
types	Type[4]  (id=3019)	
	[0]	StringType  (id=3020)	
	[1]	StringType  (id=3020)	
	[2]	StringType  (id=3020)	
	[3]	ComponentType  (id=3021)	
this	DefaultSaveEventListener  (id=2978)	
entity	Address  (id=3012)	
key	EntityKey  (id=3013)	
persister	SingleTableEntityPersister  (id=2982)	
useIdentityColumn	false	
anything	null	
source	SessionImpl  (id=27)	
requiresImmediateIdAccess	true	
id	Long  (id=3017)	
inTxn	true	
shouldDelayIdentityInserts	false	
values	Object[4]  (id=3018)	
	[0]	"foostreet" (id=3034)	
	[1]	"12 foo" (id=3036)	
	[2]	"FooCity12" (id=3038)	
	[3]	Employee  (id=3039)	
		name	"Foo1" (id=3173)	
		salary	1.0	
types 	Type[4]
	[3]	ComponentType  (id=3021)	
		canDoExtraction	null	
		cascade	CascadeStyle[2]  (id=3058)	
		componentTuplizer	PojoComponentTuplizer  (id=3060)	
			componentClass	Class<T> (my.test.own.hibernate_xml_component_ehcache.Employee) (id=1592)	
			getters	Getter[2]  (id=3078)	
				[0]	BasicPropertyAccessor$BasicGetter  (id=3081)	
				[1]	BasicPropertyAccessor$BasicGetter  (id=3082)	
			hasCustomAccessors	false	
			instantiator	PojoInstantiator  (id=3079)	
			optimizer	null	
			parentGetter	null	
			parentSetter	null	
			propertySpan	2	
			setters	Setter[2]  (id=3080)	
		entityMode	EntityMode  (id=3062)	
		hasNotNullProperty	false	
		isKey	false	
		joinedFetch	FetchMode[2]  (id=3066)	
		propertyNames	String[2]  (id=3068)	
			[0]	"name" (id=3073)	
			[1]	"salary" (id=3074)	
		propertyNullability	(id=3069)	
		propertySpan	2	
		propertyTypes	Type[2]  (id=3070)	
		typeScope	TypeFactory$TypeScopeImpl  (id=3071)	

/ 7	.
	tx.commit()
/s
EntityInsertAction.execute() line: 104	
			persister.insert( id, getState(), instance, session );

/ Geen probleem: gewoon values van Employee achteraan de prepared st	, (en als laatste de Address' id)	,
/s
SingleTableEntityPersister(AbstractEntityPersister).insert(Serializable, Object[], boolean[], int, String, Object, SessionImplementor) line: 3121	
			if ( useBatch ) {
				insert = session.getTransactionCoordinator()
						.getJdbcCoordinator()
						.getBatch( inserBatchKey )
						.getBatchStatement( sql, callable );
			}

				dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
/s
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2844	
		for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
				getPropertyTypes()[i].nullSafeSet( ps, fields[i], index, includeColumns[i], session );
fields	Object[4]  (id=3018)	
...
	[3]	Employee  (id=3172)	
		name	"Foo1" (id=3173)	
		salary	1.0	
/ de laatste	,
/s
ComponentType.nullSafeSet(PreparedStatement, Object, int, boolean[], SessionImplementor) line: 357	
/=
	public void nullSafeSet(
			PreparedStatement st,
			Object value,
			int begin,
			boolean[] settable,
			SessionImplementor session)
value	Employee  (id=3172)	
	name	"Foo1" (id=3173)	
	salary	1.0	

		Object[] subvalues = nullSafeGetValues( value, entityMode );
begin	4	
subvalues	Object[2]  (id=3379)	
	[0]	"Foo1" (id=3173)	
	[1]	Double  (id=3381)	

	for ( int i = 0; i < this.propertySpan; i++ ) {
			int len = this.propertyTypes[i].getColumnSpan( session.getFactory() );
			else if ( len == 1 ) {
				if ( settable[loc] ) {
					propertyTypes[i].nullSafeSet( st, subvalues[i], begin, session );
/ sets value in PreparedStatement st	,
/ deze komen gewoon bij de ene query	,

/t
SingleTableEntityPersister(AbstractEntityPersister).dehydrate(Serializable, Object[], Object, boolean[], boolean[][], int, PreparedStatement, SessionImplementor, int, boolean) line: 2849	
		if ( !isUpdate ) {
			index += dehydrateId( id, rowId, ps, session, index );
/s
			getIdentifierType().nullSafeSet( ps, id, index, session );

/t
EntityInsertAction.execute() line: 127	
			persister.insert( id, getState(), instance, session );
/D

/ we zien	,
HibernateLog --> 12:12:41 DEBUG org.hibernate.SQL - insert into address (address_line1__, zipcode__, city__, name_, salary_, id__) values (?, ?, ?, ?, ?, ?)
Hibernate: insert into address (address_line1__, zipcode__, city__, name_, salary_, id__) values (?, ?, ?, ?, ?, ?)
HibernateLog --> 12:13:44 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [1] as [VARCHAR] - [foostreet]
HibernateLog --> 12:14:57 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [2] as [VARCHAR] - [12 foo]
HibernateLog --> 12:14:59 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [3] as [VARCHAR] - [FooCity12]
HibernateLog --> 12:22:38 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [4] as [VARCHAR] - [Foo1]
HibernateLog --> 12:22:48 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [5] as [DOUBLE] - [1.0]
HibernateLog --> 12:24:12 TRACE org.hibernate.type.descriptor.sql.BasicBinder - binding parameter [6] as [BIGINT] - [12]

		if ( isCachePutEnabled( persister, session ) ) {
			final CacheEntry ce = persister.buildCacheEntry(
					instance,
					getState(),
					version,
					session
			);
/s
StandardCacheEntryImpl.<init>(Object[], EntityPersister, boolean, Object, SessionImplementor, Object) line: 74	
		this.disassembledState = TypeHelper.disassemble(
				state,
				persister.getPropertyTypes(),
				persister.isLazyPropertiesCacheable() ? null : persister.getPropertyLaziness(),
				session,
				owner
		);
/s
		for ( int i = 0; i < row.length; i++ ) {
			else {
				disassembled[i] = types[i].disassemble( row[i], session, owner );
/ de laatste	,
ComponentType.disassemble(Object, SessionImplementor, Object) line: 596	
		else {
			Object[] values = getPropertyValues( value, entityMode );
value	Employee  (id=3172)	
	name	"Foo1" (id=3173)	
	salary	1.0	
values	Object[2]  (id=3424)	
	[0]	"Foo1" (id=3173)	
	[1]	Double  (id=3425)	
		for ( int i = 0; i < propertyTypes.length; i++ ) {
				values[i] = propertyTypes[i].disassemble( values[i], session, owner );
/ values blijft onveranderd	,

/t
TypeHelper.disassemble(Object[], Type[], boolean[], SessionImplementor, Object) line: 148	

/ uiteindelijk	,
disassembled	Serializable[4]  (id=3475)	
	[0]	"foostreet" (id=3034)	
	[1]	"12 foo" (id=3036)	
	[2]	"FooCity12" (id=3038)	
	[3]	Object[2]  (id=3424)	
		[0]	"Foo1" (id=3173)	
		[1]	Double  (id=3425)	

/ TODO (Afmaken)
















	








/ Einde COMPONENTS TO 1C 2C








































































...
->		rowReader.finishUp( context, afterLoadActionList );
/ calls put in ehcache
////////////////////////////////////////////









/ 7	. 

/ als we een session hebben, hoe komen we dan bij de configuration	, en dus bij de RootClass's prpperties (de H properties)?

	protected void setUp() throws Exception {
             
        	Configuration configuration=new Configuration().configure();
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);

/ In sessionFactory is serviceRegistry, en daarin is de Configuration	,
/ als we een session hebben, ga dan eerst naar de session factory	, en zo bij de configuration	,

sessionFactory	SessionFactoryImpl  (id=563)	
	serviceRegistry	SessionFactoryServiceRegistryImpl  (id=568)	
		configuration	Configuration  (id=20)	
			classes	HashMap<K,V>  (id=242)	
				table	HashMap$Entry<K,V>[16]  (id=257)	
					[4]	HashMap$Entry<K,V>  (id=261)	
						value	RootClass  (id=215)	
							properties	ArrayList<E>  (id=292)	
								elementData	Object[10]  (id=302)	
									[3]	Property  (id=307)	
										cascade	"none" (id=311)	
										value	Set  (id=63)	
											element	OneToMany  (id=194)	
											key	DependantValue  (id=207)	
					[8]	HashMap$Entry<K,V>  (id=262)	
						value	RootClass  (id=70)	
							properties	ArrayList<E>  (id=144)	
								elementData	Object[10]  (id=146)	
									[2]	Backref  (id=72)	
										value	DependantValue  (id=207)	
											wrappedValue	SimpleValue  (id=224)	


/ 7	. 

/ Wij use bij .save niet direct de properties in de root classes van Address, Employee, 
/ Maar WH de persisters create hiermee entityMetamodel en entityTuplizer	, met getters/setters, en entityMetamodel.getPropertyTypes, en entityMetamodel.getProperySpan, 
/ .save doet getValues, en die haalt met getters de values uit de objs, en set ze in de H properties 	,

DefaultSaveEventListener(AbstractSaveEventListener).performSaveOrReplicate(Object, EntityKey, EntityPersister, boolean, Object, EventSource, boolean) line: 268	

		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
		Type[] types = persister.getPropertyTypes();

		if ( persister.hasCollections() ) {
			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
		}

		if ( substitute ) {
			persister.setPropertyValues( entity, values );
/ c
PojoEntityTuplizer(AbstractEntityTuplizer).setPropertyValues(Object, Object[]) line: 713	
				setters[j].set( entity, values[j], getFactory() );
/ Van het Address obj wordt de employees een PersistentSet	,

/ De values (properties) komen als loadedState in de entityentry in de pc	,

/ we zien dat de obj ook wordt aangepast met de H properties	, als substitude=true	,
/ Bij een Address obj is substitude=true	, dus wordt employees een PersistentSet	, 
/ bij een Employee is substitude false, dat klopt ook wel: er is een H property address_	, maar er is in de Employee obj geen property address_
//////////////////////////////// 

/ er komt ook een column address_ in de employee table	,

/ Bij een Employee obj	, is er een Backref prpperty	, deze heeft zelf een getter	,
		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
/s
BackrefPropertyAccessor$BackrefGetter.getForInsert(Object, Map, SessionImplementor) line: 121	
/=
	public class BackrefGetter implements Getter {
		public Object getForInsert(Object target, Map mergeMap, SessionImplementor session) {
				return session.getPersistenceContext().getOwnerId( entityName, propertyName, target, mergeMap );
/ precies goed: Long 12	,



































/ Einde HIBERNATE & EHCACHE

