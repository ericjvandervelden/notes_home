/ JUNIT BOOK CH17 

/ eclipse-jee-test
/ ws workspace

[eric@localhost ch17-dbunit]$ pwd
/home/eric/Devel/Java/Testing/junitbook2/ch17-dbunit
[eric@localhost ch17-dbunit]$ mvn eclipse:clean
/ .settings is niet rm
/ TODO
[eric@localhost ch17-dbunit]$ rm -rf .settings/

/ nu kunnen we import in eclipse, als maven project, ch17-dbunit

$ vi AbstractDbUnitTestCase.java 

public abstract class AbstractDbUnitTestCase {
 	... 
  protected static DatabaseConnection dbunitConnection;
/ Was 
  protected static HsqldbConnection dbunitConnection;


/ Intermezzo

/ 13	. 

/ in postgres	,

foo=> create table if not exists ser(id serial,s varchar(32));
foo=> insert into ser(s) values('bar');
foo=> insert into ser(s) values('foo');
foo=> select*from ser;
 id |  s  
----+-----
  1 | bar
  2 | foo
(2 rows)

/ 13	. 

/ h2	,


/ Lees	,
http://stackoverflow.com/questions/5763747/h2-in-memory-database-table-not-found

If you have your connection-url configured like this
jdbc:h2:mem:test
the content of the database is lost at the moment the last connection is closed.

If you want to keep your content you have to configure the url like this
jdbc:h2:mem:test;DB_CLOSE_DELAY=-1
If doing so, h2 will keep its content as long as the vm lives.

/ 13	. 

/ lees	,
http://www.h2database.com/html/tutorial.html#using_server

Starting the Server Tool from Command Line

[eric@localhost h2]$ pwd
/home/eric/Devel/Java/h2
[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Server
TCP server running at tcp://localhost:9092 (only local connections)
PG server running at pg://localhost:5435 (only local connections)
Web Console server running at http://localhost:8082 (only local connections)

/ inderdaad, er verschijnt in chrome, 
http://localhost:8082/login.do?jsessionid=5f84f00080938371c6e64ca0abe9ffa7

/ we zien linksboven
Auto commit : uncheck

/ we kunnen create/drop table niet rollback	, in pg wel	,

/ 13	. 

/ we oefenen	in h2,
CREATE TABLE if not exists users ( id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1), username VARCHAR(10))
/ of	,
CREATE TABLE if not exists users ( id INTEGER auto_increment, username VARCHAR(10))

/ eerst	,
CREATE TABLE if not exists users ( id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1), username VARCHAR(10))
insert into users(username)values('foo'),('bar')
select*from users
/ OK

drop table users
CREATE TABLE if not exists users ( id INTEGER auto_increment, username VARCHAR(10))
insert into users(username)values('foo'),('bar')
select*from users
/ OK

/ 13	. 

[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Server -?
Starts the H2 Console (web-) server, TCP, and PG server.
Usage: java org.h2.tools.Server <options>
When running without options, -tcp, -web, -browser and -pg are started.
Options are case sensitive. Supported options are:
[-help] or [-?]         Print the list of options
[-web]                  Start the web server with the H2 Console
[-webAllowOthers]       Allow other computers to connect - see below
[-webDaemon]            Use a daemon thread
[-webPort <port>]       The port (default: 8082)
[-webSSL]               Use encrypted (HTTPS) connections
[-browser]              Start a browser connecting to the web server
[-tcp]                  Start the TCP server
[-tcpAllowOthers]       Allow other computers to connect - see below
[-tcpDaemon]            Use a daemon thread
[-tcpPort <port>]       The port (default: 9092)
[-tcpSSL]               Use encrypted (SSL) connections
[-tcpPassword <pwd>]    The password for shutting down a TCP server
[-tcpShutdown "<url>"]  Stop the TCP server; example: tcp://localhost
[-tcpShutdownForce]     Do not wait until all connections are closed
[-pg]                   Start the PG server
[-pgAllowOthers]        Allow other computers to connect - see below
[-pgDaemon]             Use a daemon thread
[-pgPort <port>]        The port (default: 5435)
[-properties "<dir>"]   Server properties (default: ~, disable: null)
[-baseDir <dir>]        The base directory for H2 databases (all servers)
[-ifExists]             Only existing databases may be opened (all servers)
[-trace]                Print additional trace information (all servers)
[-key <from> <to>]      Allows to map a database name to another (all servers)
The options -xAllowOthers are potentially risky.
For details, see Advanced Topics / Protection against Remote Access.
See also http://h2database.com/javadoc/org/h2/tools/Server.html

/ 13	. 

/ we doen	,
[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Server
/ en	,
[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Shell -url jdbc:h2:tcp://localhost/./test

/ door deze laatste wordt de db create	,

sql> CREATE TABLE if not exists users ( id INTEGER auto_increment, username VARCHAR(10))
...> ;
(Update count: 0, 4 ms)
sql> show tables;
TABLE_NAME | TABLE_SCHEMA
USERS      | PUBLIC
(1 row, 19 ms)
sql> alter table if exists users add primary key (id)


sql> help set
...> ;
71  | Commands (Other)   | SET AUTOCOMMIT                   | SET AUTOCOMMIT { TRUE | ON | FALSE | OFF }                                                           | Switches auto commit on or off.

sql> help show
...> ;

sql> show columns from users;
FIELD    | TYPE        | NULL | KEY | DEFAULT
ID       | INTEGER(10) | NO   | PRI | (NEXT VALUE FOR PUBLIC.SYSTEM_SEQUENCE_9F9C7F0A_6935_4435_B0EC_632B8837F278)
USERNAME | VARCHAR(10) | YES  |     | NULL
(2 rows, 3 ms)

foo=>CREATE TABLE if not exists refs( id integer auto_increment primary key,rid integer not null references users(id));
/ zonder foreign key dus	,
/ of
foo=>CREATE TABLE if not exists refs( id integer auto_increment primary key,rid integer not null, foreign key (rid) references users(id));

/ of met alter table	,

sql> CREATE TABLE if not exists refs( id INTEGER auto_increment primary key);
sql> alter table refs add column rid integer not null;
sql> show columns from refs;
FIELD | TYPE        | NULL | KEY | DEFAULT
ID    | INTEGER(10) | NO   | PRI | (NEXT VALUE FOR PUBLIC.SYSTEM_SEQUENCE_E7869DBD_617D_4530_9DF7_53EAEBC15322)
RID   | INTEGER(10) | NO   |     | NULL
(2 rows, 1 ms)
sql> alter table refs add foreign key(rid)references users(id);
sql> show columns from refs;
FIELD | TYPE        | NULL | KEY | DEFAULT
ID    | INTEGER(10) | NO   | PRI | (NEXT VALUE FOR PUBLIC.SYSTEM_SEQUENCE_E7869DBD_617D_4530_9DF7_53EAEBC15322)
RID   | INTEGER(10) | NO   |     | NULL
(2 rows, 2 ms)
/ TODO we zien de foreign key niet	,

/ 13. 	

/ postgresql

/ lees	,
https://www.postgresql.org/docs/9.2/static/ddl-constraints.html

foo=> create table users(id serial primary key, name varchar(32));

foo=>CREATE TABLE if not exists refs( id serial primary key,rid integer not null references users(id));
/ zonder foreign key dus	,
/ of	, 
foo=>CREATE TABLE if not exists refs( id serial primary key,rid integer not null, foreign key(rid) references users(id));

/ het verschil tussen pg en h2 is dus 
	serial
	integer auto_increment

/ 13	. 

/ h2 als pg	,

[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Server 
TCP server running at tcp://localhost:9092 (only local connections)
PG server running at pg://localhost:5435 (only local connections)
Web Console server running at http://localhost:8082 (only local connections)
Created new window in existing browser session.
/ of	,
[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Server -pg
PG server running at pg://localhost:5435 (only local connections)

[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Shell -url jdbc:h2:pg://localhost/./test2

/ we hebben dus tcp vervangen door pg	, 
[eric@localhost h2]$ java -cp h2-1.4.193.jar org.h2.tools.Shell -url jdbc:h2:tcp://localhost/./test2
/ in onze tests vervangen we tcp door mem	,
jdbc:h2:mem:my-project-test;DB_CLOSE_DELAY=-1

sql> create table users(id serial primary key, name varchar(32));
(Update count: 0, 1 ms)
sql> insert into users(name) values('foo'),('bar');
(Update count: 2, 1 ms)
sql> select*from users;
ID | NAME
1  | foo
2  | bar
(2 rows, 2 ms)
sql> rollback;
(Update count: 0, 1 ms)
sql> select*from users;
ID | NAME
(0 rows, 0 ms)
sql> show tables;
TABLE_NAME | TABLE_SCHEMA
USERS      | PUBLIC
(1 row, 2 ms)

/ Dus rollback werkt niet zoals in pg	, want de table users is er nog	, 

/ ook 
sql> \d
/ kent hij niet	, maar dat klopt, want dat is psql	, 

/ 13	. 

/ DB_CLOSE_DELAY

/ lees	,
http://pierreandrews.net/posts/slick-h2-scala.html

/ lees	,
https://gerrydevstory.com/2014/04/11/unit-testing-using-mysql-in-memory-database-on-spring/
/ we zien 	,
  <property name="url" value="jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE" />

/ WH is DB_CLOSE_ON_EXIT=FALSE useless voor mem db	, 

/ eclipse-jee-test
/ workspace
/ proj ch17-dbunit

/ in src/test/resources, dus op het class path,
$ vi my.xml
<?xml version="1.0"?>
<dataset>
  <user username="ericj" first_name="Eric J." last_name="Van der Velden" />
</dataset>

/ 13	. 

/ we zien dat DB_CLOSE_DELAY=-1 nodig is bij meerdere connections	,

/ DB_CLOSE_DELAY of db_close_delay mag allebei	, 

$ vi MyH2Test.java

public class MyH2Test {

	private Connection connection,connection2;
	private DatabaseConnection databaseConnection,databaseConnection2;
	private Statement statement,statement2;

	/*
	 * with 1,2,3 like so, we need DB_CLOSE_DELAY=-1 at 1,
	 * if 2 is active iso 3, then DB_CLOSE_DELAY=-1 is not needed.
	 * DB_CLOSE_DELAY=-1 at connection2 makes no sense.
	 * */
						

	@Test
	public void test() throws SQLException, DatabaseUnitException, IOException {

		// 1
//		connection=DriverManager.getConnection("jdbc:h2:mem:test");
		connection=DriverManager.getConnection("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1");
		databaseConnection=new H2Connection(connection, null);
		
		//2
//		connection2=DriverManager.getConnection("jdbc:h2:mem:test");
//		databaseConnection2=new H2Connection(connection2, null);
		
		statement=connection.createStatement();
		statement.executeUpdate("CREATE TABLE user ( id INTEGER auto_increment, username VARCHAR(32), first_name VARCHAR(32), last_name VARCHAR(32) )");
		statement.close();
		databaseConnection.close();
		
		// 3
		connection2=DriverManager.getConnection("jdbc:h2:mem:test");
		databaseConnection2=new H2Connection(connection2, null);

		
		InputStream inputStream=getClass().getResourceAsStream("/my.xml");
		Reader reader=new InputStreamReader(inputStream);
		IDataSet iDataSet=new FlatXmlDataSet(reader);
		DatabaseOperation.CLEAN_INSERT.execute(databaseConnection2, iDataSet);
		
		statement2=connection2.createStatement();
		ResultSet resultSet=statement2.executeQuery("select * from user where id=1");
		Assert.assertTrue(resultSet.next());
		User user=new User();
		user.setUsername(resultSet.getString("username"));
		user.setFirstName(resultSet.getString("first_name"));
		user.setLastName(resultSet.getString("last_name"));
		Assert.assertEquals("ericj", user.getUsername());
		Assert.assertEquals("Eric J.",user.getFirstName());
		Assert.assertEquals("Van der Velden", user.getLastName());
		

	}

}

/ 13	. 

/ we hebben iets vereenvoudigd, waarin we zien dat we DB_CLOSE_DELAY=-1 nodig hebben	,

/ zonder ;DB_CLOSE_DELAY=-1 hebben we ERR
org.dbunit.dataset.NoSuchTableException: user
	at org.dbunit.database.DatabaseDataSet.getTableMetaData(DatabaseDataSet.java:278)
	at org.dbunit.operation.DeleteAllOperation.execute(DeleteAllOperation.java:109)
	at org.dbunit.operation.CompositeOperation.execute(CompositeOperation.java:79)
	at com.manning.junitbook.ch17.dbunit.MyH2Test.test2(MyH2Test.java:97)	/ bij ->

/ DB_CLOSE_DELAY=0 is de default, of je laat hem weg, of je set =0  er neer,

public class MyH2Test {

	@Test
	public void test2() throws SQLException, DatabaseUnitException, IOException {

		connection=DriverManager.getConnection("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1");
		databaseConnection=new H2Connection(connection, null);
		
		statement=connection.createStatement();
		statement.executeUpdate("CREATE TABLE user ( id INTEGER auto_increment, username VARCHAR(32), first_name VARCHAR(32), last_name VARCHAR(32) )");
		statement.close();
		databaseConnection.close();
		
		
		connection=DriverManager.getConnection("jdbc:h2:mem:test");
		databaseConnection=new H2Connection(connection, null);
		
		InputStream inputStream=getClass().getResourceAsStream("/my.xml");
		Reader reader=new InputStreamReader(inputStream);
		IDataSet iDataSet=new FlatXmlDataSet(reader);
->		DatabaseOperation.CLEAN_INSERT.execute(databaseConnection, iDataSet);
		
		statement=connection.createStatement();
		ResultSet resultSet=statement.executeQuery("select * from user where id=1");
		Assert.assertTrue(resultSet.next());
		User user=new User();
		user.setUsername(resultSet.getString("username"));
		user.setFirstName(resultSet.getString("first_name"));
		user.setLastName(resultSet.getString("last_name"));
		Assert.assertEquals("ericj", user.getUsername());
		Assert.assertEquals("Eric J.",user.getFirstName());
		Assert.assertEquals("Van der Velden", user.getLastName());
		

	}

/ 13	. 

/ we hebben een andere test create	, met create connection in @Before	, waar we zien dat we DB_CLOSE_DELAY nodig hebben	, 
/ eigenlijk is alleen DB_CLOSE_DELAY=-1 nodig bij het maken van de 1ste connectie, maar het kan geen kwaad het bij allemaal te set	,

public class MyH2Test2 {

	private Connection connection;
	private DatabaseConnection databaseConnection;
	private Statement statement;
	
	
	@Before
	public void init() throws SQLException, DatabaseUnitException{
		connection=DriverManager.getConnection("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1");
		databaseConnection=new H2Connection(connection, null);
	}
	
	@After
	public void fin() throws SQLException{
		databaseConnection.close();
	}
			

	@Test
	public void test() throws SQLException, DatabaseUnitException, IOException {
		statement=connection.createStatement();
		statement.executeUpdate("CREATE TABLE user ( id INTEGER auto_increment, username VARCHAR(32), first_name VARCHAR(32), last_name VARCHAR(32) )");
		statement.close();
	}
	
	@Test
	public void test2() throws SQLException, DatabaseUnitException, IOException {

		InputStream inputStream=getClass().getResourceAsStream("/my.xml");
		Reader reader=new InputStreamReader(inputStream);
		IDataSet iDataSet=new FlatXmlDataSet(reader);
		DatabaseOperation.CLEAN_INSERT.execute(databaseConnection, iDataSet);
		
		statement=connection.createStatement();
		ResultSet resultSet=statement.executeQuery("select * from user where id=1");
		Assert.assertTrue(resultSet.next());
		User user=new User();
		user.setUsername(resultSet.getString("username"));
		user.setFirstName(resultSet.getString("first_name"));
		user.setLastName(resultSet.getString("last_name"));
		Assert.assertEquals("ericj", user.getUsername());
		Assert.assertEquals("Eric J.",user.getFirstName());
		Assert.assertEquals("Van der Velden", user.getLastName());
		statement.close();
		

	}
	


}

/ 13	. 

/ we hebben de oorspronkelijke UserDaoJdbcImplTest, AbstractDbUnitTestCase, UserDaoJdbcImpl aangepast	, @Before ipv @BeforeClass , waardoor je DB_CLOSE_DELAY=-1 nodig hebt	, 

/ 1313	. 

/ we hebben in de dao	, "if not exists"	,
      stmt.execute("CREATE TABLE if not exists users ( id INTEGER auto_increment, username VARCHAR(10), first_name VARCHAR(10), last_name VARCHAR(10) )");

/ 1313	. 

/ omdat @Before ipv @BeforeClass, moet het een inst fct zijn, dus niet meer static,	 

/ 1313	. 

/ we use h2's auto_increment	,

/ 1313	. 

/ we hebben rm uit de @Before fct	,  maar het kan wel	, 
    dao.createTables();


$ less UserDaoJdbcImplTest.java

public class UserDaoJdbcImplTest extends AbstractDbUnitTestCase {
  @Test 
  public void testGetUserById() throws Exception {
    dao.createTables();
    IDataSet setupDataSet = getDataSet("/user.xml");
    DatabaseOperation.CLEAN_INSERT.execute(dbunitConnection, setupDataSet);
  }
  @Test 
	public void testGetUserById2() throws Exception {
  User user = dao.getUserById(1);
  assertNotNull( user);
  assertEquals( "Jeffrey", user.getFirstName() );
  assertEquals( "Lebowsky", user.getLastName() );
  assertEquals( "ElDuderino", user.getUsername() );
}

$ less AbstractDbUnitTestCase.java
public abstract class AbstractDbUnitTestCase {

 @Before
  public  void setupDatabase() throws Exception {
//    Class.forName("org.hsqldb.jdbcDriver"); 		/ TODO hoeven we niet de h2 jdbc driver te load	?
    connection = DriverManager.getConnection("jdbc:h2:mem:my-project-test;DB_CLOSE_DELAY=-1"); 
    dbunitConnection = new H2Connection(connection, null);
    dao.setConnection(connection);
//    dao.createTables();
  }

  @After
	  public  void closeDatabase() throws Exception {
    if ( dbunitConnection != null ) {
      dbunitConnection.close();
      dbunitConnection = null;
    }
  }

$ vi UserDaoJdbcImpl.java

public class UserDaoJdbcImpl implements UserDao {
 void createTables() throws SQLException {
    Statement stmt = connection.createStatement();
    try {
      stmt.execute("CREATE TABLE if not exists users ( id INTEGER auto_increment, username VARCHAR(10), first_name VARCHAR(10), last_name VARCHAR(10) )");
    } finally {
      close(stmt);
    }
  }
/ Dus erbij	, 
if not exists
auto_increment

/ 13	. 

/ we moeten WH	, 
    connection = DriverManager.getConnection("jdbc:h2:mem:my-project-test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=true");

/ anders tussen verschillende runs effects	,

/ 13	. 

/ maar junit heeft geen vastgestelde orde van zijn tests	, 
/ dus als we 	,

  public void testGetUserById() throws Exception {
    dao.createTables();

    IDataSet setupDataSet = getDataSet("/user.xml");
    DatabaseOperation.CLEAN_INSERT.execute(dbunitConnection, setupDataSet);
  }
  @Test 
	public void testGetUserById2() throws Exception {
  		User user = dao.getUserById(1);

/ en hij doet testGetUserById2 eerder, dan kent hij table users niet	, 


/ Einde Intermezzo


 
 
/ Einde JUNIT BOOK CH17

/ DBUNIT

public abstract class DatabaseOperation
{
    public static final DatabaseOperation INSERT = new InsertOperation();
    public static final DatabaseOperation DELETE_ALL = new DeleteAllOperation();
    public static final DatabaseOperation CLEAN_INSERT = new CompositeOperation( DELETE_ALL, INSERT);    

public class CompositeOperation extends DatabaseOperation

public class DeleteAllOperation extends AbstractOperation
public abstract class AbstractOperation extends DatabaseOperation

public class InsertOperation extends AbstractBatchOperation
public abstract class AbstractBatchOperation extends AbstractOperation
public abstract class AbstractOperation extends DatabaseOperation




/ Einde DBUNIT

/ JUNIT BOOK CH17 DEBUG

/ 7	. 

UserDaoJdbcImplTest.testGetUserById() line: 40	
    IDataSet setupDataSet = getDataSet("/user.xml");
    DatabaseOperation.CLEAN_INSERT.execute(dbunitConnection, setupDataSet);
/s
CompositeOperation.execute(IDatabaseConnection, IDataSet) line: 74	
       for (int i = 0; i < _actions.length; i++)
        {
            DatabaseOperation action = _actions[i];
            action.execute(connection, dataSet);
/s
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 79	
        IDataSet databaseDataSet = connection.createDataSet();

/ Dit doe je ook zelf in de test	,
    IDataSet actualDataSet = dbunitConnection.createDataSet();
/ TODO
/ Dus org.dbunit.ext.h2.H2Connection heeft _dataSet, en _databaseConfig, en dat onderscheidt hem van org.h2.jdbc.Connection	, die hij ook heeft	, 

/ Intermezzo 

/ later	,

DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 109	
        IDataSet databaseDataSet = connection.createDataSet();		
/ nu
                ITableMetaData databaseMetaData = databaseDataSet.getTableMetaData(tableName);
/ later
/ calls DatabaseDataSet.initialize	, die _tableMap in de DatabaseDataSet sets, 
/ we hebben dan 	,

connection	org.dbunit.ext.h2.H2Connection  (id=438)	
	_connection	org.h2.jdbc.JdbcConnection  (id=467)	
	_databaseConfig	org.dbunit.database.DatabaseConfig  (id=452)	
	_dataSet	org.dbunit.database.DatabaseDataSet  (id=445)	
		_caseSensitiveTableNames	false	
		_connection	org.dbunit.ext.h2.H2Connection  (id=438)	
		_oracleRecycleBinTableFilter	org.dbunit.database.DatabaseDataSet$OracleRecycleBinTableFilter  (id=447)	
		_orderedTableNameMap	null	
		_tableFilter	null	
		_tableMap	org.dbunit.dataset.OrderedTableNameMap  (id=617)	
org.dbunit.dataset.OrderedTableNameMap[_tableNames=[USERS], _tableMap={USERS=null}, _caseSensitiveTableNames=false]
	_schema	null	



/ Einde Intermezzo 
/s
H2Connection(AbstractDatabaseConnection).createDataSet() line: 69	
            _dataSet = new DatabaseDataSet(this);
this	org.dbunit.ext.h2.H2Connection  (id=439)	
/s
DatabaseDataSet.<init>(IDatabaseConnection) line: 74	
    	this(connection, connection.getConfig().getFeature(DatabaseConfig.FEATURE_CASE_SENSITIVE_TABLE_NAMES));
DatabaseConfig.FEATURE_CASE_SENSITIVE_TABLE_NAMES="http://www.dbunit.org/features/caseSensitiveTableNames"

this	org.dbunit.ext.h2.H2Connection  (id=439)	
	_connection	org.h2.jdbc.JdbcConnection  (id=459)	
	_databaseConfig	org.dbunit.database.DatabaseConfig  (id=465)	
		_propertyMap	java.util.HashMap<K,V>  (id=487)	
			table	java.util.HashMap$Entry<K,V>[16]  (id=500)	
				[0]	java.util.HashMap$Entry<K,V>  (id=501)	
http://www.dbunit.org/properties/statementFactory=org.dbunit.database.statement.PreparedStatementFactory@405890bd
				[1]	java.util.HashMap$Entry<K,V>  (id=502)	
http://www.dbunit.org/properties/fetchSize=100
				[6]	java.util.HashMap$Entry<K,V>  (id=503)	
http://www.dbunit.org/properties/datatypeFactory=org.dbunit.ext.h2.H2DataTypeFactory@7686894b
				[7]	java.util.HashMap$Entry<K,V>  (id=504)	
http://www.dbunit.org/properties/escapePattern=null
				[8]	java.util.HashMap$Entry<K,V>  (id=505)	
http://www.dbunit.org/properties/batchSize=100
				[9]	java.util.HashMap$Entry<K,V>  (id=506)	
http://www.dbunit.org/properties/tableType=[Ljava.lang.String;@7a9fd7b7
				[12]	java.util.HashMap$Entry<K,V>  (id=507)	
http://www.dbunit.org/properties/resultSetTableFactory=org.dbunit.database.CachedResultSetTableFactory@140b6e46

/s
DatabaseDataSet.<init>(IDatabaseConnection, boolean) line: 87	
        this(connection, caseSensitiveTableNames, null);
caseSensitiveTableNames	false	
/s
DatabaseDataSet.<init>(IDatabaseConnection, boolean, ITableFilterSimple) line: 101	
/=
    public DatabaseDataSet(IDatabaseConnection connection, boolean caseSensitiveTableNames, ITableFilterSimple tableFilter) 
connection	org.dbunit.ext.h2.H2Connection  (id=439)	
caseSensitiveTableNames	false	
tableFilter	null	
/ sets properties	,
/t
H2Connection(AbstractDatabaseConnection).createDataSet() line: 72	

            _dataSet = new DatabaseDataSet(this);
/d
this	org.dbunit.ext.h2.H2Connection  (id=508)	
	_connection	org.h2.jdbc.JdbcConnection  (id=514)				 / jdbc connection	,	
	_databaseConfig	org.dbunit.database.DatabaseConfig  (id=519)	
config	org.dbunit.database.DatabaseConfig  (id=452)	
	_featuresSet	java.util.HashSet<E>  (id=454)	
[http://www.dbunit.org/features/datatypeWarning]
	_propertyMap	java.util.HashMap<K,V>  (id=455)	
{http://www.dbunit.org/properties/statementFactory=org.dbunit.database.statement.PreparedStatementFactory@7bfabad8, 
http://www.dbunit.org/properties/fetchSize=100, 
http://www.dbunit.org/properties/datatypeFactory=org.dbunit.ext.h2.H2DataTypeFactory@a00fa7f, 
http://www.dbunit.org/properties/escapePattern=null, 
http://www.dbunit.org/properties/batchSize=100, 
http://www.dbunit.org/properties/tableType=[Ljava.lang.String;@463dacfa,  /= ["TABLE"]	,
http://www.dbunit.org/properties/resultSetTableFactory=org.dbunit.database.CachedResultSetTableFactory@7b27751c}

	_dataSet	org.dbunit.database.DatabaseDataSet  (id=536)	
		_caseSensitiveTableNames	false	
		_connection	org.dbunit.ext.h2.H2Connection  (id=508)	 / pointer back
		_orderedTableNameMap	null	
		_tableFilter	null	
		_tableMap	null	
	_schema	null	
/t
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 83	
        IDataSet databaseDataSet = connection.createDataSet();
/d
        DatabaseConfig databaseConfig = connection.getConfig();
        IStatementFactory statementFactory = (IStatementFactory)databaseConfig.getProperty(DatabaseConfig.PROPERTY_STATEMENT_FACTORY);
org.dbunit.database.statement.PreparedStatementFactory@405890bd
        IBatchStatement statement = statementFactory.createBatchStatement(connection);
/s
PreparedStatementFactory.createBatchStatement(IDatabaseConnection) line: 57	
        if (supportBatchStatement(connection))
/s
PreparedStatementFactory(AbstractStatementFactory).supportBatchStatement(IDatabaseConnection) line: 53	
        if (connection.getConfig().getFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS))
/n
        return false;
/t
PreparedStatementFactory.createBatchStatement(IDatabaseConnection) line: 57	
        if (supportBatchStatement(connection))
/d
/n
            return new SimpleStatement(connection.getConnection());
/s
SimpleStatement.<init>(Connection) line: 49	
        super(connection);
/s
SimpleStatement(AbstractBatchStatement).<init>(Connection) line: 47	
        _statement = connection.createStatement();

public class SimpleStatement extends AbstractBatchStatement
public abstract class AbstractBatchStatement implements IBatchStatement

/t
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 88	
        IBatchStatement statement = statementFactory.createBatchStatement(connection);
/d
            ITableIterator iterator = dataSet.iterator();
/ TODO
            while (iterator.next())
/j

/ Intermezzo

public class DefaultTableIterator implements ITableIterator
    private final ITable[] _tables;
    private int _index = -1;
    public DefaultTableIterator(ITable[] tables, boolean reversed) {
        _tables = tables;
    }
    public boolean next() throws DataSetException
    {
        _index++;
        return _index < _tables.length;
    }
    public ITableMetaData getTableMetaData() throws DataSetException
    {
        return getTable().getTableMetaData();
    }

    public ITable getTable() throws DataSetException
    {
    	return _tables[_index];
    }


/ Einde Intermezzo

                String tableName = iterator.getTableMetaData().getTableName();
/s
DefaultTable.getTableMetaData() line: 181	
        return _metaData;

this	org.dbunit.dataset.DefaultTable  (id=717)	
	_metaData	org.dbunit.dataset.DefaultTableMetaData  (id=719)	
		_columns	org.dbunit.dataset.Column[4]  (id=740)	
			[0]	org.dbunit.dataset.Column  (id=748)	
				_autoIncrement	null	
				_columnName	"id" (id=753)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=755)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=760)	
					_name	"nullableUnknown" (id=767)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=763)	
			[1]	org.dbunit.dataset.Column  (id=749)	
				_autoIncrement	null	
				_columnName	"username" (id=768)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=755)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=760)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=763)	
			[2]	org.dbunit.dataset.Column  (id=750)	
				_autoIncrement	null	
				_columnName	"first_name" (id=769)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=755)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=760)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=763)	
			[3]	org.dbunit.dataset.Column  (id=751)	
				_autoIncrement	null	
				_columnName	"last_name" (id=770)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=755)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=760)	
					_name	"nullableUnknown" (id=767)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=763)	
		_columnsToIndexes	java.util.HashMap<K,V>  (id=743)	
			entrySet	null	
			hashSeed	0	
			keySet	null	
			loadFactor	0.75	
			modCount	4	
			size	4	
			table	java.util.HashMap$Entry<K,V>[8]  (id=771)	
				[0]	java.util.HashMap$Entry<K,V>  (id=772)	
ID=0
				[2]	java.util.HashMap$Entry<K,V>  (id=773)	
USERNAME=1
				[4]	java.util.HashMap$Entry<K,V>  (id=774)	
FIRST_NAME=2
				[6]	java.util.HashMap$Entry<K,V>  (id=775)	
LAST_NAME=3
			threshold	6	
			values	null	
		_primaryKeys	org.dbunit.dataset.Column[0]  (id=744)	
		_tableName	"users" (id=745)	
		dataTypeFactoryValidator	org.dbunit.dataset.AbstractTableMetaData$DataTypeFactoryValidator  (id=746)	
	_rowList	java.util.ArrayList<E>  (id=722)	
		elementData	java.lang.Object[10]  (id=823)	
			[0]	java.lang.Object[4]  (id=825)	
				[0]	"1" (id=827)	
				[1]	"ElDuderino" (id=828)	
				[2]	"Jeffrey" (id=830)	
				[3]	"Lebowsky" (id=831)	
		size	1	

/t
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 96	
                String tableName = iterator.getTableMetaData().getTableName();
/d
users
                if (!tablesSeen.contains(tableName))
                {
                    tableNames.push(tableName);
                    tablesSeen.add(tableName);

            while (!tableNames.isEmpty())
            {
                String tableName = (String)tableNames.pop();

                // Use database table name. Required to support case sensitive database.
                ITableMetaData databaseMetaData = databaseDataSet.getTableMetaData(tableName);
/s
DatabaseDataSet.getTableMetaData(String) line: 273	
        initialize();
/s
DatabaseDataSet.initialize() line: 167	
        	Connection jdbcConnection = _connection.getConnection();
jdbcConnection	org.h2.jdbc.JdbcConnection  (id=459)	

            DatabaseMetaData databaseMetaData = jdbcConnection.getMetaData();
databaseMetaData	org.h2.jdbc.JdbcDatabaseMetaData  (id=877)	
	conn	org.h2.jdbc.JdbcConnection  (id=459)	
	id	0	
	trace	org.h2.message.Trace  (id=531)	
	traceType	2	
            String schema = _connection.getSchema();
null
databaseMetaData	org.h2.jdbc.JdbcDatabaseMetaData  (id=877)	
	conn	org.h2.jdbc.JdbcConnection  (id=459)	
	id	0	
	trace	org.h2.message.Trace  (id=531)	
	traceType	2	

config	org.dbunit.database.DatabaseConfig  (id=465)	
	_featuresSet	java.util.HashSet<E>  (id=486)	
	_propertyMap	java.util.HashMap<K,V>  (id=487)	

            String[] tableType = (String[])config.getProperty(DatabaseConfig.PROPERTY_TABLE_TYPE);
[TABLE]
            ResultSet resultSet = databaseMetaData.getTables( null, schema, "%", tableType);
/s
/ met Maven, click op Attach Source, en Cancel, dat wordt source attached	, 

JdbcDatabaseMetaData.getTables(String, String, String, String[]) line: 156		/ h2's jdbc
this	org.h2.jdbc.JdbcDatabaseMetaData  (id=961)	

            if (types != null && types.length > 0) {
                StatementBuilder buff = new StatementBuilder("TABLE_TYPE IN(");
                for (int i = 0; i < types.length; i++) {
                    buff.appendExceptFirst(", ");
                    buff.append('?');
                }
                tableType = buff.append(')').toString();
            } else {
                tableType = "TRUE";
            }
/ TODO
            PreparedStatement prep = conn.prepareAutoCloseStatement("SELECT "
                    + "TABLE_CATALOG TABLE_CAT, "
                    + "TABLE_SCHEMA TABLE_SCHEM, "
                    + "TABLE_NAME, "
                    + "TABLE_TYPE, "
                    + "REMARKS, "
                    + "TYPE_NAME TYPE_CAT, "
                    + "TYPE_NAME TYPE_SCHEM, "
                    + "TYPE_NAME, "
                    + "TYPE_NAME SELF_REFERENCING_COL_NAME, "
                    + "TYPE_NAME REF_GENERATION, "
                    + "SQL "
                    + "FROM INFORMATION_SCHEMA.TABLES "
                    + "WHERE TABLE_CATALOG LIKE ? ESCAPE ? "
                    + "AND TABLE_SCHEMA LIKE ? ESCAPE ? "
                    + "AND TABLE_NAME LIKE ? ESCAPE ? "
                    + "AND (" + tableType + ") "
                    + "ORDER BY TABLE_TYPE, TABLE_SCHEMA, TABLE_NAME");
            prep.setString(1, getCatalogPattern(catalogPattern));
            prep.setString(2, "\\");
            prep.setString(3, getSchemaPattern(schemaPattern));
            prep.setString(4, "\\");
            prep.setString(5, getPattern(tableNamePattern));
            prep.setString(6, "\\");
            for (int i = 0; types != null && i < types.length; i++) {
                prep.setString(7 + i, types[i]);
            }
/ TODO
            return prep.executeQuery();
/t
DatabaseDataSet.initialize() line: 197	
           ResultSet resultSet = databaseMetaData.getTables(
                    null, schema, "%", tableType);
/d
resultSet	org.h2.jdbc.JdbcResultSet  (id=969)	
	result	org.h2.result.LocalResult  (id=975)	
		rows	java.util.ArrayList<E>  (id=982)	
			elementData	java.lang.Object[4]  (id=1013)	
				[0]	org.h2.value.Value[11]  (id=1014)	
					[0]	org.h2.value.ValueString  (id=1017)	
						value	"MY-PROJECT-TEST" (id=1060)	
					[1]	org.h2.value.ValueString  (id=1018)	
						value	"PUBLIC" (id=1088)	
					[2]	org.h2.value.ValueString  (id=1019)	
						value	"USERS" (id=1116)	
					[3]	org.h2.value.ValueString  (id=1020)	
						value	"TABLE" (id=1144)	
					[4]	org.h2.value.ValueString  (id=1021)	
						value	"" (id=534)	
					[5]	org.h2.value.ValueNull  (id=1022)	
					[6]	org.h2.value.ValueNull  (id=1022)	
					[7]	org.h2.value.ValueNull  (id=1022)	
					[8]	org.h2.value.ValueNull  (id=1022)	
					[9]	org.h2.value.ValueNull  (id=1022)	
					[10]	org.h2.value.ValueString  (id=1025)	
						value	"CREATE MEMORY TABLE PUBLIC.USERS(\n    ID INTEGER DEFAULT (NEXT VALUE FOR PUBLIC.SYSTEM_SEQUENCE_B974A95C_363A_445C_9D77_F4C5F2D6F85A) NOT NULL NULL_TO_DEFAULT SEQUENCE PUBLIC.SYSTEM_SEQUENCE_B974A95C_363A_445C_9D77_F4C5F2D6F85A,\n    USERNAME VARCHAR(10),\n    FIRST_NAME VARCHAR(10),\n    LAST_NAME VARCHAR(10)\n)" (id=1280)	
			size	1	

           	OrderedTableNameMap tableMap = super.createTableNameMap();
                while (resultSet.next())
                {
                    String catalogName = resultSet.getString(1);
                    String schemaName = resultSet.getString(2);
                    String tableName = resultSet.getString(3);
catalogName	"MY-PROJECT-TEST" (id=1060)	
schemaName	"PUBLIC" (id=1088)	
tableName	"USERS" (id=1116)	

                   	QualifiedTableName qualifiedTableName = new QualifiedTableName(tableName, schemaName);
                    tableName = qualifiedTableName.getQualifiedNameIfEnabled(config);
USERS
                    // Put the table into the table map
                    tableMap.add(tableName, null);
                _tableMap = tableMap;
                resultSet.close();

/ Hier in DatabaseDataSet.initialize is dus _tableMap in DatabaseDataSet set	,
this	org.dbunit.database.DatabaseDataSet  (id=445)	
	_caseSensitiveTableNames	false	
	_connection	org.dbunit.ext.h2.H2Connection  (id=438)	
	_orderedTableNameMap	null	
	_tableFilter	null	
	_tableMap	org.dbunit.dataset.OrderedTableNameMap  (id=617)	
		_caseSensitiveTableNames	false	
		_lastTableNameOverride	null	
		_tableMap	java.util.HashMap<K,V>  (id=618)	
{USERS=null}
		_tableNames	java.util.ArrayList<E>  (id=619)	
[USERS]


/t
DatabaseDataSet.getTableMetaData(String) line: 276	
        initialize();
/d
        // Try to find cached metadata
        ITableMetaData metaData = (ITableMetaData)_tableMap.get(tableName);
        if (metaData != null)
/n
        // Create metadata and cache it
        metaData = new DatabaseTableMetaData(_tableMap.getTableName(tableName), _connection, true, super.isCaseSensitiveTableNames());
_caseSensitiveMetaData	false	
_columns	org.dbunit.dataset.Column[8]  (id=1332)	
[(NAME, VARCHAR, nullable), 
(ADMIN, VARCHAR, nullable), 
(REMARKS, VARCHAR, nullable), 
(ID, INTEGER, nullable), 
(ID, INTEGER, noNulls), 
(USERNAME, VARCHAR, nullable), 
(FIRST_NAME, VARCHAR, nullable), 
(LAST_NAME, VARCHAR, nullable)]
_columnsToIndexes	null	
_connection	org.dbunit.ext.h2.H2Connection  (id=439)	
_originalTableName	"USERS" (id=1326)	
_primaryKeys	org.dbunit.dataset.Column[0]  (id=744)	
_qualifiedTableNameSupport	org.dbunit.util.QualifiedTableName  (id=1327)	
dataTypeFactoryValidator	org.dbunit.dataset.AbstractTableMetaData$DataTypeFactoryValidator  (id=1328)	

        // Put the metadata object into the cache map
        _tableMap.update(tableName, metaData);

        return metaData;
/t
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 110	
                ITableMetaData databaseMetaData = databaseDataSet.getTableMetaData(tableName);
/d
                tableName = databaseMetaData.getTableName();
USERS
                sqlBuffer.append(getDeleteAllCommand());
        return "delete from ";
                sqlBuffer.append(getQualifiedName(connection.getSchema(), tableName, connection));
delete from USERS                
				statement.addBatch(sqlBuffer.toString());
/s
statement	org.dbunit.database.statement.SimpleStatement  (id=695)	
SimpleStatement.addBatch(String) line: 54	
        _list.add(sql);
/t
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 120	
            while (!tableNames.isEmpty())
            {
				...
                statement.addBatch(sqlBuffer.toString());
/d
                count++;
/ volgende while loop is er NIET	,

            if (count > 0)
            {
                statement.executeBatch();
/s
SimpleStatement.executeBatch() line: 60	
        for (int i = 0; i < _list.size(); i++)
        {
            String sql = (String)_list.get(i);
delete from USERS
            boolean r = _statement.execute(sql);
/s
JdbcStatement.execute(String) line: 157				/ h2's jdbc	,
this	org.h2.jdbc.JdbcStatement  (id=1420)	
            return executeInternal(sql);
/s
JdbcStatement.executeInternal(String) line: 165	
            CommandInterface command = conn.prepareCommand(sql, fetchSize);
/s
JdbcConnection.prepareCommand(String, int) line: 1203	
        return session.prepareCommand(sql, fetchSize);
/s
Session.prepareCommand(String, int) line: 502	
        return prepareLocal(sql);


/ intermezzo

/ in	,
JdbcStatement.executeInternal(String) line: 170	

this	org.h2.jdbc.JdbcStatement  (id=1420)	
	conn	org.h2.jdbc.JdbcConnection  (id=459)	
		session	org.h2.engine.Session  (id=525)	
/ TODO een conn, een jdbc obj, heeft een session , een db/server obj	,

public class JdbcStatement extends TraceObject implements Statement, JdbcStatementBackwardsCompat {
    protected JdbcConnection conn;
    protected SessionInterface session;

/**
 * A local or remote session. A session represents a database connection.
 */
public interface SessionInterface extends Closeable {

/**
 * A session represents an embedded database connection. When using the server
 * mode, this object resides on the server side and communicates with a
 * SessionRemote object on the client side.
 */
public class Session extends SessionWithState {

/ Einde intermezzo

/t
JdbcStatement.executeInternal(String) line: 184	
            CommandInterface command = conn.prepareCommand(sql, fetchSize);
/d
                    if (command.isQuery()) {
/n
                    } else {
                        returnsResultSet = false;
                        updateCount = command.executeUpdate();
/t
SimpleStatement.executeBatch() line: 72	
            boolean r = _statement.execute(sql);
false
/ WH omdat de table leeg is	,
           if(!r)
            {
                result += _statement.getUpdateCount();
0
/ WH omdat de table leeg is	,
/t
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 123	
            if (count > 0)
            {
                statement.executeBatch();
/d
                statement.clearBatch();
/s
        _list.clear();
/t
DeleteAllOperation.execute(IDatabaseConnection, IDataSet) line: 123	
                statement.clearBatch();
/d
       finally
        {
            statement.close();
/t
CompositeOperation.execute(IDatabaseConnection, IDataSet) line: 79	
        for (int i = 0; i < _actions.length; i++)
        {
            DatabaseOperation action = _actions[i];
            action.execute(connection, dataSet);
/d
/ volgende
/s
InsertOperation(AbstractBatchOperation).execute(IDatabaseConnection, IDataSet) line: 123	
	...
                            statement = factory.createPreparedBatchStatement(
                                    operationData.getSql(), connection);
/s
OperationData.getSql() line: 51	
        return _sql;
insert into USERS (ID, USERNAME, FIRST_NAME, LAST_NAME) values (?, ?, ?, ?)
/t
/s
PreparedStatementFactory.createPreparedBatchStatement(String, IDatabaseConnection) line: 78	
            statement = new SimplePreparedStatement(sql, connection.getConnection());
        return new AutomaticPreparedBatchStatement(statement, batchSize.intValue());
/t
InsertOperation(AbstractBatchOperation).execute(IDatabaseConnection, IDataSet) line: 177	
                            statement = factory.createPreparedBatchStatement(
                                    operationData.getSql(), connection);
/d
                        // for each column
                        Column[] columns = operationData.getColumns();
[(ID, INTEGER, noNulls), (USERNAME, VARCHAR, nullable), (FIRST_NAME, VARCHAR, nullable), (LAST_NAME, VARCHAR, nullable)]
                        for (int j = 0; j < columns.length; j++)
                               Column column = columns[j];
                            	try
								{
	                                statement.addValue(table.getValue(row, column.getColumnName()), column.getDataType());
/s
DefaultTable.getValue(int, String) line: 197	
        Object[] rowValues = (Object[])_rowList.get(row);
[1, ElDuderino, Jeffrey, Lebowsky]
        return rowValues[getColumnIndex(column)];

/ Zo voor alle 4	,
                        statement.addBatch();
/s
AutomaticPreparedBatchStatement.addBatch() line: 70	
        _statement.addBatch();
/s
SimplePreparedStatement.addBatch() line: 80	
        boolean result = _statement.execute();
/s
JdbcPreparedStatement.execute() line: 180 [local variables unavailable]	
                        setExecutingStatement(command);
command	org.h2.command.CommandContainer  (id=1577)	
insert into USERS (ID, USERNAME, FIRST_NAME, LAST_NAME) values (?, ?, ?, ?) {1: 1, 2: 'ElDuderino', 3: 'Jeffrey', 4: 'Lebowsky'}

this	org.h2.jdbc.JdbcPreparedStatement  (id=1575)	
	command	org.h2.command.CommandContainer  (id=1577)	
		prepared	org.h2.command.dml.Insert  (id=1580)	
			table	org.h2.mvstore.db.MVTable  (id=1601)	
/ TODO

                        } else {
                            returnsResultSet = false;
                            updateCount = command.executeUpdate();
1
/t
SimplePreparedStatement.addBatch() line: 83	
        onnection(AbstractDatabaseConnection).createDataSet() line: 69	

        if (!result)
        {
            _result += _statement.getUpdateCount();
1
/t
InsertOperation(AbstractBatchOperation).execute(IDatabaseConnection, IDataSet) line: 206	
                        statement.addBatch();
/d
                statement.executeBatch();
/s
SimplePreparedStatement.executeBatch() line: 93	
        int result = _result;
        clearBatch();
        return result;
/t
UserDaoJdbcImplTest.testGetUserById() line: 41	
    DatabaseOperation.CLEAN_INSERT.execute(dbunitConnection, setupDataSet);
/d

/ 7	. 

  public void testAddUser() throws Exception {
    User user = newUser();
    long id = dao.addUser(user);
1
    assertTrue(id>0);
    IDataSet expectedDataSet = getDataSet("/user.xml");
    IDataSet actualDataSet = dbunitConnection.createDataSet();
/s
H2Connection(AbstractDatabaseConnection).createDataSet() line: 69	
            _dataSet = new DatabaseDataSet(this);
this	org.dbunit.ext.h2.H2Connection  (id=1685)	

/ MORGENOCHTEND

  public void testGetUserById() throws Exception {
    IDataSet setupDataSet = getDataSet("/user.xml");
    DatabaseOperation.CLEAN_INSERT.execute(dbunitConnection, setupDataSet);
    IDataSet actualDataSet = dbunitConnection.createDataSet();
/ hier is _dataSet !=null	,

  public void testAddUser() throws Exception {
    User user = newUser();
    long id = dao.addUser(user);
    assertTrue(id>0);
    IDataSet expectedDataSet = getDataSet("/user.xml");
    IDataSet actualDataSet = dbunitConnection.createDataSet();
/ hier is _dataSet ==null	,
 
 
H2Connection(AbstractDatabaseConnection).createDataSet() line: 72	
        if (_dataSet == null)
        {
            _dataSet = new DatabaseDataSet(this);
        }
        return _dataSet;
/ Als _dataSet ==null, maakt hij een nieuwe, lege	,



/ 7	. 

  @Test
  public void testAddUseIgnoringId() throws Exception {
    IDataSet setupDataSet = getDataSet("/user.xml");
    DatabaseOperation.DELETE_ALL.execute(dbunitConnection, setupDataSet);
    User user = newUser();
    long id = dao.addUser(user);
    assertTrue(id>0);
    IDataSet expectedDataSet = getDataSet("/user.xml");
    IDataSet actualDataSet = dbunitConnection.createDataSet();
    Assertion.assertEquals( expectedDataSet, actualDataSet );
  }
/s
DbUnitAssert.assertEquals(IDataSet, IDataSet, FailureHandler) line: 244	
/=
    public void assertEquals(IDataSet expectedDataSet, IDataSet actualDataSet, FailureHandler failureHandler) throws DatabaseUnitException 

this	org.dbunit.assertion.DbUnitAssert  (id=452)	
expectedDataSet	org.dbunit.dataset.xml.FlatXmlDataSet  (id=448)	
	_activeTable	null	
	_caseSensitiveTableNames	false	
	_orderedTableNameMap	org.dbunit.dataset.OrderedTableNameMap  (id=465)	<<-	
	_tables	org.dbunit.dataset.OrderedTableNameMap  (id=463)					<-	
		_caseSensitiveTableNames	false	
		_lastTableNameOverride	null	
		_tableMap	java.util.HashMap<K,V>  (id=479)	
		_tableNames	java.util.ArrayList<E>  (id=480)	
actualDataSet	org.dbunit.database.DatabaseDataSet  (id=449)	
	_caseSensitiveTableNames	false	
	_connection	org.dbunit.ext.h2.H2Connection  (id=470)	
	_oracleRecycleBinTableFilter	org.dbunit.database.DatabaseDataSet$OracleRecycleBinTableFilter  (id=474)	
	_orderedTableNameMap	null	
	_tableFilter	null	
	_tableMap	org.dbunit.dataset.OrderedTableNameMap  (id=478)				<-	
		_caseSensitiveTableNames	false	
		_lastTableNameOverride	null	
		_tableMap	java.util.HashMap<K,V>  (id=481)	
		_tableNames	java.util.ArrayList<E>  (id=482)	

/ we zien bij <- dezelfde dingen? Maar see <<-	,

        // tables
        for (int i = 0; i < expectedNames.length; i++) {
            String name = expectedNames[i];
            assertEquals(expectedDataSet.getTable(name), actualDataSet.getTable(name), failureHandler);

/ intermezzo

public class FlatXmlDataSet extends CachedDataSet
public class CachedDataSet extends AbstractDataSet implements IDataSetConsumer
    private OrderedTableNameMap _tables;
    private DefaultTable _activeTable;


public class DatabaseDataSet extends AbstractDataSet
    private final IDatabaseConnection _connection;
    private OrderedTableNameMap _tableMap = null;
    private final ITableFilterSimple _tableFilter;


public abstract class AbstractDataSet implements IDataSet
    private OrderedTableNameMap _orderedTableNameMap;
    private boolean _caseSensitiveTableNames = false;





/ Einde intermezzo


/s
FlatXmlDataSet(AbstractDataSet).getTable(String) line: 159	
        initialize();
/s
FlatXmlDataSet(AbstractDataSet).initialize() line: 97	
        if(_orderedTableNameMap != null)				/ <<-
            // already initialized
            return;
/t
FlatXmlDataSet(AbstractDataSet).getTable(String) line: 164	
        initialize();
/d
        ITable found = (ITable) _orderedTableNameMap.get(tableName);

this	org.dbunit.dataset.xml.FlatXmlDataSet  (id=448)	
tableName	"USERS" (id=466)	
found	org.dbunit.dataset.DefaultTable  (id=510)	
	_metaData	org.dbunit.dataset.DefaultTableMetaData  (id=514)	
		_columns	org.dbunit.dataset.Column[4]  (id=529)	
			[0]	org.dbunit.dataset.Column  (id=538)	
				_autoIncrement	null	
				_columnName	"id" (id=544)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=545)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=548)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=551)	
			[1]	org.dbunit.dataset.Column  (id=539)	
				_autoIncrement	null	
				_columnName	"username" (id=553)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=545)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=548)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=551)	
			[2]	org.dbunit.dataset.Column  (id=540)	
				_autoIncrement	null	
				_columnName	"first_name" (id=555)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=545)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=548)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=551)	
			[3]	org.dbunit.dataset.Column  (id=541)	
				_autoIncrement	null	
				_columnName	"last_name" (id=558)	
				_dataType	org.dbunit.dataset.datatype.UnknownDataType  (id=545)	
				_defaultValue	null	
				_nullable	org.dbunit.dataset.Column$Nullable  (id=548)	
				_remarks	null	
				_sqlTypeName	"UNKNOWN" (id=551)	
		_columnsToIndexes	java.util.HashMap<K,V>  (id=531)	
		_primaryKeys	org.dbunit.dataset.Column[0]  (id=533)	
		_tableName	"users" (id=534)	
		dataTypeFactoryValidator	org.dbunit.dataset.AbstractTableMetaData$DataTypeFactoryValidator  (id=535)	
	_rowList	java.util.ArrayList<E>  (id=517)	
		elementData	java.lang.Object[10]  (id=520)	
			[0]	java.lang.Object[4]  (id=522)	
				[0]	"1" (id=524)	
				[1]	"ElDuderino" (id=525)	
				[2]	"Jeffrey" (id=526)	
				[3]	"Lebowsky" (id=527)	
		modCount	1	
		size	1	

            return found;
/t
DbUnitAssert.assertEquals(IDataSet, IDataSet, FailureHandler) line: 244	
        // tables
        for (int i = 0; i < expectedNames.length; i++) {
            String name = expectedNames[i];
            assertEquals(expectedDataSet.getTable(name), actualDataSet.getTable(name), failureHandler);
/pd
/s
DatabaseDataSet.getTable(String) line: 298	
        initialize();
/s
DatabaseDataSet.initialize() line: 171	
        if (_tableMap != null)
        {
            return;

/ MORGENOCHTEND
this	org.dbunit.database.DatabaseDataSet  (id=447)	
	_tableMap	org.dbunit.dataset.OrderedTableNameMap  (id=458)	
		_tableMap	java.util.HashMap<K,V>  (id=459)	
			table	java.util.HashMap$Entry<K,V>[16]  (id=461)	
				[3]	java.util.HashMap$Entry<K,V>  (id=462)	
					key	"USERS" (id=463)	
					value	org.dbunit.database.DatabaseTableMetaData  (id=464)	
						_caseSensitiveMetaData	false	
						_columns	org.dbunit.dataset.Column[8]  (id=518)	
[(NAME, VARCHAR, nullable), (ADMIN, VARCHAR, nullable), (REMARKS, VARCHAR, nullable), (ID, INTEGER, nullable), (ID, INTEGER, noNulls), (USERNAME, VARCHAR, nullable), (FIRST_NAME, VARCHAR, nullable), (LAST_NAME, VARCHAR, nullable)]
						_columnsToIndexes	null	
						_connection	org.dbunit.ext.h2.H2Connection  (id=450)	
						_originalTableName	"USERS" (id=468)	
						_primaryKeys	org.dbunit.dataset.Column[0]  (id=562)	
						_qualifiedTableNameSupport	org.dbunit.util.QualifiedTableName  (id=469)	
						dataTypeFactoryValidator	org.dbunit.dataset.AbstractTableMetaData$DataTypeFactoryValidator  (id=471)	
/ Lees	,
https://groups.google.com/forum/#!topic/h2-database/0lTX7Jzwprw

/t
DatabaseDataSet.getTable(String) line: 304	
        initialize();
/d
            ITableMetaData metaData = getTableMetaData(tableName);
/s
DatabaseDataSet.getTableMetaData(String) line: 285	
        initialize();
/ is al	,
        // Try to find cached metadata
        ITableMetaData metaData = (ITableMetaData)_tableMap.get(tableName);
        if (metaData != null)
        {
            return metaData;
/t
DatabaseDataSet.getTable(String) line: 306	
            ITableMetaData metaData = getTableMetaData(tableName);
/d
            DatabaseConfig config = _connection.getConfig();
org.dbunit.database.DatabaseConfig[_featuresSet=[http://www.dbunit.org/features/datatypeWarning], _propertyMap={http://www.dbunit.org/properties/statementFactory=org.dbunit.database.statement.PreparedStatementFactory@21cb0e86, http://www.dbunit.org/properties/fetchSize=100, http://www.dbunit.org/properties/datatypeFactory=org.dbunit.ext.h2.H2DataTypeFactory@1a2690bf, http://www.dbunit.org/properties/escapePattern=null, http://www.dbunit.org/properties/batchSize=100, http://www.dbunit.org/properties/tableType=[Ljava.lang.String;@59e8f902, http://www.dbunit.org/properties/resultSetTableFactory=org.dbunit.database.CachedResultSetTableFactory@4e34206b}]

            IResultSetTableFactory factory = (IResultSetTableFactory)config.getProperty(
                    DatabaseConfig.PROPERTY_RESULTSET_TABLE_FACTORY);
            return factory.createTable(metaData, _connection);
/s
CachedResultSetTableFactory.createTable(ITableMetaData, IDatabaseConnection) line: 61	
        return new CachedResultSetTable(metaData, connection);
/s
CachedResultSetTable.<init>(ITableMetaData, IDatabaseConnection) line: 54	
        this(new ForwardOnlyResultSetTable(metaData, connection));
/s
ForwardOnlyResultSetTable.<init>(ITableMetaData, IDatabaseConnection) line: 59	
        super(metaData, connection);
/s
ForwardOnlyResultSetTable(AbstractResultSetTable).<init>(ITableMetaData, IDatabaseConnection) line: 97	
		_statement = createStatement(connection);

       	String escapePattern = (String)connection.getConfig().getProperty(
                DatabaseConfig.PROPERTY_ESCAPE_PATTERN);
null
        try
        {
            String schema = connection.getSchema();
null
            String selectStatement = getSelectStatement(schema, metaData, escapePattern);
/s
AbstractResultSetTable.getSelectStatement(String, ITableMetaData, String) line: 133	
        return DatabaseDataSet.getSelectStatement(schema, metaData, escapePattern);
/s
DatabaseDataSet.getSelectStatement(String, ITableMetaData, String) line: 116	
        Column[] columns = metaData.getColumns();
[(NAME, VARCHAR, nullable), (ADMIN, VARCHAR, nullable), (REMARKS, VARCHAR, nullable), (ID, INTEGER, nullable), (ID, INTEGER, noNulls), (USERNAME, VARCHAR, nullable), (FIRST_NAME, VARCHAR, nullable), (LAST_NAME, VARCHAR, nullable)]
        Column[] primaryKeys = metaData.getPrimaryKeys();
[]

/ REMARKS, ID, 

        StringBuffer sqlBuffer = new StringBuffer(128);
        sqlBuffer.append("select ");
        for (int i = 0; i < columns.length; i++)
        {
            if (i > 0)
            {
                sqlBuffer.append(", ");
            }
            String columnName = new QualifiedTableName(
                    columns[i].getColumnName(), null, escapePattern).getQualifiedName();
            sqlBuffer.append(columnName);
        }

        // from
        sqlBuffer.append(" from ");
        sqlBuffer.append(new QualifiedTableName(
                metaData.getTableName(), schema, escapePattern).getQualifiedName());













            





/ Einde JUNIT BOOK CH17 DEBUG
