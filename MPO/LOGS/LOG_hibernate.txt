/ See DEBUG HIBERNATE
/ See WITH SPRING
/ See LAZYINITIALIZATIONEXCEPTION
/ See EXERCISES LAZYINITIALIZATIONEXCEPTION

/ DEBUG HIBERNATE

/ 7	 

/ ws 
/ proj hibernate mappings
/ pkg my.test.own.objects

/ Main, Item Category

Main.setUp() line: 83	
        	Configuration configuration=new Configuration().configure();
/s
Configuration.<init>() line: 293	
		this( new SettingsFactory() );
/s
Configuration.<init>(SettingsFactory) line: 238	
	private TypeResolver typeResolver = new TypeResolver();
/s
TypeResolver.<init>() line: 46	
		this(  new BasicTypeRegistry(), new TypeFactory() );

/s
BasicTypeRegistry.<init>() line: 49	
	public BasicTypeRegistry() {
		register( IntegerType.INSTANCE );
		register( StringType.INSTANCE );
		register( DateType.INSTANCE );

/ Lees	,
https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html

https://docs.oracle.com/cd/E11882_01/java.112/e16548/apxref.htm#JJDBC28905
/ -> 
https://docs.oracle.com/cd/E11882_01/java.112/e16548/datacc.htm#JJDBC28363

https://docs.oracle.com/cd/E11882_01/java.112/e16548/toc.htm
/-> Ch11	,
https://docs.oracle.com/cd/E11882_01/java.112/e16548/datacc.htm#JJDBC28365
/ -> 
https://docs.oracle.com/cd/E11882_01/java.112/e16548/apxref.htm#JJDBC28906

/ 13	. 

package org.hibernate.type;
public class IntegerType extends AbstractSingleColumnStandardBasicType<Integer>
	public IntegerType() {
		super( org.hibernate.type.descriptor.sql.IntegerTypeDescriptor.INSTANCE, IntegerTypeDescriptor.INSTANCE );
	}
/ links: org.hibernate.type.descriptor.sql.IntegerTypeDescriptor.INSTANCE
/ rechts: org.hibernate.type.descriptor.java.IntegerTypeDescriptor.INSTANCE
	@Override
	public String[] getRegistrationKeys() {
		return new String[] { getName(), int.class.getName(), Integer.class.getName() };
	}
[integer, int, java.lang.Integer]

package org.hibernate.type.descriptor.sql;
public class IntegerTypeDescriptor implements SqlTypeDescriptor {
	@Override
	public int getSqlType() {
		return Types.INTEGER;
	}

package org.hibernate.type.descriptor.java;
public class IntegerTypeDescriptor extends AbstractTypeDescriptor<Integer> {
	@Override
	public String toString(Integer value) {
		return value == null ? null : value.toString();
	}
	@Override
	public Integer fromString(String string) {
		return string == null ? null : Integer.valueOf( string );
	}

/ 13	. 

package org.hibernate.type;
public class DateType
	public DateType() {
		super( org.hibernate.type.descriptor.sql.DateTypeDescriptor.INSTANCE, JdbcDateTypeDescriptor.INSTANCE );

/ links: org.hibernate.type.descriptor.sql.DateTypeDescriptor.INSTANCE
/ rechts: org.hibernate.type.descriptor.java.JdbcDateTypeDescriptor.INSTANCE

package org.hibernate.type.descriptor.sql;
public class DateTypeDescriptor implements SqlTypeDescriptor {
	@Override
	public int getSqlType() {
		return Types.DATE;
	}

package org.hibernate.type.descriptor.java;
public class JdbcDateTypeDescriptor extends AbstractTypeDescriptor<Date> {
	@Override
	public String toString(Date value) {
		return new SimpleDateFormat( DATE_FORMAT ).format( value );
	}
	@Override
	public Date fromString(String string) {
		try {
			return new Date( new SimpleDateFormat(DATE_FORMAT).parse( string ).getTime() );
		}
		catch ( ParseException pe) {
			throw new HibernateException( "could not parse date string" + string, pe );
		}
	}

/ 13	. 

package org.hibernate.type;
public class StringType
	public StringType() {
		super( VarcharTypeDescriptor.INSTANCE, StringTypeDescriptor.INSTANCE );
	}
/ links: org.hibernate.type.descriptor.sql.VarcharTypeDescriptor
/ rechts: org.hibernate.type.descriptor.java.StringTypeDescriptor
	@Override
	public String[] getRegistrationKeys() {
		return new String[] { getName(), int.class.getName(), Integer.class.getName() };
	}
[string, java.lang.String]

package org.hibernate.type.descriptor.java;
public class StringTypeDescriptor extends AbstractTypeDescriptor<String> {
	public String toString(String value) {
		return value;
	}

	public String fromString(String string) {
		return string;
	}

package org.hibernate.type.descriptor.sql;
public class VarcharTypeDescriptor implements SqlTypeDescriptor {
	@Override
	public int getSqlType() {
		return Types.VARCHAR;
	}

/t
BasicTypeRegistry.<init>() line: 117	
{java.util.GregorianCalendar=org.hibernate.type.CalendarType@387162d9,
 imm_calendar=org.hibernate.type.AdaptedImmutableType@5e0651,
 text=org.hibernate.type.TextType@3fa497e2,
 java.sql.Date=org.hibernate.type.DateType@4fa6cb2d,
 Byte[]=org.hibernate.type.WrapperBinaryType@fa09c82,
 wrapper-characters=org.hibernate.type.CharacterArrayType@101837c4,
 character=org.hibernate.type.CharacterType@5e691263,
 char[]=org.hibernate.type.CharArrayType@1833e2a6,
 java.util.Calendar=org.hibernate.type.CalendarType@387162d9,
 java.sql.Blob=org.hibernate.type.BlobType@1eeeece6,
 materialized_nclob=org.hibernate.type.MaterializedNClobType@669b675b,
 imm_timestamp=org.hibernate.type.AdaptedImmutableType@15ee86f2,
 java.lang.Short=org.hibernate.type.ShortType@403a6e15,
 [C=org.hibernate.type.CharArrayType@1833e2a6,
 date=org.hibernate.type.DateType@4fa6cb2d,
 imm_time=org.hibernate.type.AdaptedImmutableType@657430d3,
 characters=org.hibernate.type.CharArrayType@1833e2a6,
 [Ljava.lang.Character;=org.hibernate.type.CharacterArrayType@101837c4,
 java.lang.Integer=org.hibernate.type.IntegerType@43463148,
 java.sql.NClob=org.hibernate.type.NClobType@4a8171b,
 java.sql.Timestamp=org.hibernate.type.TimestampType@56d0a8c,
 time=org.hibernate.type.TimeType@4bfa385a,
 long=org.hibernate.type.LongType@2a91a829,
 Character[]=org.hibernate.type.CharacterArrayType@101837c4,
 big_integer=org.hibernate.type.BigIntegerType@4ad9cb27,
 currency=org.hibernate.type.CurrencyType@6f8bf360,
 wrapper-binary=org.hibernate.type.WrapperBinaryType@fa09c82,
 java.lang.String=org.hibernate.type.StringType@519f8603,
 java.lang.Long=org.hibernate.type.LongType@2a91a829,
 java.math.BigDecimal=org.hibernate.type.BigDecimalType@8ba6621,
 short=org.hibernate.type.ShortType@403a6e15,
 ntext=org.hibernate.type.NTextType@24ee50b4,
 char=org.hibernate.type.CharacterType@5e691263,
 [Ljava.lang.Byte;=org.hibernate.type.WrapperBinaryType@fa09c82,
 byte[]=org.hibernate.type.BinaryType@40420970,
 uuid-char=org.hibernate.type.UUIDCharType@28de323b,
 true_false=org.hibernate.type.TrueFalseType@6636e83b,
 java.sql.Time=org.hibernate.type.TimeType@4bfa385a,
 java.util.Locale=org.hibernate.type.LocaleType@611c3b04,
 materialized_blob=org.hibernate.type.MaterializedBlobType@3dafab2e,
 java.net.URL=org.hibernate.type.UrlType@7bca4b51,
 imm_calendar_date=org.hibernate.type.AdaptedImmutableType@259847e5,
 java.lang.Float=org.hibernate.type.FloatType@115783a2,
 dbtimestamp=org.hibernate.type.DbTimestampType@e1a8f49,
 timestamp=org.hibernate.type.TimestampType@56d0a8c,
 object=org.hibernate.type.ObjectType@3dac8e4a,
 url=org.hibernate.type.UrlType@7bca4b51,
 image=org.hibernate.type.ImageType@24024ad8,
 binary=org.hibernate.type.BinaryType@40420970,
 java.lang.Class=org.hibernate.type.ClassType@7dc0cd3b,
 double=org.hibernate.type.DoubleType@23e94776,
 java.lang.Byte=org.hibernate.type.ByteType@5e5aefe,
 numeric_boolean=org.hibernate.type.NumericBooleanType@7a2897ac,
 java.lang.Character=org.hibernate.type.CharacterType@5e691263,
 nclob=org.hibernate.type.NClobType@4a8171b,
 string=org.hibernate.type.StringType@519f8603,
 serializable=org.hibernate.type.SerializableType@5f064398,
 big_decimal=org.hibernate.type.BigDecimalType@8ba6621,
 int=org.hibernate.type.IntegerType@43463148,
 timezone=org.hibernate.type.TimeZoneType@2c9596e5,
 imm_date=org.hibernate.type.AdaptedImmutableType@3c211e40,
 imm_dbtimestamp=org.hibernate.type.AdaptedImmutableType@20de42ca,
 java.lang.Boolean=org.hibernate.type.BooleanType@4fc55da3,
 materialized_clob=org.hibernate.type.MaterializedClobType@13b5b562,
 locale=org.hibernate.type.LocaleType@611c3b04,
 ncharacter=org.hibernate.type.CharacterNCharType@2f33cbcc,
 java.lang.Double=org.hibernate.type.DoubleType@23e94776,
 clob=org.hibernate.type.ClobType@767c7fc2,
 integer=org.hibernate.type.IntegerType@43463148,
 calendar=org.hibernate.type.CalendarType@387162d9,
 pg-uuid=org.hibernate.type.PostgresUUIDType@2e60639b,
 java.util.Currency=org.hibernate.type.CurrencyType@6f8bf360,
 java.util.UUID=org.hibernate.type.UUIDBinaryType@2e8d404,
 java.lang.Object=org.hibernate.type.ObjectType@3dac8e4a,
 java.util.Date=org.hibernate.type.TimestampType@56d0a8c,
 calendar_date=org.hibernate.type.CalendarDateType@6d287249,
 blob=org.hibernate.type.BlobType@1eeeece6,
 class=org.hibernate.type.ClassType@7dc0cd3b,
 [B=org.hibernate.type.BinaryType@40420970,
 imm_serializable=org.hibernate.type.AdaptedImmutableType@15de3027,
 nstring=org.hibernate.type.StringNVarcharType@7d75c05,
 java.sql.Clob=org.hibernate.type.ClobType@767c7fc2,
 java.util.TimeZone=org.hibernate.type.TimeZoneType@2c9596e5,
 java.math.BigInteger=org.hibernate.type.BigIntegerType@4ad9cb27,
 imm_binary=org.hibernate.type.AdaptedImmutableType@53c3dcdc,
 byte=org.hibernate.type.ByteType@5e5aefe,
 yes_no=org.hibernate.type.YesNoType@4382b300,
 boolean=org.hibernate.type.BooleanType@4fc55da3,
 float=org.hibernate.type.FloatType@115783a2,
 uuid-binary=org.hibernate.type.UUIDBinaryType@2e8d404}

/t
TypeResolver.<init>() line: 46	
		this(  new BasicTypeRegistry(), new TypeFactory() );
/pd
/s
TypeFactory.<init>() line: 58	
/t
TypeResolver.<init>() line: 47	
		this.basicTypeRegistry = basicTypeRegistry;
		this.typeFactory = typeFactory;

/t
Configuration.<init>(SettingsFactory) line: 255	
	private TypeResolver typeResolver = new TypeResolver();
/d
	private transient Mapping mapping = buildMapping();
	final ObjectNameNormalizer normalizer = new ObjectNameNormalizerImpl();
/t
Configuration.<init>(SettingsFactory) line: 289	
		this.settingsFactory = settingsFactory;
		reset();
/s
Configuration.reset() line: 300	
		metadataSourceQueue = new MetadataSourceQueue();
		createReflectionManager();
		xmlHelper = new XMLHelper();
		entityTuplizerFactory = new EntityTuplizerFactory();

		identifierGeneratorFactory = new DefaultIdentifierGeneratorFactory();
/s
DefaultIdentifierGeneratorFactory.<init>() line: 74	
		register( "uuid2", UUIDGenerator.class );
		register( "guid", GUIDGenerator.class );			// can be done with UUIDGenerator + strategy
		register( "uuid", UUIDHexGenerator.class );			// "deprecated" for new use
		register( "uuid.hex", UUIDHexGenerator.class ); 	// uuid.hex is deprecated
		register( "hilo", TableHiLoGenerator.class );
		register( "assigned", Assigned.class );
		register( "identity", IdentityGenerator.class );
		register( "select", SelectGenerator.class );
		register( "sequence", SequenceGenerator.class );
		register( "seqhilo", SequenceHiLoGenerator.class );
		register( "increment", IncrementGenerator.class );
		register( "foreign", ForeignGenerator.class );
		register( "sequence-identity", SequenceIdentityGenerator.class );
		register( "enhanced-sequence", SequenceStyleGenerator.class );
		register( "enhanced-table", TableGenerator.class );
	}

this	DefaultIdentifierGeneratorFactory  (id=247)	
	dialect	null	
	generatorStrategyToClassNameMap	ConcurrentHashMap<K,V>  (id=248)	
{select=class org.hibernate.id.SelectGenerator,
 assigned=class org.hibernate.id.Assigned,
 uuid2=class org.hibernate.id.UUIDGenerator,
 sequence-identity=class org.hibernate.id.SequenceIdentityGenerator,
 seqhilo=class org.hibernate.id.SequenceHiLoGenerator,
 enhanced-table=class org.hibernate.id.enhanced.TableGenerator,
 uuid.hex=class org.hibernate.id.UUIDHexGenerator,
 hilo=class org.hibernate.id.TableHiLoGenerator,
 uuid=class org.hibernate.id.UUIDHexGenerator,
 identity=class org.hibernate.id.IdentityGenerator,
 guid=class org.hibernate.id.GUIDGenerator,
 enhanced-sequence=class org.hibernate.id.enhanced.SequenceStyleGenerator,
 increment=class org.hibernate.id.IncrementGenerator,
 foreign=class org.hibernate.id.ForeignGenerator,
 sequence=class org.hibernate.id.SequenceGenerator}

/t
Configuration.reset() line: 353	
		identifierGeneratorFactory = new DefaultIdentifierGeneratorFactory();
/d
		setEntityResolver( new EJB3DTDEntityResolver() );
		specjProprietarySyntaxEnabled = System.getProperty( "hibernate.enable_specj_proprietary_syntax" ) != null;
false
/t
Main.setUp() line: 83	
        	Configuration configuration=new Configuration().configure();
/pd
/s
Configuration.configure() line: 2054	
		configure( "/hibernate.cfg.xml" );
/s
Configuration.configure(String) line: 2073	
		InputStream stream = getConfigurationInputStream( resource );
		return doConfigure( stream, resource );
/s
Configuration.doConfigure(InputStream, String) line: 2160	
			Document document = xmlHelper.createSAXReader( errorLogger,  entityResolver )
					.read( new InputSource( stream ) );
/d
			doConfigure( document );
/s
Configuration.doConfigure(Document) line: 2201	
		Element sfNode = doc.getRootElement().element( "session-factory" );

/ Dit is de DefaultElement <session-factory/> 	, straks <mapping/>

sfNode	DefaultElement  (id=345)	
	qname	QName  (id=118)	
org.dom4j.QName@c847a0d3 [name: session-factory namespace: "org.dom4j.Namespace@babe [Namespace: prefix  mapped to URI ""]"]
	content	ArrayList<E>  (id=349)	
		elementData	Object[33]  (id=353)	
			[0]	DefaultComment  (id=354)	
			[1]	DefaultElement  (id=355)	
				attributes	ArrayList<E>  (id=463)	
[org.dom4j.tree.DefaultAttribute@2d17d41d [Attribute: name name value "connection.driver_class"]]
				content	DefaultText  (id=464)	
org.dom4j.tree.DefaultText@45890909 [Text: "org.postgresql.Driver"]
			[2]	DefaultElement  (id=356)	
			[3]	DefaultElement  (id=357)	
			[4]	DefaultElement  (id=358)	
			[5]	DefaultComment  (id=365)	
			[6]	DefaultComment  (id=366)	
			[7]	DefaultElement  (id=367)	
			[8]	DefaultComment  (id=368)	
			[9]	DefaultElement  (id=369)	
			[10]	DefaultComment  (id=372)	
			[11]	DefaultElement  (id=373)	
				attributes	ArrayList<E>  (id=451)	
[org.dom4j.tree.DefaultAttribute@318957f4 [Attribute: name name value "current_session_context_class"]]
				content	DefaultText  (id=452)	
org.dom4j.tree.DefaultText@757d93a9 [Text: "thread"]
			[12]	DefaultComment  (id=375)	
			[13]	DefaultComment  (id=377)	
			[14]	DefaultElement  (id=378)	
				attributes	DefaultAttribute  (id=134)	
org.dom4j.tree.DefaultAttribute@3b7fb05a [Attribute: name name value "hbm2ddl.auto"]
				content	DefaultText  (id=137)	
org.dom4j.tree.DefaultText@37041974 [Text: "create"]
			[15]	DefaultComment  (id=380)	
			[16]	DefaultElement  (id=382)	
			[17]	DefaultElement  (id=383)	
			[18]	DefaultElement  (id=385)	
			[19]	DefaultElement  (id=387)	
			[20]	DefaultElement  (id=389)	
			[21]	DefaultElement  (id=390)	
			[22]	DefaultElement  (id=392)	
		size	23	
	parentBranch	DefaultElement  (id=350)	
	qname	QName  (id=351)	
org.dom4j.QName@c847a0d3 [name: session-factory namespace: "org.dom4j.Namespace@babe [Namespace: prefix  mapped to URI ""]"]

		addProperties( sfNode );
/s
Configuration.addProperties(Element) line: 2036	

/ Onze 
<hibernate-configuration>
 <session-factory>
 	<property name="connection.driver_class">org.postgresql.Driver</property>
	...
 	<mapping resource="my/test/own/hibernate_mappings/Employee.hbm.xml"/> -->
	...
/ we nemen nu alleen de <property/>'s eruit	,
  
		Iterator itr = parent.elementIterator( "property" );
		while ( itr.hasNext() ) {
			Element node = (Element) itr.next();
			String name = node.attributeValue( "name" );
connection.driver_class
			String value = node.getText().trim();
org.postgresql.Driver
			properties.setProperty( name, value );
			if ( !name.startsWith( "hibernate" ) ) {
				properties.setProperty( "hibernate." + name, value );
			}

/ we add	,
 hibernate.connection.driver_class=org.postgresql.Driver,
 connection.driver_class=org.postgresql.Driver,

/ In het totaal is properties nu	,

{java.runtime.name=OpenJDK Runtime Environment,
 sun.boot.library.path=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/amd64,
 java.vm.version=24.65-b04,
 java.vm.vendor=Oracle Corporation,
 java.vendor.url=http://java.oracle.com/,
 path.separator=:,
 java.vm.name=OpenJDK 64-Bit Server VM,
 file.encoding.pkg=sun.io,
 user.country=US,
 sun.java.launcher=SUN_STANDARD,
 sun.os.patch.level=unknown,
 java.vm.specification.name=Java Virtual Machine Specification,
 user.dir=/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace/hibernate_mappings,
 java.runtime.version=1.7.0_71-mockbuild_2014_10_15_17_02-b00,
 java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment,
 java.endorsed.dirs=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/endorsed,
 os.arch=amd64,
 java.io.tmpdir=/tmp,
 line.separator=
,
 java.vm.specification.vendor=Oracle Corporation,
 os.name=Linux,
 sun.jnu.encoding=UTF-8,
 java.library.path=/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib,
 java.specification.name=Java Platform API Specification,
 java.class.version=51.0,
 sun.management.compiler=HotSpot 64-Bit Tiered Compilers,
 os.version=3.16.6-200.fc20.x86_64,
 user.home=/home/eric,
 user.timezone=Europe/Amsterdam,
 java.awt.printerjob=sun.print.PSPrinterJob,
 file.encoding=UTF-8,
 java.specification.version=1.7,
 hibernate.connection.driver_class=org.postgresql.Driver,
 user.name=eric,
 java.class.path=/home/eric/Devel/Java/Eclipse/eclipse-jee-test/workspace/hibernate_mappings/target/classes:/home/eric/.m2/repository/org/terracotta/ehcache-probe/1.0.3/ehcache-probe-1.0.3.jar:/home/eric/.m2/repository/org/hibernate/hibernate-core/4.3.6.Final/hibernate-core-4.3.6.Final.jar:/home/eric/.m2/repository/org/jboss/logging/jboss-logging/3.1.3.GA/jboss-logging-3.1.3.GA.jar:/home/eric/.m2/repository/org/jboss/logging/jboss-logging-annotations/1.2.0.Beta1/jboss-logging-annotations-1.2.0.Beta1.jar:/home/eric/.m2/repository/org/jboss/spec/javax/transaction/jboss-transaction-api_1.2_spec/1.0.0.Final/jboss-transaction-api_1.2_spec-1.0.0.Final.jar:/home/eric/.m2/repository/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar:/home/eric/.m2/repository/xml-apis/xml-apis/1.0.b2/xml-apis-1.0.b2.jar:/home/eric/.m2/repository/org/hibernate/common/hibernate-commons-annotations/4.0.5.Final/hibernate-commons-annotations-4.0.5.Final.jar:/home/eric/.m2/repository/org/hibernate/javax/persistence/hibernate-jpa-2.1-api/1.0.0.Final/hibernate-jpa-2.1-api-1.0.0.Final.jar:/home/eric/.m2/repository/org/javassist/javassist/3.18.1-GA/javassist-3.18.1-GA.jar:/home/eric/.m2/repository/antlr/antlr/2.7.7/antlr-2.7.7.jar:/home/eric/.m2/repository/org/jboss/jandex/1.1.0.Final/jandex-1.1.0.Final.jar:/home/eric/.m2/repository/org/postgresql/postgresql/9.3-1102-jdbc41/postgresql-9.3-1102-jdbc41.jar:/home/eric/.m2/repository/net/sf/ehcache/ehcache-core/2.6.9/ehcache-core-2.6.9.jar:/home/eric/.m2/repository/org/hibernate/hibernate-ehcache/4.3.6.Final/hibernate-ehcache-4.3.6.Final.jar:/home/eric/.m2/repository/org/slf4j/slf4j-api/1.7.7/slf4j-api-1.7.7.jar:/home/eric/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:/home/eric/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/home/eric/.m2/repository/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar,
 hibernate.bytecode.use_reflection_optimizer=false,
 java.vm.specification.version=1.7,
 sun.java.command=my.test.own.objects.Main,
 java.home=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre,
 sun.arch.data.model=64,
 user.language=en,
 java.specification.vendor=Oracle Corporation,
 awt.toolkit=sun.awt.X11.XToolkit,
 java.vm.info=mixed mode,
 java.version=1.7.0_71,
 java.ext.dirs=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/ext:/usr/java/packages/lib/ext,
 sun.boot.class.path=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/resources.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/rt.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/jce.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/rhino.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/lib/jfr.jar:/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.71-2.5.3.0.fc20.x86_64/jre/classes,
 java.vendor=Oracle Corporation,
 connection.driver_class=org.postgresql.Driver,
 file.separator=/,
 java.vendor.url.bug=http://bugreport.sun.com/bugreport/,
 sun.io.unicode.encoding=UnicodeLittle,
 sun.cpu.endian=little,
 sun.desktop=gnome,
 sun.cpu.isalist=}

/ volgende,	
		while ( itr.hasNext() ) {
			String name = node.attributeValue( "name" );
connection.url/hibernateconnection.url
connection.username/ hibernate.connection.username
connection.password/ hibernate.connection.password
dialect/hibernate.dialect
show_sql/hibernate.show_sql
current_session_context_class/ hibernate.current_session_context_class
hbm2ddl.auto/ hibernate.hbm2ddl.auto
			String value = node.getText().trim();
jdbc:postgresql://localhost/foo
foo
org.hibernate.dialect.PostgreSQLDialect
true
foo
thread
create

/t
Configuration.doConfigure(Document) line: 2207	
		addProperties( sfNode );
/d
		parseSessionFactory( sfNode, name );
/s
Configuration.parseSessionFactory(Element, String) line: 2222	

/ Nu de <mapping/>'s	,
 	<mapping resource="my/test/own/hibernate_mappings/Sporter.hbm.xml"/>
	...

		while ( elements.hasNext() ) {
			Element subelement = (Element) elements.next();
...
org.dom4j.tree.DefaultElement@2da8bc4f [Element: <mapping attributes: [org.dom4j.tree.DefaultAttribute@20e2fdf4 [Attribute: name resource value "my/test/own/hibernate_mappings/Sporter.hbm.xml"]]/>]

/ we hadden eerst <session-factory/> als DefaultElement	, nu <mapping/>

			String subelementName = subelement.getName();
			if ( "mapping".equals( subelementName ) ) {
/ NEE	, eerst alle <property/>'s	, 
/ JA
			else if ( "class-cache".equals( subelementName ) ) {
/NEE
			else if ( "collection-cache".equals( subelementName ) ) {
/NEE
subelement	DefaultElement  (id=128)	
	attributes	ArrayList<E>  (id=273)	
[org.dom4j.tree.DefaultAttribute@1d5c484e [Attribute: name resource value "my/test/own/hibernate_mappings/Sporter.hbm.xml"]]
	content	null	
				parseMappingElement( subelement, name );

/ Intermezzo

/ Gaat write	, 

this	Configuration  (id=18)	
	metadataSourceQueue	Configuration$MetadataSourceQueue  (id=208)	
		annotatedClasses	ArrayList<E>  (id=210)						/ We doen GEEN annotaties	,
		annotatedClassesByEntityNameMap	HashMap<K,V>  (id=211)	
		hbmMetadataByEntityNameXRef	HashMap<K,V>  (id=215)				<-
		hbmMetadataToEntityNamesMap	LinkedHashMap<K,V>  (id=216)		<-

/ Deze laatste 2 zijn ongeveer elkaars inverse	,

			for ( String entity : entityNames ) {
				hbmMetadataByEntityNameXRef.put( entity, metadataXml );
			}
			this.hbmMetadataToEntityNamesMap.put( metadataXml, entityNames );

entityNames=[my.test.own.hibernate_mappings.Club]


/ Einde Intermezzo

/s
Configuration.parseMappingElement(Element, String) line: 2246	
		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
org.dom4j.tree.DefaultAttribute@1d5c484e [Attribute: name resource value "my/test/own/hibernate_mappings/Sporter.hbm.xml"]
		final Attribute fileAttribute = mappingElement.attribute( "file" );
		final Attribute jarAttribute = mappingElement.attribute( "jar" );
		final Attribute packageAttribute = mappingElement.attribute( "package" );
		final Attribute classAttribute = mappingElement.attribute( "class" );

		if ( resourceAttribute != null ) {
			final String resourceName = resourceAttribute.getValue();
my/test/own/hibernate_mappings/Sporter.hbm.xml
			addResource( resourceName );

/ Intermezzo

[eric@localhost hibernate_mappings]$ jar tvf target/hibernate_mappings-0.0.1-SNAPSHOT.jar
     0 Tue Sep 08 11:42:38 CEST 2015 META-INF/
   129 Tue Sep 08 11:42:36 CEST 2015 META-INF/MANIFEST.MF
     0 Tue Sep 08 11:42:34 CEST 2015 my/
     0 Tue Sep 08 11:42:34 CEST 2015 my/test/
     0 Tue Sep 08 11:42:34 CEST 2015 my/test/own/
     0 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/
  3971 Tue Sep 08 11:42:34 CEST 2015 ehcache.xml
   543 Tue Sep 08 11:42:34 CEST 2015 log4j.properties
  7956 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main_N_1.class
  1037 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Club.class
  2471 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Address.class
   682 Tue Sep 08 11:42:34 CEST 2015 my/test/own/hibernate_mappings/Club.hbm.xml
  4786 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main6a4.class
  7893 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main5.class
  4526 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main6a5.class
   931 Tue Sep 08 11:42:34 CEST 2015 my/test/own/hibernate_mappings/Employee.hbm.xml
  4731 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main6.class
  1643 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Employee.class
 11957 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/MainOld.class
  8571 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main4.class
  8237 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main2_N_1.class
  6720 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/MainDeleteEntityNotFromColl.class
  4734 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main3_N_1.class
  4815 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main6a3.class
  9570 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main2Old.class
  4796 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main6a.class
   881 Tue Sep 08 11:42:34 CEST 2015 my/test/own/hibernate_mappings/Sporter.hbm.xml
  4827 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Main6a2.class
  1431 Tue Sep 08 11:42:34 CEST 2015 my/test/own/hibernate_mappings/Address.hbm.xml
  1353 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/Sporter.class
 10670 Tue Sep 08 11:42:36 CEST 2015 my/test/own/hibernate_mappings/MainDeleteEntityAlsoFromColl.class
  1751 Tue Sep 08 11:42:34 CEST 2015 hibernate.cfg.xml
     0 Tue Sep 08 11:42:38 CEST 2015 META-INF/maven/
     0 Tue Sep 08 11:42:38 CEST 2015 META-INF/maven/my.test.own/
     0 Tue Sep 08 11:42:38 CEST 2015 META-INF/maven/my.test.own/hibernate_mappings/
  2362 Tue Sep 08 11:34:06 CEST 2015 META-INF/maven/my.test.own/hibernate_mappings/pom.xml
   124 Tue Sep 08 11:42:36 CEST 2015 META-INF/maven/my.test.own/hibernate_mappings/pom.properties

/ we zien de Sporter.hbm.xml naast Sporter.class	,

/ Einde Intermezzo

/s
Configuration.addResource(String) line: 757	
		ClassLoader contextClassLoader = ClassLoaderHelper.getContextClassLoader();
sun.misc.Launcher$AppClassLoader@1ab2f2d6
			resourceInputStream = contextClassLoader.getResourceAsStream( resourceName );
java.io.BufferedInputStream@41b5ec35
resourceName=my/test/own/hibernate_mappings/Sporter.hbm.xml

		add( resourceInputStream, "resource", resourceName );
...
/s
Configuration.add(InputSource, Origin) line: 517	
		XmlDocument metadataXml = MappingReader.INSTANCE.readMappingDocument( entityResolver, inputSource, origin );

metadataXml	XmlDocumentImpl  (id=190)	
	origin	OriginImpl  (id=194)	
		name	"my/test/own/hibernate_mappings/Sporter.hbm.xml" (id=163)	
		type	"resource" (id=170)	
	documentTree	DefaultDocument  (id=193)	/= Sporter.hbm.xml	,
		content	ArrayList<E>  (id=197)	
			elementData	Object[5]  (id=220)	
				[0]	DefaultElement  (id=206)	
			size	1	
		docType	DefaultDocumentType  (id=198)	
		documentFactory	DocumentFactory  (id=201)	
		encoding	"UTF-8" (id=204)	
		entityResolver	EJB3DTDEntityResolver  (id=66)	
		name	null	
		rootElement	DefaultElement  (id=206)	

		add( metadataXml );
/s
Configuration.add(XmlDocument) line: 523	
		if ( inSecondPass || !isOrmXml( metadataXml ) ) {
/ JA	, is niet <entity-mappings/> 
TODO
			metadataSourceQueue.add( metadataXml );
/s
Configuration$MetadataSourceQueue.add(XmlDocument) line: 3672	
/=
		public void add(XmlDocument metadataXml) {
			final Document document = metadataXml.getDocumentTree();
document	DefaultDocument  (id=193)	

document=Sporter.hbm.xml

<hibernate-mapping package="my.test.own.hibernate_mappings">
<class name="Sporter" table="sporter" >
	<id name="id" column="id_" >	
		<generator class="identity"/>
	</id>
	<property name="name" column="name_" />
</class>
</hibernate-mapping>
/=
<hibernate-mapping 
	package="my.test.own.hibernate_mappings"
	default-cascade="none"
	default-access="property"
	default-lazy="true"
	auto-import="true" >
<class 	
	name="Sporter" 
	table="sporter" >
	mutable="true"
	polymorphism="implicit"
	dynamic-update="false"
	dynamic-insert="false"
	select-before-update="false"
	optimistic-lock="version" >	

	<id 
		name="id" 
		column="id_" >	
		<generator 
			class="identity"/>
	</id>
	<property 
		name="name" 
		column="name_" 
		unique="false"
		optimistic-lock="false"
		lazy="false"
		generated="never"
	/>
</class>
</hibernate-mapping>


document	DefaultDocument  (id=362)	
	content	ArrayList<E>  (id=375)	
		elementData	Object[5]  (id=398)	
			[0]	DefaultElement  (id=383)	
				attributes	ArrayList<E>  (id=401)	
					elementData	Object[5]  (id=406)	
						[0]	DefaultAttribute  (id=387)	
org.dom4j.tree.DefaultAttribute@4156f8b9 [Attribute: name package value "my.test.own.hibernate_mappings"]
						[1]	DefaultAttribute  (id=408)	
org.dom4j.tree.DefaultAttribute@26e1cd69 [Attribute: name default-cascade value "none"]
						[2]	DefaultAttribute  (id=409)	
org.dom4j.tree.DefaultAttribute@3274bc70 [Attribute: name default-access value "property"]
						[3]	DefaultAttribute  (id=410)	
org.dom4j.tree.DefaultAttribute@dff76f1 [Attribute: name default-lazy value "true"]
						[4]	DefaultAttribute  (id=411)	
org.dom4j.tree.DefaultAttribute@7ed9cf64 [Attribute: name auto-import value "true"]
					size	5	
				content	DefaultElement  (id=402)	
					attributes	ArrayList<E>  (id=423)	
						elementData	Object[8]  (id=572)	
							[0]	DefaultAttribute  (id=574)	
org.dom4j.tree.DefaultAttribute@618926ef [Attribute: name name value "Sporter"]
							[1]	DefaultAttribute  (id=575)	
org.dom4j.tree.DefaultAttribute@735b46ef [Attribute: name table value "sporter"]
							[2]	DefaultAttribute  (id=576)	
org.dom4j.tree.DefaultAttribute@6d8e3013 [Attribute: name mutable value "true"]
							[3]	DefaultAttribute  (id=577)	
org.dom4j.tree.DefaultAttribute@11f66796 [Attribute: name polymorphism value "implicit"]
							[4]	DefaultAttribute  (id=578)	
org.dom4j.tree.DefaultAttribute@480ab210 [Attribute: name dynamic-update value "false"]
							[5]	DefaultAttribute  (id=579)	
org.dom4j.tree.DefaultAttribute@36305d63 [Attribute: name dynamic-insert value "false"]
							[6]	DefaultAttribute  (id=580)	
org.dom4j.tree.DefaultAttribute@21432a60 [Attribute: name select-before-update value "false"]
							[7]	DefaultAttribute  (id=582)	
org.dom4j.tree.DefaultAttribute@409315af [Attribute: name optimistic-lock value "version"]
						size	8	
					content	ArrayList<E>  (id=424)	
						elementData	Object[15]  (id=445)	
							[0]	DefaultElement  (id=448)	
								attributes	ArrayList<E>  (id=555)	
									elementData	Object[2]  (id=559)	
										[0]	DefaultAttribute  (id=561)	
org.dom4j.tree.DefaultAttribute@6022ef16 [Attribute: name name value "id"]
										[1]	DefaultAttribute  (id=562)	
org.dom4j.tree.DefaultAttribute@157ebea9 [Attribute: name column value "id_"]
									size	2	
								content	DefaultElement  (id=556)	
									attributes	ArrayList<E>  (id=631)	
[org.dom4j.tree.DefaultAttribute@53134610 [Attribute: name class value "identity"]]
									content	null	
									parentBranch	DefaultElement  (id=448)	
									qname	QName  (id=565)	
org.dom4j.QName@111a9ad3 [name: generator namespace: "org.dom4j.Namespace@babe [Namespace: prefix  mapped to URI ""]"]
								parentBranch	DefaultElement  (id=402)	
								qname	QName  (id=557)	
org.dom4j.QName@d1b [name: id namespace: "org.dom4j.Namespace@babe [Namespace: prefix  mapped to URI ""]"]
							[1]	DefaultElement  (id=449)	
								attributes	ArrayList<E>  (id=746)	
									elementData	Object[6]  (id=749)	
										[0]	DefaultAttribute  (id=751)	
org.dom4j.tree.DefaultAttribute@679d98ba [Attribute: name name value "name"]
										[1]	DefaultAttribute  (id=752)	
org.dom4j.tree.DefaultAttribute@1b96107b [Attribute: name column value "name_"]
										[2]	DefaultAttribute  (id=753)	
org.dom4j.tree.DefaultAttribute@19140963 [Attribute: name unique value "false"]
										[3]	DefaultAttribute  (id=755)	
org.dom4j.tree.DefaultAttribute@72744f71 [Attribute: name optimistic-lock value "true"]
										[4]	DefaultAttribute  (id=756)	
org.dom4j.tree.DefaultAttribute@320bbe6b [Attribute: name lazy value "false"]
										[5]	DefaultAttribute  (id=758)	
org.dom4j.tree.DefaultAttribute@21027c78 [Attribute: name generated value "never"]
									size	6	
								content	null	
								parentBranch	DefaultElement  (id=402)	
								qname	QName  (id=141)	
org.dom4j.QName@c4cdddd5 [name: property namespace: "org.dom4j.Namespace@babe [Namespace: prefix  mapped to URI ""]"]
							[2]	DefaultComment  (id=450)	

/ Intermezzo

$ vi hibernate.cfg.xml
<hibernate-configuration>

$ vi Item.hbm.xml
<hibernate-mapping package="my.test.own.objects">

/ Einde Intermezzo

/ we zijn nog in	,
Configuration$MetadataSourceQueue.add(XmlDocument) line: 3670	
			final Document document = metadataXml.getDocumentTree();
/d
			final Element hmNode = document.getRootElement();
<hibernate-mapping/>
			Attribute packNode = hmNode.attribute( "package" );
org.dom4j.tree.DefaultAttribute@66c094f6 [Attribute: name package value "my.test.own.hibernate_mappings"]
			String defaultPackage = packNode != null ? packNode.getValue() : "";
my.test.own.hibernate_mappings
			findClassNames( defaultPackage, hmNode, entityNames );

/ Intermezzo

$ vi Sporter.hbm.xml
<hibernate-mapping 
	package="my.test.own.hibernate_mappings">
<class 
	name="Sporter" 
	table="sporter">
...
</class>

/ Intermezzo

/s
Configuration$MetadataSourceQueue.findClassNames(String, Element, Set<String>) line: 3683	
/=
		private void findClassNames(String defaultPackage, Element startNode, Set<String> names) {

			Iterator[] classes = new Iterator[4];
			classes[0] = startNode.elementIterator( "class" );
			classes[1] = startNode.elementIterator( "subclass" );
			classes[2] = startNode.elementIterator( "joined-subclass" );
			classes[3] = startNode.elementIterator( "union-subclass" );

			Iterator classIterator = new JoinedIterator( classes );
			while ( classIterator.hasNext() ) {
				Element element = ( Element ) classIterator.next();
element	DefaultElement  (id=224)	<class/>
				String entityName = element.attributeValue( "entity-name" );
null
				if ( entityName == null ) {
					entityName = getClassName( element.attribute( "name" ), defaultPackage );
my.test.own.hibernate_mappings.Sporter
				names.add( entityName );
/t
Configuration$MetadataSourceQueue.add(XmlDocument) line: 3674	
			findClassNames( defaultPackage, hmNode, entityNames );
/d
			for ( String entity : entityNames ) {
				hbmMetadataByEntityNameXRef.put( entity, metadataXml );
			this.hbmMetadataToEntityNamesMap.put( metadataXml, entityNames );
...
/t
Configuration.parseSessionFactory(Element, String) line: 2227	
			if ( "mapping".equals( subelementName ) ) {
				parseMappingElement( subelement, name );
/d
/ volgende	,
		while ( elements.hasNext() ) {
			Element subelement = (Element) elements.next();
			String subelementName = subelement.getName();
			if ( "mapping".equals( subelementName ) ) {
				parseMappingElement( subelement, name );
...
/s
Configuration$MetadataSourceQueue.add(XmlDocument) line: 3668	
			for ( String entity : entityNames ) {
				hbmMetadataByEntityNameXRef.put( entity, metadataXml );
			}
			this.hbmMetadataToEntityNamesMap.put( metadataXml, entityNames );

/t
Configuration.parseSessionFactory(Element, String) line: 2243	
		while ( elements.hasNext() ) {
			Element subelement = (Element) elements.next();
			String subelementName = subelement.getName();
			if ( "mapping".equals( subelementName ) ) {
				parseMappingElement( subelement, name );
			}
/d
this	Configuration  (id=18)	
	metadataSourceQueue	Configuration$MetadataSourceQueue  (id=208)	
		annotatedClasses	ArrayList<E>  (id=210)	
		annotatedClassesByEntityNameMap	HashMap<K,V>  (id=211)	
		hbmMetadataByEntityNameXRef	HashMap<K,V>  (id=215)	
			size	7	
			table	HashMap$Entry<K,V>[16]  (id=584)	
				[1]	HashMap$Entry<K,V>  (id=643)	
					hash	-1996056975	
					key	"my.test.own.objects.Category" (id=648)	
					next	null	
					value	XmlDocumentImpl  (id=649)	
						documentTree	DefaultDocument  (id=650)		<hibernate-mapping/>
						origin	OriginImpl  (id=651)	
				[2]	HashMap$Entry<K,V>  (id=644)	
				[3]	HashMap$Entry<K,V>  (id=585)	
				[6]	HashMap$Entry<K,V>  (id=645)	
				[9]	HashMap$Entry<K,V>  (id=586)	
				[11]	HashMap$Entry<K,V>  (id=646)	
				[12]	HashMap$Entry<K,V>  (id=647)	


/t
Main.setUp() line: 84	
        	Configuration configuration=new Configuration().configure();
/d
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();

/ Ze type door	, er staat
    		new StandardServiceRegistryBuilder()
				.applySettings(configuration.getProperties())
				.build();
/s
StandardServiceRegistryBuilder.<init>() line: 73	
		this( new BootstrapServiceRegistryBuilder().build() );
/s
BootstrapServiceRegistryBuilder.build() line: 253	
		return new BootstrapServiceRegistryImpl(
				autoCloseRegistry,
				classLoaderService,
				strategySelectorBuilder.buildSelector( classLoaderService ),
				integratorService
		);
/s
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 165	
		final StrategySelectorImpl strategySelector = new StrategySelectorImpl( classLoaderService );

		// build the baseline...
		addDialects( strategySelector );


/s
StrategySelectorBuilder.addDialects(StrategySelectorImpl) line: 198	
		addDialect( strategySelector, Cache71Dialect.class );

		addDialect( strategySelector, CUBRIDDialect.class );
		addDialect( strategySelector, DB2Dialect.class );
		addDialect( strategySelector, DB2390Dialect.class );
		addDialect( strategySelector, DB2400Dialect.class );
		addDialect( strategySelector, DerbyTenFiveDialect.class );
		addDialect( strategySelector, DerbyTenSixDialect.class );
		addDialect( strategySelector, DerbyTenSevenDialect.class );
		addDialect( strategySelector, FirebirdDialect.class );
		addDialect( strategySelector, FrontBaseDialect.class );
		addDialect( strategySelector, H2Dialect.class );
		addDialect( strategySelector, HSQLDialect.class );
/s
StrategySelectorBuilder.addDialect(StrategySelectorImpl, Class<Dialect>) line: 244	
		String simpleName = dialectClass.getSimpleName();
H2Dialect
		if ( simpleName.endsWith( "Dialect" ) ) {
			simpleName = simpleName.substring( 0, simpleName.length() - "Dialect".length() );
H2
		}
		strategySelector.registerStrategyImplementor( Dialect.class, simpleName, dialectClass );

/ Intermezzo

public class StrategySelectorImpl implements StrategySelector {
	private final Map<Class,Map<String,Class>> namedStrategyImplementorByStrategyMap
			= new ConcurrentHashMap<Class, Map<String, Class>>();

/ Einde Intermezzo

/s
StrategySelectorImpl.registerStrategyImplementor(Class<T>, String, Class<? extends T>) line: 67	
		Map<String,Class> namedStrategyImplementorMap = namedStrategyImplementorByStrategyMap.get( strategy );
		if ( namedStrategyImplementorMap == null ) {
/ NEE
/ Alleen de 1ste keer, zijn we al voorbij	,
			namedStrategyImplementorMap = new ConcurrentHashMap<String, Class>();
/ NIET
			namedStrategyImplementorByStrategyMap.put( strategy, namedStrategyImplementorMap );
/ NIET
		}

		final Class old = namedStrategyImplementorMap.put( name, implementation );
name	"HSQL" (id=1640)	
implementation	Class<T> (org.hibernate.dialect.HSQLDialect) (id=1638)	

namedStrategyImplementorByStrategyMap	ConcurrentHashMap<K,V>  (id=1562)	
{class org.hibernate.dialect.Dialect={
 HSQL=class org.hibernate.dialect.HSQLDialect,
 DB2=class org.hibernate.dialect.DB2Dialect,
 DerbyTenSix=class org.hibernate.dialect.DerbyTenSixDialect,
 DB2400=class org.hibernate.dialect.DB2400Dialect,
 DerbyTenSeven=class org.hibernate.dialect.DerbyTenSevenDialect,
 CUBRID=class org.hibernate.dialect.CUBRIDDialect,
 H2=class org.hibernate.dialect.H2Dialect,
 Cache71=class org.hibernate.dialect.Cache71Dialect,
 DerbyTenFive=class org.hibernate.dialect.DerbyTenFiveDialect,
 FrontBase=class org.hibernate.dialect.FrontBaseDialect,
 DB2390=class org.hibernate.dialect.DB2390Dialect,
 Firebird=class org.hibernate.dialect.FirebirdDialect}}
/t
		addDialect( strategySelector, InformixDialect.class );
		addDialect( strategySelector, IngresDialect.class );
		addDialect( strategySelector, Ingres9Dialect.class );
		addDialect( strategySelector, Ingres10Dialect.class );
		addDialect( strategySelector, InterbaseDialect.class );
		addDialect( strategySelector, JDataStoreDialect.class );
		addDialect( strategySelector, MckoiDialect.class );
		addDialect( strategySelector, MimerSQLDialect.class );
		addDialect( strategySelector, MySQL5Dialect.class );
		addDialect( strategySelector, MySQL5InnoDBDialect.class );
		addDialect( strategySelector, MySQL5Dialect.class );
		addDialect( strategySelector, MySQL5InnoDBDialect.class );
		addDialect( strategySelector, Oracle8iDialect.class );
		addDialect( strategySelector, Oracle9iDialect.class );
		addDialect( strategySelector, Oracle10gDialect.class );
		addDialect( strategySelector, PointbaseDialect.class );
		addDialect( strategySelector, PostgresPlusDialect.class );
		addDialect( strategySelector, PostgreSQL81Dialect.class );
		addDialect( strategySelector, PostgreSQL82Dialect.class );
		addDialect( strategySelector, PostgreSQL9Dialect.class );
		addDialect( strategySelector, ProgressDialect.class );
		addDialect( strategySelector, SAPDBDialect.class );
		addDialect( strategySelector, SQLServerDialect.class );
		addDialect( strategySelector, SQLServer2005Dialect.class );
		addDialect( strategySelector, SQLServer2008Dialect.class );
		addDialect( strategySelector, Sybase11Dialect.class );
		addDialect( strategySelector, SybaseAnywhereDialect.class );
		addDialect( strategySelector, SybaseASE15Dialect.class );
		addDialect( strategySelector, SybaseASE157Dialect.class );
		addDialect( strategySelector, TeradataDialect.class );
		addDialect( strategySelector, TimesTenDialect.class );
/t
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 166	
		addDialects( strategySelector );
/d
		addJtaPlatforms( strategySelector );
/s
StrategySelectorBuilder.addJtaPlatforms(StrategySelectorImpl) line: 252	
		addJtaPlatforms(
				strategySelector,
				BorlandEnterpriseServerJtaPlatform.class,
				"Borland",
				"org.hibernate.service.jta.platform.internal.BorlandEnterpriseServerJtaPlatform"
		);

/ we register BorlandEnterpriseServerJtaPlatform.class 2 keer, onder 2 names	, "Borland" en "org.hibernate.service.jta.platform.internal.BorlandEnterpriseServerJtaPlatform"	, 

/s
	private void addJtaPlatforms(StrategySelectorImpl strategySelector, Class<? extends JtaPlatform> impl, String... names) {
names String[2]
[Borland, org.hibernate.service.jta.platform.internal.BorlandEnterpriseServerJtaPlatform]
		for ( String name : names ) {
			strategySelector.registerStrategyImplementor( JtaPlatform.class, name, impl );
/s
StrategySelectorImpl.registerStrategyImplementor(Class<T>, String, Class<? extends T>) line: 61	
		Map<String,Class> namedStrategyImplementorMap = namedStrategyImplementorByStrategyMap.get( strategy );
		if ( namedStrategyImplementorMap == null ) {
/ JA	, 1 keer	,
			namedStrategyImplementorMap = new ConcurrentHashMap<String, Class>();
			namedStrategyImplementorByStrategyMap.put( strategy, namedStrategyImplementorMap );
strategy	Class<T> (org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform) (id=1682)	

		}
		final Class old = namedStrategyImplementorMap.put( name, implementation );

strategySelector	StrategySelectorImpl  (id=1560)	
	namedStrategyImplementorByStrategyMap	ConcurrentHashMap<K,V>  (id=1562)	
		segments	ConcurrentHashMap$Segment<K,V>[16]  (id=1596)	
			[0]	ConcurrentHashMap$Segment<K,V>  (id=1597)	
				count	0	
			[6]	ConcurrentHashMap$Segment<K,V>  (id=1598)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1602)	
					[1]	ConcurrentHashMap$HashEntry<K,V>  (id=1603)	
						key	Class<T> (org.hibernate.dialect.Dialect) (id=1604)	
						value	ConcurrentHashMap<K,V>  (id=1605)	
/ Hier alle Dialect's	, 
			[7]	ConcurrentHashMap$Segment<K,V>  (id=1711)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1715)	
					[0]	ConcurrentHashMap$HashEntry<K,V>  (id=1718)	
						key	Class<T> (org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform) (id=1682)	
						value	ConcurrentHashMap<K,V>  (id=1683)	
							entrySet	ConcurrentHashMap$EntrySet  (id=1685)	
							hashSeed	0	
							keySet	null	
							keySet	null	
							segmentMask	15	
							segments	ConcurrentHashMap$Segment<K,V>[16]  (id=1886)	
								[0]	ConcurrentHashMap$Segment<K,V>  (id=1938)	
									count	0	
									loadFactor	0.75	
									modCount	0	
									sync	ReentrantLock$NonfairSync  (id=1975)	
									table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1976)	
									threshold	1	
								[6]	ConcurrentHashMap$Segment<K,V>  (id=1939)	
									count	1	
									loadFactor	0.75	
									modCount	1	
									sync	ReentrantLock$NonfairSync  (id=1994)	
									table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=2012)	
										[0]	ConcurrentHashMap$HashEntry<K,V>  (id=2030)	
											hash	1652151460	
											key	"Borland" (id=1680)	
											next	null	
											value	Class<T> (org.hibernate.engine.transaction.jta.platform.internal.BorlandEnterpriseServerJtaPlatform) (id=1676)	
									threshold	1	
								[9]	ConcurrentHashMap$Segment<K,V>  (id=1940)	
									count	1	
									loadFactor	0.75	
									modCount	1	
									sync	ReentrantLock$NonfairSync  (id=2065)	
									table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=2083)	
										[1]	ConcurrentHashMap$HashEntry<K,V>  (id=2118)	
											hash	-1739301121	
											key	"org.hibernate.service.jta.platform.internal.BorlandEnterpriseServerJtaPlatform" (id=1691)	
											next	null	
											value	Class<T> (org.hibernate.engine.transaction.jta.platform.internal.BorlandEnterpriseServerJtaPlatform) (id=1676)	
									threshold	1	

/t

		addJtaPlatforms(
				strategySelector,
				BitronixJtaPlatform.class,
				"Bitronix",
				"org.hibernate.service.jta.platform.internal.BitronixJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				JBossAppServerJtaPlatform.class,
				"JBossAS",
				"org.hibernate.service.jta.platform.internal.JBossAppServerJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				JBossStandAloneJtaPlatform.class,
				"JBossTS",
				"org.hibernate.service.jta.platform.internal.JBossStandAloneJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				JOnASJtaPlatform.class,
				"JOnAS",
				"org.hibernate.service.jta.platform.internal.JOnASJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				JOTMJtaPlatform.class,
				"JOTM",
				"org.hibernate.service.jta.platform.internal.JOTMJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				JRun4JtaPlatform.class,
				"JRun4",
				"org.hibernate.service.jta.platform.internal.JRun4JtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				OC4JJtaPlatform.class,
				"OC4J",
				"org.hibernate.service.jta.platform.internal.OC4JJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				OrionJtaPlatform.class,
				"Orion",
				"org.hibernate.service.jta.platform.internal.OrionJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				ResinJtaPlatform.class,
				"Resin",
				"org.hibernate.service.jta.platform.internal.ResinJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				SunOneJtaPlatform.class,
				"SunOne",
				"org.hibernate.service.jta.platform.internal.SunOneJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				WeblogicJtaPlatform.class,
				"Weblogic",
				"org.hibernate.service.jta.platform.internal.WeblogicJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				WebSphereJtaPlatform.class,
				"WebSphere",
				"org.hibernate.service.jta.platform.internal.WebSphereJtaPlatform"
		);

		addJtaPlatforms(
				strategySelector,
				WebSphereExtendedJtaPlatform.class,
				"WebSphereExtended",
				"org.hibernate.service.jta.platform.internal.WebSphereExtendedJtaPlatform"
		);
	}

/ Intermezzo

package org.hibernate.engine.transaction.jta.platform.internal;
public class BitronixJtaPlatform extends AbstractJtaPlatform {

/ Einde Intermezzo
/t
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 167	
		addJtaPlatforms( strategySelector );
/d
		addTransactionFactories( strategySelector );
/s
StrategySelectorBuilder.addTransactionFactories(StrategySelectorImpl) line: 358	

		strategySelector.registerStrategyImplementor( TransactionFactory.class, JdbcTransactionFactory.SHORT_NAME, JdbcTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, "org.hibernate.transaction.JDBCTransactionFactory", JdbcTransactionFactory.class );

		strategySelector.registerStrategyImplementor( TransactionFactory.class, JtaTransactionFactory.SHORT_NAME, JtaTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, "org.hibernate.transaction.JTATransactionFactory", JtaTransactionFactory.class );

		strategySelector.registerStrategyImplementor( TransactionFactory.class, CMTTransactionFactory.SHORT_NAME, CMTTransactionFactory.class );
		strategySelector.registerStrategyImplementor( TransactionFactory.class, "org.hibernate.transaction.CMTTransactionFactory", CMTTransactionFactory.class );

/ Ook weer onder 2 names	, steeds	, 

/t
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 168	
		addTransactionFactories( strategySelector );
/d
		addMultiTableBulkIdStrategies( strategySelector );

/ Lees	,
http://stackoverflow.com/questions/23305356/how-to-disable-temporary-tables-recreation-in-hibernate-4

		strategySelector.registerStrategyImplementor(
				MultiTableBulkIdStrategy.class,
				PersistentTableBulkIdStrategy.SHORT_NAME,
				PersistentTableBulkIdStrategy.class
		);
		strategySelector.registerStrategyImplementor(
				MultiTableBulkIdStrategy.class,
				TemporaryTableBulkIdStrategy.SHORT_NAME,
				TemporaryTableBulkIdStrategy.class
		);
/t
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 169	
		addMultiTableBulkIdStrategies( strategySelector );
/d
		addEntityCopyObserverStrategies( strategySelector );
/s
StrategySelectorBuilder.addEntityCopyObserverStrategies(StrategySelectorImpl) line: 382	
		strategySelector.registerStrategyImplementor(
				EntityCopyObserver.class,
				EntityCopyNotAllowedObserver.SHORT_NAME,
				EntityCopyNotAllowedObserver.class
		);
		strategySelector.registerStrategyImplementor(
				EntityCopyObserver.class,
				EntityCopyAllowedObserver.SHORT_NAME,
				EntityCopyAllowedObserver.class
		);
		strategySelector.registerStrategyImplementor(
				EntityCopyObserver.class,
				EntityCopyAllowedLoggedObserver.SHORT_NAME,
				EntityCopyAllowedLoggedObserver.class
		);
/t
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 172	
		addEntityCopyObserverStrategies( strategySelector );
/d
		// apply auto-discovered registrations
		for ( StrategyRegistrationProvider provider : classLoaderService.loadJavaServices( StrategyRegistrationProvider.class ) ) {
/s
ClassLoaderServiceImpl.loadJavaServices(Class<S>) line: 330	
/=
	public <S> LinkedHashSet<S> loadJavaServices(Class<S> serviceContract) {

serviceContract	Class<T> (org.hibernate.boot.registry.selector.StrategyRegistrationProvider) (id=1515)	

this	ClassLoaderServiceImpl  (id=1558)	
	aggregatedClassLoader	ClassLoaderServiceImpl$AggregatedClassLoader  (id=1572)	
	serviceLoaders	HashMap<K,V>  (id=1573)	
{interface org.hibernate.integrator.spi.Integrator=java.util.ServiceLoader[org.hibernate.integrator.spi.Integrator]}

		if ( serviceLoaders.containsKey( serviceContract ) ) {
/ NEE
		else {
			serviceLoader = ServiceLoader.load( serviceContract, aggregatedClassLoader );
/s
        		return new ServiceLoader<>(service, loader);
/t
			serviceLoaders.put( serviceContract, serviceLoader );

this	ClassLoaderServiceImpl  (id=1558)	
	serviceLoaders	HashMap<K,V>  (id=1573)	
{interface org.hibernate.integrator.spi.Integrator=java.util.ServiceLoader[org.hibernate.integrator.spi.Integrator], 
 interface org.hibernate.boot.registry.selector.StrategyRegistrationProvider=java.util.ServiceLoader[org.hibernate.boot.registry.selector.StrategyRegistrationProvider]}

		final LinkedHashSet<S> services = new LinkedHashSet<S>();
		for ( S service : serviceLoader ) {
			services.add( service );
		}
		return services;
[org.hibernate.cache.ehcache.StrategyRegistrationProviderImpl@70c169b0]

/t
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 173	
		// apply auto-discovered registrations
		for ( StrategyRegistrationProvider provider : classLoaderService.loadJavaServices( StrategyRegistrationProvider.class ) ) {
/d
provider	StrategyRegistrationProviderImpl  (id=2253)	

			for ( StrategyRegistration discoveredStrategyRegistration : provider.getStrategyRegistrations() ) {
/s
StrategyRegistrationProviderImpl.getStrategyRegistrations() line: 44	

		strategyRegistrations.add(
				new SimpleStrategyRegistrationImpl(
						RegionFactory.class,
						EhCacheRegionFactory.class,
						"ehcache",
						EhCacheRegionFactory.class.getName(),
						EhCacheRegionFactory.class.getSimpleName(),
						// legacy impl class name
						"org.hibernate.cache.EhCacheRegionFactory"
				)
		);

		strategyRegistrations.add(
				new SimpleStrategyRegistrationImpl(
						RegionFactory.class,
						SingletonEhCacheRegionFactory.class,
						"ehcache-singleton",
						SingletonEhCacheRegionFactory.class.getName(),
						SingletonEhCacheRegionFactory.class.getSimpleName(),
						// legacy impl class name
						"org.hibernate.cache.SingletonEhCacheRegionFactory"
				)
		);

		return strategyRegistrations;
/t
StrategySelectorBuilder.buildSelector(ClassLoaderService) line: 174	
		// apply auto-discovered registrations
		for ( StrategyRegistrationProvider provider : classLoaderService.loadJavaServices( StrategyRegistrationProvider.class ) ) {
			for ( StrategyRegistration discoveredStrategyRegistration : provider.getStrategyRegistrations() ) {
/d
				applyFromStrategyRegistration( strategySelector, discoveredStrategyRegistration );
/s
StrategySelectorBuilder.applyFromStrategyRegistration(StrategySelectorImpl, StrategyRegistration<T>) line: 195	
		for ( String name : strategyRegistration.getSelectorNames() ) {
			strategySelector.registerStrategyImplementor(
					strategyRegistration.getStrategyRole(),
					name,
					strategyRegistration.getStrategyImplementation()
			);

strategyRegistration.getSelectorNames()=
[ehcache, org.hibernate.cache.ehcache.EhCacheRegionFactory, EhCacheRegionFactory, org.hibernate.cache.EhCacheRegionFactory]

strategyRegistration	SimpleStrategyRegistrationImpl<T>  (id=2283)	
	selectorNames	Arrays$ArrayList<E>  (id=2286)	
[ehcache, org.hibernate.cache.ehcache.EhCacheRegionFactory, EhCacheRegionFactory, org.hibernate.cache.EhCacheRegionFactory]
	strategyImplementation	Class<T> (org.hibernate.cache.ehcache.EhCacheRegionFactory) (id=2280)	
	strategyRole	Class<T> (org.hibernate.cache.spi.RegionFactory) (id=2287)	

/t
		// apply customizations
		for ( StrategyRegistration explicitStrategyRegistration : explicitStrategyRegistrations ) {
[]
		return strategySelector;
/t
BootstrapServiceRegistryBuilder.build() line: 253	
		return new BootstrapServiceRegistryImpl(
				autoCloseRegistry,
				classLoaderService,
				strategySelectorBuilder.buildSelector( classLoaderService ),
				integratorService
		);
/pd
/s
BootstrapServiceRegistryImpl.<init>(boolean, ClassLoaderService, StrategySelector, IntegratorService) line: 184	
/=
	public BootstrapServiceRegistryImpl(
			boolean autoCloseRegistry,
			ClassLoaderService classLoaderService,
			StrategySelector strategySelector,
			IntegratorService integratorService) {

classLoaderService	ClassLoaderServiceImpl  (id=1475)	
	aggregatedClassLoader	ClassLoaderServiceImpl$AggregatedClassLoader  (id=1693)	
	serviceLoaders	HashMap<K,V>  (id=1694)	
		entrySet	HashMap$EntrySet  (id=1710)	
		size	2	
		table	HashMap$Entry<K,V>[16]  (id=1695)	
			[2]	HashMap$Entry<K,V>  (id=1696)	
				key	Class<T> (org.hibernate.boot.registry.selector.StrategyRegistrationProvider) (id=1497)	
				value	ServiceLoader<S>  (id=1698)	
					loader	ClassLoaderServiceImpl$AggregatedClassLoader  (id=1693)	
					lookupIterator	ServiceLoader$LazyIterator  (id=1700)	
					providers	LinkedHashMap<K,V>  (id=1701)	
					service	Class<T> (org.hibernate.boot.registry.selector.StrategyRegistrationProvider) (id=1497)	
			[6]	HashMap$Entry<K,V>  (id=1697)	
				key	Class<T> (org.hibernate.integrator.spi.Integrator) (id=1501)	
				value	ServiceLoader<S>  (id=1699)	
					loader	ClassLoaderServiceImpl$AggregatedClassLoader  (id=1693)	
					lookupIterator	ServiceLoader$LazyIterator  (id=1702)	
					providers	LinkedHashMap<K,V>  (id=1703)	
					service	Class<T> (org.hibernate.integrator.spi.Integrator) (id=1501)	

strategySelector	StrategySelectorImpl  (id=1530)	
	namedStrategyImplementorByStrategyMap	ConcurrentHashMap<K,V>  (id=1532)	
		segments	ConcurrentHashMap$Segment<K,V>[16]  (id=1533)	
			[0]	ConcurrentHashMap$Segment<K,V>  (id=1537)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1548)	
					[1]	ConcurrentHashMap$HashEntry<K,V>  (id=1550)	
						key	Class<T> (org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform) (id=1552)	
						value	ConcurrentHashMap<K,V>  (id=1553)	
			[2]	ConcurrentHashMap$Segment<K,V>  (id=1538)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1556)	
					[0]	ConcurrentHashMap$HashEntry<K,V>  (id=1558)	
						key	Class<T> (org.hibernate.engine.transaction.spi.TransactionFactory) (id=1560)	
						value	ConcurrentHashMap<K,V>  (id=1561)	
			[3]	ConcurrentHashMap$Segment<K,V>  (id=1539)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1564)	
					[0]	ConcurrentHashMap$HashEntry<K,V>  (id=1566)	
						key	Class<T> (org.hibernate.dialect.Dialect) (id=1568)	
						value	ConcurrentHashMap<K,V>  (id=1570)	
			[7]	ConcurrentHashMap$Segment<K,V>  (id=1540)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1594)	
					[0]	ConcurrentHashMap$HashEntry<K,V>  (id=1595)	
						key	Class<T> (org.hibernate.hql.spi.MultiTableBulkIdStrategy) (id=1596)	
						value	ConcurrentHashMap<K,V>  (id=1597)	
			[10]	ConcurrentHashMap$Segment<K,V>  (id=1542)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1599)	
					[0]	ConcurrentHashMap$HashEntry<K,V>  (id=1600)	
						key	Class<T> (org.hibernate.cache.spi.RegionFactory) (id=1601)	
						value	ConcurrentHashMap<K,V>  (id=1602)	
			[13]	ConcurrentHashMap$Segment<K,V>  (id=1543)	
				count	1	
				table	ConcurrentHashMap$HashEntry<K,V>[2]  (id=1604)	
					[1]	ConcurrentHashMap$HashEntry<K,V>  (id=1605)	
						key	Class<T> (org.hibernate.event.spi.EntityCopyObserver) (id=1606)	
						value	ConcurrentHashMap<K,V>  (id=1607)	

this	BootstrapServiceRegistryImpl  (id=1529)	
autoCloseRegistry	true	
classLoaderService	ClassLoaderServiceImpl  (id=1475)	
strategySelector	StrategySelectorImpl  (id=1530)	
integratorService	IntegratorServiceImpl  (id=1479)	
	integrators	LinkedHashSet<E>  (id=1735)	
		map	LinkedHashMap<K,V>  (id=1740)	
			size	3	
			table	HashMap$Entry<K,V>[16]  (id=1758)	
				[1]	LinkedHashMap$Entry<K,V>  (id=1767)	
					key	JaccIntegrator  (id=1778)	
					value	Object  (id=1783)	
				[7]	LinkedHashMap$Entry<K,V>  (id=1768)	
					key	BeanValidationIntegrator  (id=1792)	
					value	Object  (id=1783)	
				[9]	LinkedHashMap$Entry<K,V>  (id=1773)	
					key	CollectionCacheInvalidator  (id=1801)	
					value	Object  (id=1783)	

		this.classLoaderServiceBinding = new ServiceBinding<ClassLoaderService>(
				this,
				ClassLoaderService.class,
				classLoaderService
		);
s/
	public ServiceBinding(ServiceLifecycleOwner lifecycleOwner, Class<R> serviceRole, R service) {
		this.lifecycleOwner = lifecycleOwner;
		this.serviceRole = serviceRole;
		this.serviceInitiator = null;
		this.service = service;


		this.strategySelectorBinding = new ServiceBinding<StrategySelector>(
				this,
				StrategySelector.class,
				strategySelector
		);

		this.integratorServiceBinding = new ServiceBinding<IntegratorService>(
				this,
				IntegratorService.class,
				integratorService
		);

/t
StandardServiceRegistryBuilder.<init>() line: 73	
		this( new BootstrapServiceRegistryBuilder().build() );
/ pd	,
/s
StandardServiceRegistryBuilder.<init>(BootstrapServiceRegistry) line: 82	
		this.settings = Environment.getProperties();
		this.bootstrapServiceRegistry = bootstrapServiceRegistry;
		this.configLoader = new ConfigLoader( bootstrapServiceRegistry );
/t
Main.setUp() line: 84	
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
/pd
/s
StandardServiceRegistryBuilder.applySettings(Map) line: 176	
		this.settings.putAll( settings );
		return this;
/t
/s
StandardServiceRegistryBuilder.build() line: 243	
		applyServiceContributingIntegrators();
/s
StandardServiceRegistryBuilder.applyServiceContributingIntegrators() line: 266	
		for ( Integrator integrator : bootstrapServiceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
			if ( org.hibernate.integrator.spi.ServiceContributingIntegrator.class.isInstance( integrator ) ) {
/ JA	, 
integrator	JaccIntegrator  (id=1778)	
				org.hibernate.integrator.spi.ServiceContributingIntegrator.class.cast( integrator ).prepareServices( this );
/t
StandardServiceRegistryBuilder.build() line: 249	
		applyServiceContributors();
/s
StandardServiceRegistryBuilder.applyServiceContributors() line: 270	
		final LinkedHashSet<ServiceContributor> serviceContributors =
				bootstrapServiceRegistry.getService( ClassLoaderService.class )
						.loadJavaServices( ServiceContributor.class );
/s
BootstrapServiceRegistryImpl.getService(Class<R>) line: 211	
		final ServiceBinding<R> binding = locateServiceBinding( serviceRole );
/s
BootstrapServiceRegistryImpl.locateServiceBinding(Class<R>) line: 217	
/=
	public <R extends Service> ServiceBinding<R> locateServiceBinding(Class<R> serviceRole) {
serviceRole	Class<T> (org.hibernate.boot.registry.classloading.spi.ClassLoaderService) (id=1477)	

		if ( ClassLoaderService.class.equals( serviceRole ) ) {
			return (ServiceBinding<R>) classLoaderServiceBinding;
/t
BootstrapServiceRegistryImpl.getService(Class<R>) line: 210	
		final ServiceBinding<R> binding = locateServiceBinding( serviceRole );
/ pd
binding	ServiceBinding<R>  (id=1840)	
	lifecycleOwner	BootstrapServiceRegistryImpl  (id=1529)	
	service	ClassLoaderServiceImpl  (id=1475)	
	serviceInitiator	null	
	serviceRole	Class<T> (org.hibernate.boot.registry.classloading.spi.ClassLoaderService) (id=1477)	

		return binding == null ? null : binding.getService();
/=
				return service;
service	ClassLoaderServiceImpl  (id=1475)	
/t
StandardServiceRegistryBuilder.applyServiceContributors() line: 270	
		final LinkedHashSet<ServiceContributor> serviceContributors =
				bootstrapServiceRegistry.getService( ClassLoaderService.class )
						.loadJavaServices( ServiceContributor.class );
/pd
/s
ClassLoaderServiceImpl.loadJavaServices(Class<S>) line: 330	
/=
	public <S> LinkedHashSet<S> loadJavaServices(Class<S> serviceContract) {

serviceContract	Class<T> (org.hibernate.service.spi.ServiceContributor) (id=1973)	

this	ClassLoaderServiceImpl  (id=1475)	
	serviceLoaders	HashMap<K,V>  (id=1694)	
		size	3	
		table	HashMap$Entry<K,V>[16]  (id=1695)	
			[2]	HashMap$Entry<K,V>  (id=1696)	
				key	Class<T> (org.hibernate.boot.registry.selector.StrategyRegistrationProvider) (id=1497)	
				value	ServiceLoader<S>  (id=1698)	
			[6]	HashMap$Entry<K,V>  (id=1697)	
				key	Class<T> (org.hibernate.integrator.spi.Integrator) (id=1501)	
				value	ServiceLoader<S>  (id=1699)	
			[9]	HashMap$Entry<K,V>  (id=1975)	
				key	Class<T> (org.hibernate.service.spi.ServiceContributor) (id=1973)	
				value	ServiceLoader<S>  (id=1976)	

		if ( serviceLoaders.containsKey( serviceContract ) ) {
/ JA
			serviceLoader = serviceLoaders.get( serviceContract );
serviceLoader	ServiceLoader<S>  (id=1976)	
	loader	ClassLoaderServiceImpl$AggregatedClassLoader  (id=1693)	
	lookupIterator	ServiceLoader$LazyIterator  (id=2005)	
	providers	LinkedHashMap<K,V>  (id=2006)	
	service	Class<T> (org.hibernate.service.spi.ServiceContributor) (id=1973)	

		for ( S service : serviceLoader ) {
/ GEEN
		return services;
[]
/t
StandardServiceRegistryBuilder.applyServiceContributors() line: 274	
		final LinkedHashSet<ServiceContributor> serviceContributors =
				bootstrapServiceRegistry.getService( ClassLoaderService.class )
						.loadJavaServices( ServiceContributor.class );
/d
		for ( ServiceContributor serviceContributor : serviceContributors ) {
/ GEEN

/ HIER HIER HIER

/t
StandardServiceRegistryBuilder.build() line: 251	
		applyServiceContributors();
/d
		return new StandardServiceRegistryImpl(
				autoCloseRegistry,
				bootstrapServiceRegistry,
				initiators,
				providedServices,
				settingsCopy
		);
this	StandardServiceRegistryBuilder  (id=1468)	
	bootstrapServiceRegistry	BootstrapServiceRegistryImpl  (id=1529)	
		classLoaderServiceBinding	ServiceBinding<R>  (id=1840)	
			lifecycleOwner	BootstrapServiceRegistryImpl  (id=1529)	
			service	ClassLoaderServiceImpl  (id=1475)	
			serviceInitiator	null	
			serviceRole	Class<T> (org.hibernate.boot.registry.classloading.spi.ClassLoaderService) (id=1477)	
		integratorServiceBinding	ServiceBinding<R>  (id=1846)	
			lifecycleOwner	BootstrapServiceRegistryImpl  (id=1529)	
			service	IntegratorServiceImpl  (id=1479)	
			serviceInitiator	null	
			serviceRole	Class<T> (org.hibernate.integrator.spi.IntegratorService) (id=1481)	
		strategySelectorBinding	ServiceBinding<R>  (id=2039)	
			lifecycleOwner	BootstrapServiceRegistryImpl  (id=1529)	
			service	StrategySelectorImpl  (id=1530)	
			serviceInitiator	null	
			serviceRole	Class<T> (org.hibernate.boot.registry.selector.spi.StrategySelector) (id=1517)	
	initiators	ArrayList<E>  (id=1847)	
		elementData	Object[19]  (id=2045)	
			[0]	ConfigurationServiceInitiator  (id=2048)	
			[1]	ImportSqlCommandExtractorInitiator  (id=2049)	
			[2]	JndiServiceInitiator  (id=2050)	
			[3]	JmxServiceInitiator  (id=2051)	
			[4]	PersisterClassResolverInitiator  (id=2052)	
			[5]	PersisterFactoryInitiator  (id=2061)	
			[6]	ConnectionProviderInitiator  (id=2062)	
			[7]	MultiTenantConnectionProviderInitiator  (id=2066)	
			[8]	DialectResolverInitiator  (id=2067)	
			[9]	DialectFactoryInitiator  (id=2071)	
			[10]	BatchBuilderInitiator  (id=2074)	
			[11]	JdbcServicesInitiator  (id=2075)	
			[12]	RefCursorSupportInitiator  (id=2079)	
			[13]	MutableIdentifierGeneratorFactoryInitiator  (id=2082)	
			[14]	JtaPlatformResolverInitiator  (id=2083)	
			[15]	JtaPlatformInitiator  (id=2087)	
			[16]	TransactionFactoryInitiator<T>  (id=2090)	
			[17]	SessionFactoryServiceRegistryFactoryInitiator  (id=2091)	
			[18]	RegionFactoryInitiator  (id=2095)	
		size	19	
	providedServices	ArrayList<E>  (id=1848)	
		elementData	Object[10]  (id=2098)	
			[0]	ProvidedService<R>  (id=2101)	
				service	DisabledJaccServiceImpl  (id=2105)	
				serviceRole	Class<T> (org.hibernate.secure.spi.JaccService) (id=2107)	
			[1]	ProvidedService<R>  (id=2102)	
				service	DisabledJaccServiceImpl  (id=2109)	
				serviceRole	Class<T> (org.hibernate.secure.spi.JaccService) (id=2107)	
		size	2	

/ Intermezzo

public class StandardServiceRegistryBuilder {
	private final List<StandardServiceInitiator> initiators = standardInitiatorList();

	private static List<StandardServiceInitiator> standardInitiatorList() {
		final List<StandardServiceInitiator> initiators = new ArrayList<StandardServiceInitiator>();
		initiators.addAll( StandardServiceInitiators.LIST );
		return initiators;
	}

public final class StandardServiceInitiators {
	private StandardServiceInitiators() {
	}

	public static List<StandardServiceInitiator> LIST = buildStandardServiceInitiatorList();

	private static List<StandardServiceInitiator> buildStandardServiceInitiatorList() {
		final List<StandardServiceInitiator> serviceInitiators = new ArrayList<StandardServiceInitiator>();

		serviceInitiators.add( ConfigurationServiceInitiator.INSTANCE );
		serviceInitiators.add( ImportSqlCommandExtractorInitiator.INSTANCE );

		serviceInitiators.add( JndiServiceInitiator.INSTANCE );
		serviceInitiators.add( JmxServiceInitiator.INSTANCE );

		serviceInitiators.add( PersisterClassResolverInitiator.INSTANCE );
		serviceInitiators.add( PersisterFactoryInitiator.INSTANCE );

		serviceInitiators.add( ConnectionProviderInitiator.INSTANCE );
		serviceInitiators.add( MultiTenantConnectionProviderInitiator.INSTANCE );
		serviceInitiators.add( DialectResolverInitiator.INSTANCE );
		serviceInitiators.add( DialectFactoryInitiator.INSTANCE );
		serviceInitiators.add( BatchBuilderInitiator.INSTANCE );
		serviceInitiators.add( JdbcServicesInitiator.INSTANCE );
		serviceInitiators.add( RefCursorSupportInitiator.INSTANCE );

		serviceInitiators.add( MutableIdentifierGeneratorFactoryInitiator.INSTANCE);

		serviceInitiators.add( JtaPlatformResolverInitiator.INSTANCE );
		serviceInitiators.add( JtaPlatformInitiator.INSTANCE );
		serviceInitiators.add( TransactionFactoryInitiator.INSTANCE );

		serviceInitiators.add( SessionFactoryServiceRegistryFactoryInitiator.INSTANCE );

		serviceInitiators.add( RegionFactoryInitiator.INSTANCE );

		return Collections.unmodifiableList( serviceInitiators );
	}
}

public class DialectFactoryInitiator implements StandardServiceInitiator<DialectFactory> {
	/**
	 * Singleton access
	 */
	public static final DialectFactoryInitiator INSTANCE = new DialectFactoryInitiator();

	@Override
	public Class<DialectFactory> getServiceInitiated() {
		return DialectFactory.class;
	}

	@Override
	public DialectFactory initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
		return new DialectFactoryImpl();
	}
}

/ Einde Intermezzo

/s
StandardServiceRegistryImpl.<init>(boolean, BootstrapServiceRegistry, List<StandardServiceInitiator>, List<ProvidedService>, Map<?,?>) line: 87	
/=
	@SuppressWarnings( {"unchecked"})
	public StandardServiceRegistryImpl(
			boolean autoCloseRegistry,
			BootstrapServiceRegistry bootstrapServiceRegistry,
			List<StandardServiceInitiator> serviceInitiators,
			List<ProvidedService> providedServices,
			Map<?, ?> configurationValues) {

bootstrapServiceRegistry	BootstrapServiceRegistryImpl  (id=1529)	
	classLoaderServiceBinding	ServiceBinding<R>  (id=1840)	
		service	ClassLoaderServiceImpl  (id=1475)	
			serviceLoaders	HashMap<K,V>  (id=1694)	
{interface org.hibernate.boot.registry.selector.StrategyRegistrationProvider=java.util.ServiceLoader[org.hibernate.boot.registry.selector.StrategyRegistrationProvider], interface org.hibernate.integrator.spi.Integrator=java.util.ServiceLoader[org.hibernate.integrator.spi.Integrator], interface org.hibernate.service.spi.ServiceContributor=java.util.ServiceLoader[org.hibernate.service.spi.ServiceContributor]}
	integratorServiceBinding	ServiceBinding<R>  (id=1846)	
	strategySelectorBinding	ServiceBinding<R>  (id=2039)	

serviceInitiators	ArrayList<E>  (id=1847)	
	elementData	Object[19]  (id=2045)	
		[0]	ConfigurationServiceInitiator  (id=2048)	
		[1]	ImportSqlCommandExtractorInitiator  (id=2049)	
		[2]	JndiServiceInitiator  (id=2050)	
		[3]	JmxServiceInitiator  (id=2051)	
		[4]	PersisterClassResolverInitiator  (id=2052)	
		[5]	PersisterFactoryInitiator  (id=2061)	
		[6]	ConnectionProviderInitiator  (id=2062)	
		[7]	MultiTenantConnectionProviderInitiator  (id=2066)	
		[8]	DialectResolverInitiator  (id=2067)	
		[9]	DialectFactoryInitiator  (id=2071)	
		[10]	BatchBuilderInitiator  (id=2074)	
		[11]	JdbcServicesInitiator  (id=2075)	
		[12]	RefCursorSupportInitiator  (id=2079)	
		[13]	MutableIdentifierGeneratorFactoryInitiator  (id=2082)	
		[14]	JtaPlatformResolverInitiator  (id=2083)	
		[15]	JtaPlatformInitiator  (id=2087)	
		[16]	TransactionFactoryInitiator<T>  (id=2090)	
		[17]	SessionFactoryServiceRegistryFactoryInitiator  (id=2091)	
		[18]	RegionFactoryInitiator  (id=2095)	
	size	19	

providedServices	ArrayList<E>  (id=1848)	
	elementData	Object[10]  (id=2098)	
		[0]	ProvidedService<R>  (id=2101)	
			service	DisabledJaccServiceImpl  (id=2105)	
			serviceRole	Class<T> (org.hibernate.secure.spi.JaccService) (id=2107)	
		[1]	ProvidedService<R>  (id=2102)	
			service	DisabledJaccServiceImpl  (id=2109)	
			serviceRole	Class<T> (org.hibernate.secure.spi.JaccService) (id=2107)	
	size	2	

		super( bootstrapServiceRegistry, autoCloseRegistry );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).<init>(BootstrapServiceRegistry, boolean) line: 112	
		this.parent = (ServiceRegistryImplementor) bootstrapServiceRegistry;
		this.allowCrawling = ConfigurationHelper.getBoolean( ALLOW_CRAWLING, Environment.getProperties(), true );
true
		this.autoCloseRegistry = autoCloseRegistry;
		this.parent.registerChild( this );

this	StandardServiceRegistryImpl  (id=1623)	
	parent	BootstrapServiceRegistryImpl  (id=1624)	

/t
StandardServiceRegistryImpl.<init>(boolean, BootstrapServiceRegistry, List<StandardServiceInitiator>, List<ProvidedService>, Map<?,?>) line: 89	
		super( bootstrapServiceRegistry, autoCloseRegistry );
/d
		this.configurationValues = configurationValues;
/=settings

		// process initiators
		for ( ServiceInitiator initiator : serviceInitiators ) {
/ die 18 hierboven	,
			createServiceBinding( initiator );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createServiceBinding(ServiceInitiator<R>) line: 121	
		final ServiceBinding serviceBinding = new ServiceBinding( this, initiator );
/s
ServiceBinding<R>.<init>(ServiceLifecycleOwner, ServiceInitiator<R>) line: 62	
		this.lifecycleOwner = lifecycleOwner;
		this.serviceRole = serviceInitiator.getServiceInitiated();
/s
ConfigurationServiceInitiator.getServiceInitiated() line: 50	
		return ConfigurationService.class;
/t
ServiceBinding<R>.<init>(ServiceLifecycleOwner, ServiceInitiator<R>) line: 63	
		this.serviceRole = serviceInitiator.getServiceInitiated();
/d
		this.serviceInitiator = serviceInitiator;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createServiceBinding(ServiceInitiator<R>) line: 122	
		final ServiceBinding serviceBinding = new ServiceBinding( this, initiator );
/d
		serviceBindingMap.put( initiator.getServiceInitiated(), serviceBinding );
/s
ConfigurationServiceInitiator.getServiceInitiated() line: 50	
		return ConfigurationService.class;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createServiceBinding(ServiceInitiator<R>) line: 122	
		final ServiceBinding serviceBinding = new ServiceBinding( this, initiator );
		serviceBindingMap.put( initiator.getServiceInitiated(), serviceBinding );
/d
/t
StandardServiceRegistryImpl.<init>(boolean, BootstrapServiceRegistry, List<StandardServiceInitiator>, List<ProvidedService>, Map<?,?>) line: 93	
		// process initiators
		for ( ServiceInitiator initiator : serviceInitiators ) {
			createServiceBinding( initiator );
/d
/ volgende	,
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createServiceBinding(ServiceInitiator<R>) line: 121	
		final ServiceBinding serviceBinding = new ServiceBinding( this, initiator );
/s
ServiceBinding<R>.<init>(ServiceLifecycleOwner, ServiceInitiator<R>) line: 62	
		this.lifecycleOwner = lifecycleOwner;
		this.serviceRole = serviceInitiator.getServiceInitiated();
/s
ImportSqlCommandExtractorInitiator.getServiceInitiated() line: 46	
		return ImportSqlCommandExtractor.class;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createServiceBinding(ServiceInitiator<R>) line: 122	
		final ServiceBinding serviceBinding = new ServiceBinding( this, initiator );
		serviceBindingMap.put( initiator.getServiceInitiated(), serviceBinding );
/d
/t
StandardServiceRegistryImpl.<init>(boolean, BootstrapServiceRegistry, List<StandardServiceInitiator>, List<ProvidedService>, Map<?,?>) line: 92	
		// process initiators
		for ( ServiceInitiator initiator : serviceInitiators ) {
			createServiceBinding( initiator );
/d
/ Als allemaal	, 

serviceBindingMap	ConcurrentServiceBinding<K,V>  (id=1628)	
	treeRoot	ConcurrentServiceBinding$Node<K,V>  (id=1674)	
org.hibernate.service.internal.ConcurrentServiceBinding@2f0496f0
<interface org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformResolver, org.hibernate.service.spi.ServiceBinding@c6bc762>
L-> <interface org.hibernate.engine.jdbc.spi.JdbcServices, org.hibernate.service.spi.ServiceBinding@77eef94c>
	L-> <interface org.hibernate.engine.config.spi.ConfigurationService, org.hibernate.service.spi.ServiceBinding@3baec528>
		L-> <interface org.hibernate.service.spi.SessionFactoryServiceRegistryFactory, org.hibernate.service.spi.ServiceBinding@6a312a17>
			L-> <interface org.hibernate.persister.spi.PersisterFactory, org.hibernate.service.spi.ServiceBinding@41c28278>
		R-> <interface org.hibernate.engine.jdbc.batch.spi.BatchBuilder, org.hibernate.service.spi.ServiceBinding@4903b602>
	R-> <interface org.hibernate.engine.jndi.spi.JndiService, org.hibernate.service.spi.ServiceBinding@1d00c794>
		L-> <interface org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider, org.hibernate.service.spi.ServiceBinding@12a262c1>
			L-> <interface org.hibernate.engine.jdbc.cursor.spi.RefCursorSupport, org.hibernate.service.spi.ServiceBinding@63017675>
		R-> <interface org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory, org.hibernate.service.spi.ServiceBinding@75082e1a>
R-> <interface org.hibernate.persister.spi.PersisterClassResolver, org.hibernate.service.spi.ServiceBinding@512327c>
	L-> <interface org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform, org.hibernate.service.spi.ServiceBinding@6c0ae8fc>
		L-> <interface org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractor, org.hibernate.service.spi.ServiceBinding@75bbd333>
			L-> <interface org.hibernate.cache.spi.RegionFactory, org.hibernate.service.spi.ServiceBinding@40462fce>
		R-> <interface org.hibernate.jmx.spi.JmxService, org.hibernate.service.spi.ServiceBinding@547fcdfc>
	R-> <interface org.hibernate.engine.transaction.spi.TransactionFactory, org.hibernate.service.spi.ServiceBinding@3fec9e59>
		L-> <interface org.hibernate.engine.jdbc.dialect.spi.DialectResolver, org.hibernate.service.spi.ServiceBinding@479005d8>
			L-> <interface org.hibernate.engine.jdbc.connections.spi.ConnectionProvider, org.hibernate.service.spi.ServiceBinding@406fcc9c>
		R-> <interface org.hibernate.engine.jdbc.dialect.spi.DialectFactory, org.hibernate.service.spi.ServiceBinding@6be236d0>

		// then, explicitly provided service instances
		for ( ProvidedService providedService : providedServices ) {
			createServiceBinding( providedService );

providedService	ProvidedService<R>  (id=1688)	
	service	DisabledJaccServiceImpl  (id=1701)	
	serviceRole	Class<T> (org.hibernate.secure.spi.JaccService) (id=1548)	

/t
Main.setUp() line: 85	
    		serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
/d
    		sessionFactory=configuration.buildSessionFactory(serviceRegistry);
/s
	/**
	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
	 * {@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} after
	 * building the {@link SessionFactory} will not affect it.
	 *
	 * @param serviceRegistry The registry of services to be used in creating this session factory.
	 *
	 * @return The built {@link SessionFactory}

Configuration.buildSessionFactory(ServiceRegistry) line: 1841	
		buildTypeRegistrations( serviceRegistry );
/s
Configuration.buildTypeRegistrations(ServiceRegistry) line: 1867	
		final TypeContributions typeContributions = new TypeContributions() {
			...
		// add Dialect contributed types
		final Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();

/ JdbcServices is 1 van de Services hierboven	, 

/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 199	
		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).locateServiceBinding(Class<R>) line: 143	
		return locateServiceBinding( serviceRole, true );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).locateServiceBinding(Class<R>, boolean) line: 148	
		ServiceBinding<R> serviceBinding = serviceBindingMap.get( serviceRole );

serviceBinding	ServiceBinding<R>  (id=1733)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=1623)	
	service	null	
	serviceInitiator	JdbcServicesInitiator  (id=1735)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=1729)	

			return serviceBinding;
/t
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 204	
		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
/d
		R service = serviceBinding.getService();
null
		if ( service == null ) {
			service = initializeService( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 220	
		// PHASE 1 : create service
		R service = createService( serviceBinding );

serviceBinding	ServiceBinding<R>  (id=1733)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=1623)	
	service	null	
	serviceInitiator	JdbcServicesInitiator  (id=1735)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=1729)	
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 244	
		final ServiceInitiator<R> serviceInitiator = serviceBinding.getServiceInitiator();
serviceInitiator	JdbcServicesInitiator  (id=1735)	

			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/s
StandardServiceRegistryImpl.initiateService(ServiceInitiator<R>) line: 105	
		return ( (StandardServiceInitiator<R>) serviceInitiator ).initiateService( configurationValues, this );
/s
JdbcServicesInitiator.initiateService(Map, ServiceRegistryImplementor) line: 52	
/=
public class JdbcServicesInitiator implements StandardServiceInitiator<JdbcServices> {
	@Override
	public JdbcServices initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
		return new JdbcServicesImpl();
/s
JdbcServicesImpl.<init>() line: 369	
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 254	
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/d
			// IMPL NOTE : the register call here is important to avoid potential stack overflow issues
			//		from recursive calls through #configureService
			registerService( serviceBinding, service );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).registerService(ServiceBinding<R>, R) line: 213	
		serviceBinding.setService( service );

serviceBinding	ServiceBinding<R>  (id=1733)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=1623)	
	service	JdbcServicesImpl  (id=1827)	
	serviceInitiator	JdbcServicesInitiator  (id=1735)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=1729)	

		synchronized ( serviceBindingList ) {
			serviceBindingList.add( serviceBinding );

this	StandardServiceRegistryImpl  (id=1623)	
	serviceBindingList	ArrayList<E>  (id=1627)	
		elementData	Object[20]  (id=1856)	
			[0]	ServiceBinding<R>  (id=1858)	
				lifecycleOwner	StandardServiceRegistryImpl  (id=1623)	
				service	DisabledJaccServiceImpl  (id=1701)	
				serviceInitiator	null	
				serviceRole	Class<T> (org.hibernate.secure.spi.JaccService) (id=1548)	
			[1]	ServiceBinding<R>  (id=1733)	
				lifecycleOwner	StandardServiceRegistryImpl  (id=1623)	
				service	JdbcServicesImpl  (id=1827)	
				serviceInitiator	JdbcServicesInitiator  (id=1735)	
				serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=1729)	
		size	2	

/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 226	
		// PHASE 1 : create service
		R service = createService( serviceBinding );
/d
serviceBinding	ServiceBinding<R>  (id=1733)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=1623)	
	service	JdbcServicesImpl  (id=1827)	
	serviceInitiator	JdbcServicesInitiator  (id=1735)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=1729)	
service	JdbcServicesImpl  (id=1827)	
	connectionProvider	null	
	dialect	null	
	extractedMetaDataSupport	null	
	lobCreatorBuilder	null	
	serviceRegistry	null	
	sqlExceptionHelper	null	
	sqlStatementLogger	null	

		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).injectDependencies(ServiceBinding<R>) line: 267	
		final R service = serviceBinding.getService();
service	JdbcServicesImpl  (id=1827)	
	connectionProvider	null	
	dialect	null	
	extractedMetaDataSupport	null	
	lobCreatorBuilder	null	
	serviceRegistry	null	
	sqlExceptionHelper	null	
	sqlStatementLogger	null	

		applyInjections( service );
/NIETS
/ want, 
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).applyInjections(R) line: 289	
			for ( Method method : service.getClass().getMethods() ) {
18 Methods
				InjectService injectService = method.getAnnotation( InjectService.class );
				if ( injectService == null ) {
/ JA
					continue;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).injectDependencies(ServiceBinding<R>) line: 271	
		applyInjections( service );
/d
		if ( ServiceRegistryAwareService.class.isInstance( service ) ) {
			( (ServiceRegistryAwareService) service ).injectServices( this );
/s
JdbcServicesImpl.injectServices(ServiceRegistryImplementor) line: 89	
		this.serviceRegistry = serviceRegistry;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 234	
		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );
/d
		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/s
StandardServiceRegistryImpl.configureService(ServiceBinding<R>) line: 110	
		if ( Configurable.class.isInstance( serviceBinding.getService() ) ) {
			( (Configurable) serviceBinding.getService() ).configure( configurationValues );
/s
JdbcServicesImpl.configure(Map) line: 94	
		final JdbcConnectionAccess jdbcConnectionAccess = buildJdbcConnectionAccess( configValues );
/s
JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 257	
		final MultiTenancyStrategy multiTenancyStrategy = MultiTenancyStrategy.determineMultiTenancyStrategy( configValues );
/s
MultiTenancyStrategy.determineMultiTenancyStrategy(Map) line: 80	
		final Object strategy = properties.get( Environment.MULTI_TENANT );
null
		if ( strategy == null ) {
			return MultiTenancyStrategy.NONE;
/t
JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 260	
		final MultiTenancyStrategy multiTenancyStrategy = MultiTenancyStrategy.determineMultiTenancyStrategy( configValues );
/d
		if ( MultiTenancyStrategy.NONE == multiTenancyStrategy ) {
			connectionProvider = serviceRegistry.getService( ConnectionProvider.class );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 199	
		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
serviceRole=interface org.hibernate.engine.jdbc.connections.spi.ConnectionProvider
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).locateServiceBinding(Class<R>, boolean) line: 148	
		ServiceBinding<R> serviceBinding = serviceBindingMap.get( serviceRole );
/ serviceBindingMap.treeRoot=...

serviceBinding	ServiceBinding<R>  (id=99)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
	service	null	
	serviceInitiator	ConnectionProviderInitiator  (id=101)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.connections.spi.ConnectionProvider) (id=78)	

			return serviceBinding;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 204	
		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
/d
		R service = serviceBinding.getService();
null
		if ( service == null ) {
			service = initializeService( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 225	
		// PHASE 1 : create service
		R service = createService( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 244	

		final ServiceInitiator<R> serviceInitiator = serviceBinding.getServiceInitiator();
serviceInitiator	ConnectionProviderInitiator  (id=101)	

			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/s
StandardServiceRegistryImpl.initiateService(ServiceInitiator<R>) line: 105	
		return ( (StandardServiceInitiator<R>) serviceInitiator ).initiateService( configurationValues, this );
/s
ConnectionProviderInitiator.initiateService(Map, ServiceRegistryImplementor) line: 109	
		final MultiTenancyStrategy strategy = MultiTenancyStrategy.determineMultiTenancyStrategy(  configurationValues );
NONE
		final StrategySelector strategySelector = registry.getService( StrategySelector.class );

/ Intermezzo

/ we zitten nu in de 3de .getService	, 

my.test.own.objects.Main at localhost:47651	
	Thread [main] (Suspended)	
		StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 200	
serviceRole	Class<T> (org.hibernate.boot.registry.selector.spi.StrategySelector) (id=1000)	

		ConnectionProviderInitiator.initiateService(Map, ServiceRegistryImplementor) line: 115	
		ConnectionProviderInitiator.initiateService(Map, ServiceRegistryImplementor) line: 55	
		StandardServiceRegistryImpl.initiateService(ServiceInitiator<R>) line: 105	
		StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 251	
serviceRole	Class<T> (org.hibernate.engine.jdbc.connections.spi.ConnectionProvider) (id=1603)	

		StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 225	
		StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 206	
/=
	public <R extends Service> R getService(Class<R> serviceRole) {
serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=31)	

		JdbcServicesImpl.buildJdbcConnectionAccess(Map) line: 260	
		JdbcServicesImpl.configure(Map) line: 94	
		StandardServiceRegistryImpl.configureService(ServiceBinding<R>) line: 111	
		StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 234	
		StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 206	
		Configuration.buildTypeRegistrations(ServiceRegistry) line: 1885	
		Configuration.buildSessionFactory(ServiceRegistry) line: 1843	
		Main.setUp() line: 85	
		Main.<init>() line: 72	
		Main.main(String[]) line: 67	

/ Einde Intermezzo

/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 199	

		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
serviceRole=interface org.hibernate.boot.registry.selector.spi.StrategySelector
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).locateServiceBinding(Class<R>, boolean) line: 148	
		ServiceBinding<R> serviceBinding = serviceBindingMap.get( serviceRole );
null
serviceBindingMap.treeRoot=...

		if ( serviceBinding == null && checkParent && parent != null ) {
			// look in parent
			serviceBinding = parent.locateServiceBinding( serviceRole );
/s
BootstrapServiceRegistryImpl.locateServiceBinding(Class<R>) line: 217	
/=
	public <R extends Service> ServiceBinding<R> locateServiceBinding(Class<R> serviceRole) {
serviceRole=interface org.hibernate.boot.registry.selector.spi.StrategySelector

		else if ( StrategySelector.class.equals( serviceRole) ) {
			return (ServiceBinding<R>) strategySelectorBinding;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).getService(Class<R>) line: 204	
		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
/d
serviceBinding	ServiceBinding<R>  (id=188)	
	lifecycleOwner	BootstrapServiceRegistryImpl  (id=87)	
	service	StrategySelectorImpl  (id=190)	
	serviceInitiator	null	
	serviceRole	Class<T> (org.hibernate.boot.registry.selector.spi.StrategySelector) (id=157)	

/ Nu is serviceInitiator==null	, en de service is er al	,

		return service;
/t
ConnectionProviderInitiator.initiateService(Map, ServiceRegistryImplementor) line: 118	
		final StrategySelector strategySelector = registry.getService( StrategySelector.class );
/d
		final String providerName = getConfiguredConnectionProviderName( configurationValues );
/s
ConnectionProviderInitiator.getConfiguredConnectionProviderName(Map) line: 177	
		String providerName = (String) configurationValues.get( Environment.CONNECTION_PROVIDER );
Environment.CONNECTION_PROVIDER="hibernate.connection.provider_class"
null
		if ( LEGACY_CONNECTION_PROVIDER_MAPPING.containsKey( providerName ) ) {
LEGACY_CONNECTION_PROVIDER_MAPPING={
	org.hibernate.connection.DriverManagerConnectionProvider=org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl, 
	org.hibernate.connection.UserSuppliedConnectionProvider=org.hibernate.engine.jdbc.connections.internal.UserSuppliedConnectionProviderImpl, 
	org.hibernate.connection.DatasourceConnectionProvider=org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl}
/ NEE
/ want providerName==null	,
		return providerName;
null

/ Straks wordt er toch new DriverManagerConnectionProviderImpl()	, 

/ Intermezzo

interface AvailableSettings
	String CONNECTION_PROVIDER ="hibernate.connection.provider_class";

public class ConnectionProviderInitiator implements StandardServiceInitiator<ConnectionProvider> {
	static {
		LEGACY_CONNECTION_PROVIDER_MAPPING = new HashMap<String,String>( 5 );

		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
				"org.hibernate.connection.DatasourceConnectionProvider",
				DatasourceConnectionProviderImpl.class.getName()
		);
		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
				"org.hibernate.connection.DriverManagerConnectionProvider",
				DriverManagerConnectionProviderImpl.class.getName()
		);
		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
				"org.hibernate.connection.UserSuppliedConnectionProvider",
				UserSuppliedConnectionProviderImpl.class.getName()
		);
	}

/t
ConnectionProviderInitiator.initiateService(Map, ServiceRegistryImplementor) line: 122	
		final String providerName = getConfiguredConnectionProviderName( configurationValues );
/d
null
		else if ( configurationValues.get( Environment.DATASOURCE ) != null ) {
Environment.DATASOURCE=hibernate.connection.datasource
/ NEE
		if ( connectionProvider == null ) {
			if ( c3p0ConfigDefined( configurationValues ) ) {
/ NEE
		if ( connectionProvider == null ) {
			if ( proxoolConfigDefined( configurationValues ) ) {
/ NEE
		if ( connectionProvider == null ) {
			if ( configurationValues.get( Environment.URL ) != null ) {
Environment.URL=hibernate.connection.url
/ JA
				connectionProvider = new DriverManagerConnectionProviderImpl();
connectionProvider	DriverManagerConnectionProviderImpl  (id=252)	
	active	true	
	connectionCreator	null	
	connections	ConcurrentLinkedQueue<E>  (id=262)	
[]
	executorService	null	
	serviceRegistry	null	

/ Intermezzo

interface AvailableSettings
	String URL ="hibernate.connection.url";

$ vi hibernate.cfg.xml
<hibernate-configuration>
 <session-factory>
 	<property name="connection.url">jdbc:postgresql://localhost/foo</property>

/ Einde Intermezzo

		final Map injectionData = (Map) configurationValues.get( INJECTION_DATA );
		if ( injectionData != null && injectionData.size() > 0 ) {
/ NEE

/ Intermezzo

public class ConnectionProviderInitiator implements StandardServiceInitiator<ConnectionProvider> {
	public static final String INJECTION_DATA = "hibernate.connection_provider.injection_data";

/ Einde Intermezzo

		return connectionProvider;
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).createService(ServiceBinding<R>) line: 254	
			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
/d
service	DriverManagerConnectionProviderImpl  (id=252)	
serviceInitiator=org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator@42704d54

			registerService( serviceBinding, service );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).registerService(ServiceBinding<R>, R) line: 215	
		serviceBinding.setService( service );

serviceBinding	ServiceBinding<R>  (id=99)	
	lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
	service	DriverManagerConnectionProviderImpl  (id=252)	
	serviceInitiator	ConnectionProviderInitiator  (id=101)	
	serviceRole	Class<T> (org.hibernate.engine.jdbc.connections.spi.ConnectionProvider) (id=78)	

		synchronized ( serviceBindingList ) {
			serviceBindingList.add( serviceBinding );

this	StandardServiceRegistryImpl  (id=19)	
	serviceBindingList	ArrayList<E>  (id=61)	
		elementData	Object[20]  (id=310)	
			[0]	ServiceBinding<R>  (id=313)	
				lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
				service	DisabledJaccServiceImpl  (id=315)	
				serviceInitiator	null	
				serviceRole	Class<T> (org.hibernate.secure.spi.JaccService) (id=317)	
			[1]	ServiceBinding<R>  (id=35)	
				lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
				service	JdbcServicesImpl  (id=52)	
					connectionProvider	null	
					dialect	null	
					extractedMetaDataSupport	null	
					lobCreatorBuilder	null	
					serviceRegistry	StandardServiceRegistryImpl  (id=19)	
					sqlExceptionHelper	null	
					sqlStatementLogger	null	
				serviceInitiator	JdbcServicesInitiator  (id=37)	
				serviceRole	Class<T> (org.hibernate.engine.jdbc.spi.JdbcServices) (id=21)	
			[2]	ServiceBinding<R>  (id=99)	
				lifecycleOwner	StandardServiceRegistryImpl  (id=19)	
				service	DriverManagerConnectionProviderImpl  (id=252)	
					active	true	
					connectionCreator	null	
					connections	ConcurrentLinkedQueue<E>  (id=262)	
					executorService	null	
					serviceRegistry	null	
				serviceInitiator	ConnectionProviderInitiator  (id=101)	
				serviceRole	Class<T> (org.hibernate.engine.jdbc.connections.spi.ConnectionProvider) (id=78)	
		size	3	

/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 226	
		// PHASE 1 : create service
		R service = createService( serviceBinding );
/d
service	DriverManagerConnectionProviderImpl  (id=252)	

		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );
/s
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).injectDependencies(ServiceBinding<R>) line: 271	
		final R service = serviceBinding.getService();
service	DriverManagerConnectionProviderImpl  (id=2028)	
	active	true	
	connectionCreator	null	
	connections	ConcurrentLinkedQueue<E>  (id=2029)	
	executorService	null	
	serviceRegistry	null	

		applyInjections( service );
/ NIETS
		if ( ServiceRegistryAwareService.class.isInstance( service ) ) {
			( (ServiceRegistryAwareService) service ).injectServices( this );
/t
StandardServiceRegistryImpl(AbstractServiceRegistryImpl).initializeService(ServiceBinding<R>) line: 234	
		// PHASE 2 : inject service (***potentially recursive***)
		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );
/d
service	DriverManagerConnectionProviderImpl  (id=2028)	
	active	true	
	connectionCreator	null	
	connections	ConcurrentLinkedQueue<E>  (id=2029)	
	executorService	null	
	serviceRegistry	StandardServiceRegistryImpl  (id=19)		<-

		// PHASE 3 : configure service
		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
/s
StandardServiceRegistryImpl.configureService(ServiceBinding<R>) line: 111	
		if ( Configurable.class.isInstance( serviceBinding.getService() ) ) {
			( (Configurable) serviceBinding.getService() ).configure( configurationValues );
/s
DriverManagerConnectionProviderImpl.configure(Map) line: 93	
		connectionCreator = buildCreator( configurationValues );
/s
DriverManagerConnectionProviderImpl.buildCreator(Map) line: 153	
		final ConnectionCreatorBuilder connectionCreatorBuilder = new ConnectionCreatorBuilder( serviceRegistry );
		final String driverClassName = (String) configurationValues.get( AvailableSettings.DRIVER );
AvailableSettings.DRIVER ="hibernate.connection.driver_class";
driverClassName	"org.postgresql.Driver" (id=2058)	

		connectionCreatorBuilder.setDriver( loadDriverIfPossible( driverClassName ) );
/s
DriverManagerConnectionProviderImpl.loadDriverIfPossible(String) line: 199	
			final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
			final Class<Driver> driverClass = classLoaderService.classForName( driverClassName );
driverClass	Class<T> (org.postgresql.Driver) (id=2064)	
				return driverClass.newInstance();
/t
DriverManagerConnectionProviderImpl.buildCreator(Map) line: 158	
		connectionCreatorBuilder.setDriver( loadDriverIfPossible( driverClassName ) );
/d
connectionCreatorBuilder	ConnectionCreatorBuilder  (id=2054)	
	autoCommit	false	
	connectionProps	null	
	driver	Driver  (id=2074)	
	isolation	null	
	serviceRegistry	StandardServiceRegistryImpl  (id=19)	
	url	null	

		final String url = (String) configurationValues.get( AvailableSettings.URL );
AvailableSettings.URL=hibernate.connection.url
url=jdbc:postgresql://localhost/foo
		connectionCreatorBuilder.setUrl( url );

		final Properties connectionProps = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
/s
ConnectionProviderInitiator.getConnectionProperties(Map<?,?>) line: 252	
		for ( Map.Entry entry : properties.entrySet() ) {
			final String key = (String) entry.getKey();
			final String value = (String) entry.getValue();
			if ( key.startsWith( Environment.CONNECTION_PREFIX ) ) {		/ alle betreffende hibernate.connection	, 
hibernate.connection.url
hibernate.connection.driver_class
hibernate.connection.password
hibernate.connection.username
				if ( SPECIAL_PROPERTIES.contains( key ) ) {
					if ( Environment.USER.equals( key ) ) {					/ alleen hibernate.connection.user	,
						result.setProperty( "user", value );
					}
				}
				else {
					result.setProperty(										/ hibernate.connection.password	,
							key.substring( Environment.CONNECTION_PREFIX.length() + 1 ),
							value
		return result;
/t

/ Intermezzo

public class ConnectionProviderInitiator implements StandardServiceInitiator<ConnectionProvider> {

	private static final Set<String> SPECIAL_PROPERTIES;

	static {
		SPECIAL_PROPERTIES = new HashSet<String>();
		SPECIAL_PROPERTIES.add( Environment.DATASOURCE );
hibernate.connection.datasource
		SPECIAL_PROPERTIES.add( Environment.URL );
hibernate.connection.url
		SPECIAL_PROPERTIES.add( Environment.CONNECTION_PROVIDER );
hibernate.connection.provider_class
		SPECIAL_PROPERTIES.add( Environment.POOL_SIZE );
hibernate.connection.pool_size
		SPECIAL_PROPERTIES.add( Environment.ISOLATION );
hibernate.connection.isolation
		SPECIAL_PROPERTIES.add( Environment.DRIVER );
hibernate.connection.driver_class
		SPECIAL_PROPERTIES.add( Environment.USER );
hibernate.connection.username

	}

/ Einde Intermezzo

/t
DriverManagerConnectionProviderImpl.buildCreator(Map) line: 171	
		final Properties connectionProps = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
/d
{user=foo, password=foo}

		connectionCreatorBuilder.setConnectionProps( connectionProps );
		final boolean autoCommit = ConfigurationHelper.getBoolean( AvailableSettings.AUTOCOMMIT, configurationValues, false );
false
/ "hibernate.connection.autocommit" kun je geven in hibernate.cfg.xml

		final Integer isolation = ConfigurationHelper.getInteger( AvailableSettings.ISOLATION, configurationValues );
/ "hibernate.connection.isolation" kun je geven in hibernate.cfg.xml
null

connectionCreatorBuilder	ConnectionCreatorBuilder  (id=2054)	
	autoCommit	false	
	connectionProps	Properties  (id=2096)	
	driver	Driver  (id=2074)	
	isolation	null	
	serviceRegistry	StandardServiceRegistryImpl  (id=19)	
	url	"jdbc:postgresql://localhost/foo" (id=2090)	

		connectionCreatorBuilder.setIsolation( isolation );
		return connectionCreatorBuilder.build();
/s
			return new DriverConnectionCreator( driver, serviceRegistry, url, connectionProps, autoCommit, isolation );
/s
DriverConnectionCreator.<init>(Driver, ServiceRegistryImplementor, String, Properties, Boolean, Integer) line: 48	
		super( serviceRegistry, url, connectionProps, autocommit, isolation );
/ sets these properties	,
		this.driver = driver;
/t
DriverManagerConnectionProviderImpl.configure(Map) line: 97	
		connectionCreator = buildCreator( configurationValues );
/d
this	DriverManagerConnectionProviderImpl  (id=2028)	
	connectionCreator	DriverConnectionCreator  (id=2182)	
		autoCommit	false	
		connectionProps	Properties  (id=2096)	
		driver	Driver  (id=2074)	
		isolation	null	
		serviceRegistry	StandardServiceRegistryImpl  (id=19)	
		simpleConverterAccess	ValueHolder<T>  (id=2187)	
		url	"jdbc:postgresql://localhost/foo" (id=2090)	

		final int minSize = ConfigurationHelper.getInt( MIN_SIZE, configurationValues, 1 );
1
		final int maxSize = ConfigurationHelper.getInt( AvailableSettings.POOL_SIZE, configurationValues, 20 );
20
		final int initialSize = ConfigurationHelper.getInt( INITIAL_SIZE, configurationValues, minSize );
1
		final long validationInterval = ConfigurationHelper.getLong( VALIDATION_INTERVAL, configurationValues, 30 );
30
		for ( int i = 0; i < initialSize; i++ ) {
			connections.add( connectionCreator.createConnection() );
/s
DriverConnectionCreator(BasicConnectionCreator).createConnection() line: 75	
		final Connection conn = makeConnection( url, connectionProps );
/s
DriverConnectionCreator.makeConnection(String, Properties) line: 55	
			return driver.connect( url, connectionProps );

/ MORGENOCHTEND WH RM
/s
Driver.connect(String, Properties) line: 232	
/=
    public java.sql.Connection connect(String url, Properties info) throws SQLException
url	"jdbc:postgresql://localhost/foo" (id=1664)	
info={user=foo, password=foo}
/s
            defaults = getDefaultProperties();
/s
Driver.getDefaultProperties() line: 86	

        // Make sure we load properties with the maximum possible
        // privileges.
       try
        {
            defaultProperties = (Properties)
                AccessController.doPrivileged(new PrivilegedExceptionAction() {
/ TODO
                        public Object run() throws IOException {
                            return loadDefaultProperties();
/s
Driver.loadDefaultProperties() line: 122	
       Properties merged = new Properties();
            merged.setProperty("user", System.getProperty("user.name"));
{user=eric}
        // When loading the driver config files we don't want settings found
        // in later files in the classpath to override settings specified in
        // earlier files.  To do this we've got to read the returned
        // Enumeration into temporary storage.
        ArrayList urls = new ArrayList();
        Enumeration urlEnum = cl.getResources("org/postgresql/driverconfig.properties");
/ GEEN	,
/ TODO
        return merged;
...
/t
Driver.connect(String, Properties) line: 246	
            defaults = getDefaultProperties();
{user=eric}
       	Properties props = new Properties(defaults);
        if (info != null)
info={user=foo, password=foo}
           for (Enumeration e = info.propertyNames(); e.hasMoreElements(); )
            {
                String propName = (String)e.nextElement();
                String propValue = info.getProperty(propName);
                props.setProperty( propName,propValue );
			}
props={user=foo, password=foo}
        // parse URL and add more properties
        if ((props = parseURL(url, props)) == null)
url	"jdbc:postgresql://localhost/foo" (id=1664)	
props={user=foo, password=foo}
        l_urlServer = l_urlServer.substring("jdbc:postgresql:".length());
//localhost/foo
       if (l_urlServer.startsWith("//")) {
localhost/foo
            l_urlServer = l_urlServer.substring(2);
9
            urlProps.setProperty("PGDBNAME", l_urlServer.substring(slash + 1));
{PGDBNAME=foo}
               } else {
                    ports.append("5432");
                    hosts.append(address);
            urlProps.setProperty("PGPORT", ports.toString());
            urlProps.setProperty("PGHOST", hosts.toString());
        return urlProps;
{PGDBNAME=foo, PGPORT=5432, PGHOST=localhost}
/t
Driver.connect(String, Properties) line: 268	
        if ((props = parseURL(url, props)) == null)
/d
           long timeout = timeout(props);
0
            if (timeout <= 0)
                return makeConnection(url, props);
/s
Driver.makeConnection(String, Properties) line: 410	
        return new org.postgresql.jdbc4.Jdbc4Connection(hostSpecs(props),
                                      user(props), database(props),
                                      props, url);

/ Intermezzo

/ we zijn in 	,
...
/s
	DriverManagerConnectionProviderImpl.configure(Map) line: 106	
...
/s
	JdbcServicesImpl.configure(Map) line: 94	
...

/ Einde Intermezzo


/s
Jdbc4Connection.<init>(HostSpec[], String, String, Properties, String) line: 24	
/=
    public Jdbc4Connection(HostSpec[] hostSpecs, String user, String database, Properties info, String url) throws SQLException {
hostSpecs	HostSpec[1]  (id=1607)	
	[0]	HostSpec  (id=1617)	
		host	"localhost" (id=1620)	
		port	5432	
user	"foo" (id=1588)	
database	"foo" (id=1614)	
info	Properties  (id=1591)	
{PGDBNAME=foo, PGPORT=5432, PGHOST=localhost}
url	"jdbc:postgresql://localhost/foo" (id=1576)	

        super(hostSpecs, user, database, info, url);
/s
Jdbc4Connection(AbstractJdbc4Connection).<init>(HostSpec[], String, String, Properties, String) line: 31	
        super(hostSpecs, user, database, info, url);
/s
Jdbc4Connection(AbstractJdbc3Connection).<init>(HostSpec[], String, String, Properties, String) line: 29	
        super(hostSpec, user, database, info, url);
/s
Jdbc4Connection(AbstractJdbc2Connection).<init>(HostSpec[], String, String, Properties, String) line: 92	

    //
    // Driver-wide connection ID counter, used for logging
    //
    private static int nextConnectionID = 1;

    // Per-connection logger
    private final Logger logger;

    /* URL we were created via */
    private final String creatingURL;

    // Connection's autocommit state.
    public boolean autoCommit = true;

    // Connection's readonly state.
    public boolean readOnly = false;

        this.creatingURL = url;
jdbc:postgresql://localhost/foo

        int logLevel = Driver.getLogLevel();
0
        String connectionLogLevel = info.getProperty("loglevel");
null
        if (connectionLogLevel != null) {
            try {
                logLevel = Integer.parseInt(connectionLogLevel);
/ NIET
/ TODO
        synchronized (AbstractJdbc2Connection.class) {
            logger = new Logger(nextConnectionID++);
            logger.setLogLevel(logLevel);
0
        if (logLevel > 0)
/ NEE
            enableDriverManagerLogging();
/ NIET
/ TODO

        prepareThreshold = 5;
        try
        {
            prepareThreshold = Integer.parseInt(info.getProperty("prepareThreshold", "5"));
5

        boolean binaryTransfer = true;
        try
        {
            binaryTransfer = Boolean.valueOf(info.getProperty("binaryTransfer", "true")).booleanValue();
true


        //Print out the driver version number
        if (logger.logInfo())
            logger.info(Driver.getVersion());

        // Now make the initial connection and set up local state
        this.protoConnection = ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
/s
ConnectionFactory.openConnection(HostSpec[], String, String, Properties, Logger) line: 55	
        String protoName = info.getProperty("protocolVersion");
null

class ConnectionFactory
   private static final Object[][] versions = {
                { "3", new org.postgresql.core.v3.ConnectionFactoryImpl() },
                { "2", new org.postgresql.core.v2.ConnectionFactoryImpl() },
            };

        for (int i = 0; i < versions.length; ++i)
        {
            String versionProtoName = (String) versions[i][0];
3
            ConnectionFactory factory = (ConnectionFactory) versions[i][1];
/s
package org.postgresql.core.v3;
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 54	
        String sslmode = info.getProperty("sslmode");
null
        if (sslmode==null)
        { //Fall back to the ssl property
          requireSSL = trySSL  = (info.getProperty("ssl") != null);
false

        //  - the TCP keep alive setting
        boolean requireTCPKeepAlive = (Boolean.valueOf(info.getProperty("tcpKeepAlive")).booleanValue());
false
        for (int whichHost = 0; whichHost < hostSpecs.length; ++whichHost) {
            HostSpec hostSpec = hostSpecs[whichHost];
hostSpec	HostSpec  (id=1617)	
	host	"localhost" (id=1620)	
	port	5432	

        int connectTimeout = 0;
        String connectTimeoutProperty = info.getProperty("connectTimeout", "0");
"0"
        try {
            connectTimeout = Integer.parseInt(connectTimeoutProperty) * 1000;
0
        PGStream newStream = null;
        try
        {
            newStream = new PGStream(hostSpec, connectTimeout);
/s
PGStream.<init>(HostSpec, int) line: 57	
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort()), timeout);

socket	Socket  (id=1715)	
	factory	null	
	bound	true	
	closed	false	
	closeLock	Object  (id=1718)	
	connected	true	
	created	true	
	impl	SocksSocketImpl  (id=1719)	
		address	Inet4Address  (id=1727)	
		applicationSetProxy	false	
		closePending	false	
		cmdIn	null	
		cmdOut	null	
		cmdsock	null	
		CONNECTION_NOT_RESET	0	
		CONNECTION_RESET	2	
		CONNECTION_RESET_PENDING	1	
		external_address	null	
		fd	FileDescriptor  (id=1749)	
		fdLock	Object  (id=1751)	
		fdUseCount	0	
		localport	42520	
		port	5432	
		resetLock	Object  (id=1754)	
		resetState	0	
		server	null	
		serverPort	1080	
		serverSocket	null	
		shut_rd	false	
		shut_wr	false	
		socket	Socket  (id=1715)	
		socketInputStream	null	
		stream	true	
		timeout	0	
		trafficClass	0	
		useV4	false	
	oldImpl	false	
	shutIn	false	
	shutOut	false	

        changeSocket(socket);
/s
PGStream.changeSocket(Socket) line: 111	
        this.connection = socket;

        // Submitted by Jason Venner <jason@idiom.com>. Disable Nagle
        // as we are selective about flushing output only when we
        // really need to.
        connection.setTcpNoDelay(true);
/ TODO
        // Buffer sizes submitted by Sverre H Huseby <sverrehu@online.no>
        pg_input = new VisibleBufferedInputStream(connection.getInputStream(), 8192);
        pg_output = new BufferedOutputStream(connection.getOutputStream(), 8192);

        if (encoding != null)
null
            setEncoding(encoding);
/ NIET
/ TODO

/t
PGStream.<init>(HostSpec, int) line: 63	
        changeSocket(socket);
/d
this	PGStream  (id=1714)	
	_int2buf	null	
	_int4buf	null	
	connection	Socket  (id=1715)	Socket[addr=localhost/127.0.0.1,port=5432,localport=42520]
	encoding	null	
	encodingWriter	null	
	hostSpec	HostSpec  (id=1617)	
	pg_input	VisibleBufferedInputStream  (id=1775)	
	pg_output	BufferedOutputStream  (id=1777)	
	streamBuffer	null	

        setEncoding(Encoding.getJVMEncoding("US-ASCII"));
/s
Encoding.getJVMEncoding(String) line: 103	
        if (isAvailable(jvmEncoding))
/s
Encoding.isAvailable(String) line: 256	
       try
        {
            "DUMMY".getBytes(encodingName);
/ OK
            return true;
        }
        catch (java.io.UnsupportedEncodingException e)
/ NIET
        {
            return false;
        }
/t
Encoding.getJVMEncoding(String) line: 105	
        if (isAvailable(jvmEncoding))
/ JA
        {
            if (jvmEncoding.equals("UTF-8") || jvmEncoding.equals("UTF8"))
/ NEE
                return new UTF8Encoding(jvmEncoding);
            else
/ JA
                return new Encoding(jvmEncoding);
/ TODO
/t
PGStream.<init>(HostSpec, int) line: 63	
        setEncoding(Encoding.getJVMEncoding("US-ASCII"));
/pd
/s
PGStream.setEncoding(Encoding) line: 138	
/=
    public void setEncoding(Encoding encoding) throws IOException {
encoding	Encoding  (id=1796)	
	encoding	"US-ASCII" (id=1794)	
	fastASCIINumbers	true	

        // Intercept flush() downcalls from the writer; our caller
        // will call PGStream.flush() as needed.
        OutputStream interceptor = new FilterOutputStream(pg_output) {
                                       public void flush() throws IOException {
                                       }
                                       public void close() throws IOException {
                                           super.flush();
                                       }
                                   };
        encodingWriter = encoding.getEncodingWriter(interceptor);
/s
Encoding.getEncodingWriter(OutputStream) line: 233	
        return new OutputStreamWriter(out, encoding);
out	PGStream$1  (id=1798)									/ de stream hierboven	,

/t
PGStream.<init>(HostSpec, int) line: 65	
        setEncoding(Encoding.getJVMEncoding("US-ASCII"));
/d
        _int2buf = new byte[2];
        _int4buf = new byte[4];
/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 112	
            newStream = new PGStream(hostSpec, connectTimeout);
/d
            // Construct and send an ssl startup packet if requested.
            if (trySSL)
/ NEE
                newStream = enableSSL(newStream, requireSSL, info, logger, connectTimeout);
/ NIET
            String socketTimeoutProperty = info.getProperty("socketTimeout", "0");
"0"
            try {
                int socketTimeout = Integer.parseInt(socketTimeoutProperty);
0
                if (socketTimeout > 0) {
                    newStream.getSocket().setSoTimeout(socketTimeout*1000);
/ NIET
            // Enable TCP keep-alive probe if required.
            newStream.getSocket().setKeepAlive(requireTCPKeepAlive);
false
            // Set SO_RECVBUF read buffer size
            String receiveBufferSizeProperty = info.getProperty("receiveBufferSize", "-1");
            try {
                int receiveBufferSize = Integer.parseInt(receiveBufferSizeProperty);
-1
                if (receiveBufferSize > -1) {
                    // value of 0 not a valid buffer size value
                    if (receiveBufferSize > 0) {
                        newStream.getSocket().setReceiveBufferSize(receiveBufferSize);
/ NEE
            // Set SO_SNDBUF write buffer size 
            String sendBufferSizeProperty = info.getProperty("sendBufferSize", "-1");
            try {
                int sendBufferSize = Integer.parseInt(sendBufferSizeProperty);
                if (sendBufferSize > -1) {
                    if (sendBufferSize > 0) {
                        newStream.getSocket().setSendBufferSize(sendBufferSize);
/ NEE
            // Construct and send a startup packet.
            String[][] params = {
                                    { "user", user },
                                    { "database", database },
                                    { "client_encoding", "UTF8" },
                                    { "DateStyle", "ISO" },
                                    { "extra_float_digits", "2" },
                                    { "TimeZone",  createPostgresTimeZone() },                                    
                                };
/s
ConnectionFactoryImpl.createPostgresTimeZone() line: 265	
        String tz = TimeZone.getDefault().getID();
Europe/Amsterdam
            return tz;
/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 178	

            sendStartupPacket(newStream, params, logger);
params=
[[user, foo], [database, foo], [client_encoding, UTF8], [DateStyle, ISO], [extra_float_digits, 2], [TimeZone, Europe/Amsterdam]]
/s
ConnectionFactoryImpl.sendStartupPacket(PGStream, String[][], Logger) line: 352	

        /*
         * Precalculate message length and encode params.
         */
        int length = 4 + 4;												/ voor .SendInteger4 en 2 keer .SendInteger2 hieronder,
        byte[][] encodedParams = new byte[params.length * 2][];
        for (int i = 0; i < params.length; ++i)
        {
            encodedParams[i*2] = params[i][0].getBytes("UTF-8");
            encodedParams[i*2 + 1] = params[i][1].getBytes("UTF-8");
            length += encodedParams[i * 2].length + 1 + encodedParams[i * 2 + 1].length + 1;
        }
        length += 1; // Terminating \0			/ voor de .sendChar(0) hieronder	,

        pgStream.SendInteger4(length);
        pgStream.SendInteger2(3); // protocol major
        pgStream.SendInteger2(0); // protocol minor
        for (int i = 0; i < encodedParams.length; ++i)
        {
            pgStream.Send(encodedParams[i]);
            pgStream.SendChar(0);
        }
        pgStream.SendChar(0);

        pgStream.flush();
/s
PGStream.flush() line: 530	
        if (encodingWriter != null)
            encodingWriter.flush();
/ TODO
        pg_output.flush();
/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 181	
            sendStartupPacket(newStream, params, logger);
/d
            // Do authentication (until AuthenticationOk).
            doAuthentication(newStream, hostSpec.getHost(), user, info, logger);
/s
ConnectionFactoryImpl.doAuthentication(PGStream, String, String, Properties, Logger) line: 382	
        String password = info.getProperty("password");
foo
        while (true)
        {
            int beresp = pgStream.ReceiveChar();

            switch (beresp)
           case 'R':
                // Authentication request.
                // Get the message length
                int l_msgLen = pgStream.ReceiveInteger4();
12
                // Get the type of request
                int areq = pgStream.ReceiveInteger4();
5
               // Process the request.
                switch (areq)
                case AUTH_REQ_MD5:
                    {
                        byte[] md5Salt = pgStream.Receive(4);
[-42, -79, 84, -109]
                        byte[] digest = MD5Digest.encode(user.getBytes("UTF-8"), password.getBytes("UTF-8"), md5Salt);
[109, 100, 53, 57, 97, 52, 48, 97, 97, 55, 55, 100, 56, 56, 100, 100, 50, 55, 49, 57, 51, 53, 49, 101, 54, 57, 53, 53, 51, 97, 100, 51, 50, 50, 57]
                        pgStream.SendChar('p');
                        pgStream.SendInteger4(4 + digest.length + 1);
                        pgStream.Send(digest);
                        pgStream.SendChar(0);
                        pgStream.flush();
                        break;

/ volgende	,
        while (true)
        {
            int beresp = pgStream.ReceiveChar();
            case 'R':
                // Authentication request.
                // Get the message length
                int l_msgLen = pgStream.ReceiveInteger4();
8
                // Get the type of request
                int areq = pgStream.ReceiveInteger4();
0
                // Process the request.
                switch (areq)
                case AUTH_REQ_OK:
                    return ; // We're done.
/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 184	
            doAuthentication(newStream, hostSpec.getHost(), user, info, logger);
/d
            // Do final startup.
            ProtocolConnectionImpl protoConnection = new ProtocolConnectionImpl(newStream, user, database, info, logger, connectTimeout);
            readStartupMessages(newStream, protoConnection, logger);
/s
ConnectionFactoryImpl.readStartupMessages(PGStream, ProtocolConnectionImpl, Logger) line: 528	
        while (true)
        {
            int beresp = pgStream.ReceiveChar();
            switch (beresp)
            {
            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	22	
name	"application_name" (id=1621)	
value	"" (id=1622)	

/ volgende	,
        while (true)
        {
            int beresp = pgStream.ReceiveChar();
            switch (beresp)
            {
            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	25	
name	"client_encoding" (id=1623)	
value	"UTF8" (id=1624)	
                else if (name.equals("client_encoding"))
                {
                    if (!value.equals("UTF8"))
                        throw new PSQLException(GT.tr("Protocol error.  Session setup failed."), PSQLState.PROTOCOL_VIOLATION);
                    pgStream.setEncoding(Encoding.getDatabaseEncoding("UTF8"));
/s
Encoding.getDatabaseEncoding(String) line: 128	
        // If the backend encoding is known and there is a suitable
        // encoding in the JVM we use that. Otherwise we fall back
        // to the default encoding of the JVM.

        String[] candidates = (String[]) encodings.get(databaseEncoding);
databaseEncoding	"UTF8" (id=1625)	
candidates	String[2]  (id=1630)	
	[0]	"UTF-8" (id=1633)	
	[1]	"UTF8" (id=1625)	
            for (int i = 0; i < candidates.length; i++)
            {
                if (isAvailable(candidates[i]))
/s
Encoding.isAvailable(String) line: 255	
encodingName	"UTF-8" (id=1633)	
            "DUMMY".getBytes(encodingName);
            return true;
/t
                if (isAvailable(candidates[i]))
/d
                    return new Encoding(candidates[i]);
/t
/s
PGStream.setEncoding(Encoding) line: 138	
        // Close down any old writer.
        if (encodingWriter != null)
            encodingWriter.close();
        this.encoding = encoding;
UTF-8
        // Intercept flush() downcalls from the writer; our caller
        // will call PGStream.flush() as needed.
        OutputStream interceptor = new FilterOutputStream(pg_output) {				/ interceptor -> pg_output
                                       public void flush() throws IOException {
                                       }
                                       public void close() throws IOException {
                                           super.flush();
                                       }
                                   };

        encodingWriter = encoding.getEncodingWriter(interceptor);
/ outputStreamWriter op interceptor	,
/s
Encoding.getEncodingWriter(OutputStream) line: 233	
        return new OutputStreamWriter(out, encoding);
encoding="UTF-8"

/ Intermezzo

encodingWriter -> interceptor -> pg_output -> outputstream op socket

    public void flush() throws IOException
    {
        if (encodingWriter != null)
            encodingWriter.flush();			/ Deze doet toch niets	? TODO
        pg_output.flush();
    }

/ Einde Intermezzo

/t
ConnectionFactoryImpl.readStartupMessages(PGStream, ProtocolConnectionImpl, Logger) line: 529	

/ volgende	,
        while (true)
        {
            int beresp = pgStream.ReceiveChar();
            switch (beresp)
            {
           case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	23	
name	"DateStyle" (id=1662)	
value	"ISO, MDY" (id=1663)	

/ volgende,
        while (true)
        {
            int beresp = pgStream.ReceiveChar();
            switch (beresp)
            {
            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	25	
name	"integer_datetimes" (id=1664)	
value	"on" (id=1665)	
                else if (name.equals("integer_datetimes"))
                {
                    if (value.equals("on"))
                        protoConnection.setIntegerDateTimes(true);

/ volgende,
            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	27	
name	"IntervalStyle" (id=1666)	
value	"postgres" (id=1667)	

            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	21	
name	"is_superuser" (id=1668)	
value	"off" (id=1669)	

            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	25	
name	"server_encoding" (id=1670)	
value	"UTF8" (id=1671)	

            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	25	
name	"server_version" (id=1672)	
value	"9.3.5" (id=1673)	
                if (name.equals("server_version"))
                    protoConnection.setServerVersion(value);

            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	30	
name	"session_authorization" (id=1674)	
value	"foo" (id=1676)	

            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	35	
name	"standard_conforming_strings" (id=1677)	
value	"on" (id=1678)	
                else if (name.equals("standard_conforming_strings"))
                {
                    if (value.equals("on"))
                        protoConnection.setStandardConformingStrings(true);
/ TODO
            case 'S':
                // ParameterStatus
                int l_len = pgStream.ReceiveInteger4();
                String name = pgStream.ReceiveString();
                String value = pgStream.ReceiveString();
l_len	30	
name	"TimeZone" (id=1679)	
value	"Europe/Amsterdam" (id=1680)	
            case 'K':
                // BackendKeyData
                int l_msgLen = pgStream.ReceiveInteger4();
                if (l_msgLen != 12)
                    throw new PSQLException(GT.tr("Protocol error.  Session setup failed."), PSQLState.PROTOCOL_VIOLATION);

                int pid = pgStream.ReceiveInteger4();
                int ckey = pgStream.ReceiveInteger4();
l_msgLen	12	
pid	1502	
ckey	1221689659	

                protoConnection.setBackendKeyData(pid, ckey);
/s
    void setBackendKeyData(int cancelPid, int cancelKey) {
        this.cancelPid = cancelPid;
        this.cancelKey = cancelKey;
/ TODO
/t

           case 'Z':
                // Ready For Query; we're done.
                if (pgStream.ReceiveInteger4() != 5)
                    throw new IOException("unexpected length of ReadyForQuery packet");

                char tStatus = (char)pgStream.ReceiveChar();
                if (logger.logDebug())
                    logger.debug(" <=BE ReadyForQuery(" + tStatus + ")");

                // Update connection state.
                switch (tStatus)
                {
                case 'I':
                    protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_IDLE);
                    break;
/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 187	
            readStartupMessages(newStream, protoConnection, logger);
/d
            runInitialQueries(protoConnection, info, logger);
/s
ConnectionFactoryImpl.runInitialQueries(ProtocolConnection, Properties, Logger) line: 646	
        String dbVersion = protoConnection.getServerVersion();
9.3.5
        if (dbVersion.compareTo("9.0") >= 0) {
            SetupQueryRunner.run(protoConnection, "SET extra_float_digits = 3", false);
/s
SetupQueryRunner.run(ProtocolConnection, String, boolean) line: 64	
        QueryExecutor executor = protoConnection.getQueryExecutor();
        Query query = executor.createSimpleQuery(queryString);
queryString= SET extra_float_digits = 3
/s
QueryExecutorImpl.createSimpleQuery(String) line: 111	
        return parseQuery(sql, false);
/s
QueryExecutorImpl.parseQuery(String, boolean) line: 122	
        boolean standardConformingStrings = protoConnection.getStandardConformingStrings();
true
       for (int i = 0; i < aChars.length; ++i)
        {
            switch (aChars[i])
/ GEEN

        fragmentList.add(query.substring(fragmentStart));
[SET extra_float_digits = 3]

        if (fragmentList.size() > 1 || ((String)fragmentList.get(0)).trim().length() > 0)
            statementList.add(fragmentList.toArray(new String[fragmentList.size()]));
statementList	ArrayList<E>  (id=1693)	
	elementData	Object[10]  (id=1702)	
		[0]	String[1]  (id=1704)	
			[0]	"SET extra_float_digits = 3" (id=1690)	

        if (statementList.size() == 1)
        {
            // Only one statement.
            return new SimpleQuery((String[]) statementList.get(0), protoConnection);
/t
SetupQueryRunner.run(ProtocolConnection, String, boolean) line: 66	
        Query query = executor.createSimpleQuery(queryString);
/d
protoConnection	ProtocolConnectionImpl  (id=1607)	
queryString	"SET extra_float_digits = 3" (id=1690)	
wantResults	false	
executor	QueryExecutorImpl  (id=1692)	
query	SimpleQuery  (id=1738)	
	cleanupRef	null	
	encodedStatementName	null	
	fields	null	
	fragments	String[1]  (id=1704)	
		[0]	"SET extra_float_digits = 3" (id=1690)	
	portalDescribed	false	
	preparedTypes	null	
	protoConnection	ProtocolConnectionImpl  (id=1607)	
		cancelKey	1221689659	
		cancelPid	1502	
		closed	false	
		connectTimeout	0	
		database	"foo" (id=1609)	
		executor	QueryExecutorImpl  (id=1692)	
		integerDateTimes	true	
		logger	Logger  (id=1602)	
		notifications	ArrayList<E>  (id=1747)	
		pgStream	PGStream  (id=1592)	
		serverVersion	"9.3.5" (id=1673)	
		standardConformingStrings	true	
		transactionState	0	
		useBinaryForOids	HashSet<E>  (id=1748)	
		user	"foo" (id=1600)	
		warnings	null	
	statementDescribed	false	
	statementName	null	

        SimpleResultHandler handler = new SimpleResultHandler(protoConnection);
        int flags = QueryExecutor.QUERY_ONESHOT | QueryExecutor.QUERY_SUPPRESS_BEGIN;
        if (!wantResults)
            flags |= QueryExecutor.QUERY_NO_RESULTS | QueryExecutor.QUERY_NO_METADATA;

            executor.execute(query, null, handler, 0, 0, flags);
/s
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 228	
       if (parameters == null)
            parameters = SimpleQuery.NO_PARAMETERS;

        boolean describeOnly = (QUERY_DESCRIBE_ONLY & flags) != 0;
false

        ((V3ParameterList)parameters).convertFunctionOutParameters();
/ NIETS

        // Check parameters are all set..
        if (!describeOnly)
            ((V3ParameterList)parameters).checkAllParametersSet();
/ NIETS

                handler = sendQueryPreamble(handler, flags);
/ NIETS, handler blijft onveranderd	,
/s
QueryExecutorImpl.sendQueryPreamble(ResultHandler, int) line: 419	
/=
    private ResultHandler sendQueryPreamble(final ResultHandler delegateHandler, int flags) throws IOException {

        // Send BEGIN on first statement in transaction.
        if ((flags & QueryExecutor.QUERY_SUPPRESS_BEGIN) != 0 ||
true
                protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE)
false
            return delegateHandler;
/t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 251	
                handler = sendQueryPreamble(handler, flags);
/d
               	ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
                queryCount = 0;
                sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/s
QueryExecutorImpl.sendQuery(V3Query, V3ParameterList, int, int, int, QueryExecutorImpl$ErrorTrackingResultHandler) line: 1120	

query	SimpleQuery  (id=1738)	
	cleanupRef	null	
	encodedStatementName	null	
	fields	null	
	fragments	String[1]  (id=1704)	
	portalDescribed	false	
	preparedTypes	null	
	protoConnection	ProtocolConnectionImpl  (id=1607)	
	statementDescribed	false	
	statementName	null	

parameters	SimpleParameterList  (id=1764)	
	encoded	(id=1769)	
	flags	(id=1770)	
	paramTypes	(id=1771)	
	paramValues	Object[0]  (id=1772)	
	protoConnection	null	

        SimpleQuery[] subqueries = query.getSubqueries();
null
        SimpleParameterList[] subparams = parameters.getSubparams();
null
        boolean disallowBatching = (flags & QueryExecutor.QUERY_DISALLOW_BATCHING) != 0;
false
       if (subqueries == null)
        {
            ++queryCount;
            if (disallowBatching || queryCount >= MAX_BUFFERED_QUERIES)
/ NEE
             // If we saw errors, don't send anything more.
            if (!trackingHandler.hasErrors())
                sendOneQuery((SimpleQuery)query, (SimpleParameterList)parameters, maxRows, fetchSize, flags);
/s
QueryExecutorImpl.sendOneQuery(SimpleQuery, SimpleParameterList, int, int, int) line: 1557	

        boolean noResults = (flags & QueryExecutor.QUERY_NO_RESULTS) != 0;
true
        boolean noMeta = (flags & QueryExecutor.QUERY_NO_METADATA) != 0;
true
        boolean describeOnly = (flags & QueryExecutor.QUERY_DESCRIBE_ONLY) != 0;
false
        boolean usePortal = (flags & QueryExecutor.QUERY_FORWARD_CURSOR) != 0 && !noResults && !noMeta && fetchSize > 0 && !describeOnly;
false
        boolean oneShot = (flags & QueryExecutor.QUERY_ONESHOT) != 0 && !usePortal;
true
        boolean noBinaryTransfer = (flags & QUERY_NO_BINARY_TRANSFER) != 0;
true

        if (noResults)
        {
            rows = 1;             // We're discarding any results anyway, so limit data transfer to a minimum

        sendParse(query, params, oneShot);
/s
QueryExecutorImpl.sendParse(SimpleQuery, SimpleParameterList, boolean) line: 1187	
        byte[] encodedStatementName = query.getEncodedStatementName();
null
        String[] fragments = query.getFragments();
[SET extra_float_digits = 3]

       for (int i = 0; i < fragments.length; ++i)
        {
            parts[j] = Utils.encodeUTF8(fragments[i]);
            encodedSize += parts[j].length;
            ++j;
        }
parts=
[[83, 69, 84, 32, 101, 120, 116, 114, 97, 95, 102, 108, 111, 97, 116, 95, 100, 105, 103, 105, 116, 115, 32, 61, 32, 51]]

       encodedSize = 4
                      + (encodedStatementName == null ? 0 : encodedStatementName.length) + 1
                      + encodedSize + 1
                      + 2 + 4 * params.getParameterCount();
34
        pgStream.SendChar('P'); // Parse
        pgStream.SendInteger4(encodedSize);
        if (encodedStatementName != null) pgStream.Send(encodedStatementName);
        pgStream.SendChar(0);   // End of statement name
        for (int i = 0; i < parts.length; ++i)
        { // Query string
            pgStream.Send(parts[i]);
        }
        pgStream.SendChar(0);       // End of query string.
        pgStream.SendInteger2(params.getParameterCount());       // # of parameter types specified
        for (int i = 1; i <= params.getParameterCount(); ++i) pgStream.SendInteger4(params.getTypeOID(i));
/ NEE
        pendingParseQueue.add(new Object[]{query, query.getStatementName()});
/t
QueryExecutorImpl.sendOneQuery(SimpleQuery, SimpleParameterList, int, int, int) line: 1589	
        sendParse(query, params, oneShot);
/d
        boolean queryHasUnknown = query.hasUnresolvedTypes();
true
        boolean paramsHasUnknown = params.hasUnresolvedTypes();
false
        boolean describeStatement = describeOnly || (!oneShot && paramsHasUnknown && queryHasUnknown && !query.isStatementDescribed());
false
oneShot==true
        sendBind(query, params, portal, noBinaryTransfer);
/s
QueryExecutorImpl.sendBind(SimpleQuery, SimpleParameterList, Portal, boolean) line: 1358	

       	pgStream.SendChar('B');                  // Bind
        pgStream.SendInteger4((int)encodedSize);      // Message size
        if (encodedPortalName != null) pgStream.Send(encodedPortalName);    // Destination portal name.
/ NEE
        pgStream.SendChar(0);                    // End of portal name.
        if (encodedStatementName != null) pgStream.Send(encodedStatementName); // Source statement name.
/ NEE
        pgStream.SendChar(0);                    // End of statement name.
        pgStream.SendInteger2(params.getParameterCount());      // # of parameter format codes
0
        for (int i = 1; i <= params.getParameterCount(); ++i) pgStream.SendInteger2(params.isBinary(i) ? 1 : 0);  // Parameter format code
/ NEE
        pgStream.SendInteger2(params.getParameterCount());      // # of parameter values

        pgStream.SendInteger2(numBinaryFields);   // # of result format codes
0
        for (int i = 0; i < numBinaryFields; ++i) { pgStream.SendInteger2(fields[i].getFormat());
/ NEE
        pendingBindQueue.add(portal);
null
/t
QueryExecutorImpl.sendOneQuery(SimpleQuery, SimpleParameterList, int, int, int) line: 1635	
        sendBind(query, params, portal, noBinaryTransfer);
/d
        sendExecute(query, portal, rows);
/s
QueryExecutorImpl.sendExecute(SimpleQuery, Portal, int) line: 1479	
        byte[] encodedPortalName = (portal == null ? null : portal.getEncodedPortalName());
null
        int encodedSize = (encodedPortalName == null ? 0 : encodedPortalName.length);
0
        // Total size = 4 (size field) + 1 + N (source portal) + 4 (max rows)
        pgStream.SendChar('E');              // Execute
        pgStream.SendInteger4(4 + 1 + encodedSize + 4);  // message size
        if (encodedPortalName != null) pgStream.Send(encodedPortalName); // portal name
/ NEE
        pgStream.SendChar(0);                 // portal name terminator
        pgStream.SendInteger4(limit);       // row limit
1
        pendingExecuteQueue.add(new Object[] { query, portal });
/t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 254	
               sendQuery((V3Query)query, (V3ParameterList)parameters, maxRows, fetchSize, flags, trackingHandler);
/d
                sendSync();
/s
QueryExecutorImpl.sendSync() line: 1180	
    //
    // Message sending
    //

    private void sendSync() throws IOException {
        if (logger.logDebug())
            logger.debug(" FE=> Sync");

        pgStream.SendChar('S');     // Sync
        pgStream.SendInteger4(4); // Length
        pgStream.flush();
/ TODO
/t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 255	
               sendSync();
               processResults(handler, flags);
/s
QueryExecutorImpl.processResults(ResultHandler, int) line: 1741	
        boolean noResults = (flags & QueryExecutor.QUERY_NO_RESULTS) != 0;
true
        boolean bothRowsAndStatus = (flags & QueryExecutor.QUERY_BOTH_ROWS_AND_STATUS) != 0;
false
        while (!endQuery)
        {
            c = pgStream.ReceiveChar();
            switch (c)
            {
            case '1':    // Parse Complete (response to Parse)
                pgStream.ReceiveInteger4(); // len, discarded
                Object[] parsedQueryAndStatement = (Object[])pendingParseQueue.get(parseIndex++);
[SET extra_float_digits = 3, null]
                SimpleQuery parsedQuery = (SimpleQuery)parsedQueryAndStatement[0];
SET extra_float_digits = 3
                String parsedStatementName = (String)parsedQueryAndStatement[1];
null
                registerParsedQuery(parsedQuery, parsedStatementName);
/ NIETS, want parsedStatementName==null
/ TODO

                break;
/ volgende
            case '2':    // Bind Complete  (response to Bind)
                pgStream.ReceiveInteger4(); // len, discarded

                Portal boundPortal = (Portal)pendingBindQueue.get(bindIndex++);
null
                if (logger.logDebug())
                    logger.debug(" <=BE BindComplete [" + boundPortal + "]");

                registerOpenPortal(boundPortal);
/ NIETS, want boundPortal==null
                break;
/ volgende	,
            case 'C':  // Command Status (end of Execute)
                // Handle status.
                String status = receiveCommandStatus();
/s
QueryExecutorImpl.receiveCommandStatus() line: 2217	
        //TODO: better handle the msg len
        int l_len = pgStream.ReceiveInteger4();
8
        //read l_len -5 bytes (-4 for l_len and -1 for trailing \0)
        String status = pgStream.ReceiveString(l_len - 5);
SET
        //now read and discard the trailing \0
        pgStream.Receive(1);
        return status;
/t
QueryExecutorImpl.processResults(ResultHandler, int) line: 1863	
                String status = receiveCommandStatus();
SET
                    Object[] executeData = (Object[])pendingExecuteQueue.get(executeIndex++);
                    SimpleQuery currentQuery = (SimpleQuery)executeData[0];
SET extra_float_digits = 3
                    Portal currentPortal = (Portal)executeData[1];
null
                    Field[] fields = currentQuery.getFields();
null
                    else
                    {
                        interpretCommandStatus(status, handler);
/s
QueryExecutorImpl.interpretCommandStatus(String, ResultHandler) line: 2252	
        handler.handleCommandStatus(status, update_count, insert_oid);
/s
SetupQueryRunner$SimpleResultHandler.handleCommandStatus(String, int, long) line: 43	
/ LEEG
/t
QueryExecutorImpl.processResults(ResultHandler, int) line: 2011	

/ volgende	,
            case 'Z':    // Ready For Query (eventual response to Sync)
                receiveRFQ();
/s
QueryExecutorImpl.receiveRFQ() line: 2256		/ rfq=ready for query	,
        if (pgStream.ReceiveInteger4() != 5)
            throw new IOException("unexpected length of ReadyForQuery message");

        char tStatus = (char)pgStream.ReceiveChar();
I
        switch (tStatus)
        {
        case 'I':
            protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_IDLE);
            break;
/t
QueryExecutorImpl.processResults(ResultHandler, int) line: 2012	
            case 'Z':    // Ready For Query (eventual response to Sync)
                receiveRFQ();
/d
                endQuery = true;
                pendingParseQueue.clear();              // No more ParseComplete messages expected.
                pendingDescribeStatementQueue.clear();  // No more ParameterDescription messages expected.
                pendingDescribePortalQueue.clear();     // No more RowDescription messages expected.
                pendingBindQueue.clear();               // No more BindComplete messages expected.
                pendingExecuteQueue.clear();            // No more query executions expected.
                break;
/t
QueryExecutorImpl.execute(Query, ParameterList, ResultHandler, int, int, int) line: 284	
                processResults(handler, flags);
/d
        handler.handleCompletion();
/s
SetupQueryRunner$SimpleResultHandler.handleCompletion() line: 60	
           if (error != null)
/ NEE
/t
SetupQueryRunner.run(ProtocolConnection, String, boolean) line: 78	
            executor.execute(query, null, handler, 0, 0, flags);
/d
        }
        finally
        {
            query.close();
/s
SimpleQuery.close() line: 55	
        unprepare();
/s
SimpleQuery.unprepare() line: 166	
        if (cleanupRef != null)
/n
        statementName = null;
        encodedStatementName = null;
        fields = null;
        portalDescribed = false;
        statementDescribed = false;
/t
SetupQueryRunner.run(ProtocolConnection, String, boolean) line: 82	
            query.close();
/d
        }

        if (!wantResults)
            return null;
/t
ConnectionFactoryImpl.runInitialQueries(ProtocolConnection, Properties, Logger) line: 649	
            SetupQueryRunner.run(protoConnection, "SET extra_float_digits = 3", false);
/d
        String appName = info.getProperty("ApplicationName");
null
        if (appName != null && dbVersion.compareTo("9.0") >= 0) {
/n
            StringBuffer sql = new StringBuffer();
/n
            sql.append("SET application_name = '");
/n
			...
/t
ConnectionFactoryImpl.openConnectionImpl(HostSpec[], String, String, Properties, Logger) line: 190	
            runInitialQueries(protoConnection, info, logger);
/d
            // And we're done.
            return protoConnection;
/t
Jdbc4Connection(AbstractJdbc2Connection).<init>(HostSpec[], String, String, Properties, String) line: 145	
       // Now make the initial connection and set up local state
        this.protoConnection = ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
 /d
       	this.dbVersionNumber = protoConnection.getServerVersion();
9.3.5
        this.compatible = info.getProperty("compatible", Driver.MAJORVERSION + "." + Driver.MINORVERSION);
9.3

/ intermezzo

public class Oid {
    public static final int UNSPECIFIED = 0;
    public static final int INT2 = 21;
    public static final int INT2_ARRAY = 1005;
    public static final int INT4 = 23;
    public static final int INT4_ARRAY = 1007;
    public static final int INT8 = 20;
...
    public static final int VARCHAR = 1043;

/ Dit zijn de types van de columns in postgres	, 

23 = int
21=smallint
20=bigint
1043=varchar
1082=date

foo=> \d sporter
                                 Table "public.sporter"
 Column |          Type          |                       Modifiers                       
--------+------------------------+-------------------------------------------------------
 id_    | bigint                 | not null default nextval('sporter_id__seq'::regclass)
 name_  | character varying(255) | 
 club_  | bigint                 | not null
Indexes:
    "sporter_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_1k67yd2nymaoofah9faoxj0cl" FOREIGN KEY (club_) REFERENCES club(id_)



foo=>
SELECT * FROM pg_attribute
WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'sporter');

 attrelid | attname  | atttypid | attstattarget | attlen | attnum | attndims | attcacheoff | atttypmod | attbyval | attstorage | a
ttalign | attnotnull | atthasdef | attisdropped | attislocal | attinhcount | attcollation | attacl | attoptions | attfdwoptions
----------+----------+----------+---------------+--------+--------+----------+-------------+-----------+----------+------------+--
--------+------------+-----------+--------------+------------+-------------+--------------+--------+------------+---------------
  3293291 | tableoid |       26 |             0 |      4 |     -7 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | cmax     |       29 |             0 |      4 |     -6 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | xmax     |       28 |             0 |      4 |     -5 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | cmin     |       29 |             0 |      4 |     -4 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | xmin     |       28 |             0 |      4 |     -3 |        0 |          -1 |        -1 | t        | p          | i
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | ctid     |       27 |             0 |      6 |     -1 |        0 |          -1 |        -1 | f        | p          | s
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | id_      |       20 |            -1 |      8 |      1 |        0 |          -1 |        -1 | t        | p          | d
        | t          | t         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
  3293291 | name_    |     1043 |            -1 |     -1 |      2 |        0 |          -1 |       259 | f        | x          | i
        | f          | f         | f            | t          |           0 |          100 | NULL   | NULL       | NULL
  3293291 | club_    |       20 |            -1 |      8 |      3 |        0 |          -1 |        -1 | t        | p          | d
        | t          | f         | f            | t          |           0 |            0 | NULL   | NULL       | NULL
(9 rows)

/ 

/ einde intermezzo

        if (!haveMinimumCompatibleVersion("8.0")) {
/n
        // driver supports only null-compatible arrays
        if (!haveMinimumCompatibleVersion("8.3")) {
/n
        binaryOids.addAll(getOidSet(info.getProperty("binaryTransferEnable", "")));
/ niets
        binaryOids.removeAll(getOidSet(info.getProperty("binaryTransferDisable", "")));
/ niets

        // split for receive and send for better control
        useBinarySendForOids = new HashSet<Integer>();
        useBinarySendForOids.addAll(binaryOids);
        useBinaryReceiveForOids = new HashSet<Integer>();
        useBinaryReceiveForOids.addAll(binaryOids);

        /*
         * Does not pass unit tests because unit tests expect setDate to have
         * millisecond accuracy whereas the binary transfer only supports
         * date accuracy.
         */
        useBinarySendForOids.remove(Oid.DATE);

        protoConnection.setBinaryReceiveOids(useBinaryReceiveForOids);
/s
ProtocolConnectionImpl.setBinaryReceiveOids(Set) line: 213	
        useBinaryForOids.clear();
[]	, was al []
        useBinaryForOids.addAll(oids);

        String stringType = info.getProperty("stringtype");
null
        } else {
            bindStringAsVarchar = haveMinimumCompatibleVersion("8.0");
true
        // Initialize timestamp stuff
        timestampUtils = new TimestampUtils(haveMinimumServerVersion("7.4"), haveMinimumServerVersion("8.2"),
                                            !protoConnection.getIntegerDateTimes());
protoConnection.getIntegerDateTimes()==true
/ laatste arg is isDouble	,
/ todo
this	Jdbc4Connection  (id=251)	
	timestampUtils	TimestampUtils  (id=1007)	
		calCache	null	
		calCacheZone	0	
		defaultCal	GregorianCalendar  (id=1009)	
		defaultTz	ZoneInfo  (id=1010)	
		min74	true	
		min82	true	
		sbuf	StringBuffer  (id=1011)	
		usesDouble	false	
	typemap	null	
	useBinaryReceiveForOids	HashSet<E>  (id=987)	
	useBinarySendForOids	HashSet<E>  (id=983)	

        // Initialize common queries.
        commitQuery = getQueryExecutor().createSimpleQuery("COMMIT");
/s
QueryExecutorImpl.createSimpleQuery(String) line: 111	
        return parseQuery(sql, false);
/s
QueryExecutorImpl.parseQuery(String, boolean) line: 122	
/=
    private Query parseQuery(String query, boolean withParameters) {
        if (statementList.size() == 1)
        {
            // Only one statement.
            return new SimpleQuery((String[]) statementList.get(0), protoConnection);
/t
this	Jdbc4Connection  (id=251)	
	commitQuery	SimpleQuery  (id=1053)	
		cleanupRef	null	
		encodedStatementName	null	
		fields	null	
		fragments	String[1]  (id=1054)	
			[0]	"COMMIT" (id=1043)	
		portalDescribed	false	
		preparedTypes	null	
		protoConnection	ProtocolConnectionImpl  (id=990)	
		statementDescribed	false	
		statementName	null	

        rollbackQuery = getQueryExecutor().createSimpleQuery("ROLLBACK");

        int unknownLength = Integer.MAX_VALUE;
        String strLength = info.getProperty("unknownLength");
null
/ unknownLenght blijft zo	,

        // Initialize object handling
        _typeCache = createTypeInfo(this, unknownLength);
/s
TypeInfoCache.<clinit>() line: 69	
    // basic pg types info:
    // 0 - type name	 	postgres type name	
    // 1 - type oid			postgres type oid
    // 2 - sql type			jdbc type
    // 3 - java class		java type
    // 4 - array type oid
    private static final Object types[][] = {
        {"int2", new Integer(Oid.INT2), new Integer(Types.SMALLINT), "java.lang.Integer", new Integer(Oid.INT2_ARRAY)},
        {"int4", new Integer(Oid.INT4), new Integer(Types.INTEGER), "java.lang.Integer", new Integer(Oid.INT4_ARRAY)},
        {"oid", new Integer(Oid.OID), new Integer(Types.BIGINT), "java.lang.Long", new Integer(Oid.OID_ARRAY)},
        {"int8", new Integer(Oid.INT8), new Integer(Types.BIGINT), "java.lang.Long", new Integer(Oid.INT8_ARRAY)},
        {"money", new Integer(Oid.MONEY), new Integer(Types.DOUBLE), "java.lang.Double", new Integer(Oid.MONEY_ARRAY)},
        {"numeric", new Integer(Oid.NUMERIC), new Integer(Types.NUMERIC), "java.math.BigDecimal", new Integer(Oid.NUMERIC_ARRAY)},
        {"float4", new Integer(Oid.FLOAT4), new Integer(Types.REAL), "java.lang.Float", new Integer(Oid.FLOAT4_ARRAY)},
        {"float8", new Integer(Oid.FLOAT8), new Integer(Types.DOUBLE), "java.lang.Double", new Integer(Oid.FLOAT8_ARRAY)},
        {"char", new Integer(Oid.CHAR), new Integer(Types.CHAR), "java.lang.String", new Integer(Oid.CHAR_ARRAY)},
        {"bpchar", new Integer(Oid.BPCHAR), new Integer(Types.CHAR), "java.lang.String", new Integer(Oid.BPCHAR_ARRAY)},
        {"varchar", new Integer(Oid.VARCHAR), new Integer(Types.VARCHAR), "java.lang.String", new Integer(Oid.VARCHAR_ARRAY)},
        {"text", new Integer(Oid.TEXT), new Integer(Types.VARCHAR), "java.lang.String", new Integer(Oid.TEXT_ARRAY)},
        {"name", new Integer(Oid.NAME), new Integer(Types.VARCHAR), "java.lang.String", new Integer(Oid.NAME_ARRAY)},
        {"bytea", new Integer(Oid.BYTEA), new Integer(Types.BINARY), "[B", new Integer(Oid.BYTEA_ARRAY)},
        {"bool", new Integer(Oid.BOOL), new Integer(Types.BIT), "java.lang.Boolean", new Integer(Oid.BOOL_ARRAY)},
        {"bit", new Integer(Oid.BIT), new Integer(Types.BIT), "java.lang.Boolean", new Integer(Oid.BIT_ARRAY)},
        {"date", new Integer(Oid.DATE), new Integer(Types.DATE), "java.sql.Date", new Integer(Oid.DATE_ARRAY)},
        {"time", new Integer(Oid.TIME), new Integer(Types.TIME), "java.sql.Time", new Integer(Oid.TIME_ARRAY)},
        {"timetz", new Integer(Oid.TIMETZ), new Integer(Types.TIME), "java.sql.Time", new Integer(Oid.TIMETZ_ARRAY)},
        {"timestamp", new Integer(Oid.TIMESTAMP), new Integer(Types.TIMESTAMP), "java.sql.Timestamp", new Integer(Oid.TIMESTAMP_ARRAY)},
        {"timestamptz", new Integer(Oid.TIMESTAMPTZ), new Integer(Types.TIMESTAMP), "java.sql.Timestamp", new Integer(Oid.TIMESTAMPTZ_ARRAY)},
    };

    static {
        typeAliases = new HashMap();
        typeAliases.put("smallint", "int2");	
        typeAliases.put("integer", "int4");	 / klopt, we use in postgres altijd int , nooit int4	,
        typeAliases.put("int", "int4");
        typeAliases.put("bigint", "int8");
        typeAliases.put("float", "float8");
        typeAliases.put("boolean", "bool");
        typeAliases.put("decimal", "numeric");
    }
/t
/s
TypeInfoCache.<init>(BaseConnection, int) line: 111	
        _conn = conn;
conn	Jdbc4Connection  (id=251)	
        _unknownLength = unknownLength;
        _oidToPgName = new HashMap();
        _pgNameToOid = new HashMap();
        _pgNameToJavaClass = new HashMap();
        _pgNameToPgObject = new HashMap();
        _pgArrayToPgType = new HashMap();
        _arrayOidToDelimiter = new HashMap();

        // needs to be synchronized because the iterator is returned
        // from getPGTypeNamesWithSQLTypes()
/todo
        _pgNameToSQLType = Collections.synchronizedMap(new HashMap());

        for (int i=0; i<types.length; i++) {
            String pgTypeName = (String)types[i][0];
            Integer oid = (Integer)types[i][1];
            Integer sqlType = (Integer)types[i][2];
            String javaClass = (String)types[i][3];
            Integer arrayOid = (Integer)types[i][4];
            addCoreType(pgTypeName, oid, sqlType, javaClass, arrayOid);
/s
TypeInfoCache.addCoreType(String, Integer, Integer, String, Integer) line: 140	
/=
    public synchronized void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String javaClass, Integer arrayOid)

        _pgNameToJavaClass.put(pgTypeName, javaClass);
"int2", "java.lang.Integer"
        _pgNameToOid.put(pgTypeName, oid);
"int2",21									/ postgres internal	, waarom doen we dit ? todo					
        _oidToPgName.put(oid, pgTypeName);
21,"int2"									/ postgres internal	, waarom doen we dit ? todo
        _pgArrayToPgType.put(arrayOid, oid);
1005,21
        _pgNameToSQLType.put(pgTypeName, sqlType);
21, Types.SMALLINT

        // Currently we hardcode all core types array delimiter
        // to a comma.  In a stock install the only exception is
        // the box datatype and it's not a JDBC core type.
        //
        Character delim = new Character(',');
        _arrayOidToDelimiter.put(oid, delim);

        String pgArrayTypeName = "_" + pgTypeName;
"_int2"
        _pgNameToJavaClass.put(pgArrayTypeName, "java.sql.Array");
        _pgNameToSQLType.put(pgArrayTypeName, new Integer(Types.ARRAY));
/ todo

/t
TypeInfoCache.<init>(BaseConnection, int) line: 126	
        for (int i=0; i<types.length; i++) {
            String pgTypeName = (String)types[i][0];
            Integer oid = (Integer)types[i][1];
            Integer sqlType = (Integer)types[i][2];
            String javaClass = (String)types[i][3];
            Integer arrayOid = (Integer)types[i][4];

            addCoreType(pgTypeName, oid, sqlType, javaClass, arrayOid);
        }
/d
this	TypeInfoCache  (id=1128)	
	_arrayOidToDelimiter	HashMap<K,V>  (id=1176)	
	_conn	Jdbc4Connection  (id=251)	
	_getArrayDelimiterStatement	null	
	_getArrayElementOidStatement	null	
	_getNameStatement	null	
	_getOidStatement	null	
	_getTypeInfoStatement	null	
	_oidToPgName	HashMap<K,V>  (id=1177)	
{790=money, 1184=timestamptz, 1700=numeric, 1083=time, 17=bytea, 1082=date, 16=bool, 19=name, 700=float4, 701=float8, 18=char, 1266=timetz, 21=int2, 1560=bit, 20=int8, 23=int4, 1114=timestamp, 25=text, 1043=varchar, 26=oid, 1042=bpchar}
	_pgArrayToPgType	HashMap<K,V>  (id=1178)	
{1016=20, 791=790, 1185=1184, 1021=700, 1022=701, 1009=25, 1231=1700, 1028=26, 1014=1042, 1015=1043, 1270=1266, 1001=17, 1000=16, 1003=19, 1002=18, 1561=1560, 1005=21, 1115=1114, 1007=23, 1182=1082, 1183=1083}
	_pgNameToJavaClass	HashMap<K,V>  (id=1179)	
{numeric=java.math.BigDecimal, bpchar=java.lang.String, timetz=java.sql.Time, char=java.lang.String, _timestamp=java.sql.Array, _oid=java.sql.Array, _float8=java.sql.Array, _name=java.sql.Array, float8=java.lang.Double, _bool=java.sql.Array, _float4=java.sql.Array, date=java.sql.Date, _bytea=java.sql.Array, float4=java.lang.Float, timestamptz=java.sql.Timestamp, timestamp=java.sql.Timestamp, _money=java.sql.Array, _timestamptz=java.sql.Array, time=java.sql.Time, _text=java.sql.Array, _int8=java.sql.Array, _numeric=java.sql.Array, oid=java.lang.Long, name=java.lang.String, money=java.lang.Double, _date=java.sql.Array, _int4=java.sql.Array, _time=java.sql.Array, varchar=java.lang.String, _int2=java.sql.Array, text=java.lang.String, int8=java.lang.Long, int4=java.lang.Integer, _char=java.sql.Array, int2=java.lang.Integer, _timetz=java.sql.Array, bit=java.lang.Boolean, bytea=[B, _bit=java.sql.Array, _varchar=java.sql.Array, bool=java.lang.Boolean, _bpchar=java.sql.Array}
	_pgNameToOid	HashMap<K,V>  (id=1164)	
{text=25, numeric=1700, bpchar=1042, timetz=1266, int8=20, char=18, int4=23, float8=701, date=1082, float4=700, timestamptz=1184, int2=21, timestamp=1114, bit=1560, time=1083, bytea=17, oid=26, name=19, money=790, bool=16, varchar=1043}
	_pgNameToPgObject	HashMap<K,V>  (id=1180)	
{}
	_pgNameToSQLType	Collections$SynchronizedMap<K,V>  (id=1139)	
{numeric=2, bpchar=1, timetz=92, char=1, _timestamp=2003, _oid=2003, _float8=2003, _name=2003, float8=8, _bool=2003, _float4=2003, date=91, _bytea=2003, float4=7, timestamptz=93, timestamp=93, _money=2003, _timestamptz=2003, time=92, _text=2003, _int8=2003, _numeric=2003, oid=-5, name=12, money=8, _date=2003, _int4=2003, _time=2003, varchar=12, _int2=2003, text=12, int8=-5, int4=4, _char=2003, int2=5, _timetz=2003, bit=-7, bytea=-2, _bit=2003, _varchar=2003, bool=-7, _bpchar=2003}
	_unknownLength	2147483647	
conn	Jdbc4Connection  (id=251)	
unknownLength	2147483647	

        _pgNameToJavaClass.put("hstore", Map.class.getName());

/ HIER HIER HIER






























/ Intermezzo

/ Lees	,
https://jdbc.postgresql.org/documentation/94/connect.html#connection-parameters
https://jdbc.postgresql.org/documentation/94/ssl-client.html						/ Lees !
https://www.postgresql.org/docs/9.1/static/locale.html		/ env LANG -> en_US.UTF8	, geeft \l


/ In info kan	, 
loglevel				0
prepareThreshold		5
binaryTransfer			true
protocolVersion			null	
sslmode					null
ssl						null
tcpKeepAlive			false
connectionTimeout		0
socketTimeout			0
receiveBufferSize		-1
sendBufferSize			-1
ApplicationName			null
compatible				null
readOnly				null
stringType				null





/ Einde Intermezzo




















































/ Einde DEBUG HIBERNATE

/ HIBERNATE LAZYINITIALIZATION 

LOG_29_sep_2015.txt.2016.09.14:/ LazyInit ERR	, 

/ 7	. 

/ Oef	, 

/ ws workspace
/ proj hibernate_mappings
/ pkg my.test.own.objects
/ Sporter heeft fk naar Club	,
$ vi Main2.java

		{
		Sporter sporter=new Sporter("sporter");
		Club club=new Club("club");
		sporter.setClub(club);
		Session session=sessionFactory.openSession();
		session.save(club);
		session.save(sporter);
		session.beginTransaction().commit();
		session.close();
		}
		{
		Session session=sessionFactory.openSession();
		Sporter sporter=(Sporter)session.get(Sporter.class, 1l);
		Club club=sporter.getClub();
		session.close();									<-
		session=sessionFactory.openSession();
		String name=club.getName();							/ LazyInitializationException	,
		System.out.println("************ "+name);
		}
		
/ De session waar club=Proxy naar Club inzat is gesloten	, daarom LazyInitializationException 	
/ Als je een session close, wordt alles in de session rm	, entityEntryContext.count=0, .reentrantSafeEntries=null	,
/ club zit in de session via de sporter	, club zelf zit er niet in	, 
/ we hebben een session=sessionFactory.openSession() ertussen	, maar dat heeft geen zin	, want dit is een nieuwe session	, en daar zit de Proxy naar Club niet in	, 
/ Als we session.close() NIET,	 dan OK	, want de session is er nog , met de Club proxy er in (via sporter)	, en H. kan resolve	,

/ We zien GEEN LazyInitializationException meer	, 
/ misschien is de mapping aangepast	,
/ we zien dat club==null	, zodat club.getName() een NullPointerException geeft	, 
/ TODO

/ 7	. 

		{
		Session session=sessionFactory.openSession();
		Sporter sporter=(Sporter)session.get(Sporter.class, 1l);
		Club club=sporter.getClub();
		session.close();
		session=sessionFactory.openSession();
		session.merge(sporter);						<- NIETS	, TODO
124:	String name=club.getName();
		System.out.println("************ "+name);
		}
HibernateLog --> 09:04:37 TRACE org.hibernate.type.descriptor.sql.BasicExtractor - extracted value ([club_3_12_0_] : [BIGINT]) - [1]
org.hibernate.LazyInitializationException: could not initialize proxy - no Session
	at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:165)
	at org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:286)
	at org.hibernate.proxy.pojo.javassist.JavassistLazyInitializer.invoke(JavassistLazyInitializer.java:185)
	at my.test.own.hibernate_mappings.Club_$$_jvst4d9_4.getName(Club_$$_jvst4d9_4.java)
	at my.test.own.objects.Main2.testBasicUsage(Main2.java:124)
	at my.test.own.objects.Main2.<init>(Main2.java:77)
	at my.test.own.objects.Main2.main(Main2.java:71)

/ 7	. 

/ Maar Session.update OK	,

		{
		Session session=sessionFactory.openSession();
		Sporter sporter=(Sporter)session.get(Sporter.class, 1l);
		Club club=sporter.getClub();
		session.close();
		session=sessionFactory.openSession();
		session.update(sporter);
		String name=club.getName();
		System.out.println("************ "+name);
		}

************ club

/ We zien GEEN update query
/ TODO

/ we kunnen ook 	,
		session=sessionFactory.openSession();
		session.update(club);
		String name=club.getName();

/ Wat is logisch: update sporter of update club	?
/ TODO

/ 7	. 

/ we hebben ook in 1 block	, 
$ vi Main2a.java

	public void testBasicUsage() {
		
		Sporter sporter=new Sporter("sporter");
		Club club=new Club("club");
		sporter.setClub(club);
		Session session=sessionFactory.openSession();
		session.save(club);
		session.save(sporter);
		session.beginTransaction().commit();
		session.close();
		session=sessionFactory.openSession();
		Sporter sporter2=(Sporter)session.get(Sporter.class, 1l);
		Club club2=sporter2.getClub();
		session.close();
		session=sessionFactory.openSession();
		session.update(sporter2);				// of session.update(club2); TODO
		String name=club2.getName();			// LazyInitializationException	, als je de 2 regels erboven NIET doet	,
		System.out.println("************ "+name);
	}


/ 7	. 

/ Einde HIBERNATE LAZYINITIALIZATION 


/ HIBERNATE TX TRANSACTIONS  HQL

/ 7	. 

/ ws workspace
/ project hibernate_mappings
/ ns my.test.own.objects

$ vi Main3.java

	public void testBasicUsage() {
		
		Sporter sporter=new Sporter("sporter");
		Club club=new Club("club");
		sporter.setClub(club);
		Session session=sessionFactory.openSession();
		session.save(club);
		session.save(sporter);
		session.beginTransaction().commit();
		session.close();

		session=sessionFactory.openSession();
		Sporter sporter2=(Sporter)session.get(Sporter.class, 1l);
		Club club2=sporter2.getClub();
//		Query query=session.createQuery("update Sporter set name=:name where id=:id");				// OK
		Query query=session.createQuery("update Sporter s set s.name=:name where s.club.id=:id");
		query.setParameter("id", 1l);
		query.setParameter("name", "sporter2");
		int n=query.executeUpdate();
//		Query query2=session.createQuery("update Club set name=:name where id=:id");				// OK
		Query query2=session.createQuery("update Club c set c.name=:name where id=:id");
		query2.setParameter("id", 1l);
		query2.setParameter("name", "club2");
		int n2=query2.executeUpdate();
		session.beginTransaction().commit();
		System.out.println("+++++++++++++++: "+n);
		System.out.println("+++++++++++++++: "+n2);
		String name=club2.getName();	
		System.out.println("************: "+name);
		
	}

/ Waarom werkt deze transaction	, wanneer gestart	?	,  ook naar db is sporter2, club2	, 
/ TODO

/ Doe transactions in JDBC  
/ TODO

/ Einde HIBERNATE TX TRANSACTIONS HQL

/ HIBERNATE TX TRANSACTIONS JTA

/ H. book (427): verschil session, tx in JSE en JEE
/ (701) Open session in view	,




/ Einde HIBERNATE TX TRANSACTIONS JTA

/ ATOMIKOS

/ Geef in Google	, 
Hibernate Atomikos
/ Lees	, 
https://www.atomikos.com/Documentation/HibernateIntegration 

/ Einde ATOMIKOS

/ MIHALCEA

/ lees	,
https://twitter.com/vlad_mihalcea/status/807897555203919872
->
http://stackoverflow.com/questions/26562787/hibernateexception-couldnt-obtain-transaction-synchronized-session-for-current/26640603?stw=2#26640603



/ Einde MIHALCEA

/ BOEK

/ (244)

/ item_id in de item_image table is fk naar de item_id in de item table	,
/ item 1 heeft 2 images	, fooimage1.jpg	 en fooimage2.jpg	,
/ item 1 heeft 1 images	, barimage1.jpg,	

<set ... table="ITEM_IMAGE">
	<key column="ITEM_ID"/>
	<element column="FILENAME" .../>
</set>
/ Het staat er gewoon: dit gaat over table item_image	, dus key en element zijn columns in item_image	, 
/ key is fk	, 
/ element is de 2de column	, 

/ element is voor value type instances, verderop zien we one-to-many voor entity instances,
<set name="people" inverse="true"
	<key column="ADDRESS_ID"/>
	<one-to-many column="FILENAME"/>
</set>
/ TODO



/ (262)

<class table="BID">
	<many-to-one name="item" column="ITEM_ID" .../>
</class>
/ dit gaat over table bid	, dus item_id is column in table bid	,
/ many-to-one is zoals key in <set/> TODO

@JoinColumn is voor fk's,	


/ (264)

<class table="ITEM">
	<set name="bids">				<- er staat geen table attr, maar het is table="BID"	, dat ziet H. aan de class attr van de one-to-many	, 
		<key column="ITEM_ID" />
		<one-to-many class="Bid"/>
</class>

/ Dus we hebben 2 mappings op de BID table	,
/ Het lijkt alsof many-to-one hetzelfde doet als key	, en one-to-many de class geeft waar key is	,
/ TODO
 
/ Einde BOEK

/ LAZYINITIALIZATIONEXCEPTION

package my.test.own.hibernate_xml_N_1_bidir_ehcache;
public class Main6{
		  	String name=club.getName(); // LazyInitializationException
/ TODO

/ Einde LAZYINITIALIZATIONEXCEPTION

/ EXERCISES LAZYINITIALIZATIONEXCEPTION
/ EXERCISES LAZYINITIALIZATIONEXCEPTION

/ ws workspace
/ proj hibernate_xml_N_1_bidir_a

/ we hebben proj hibernate_xml_N_1_bidir_ehcache copy naar hibernate_xml_N_1_bidir_a	, en hier hebben we alle ehcache config rm	, 
/ TODO (Ga hibernate_xml_N_1_bidir_ehcache na)

/ Main6	, OK 					 / LazyInitializationException	,  dit hangt van de mapping af	, met de 1ste, many-to-one unidir zie we deze exc	,
/ Main4 , ehcache code	,

/ we werken met een copy van Main6	, Main6_1	,

$ vi Main6_1.java

			session = sessionFactory.openSession();
		  	Sporter sporter=new Sporter("Sporter");
		  	Club club=new Club("Club");
		  	sporter.setClub(club);
		  	club.getSporters().add(sporter);
		  	Sporter sporter2=new Sporter("Sporter2");
		  	sporter2.setClub(club);
		  	club.getSporters().add(sporter2);
		  	session.save(club); // moet eerst, 
		  	session.save(sporter);// anders hier TransientPropertyValueException
		  	session.save(sporter2);// anders hier TransientPropertyValueException
		  	session.flush();
		  	session.beginTransaction().commit();

		  	session3=sessionFactory.openSession();
		  	sporter=(Sporter)session3.get(Sporter.class, 1l);
		  	club=sporter.getClub();
		  	session3.close();
		  	String name=club.getName(); // LazyInitializationException	, 
														/ in ieder geval bij many-to-one unidir	, 
														// als we session3.close() , als we out comment session3.close(), dan GEEN LazyInitializationException 


/ 13	.  

/ many-to-one unidir	, 


<class name="Sporter" table="sporter2" >
	<id name="id" column="id_" >	
		<generator class="increment"/>
	</id>
	<property name="name" column="name_" />
	<many-to-one name="club" column="club_" not-null="true" />		/ club_ is column in eigen table, sporter2	,
</class>

<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
    <property name="name" column="name_" />
</class>

/we zien	,

foo=> \d+ sporter2
                               Table "public.sporter2"
 Column |          Type          | Modifiers | Storage  | Stats target | Description 
--------+------------------------+-----------+----------+--------------+-------------
 id_    | bigint                 | not null  | plain    |              | 
 name_  | character varying(255) |           | extended |              | 
 club_  | bigint                 | not null  | plain    |              | 
Indexes:
    "sporter2_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_pg686i5419bhdfxmrhtxw7etk" FOREIGN KEY (club_) REFERENCES club2(id_)

foo=> \d+ club2
                                Table "public.club2"
 Column |          Type          | Modifiers | Storage  | Stats target | Description 
--------+------------------------+-----------+----------+--------------+-------------
 id_    | bigint                 | not null  | plain    |              | 
 name_  | character varying(255) |           | extended |              | 
Indexes:
    "club2_pkey" PRIMARY KEY, btree (id_)
Referenced by:
    TABLE "sporter2" CONSTRAINT "fk_pg686i5419bhdfxmrhtxw7etk" FOREIGN KEY (club_) REFERENCES club2(id_)


/ 13	. 

/ many-to-one, unidir , join table	,

/ Lees	, 
https://docs.jboss.org/hibernate/orm/3.6/reference/en-US/html/associations.html#assoc-unidirectional-m21
/ Address is als Sporter, Person als Club	,

<class name="Sporter" table="sporter2" >
	<id name="id" column="id_" >	
		<generator class="increment"/>
	</id>
	<property name="name" column="name_" />
	<join table="sporter2_club2">
		<key column="sporter_"/>										/ pk in join table	, fk naar sporter2.id_ 
		<many-to-one name="club" column="club_" not-null="true" />			/ fk in join table,	 naar club2.id_	, let op name attr uit Sporter class	, 
																				/ WH omdat name="club" , Sporter.club is van type Club	, dus weet hij dat hij 
																				/ naar de club2 table moet	, nl naar club2.id_ 
	</join>
</class>

<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
    <property name="name" column="name_" />
</class>

foo=> \d+ sporter2
                               Table "public.sporter2"
 Column |          Type          | Modifiers | Storage  | Stats target | Description 
--------+------------------------+-----------+----------+--------------+-------------
 id_    | bigint                 | not null  | plain    |              | 
 name_  | character varying(255) |           | extended |              | 
Indexes:
    "sporter2_pkey" PRIMARY KEY, btree (id_)
Referenced by:
    TABLE "sporter2_club2" CONSTRAINT "fk_k9s18sb49y06jafv9mh8o80ic" FOREIGN KEY (sporter_) REFERENCES sporter2(id_)

foo=> \d+ club2
                                Table "public.club2"
 Column |          Type          | Modifiers | Storage  | Stats target | Description 
--------+------------------------+-----------+----------+--------------+-------------
 id_    | bigint                 | not null  | plain    |              | 
 name_  | character varying(255) |           | extended |              | 
Indexes:
    "club2_pkey" PRIMARY KEY, btree (id_)
Referenced by:
    TABLE "sporter2_club2" CONSTRAINT "fk_sub3kr63elnc77jil3u5tuna1" FOREIGN KEY (club_) REFERENCES club2(id_)

foo=> \d+ sporter2_club2
                    Table "public.sporter2_club2"
  Column  |  Type  | Modifiers | Storage | Stats target | Description 
----------+--------+-----------+---------+--------------+-------------
 sporter_ | bigint | not null  | plain   |              | 
 club_    | bigint | not null  | plain   |              | 
Indexes:
    "sporter2_club2_pkey" PRIMARY KEY, btree (sporter_)						/ pk	, een sporter kan maar in 1 club	, sporter_ has unique constraint	, 
Foreign-key constraints:
    "fk_k9s18sb49y06jafv9mh8o80ic" FOREIGN KEY (sporter_) REFERENCES sporter2(id_)
    "fk_sub3kr63elnc77jil3u5tuna1" FOREIGN KEY (club_) REFERENCES club2(id_)

$ vi Main6_1.java

			session = sessionFactory.openSession();
			PersistenceContext context=((SessionImplementor)session).getPersistenceContext();

		  	Sporter sporter=new Sporter("Sporter");
		  	Club club=new Club("Club");
		  	sporter.setClub(club);
		  	
		  	Sporter sporter2=new Sporter("Sporter2");
		  	sporter2.setClub(club);

		  	session.save(club); // moet eerst, 
		  	session.save(sporter);// anders hier TransientPropertyValueException
		  	session.save(sporter2);// anders hier TransientPropertyValueException

		  	session.flush();
		  	session.beginTransaction().commit();

		  	session3=sessionFactory.openSession();
			PersistenceContext context3=((SessionImplementor)session3).getPersistenceContext();
		  	sporter=(Sporter)session3.get(Sporter.class, 1l);
		  	club=sporter.getClub();
		  	session3.close();
		  	String name=club.getName(); // LazyInitializationException	, ook bij deze mapping	, 


foo=> select*from sporter2;
 id_ |  name_   
-----+----------
   1 | Sporter
   2 | Sporter2
(2 rows)

foo=> select*from club2
foo-> ;
 id_ | name_ 
-----+-------
   1 | Club
(1 row)

foo=> select*from sporter2_club2;
 sporter_ | club_ 
----------+-------
        1 |     1
        2 |     1
(2 rows)

/ 13	. 

/ one-to-many , unidir	, 

/ we zien nu GEEN LazyInitializationException	, maar een NullPointerException	, 
/ TODO

/ 

<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
 
    <property name="name" column="name_" />
    
    <set name="sporters" >
    	<key column="club_"/>				/ fk in sporter2 table	, het gaat hier over Sporters, dus dat klopt wel, 
															/ maar hierboven in de join table was key een pk	, maar inderdaad ook een fk	,
/ TODO
    	<one-to-many class="Sporter"/>
    </set>
</class>

<class name="Sporter" table="sporter2" >
    <id name="id" column="id_" >
        <generator class="increment"/>
    </id>
    <property name="name" column="name_" />
</class>

/ we zien	, 

foo=>  \d club2
            Table "public.club2"
 Column |          Type          | Modifiers 
--------+------------------------+-----------
 id_    | bigint                 | not null
 name_  | character varying(255) | 
Indexes:
    "club2_pkey" PRIMARY KEY, btree (id_)
Referenced by:
    TABLE "sporter2" CONSTRAINT "fk_pg686i5419bhdfxmrhtxw7etk" FOREIGN KEY (club_) REFERENCES club2(id_)

foo=> \d sporter2
           Table "public.sporter2"
 Column |          Type          | Modifiers 
--------+------------------------+-----------
 id_    | bigint                 | not null
 name_  | character varying(255) | 
 club_  | bigint                 | 
Indexes:
    "sporter2_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_pg686i5419bhdfxmrhtxw7etk" FOREIGN KEY (club_) REFERENCES club2(id_)

foo=> select*from club2;
 id_ | name_ 
-----+-------
   1 | Club
(1 row)

foo=> select*from sporter2;
 id_ |  name_   | club_ 
-----+----------+-------
   2 | Sporter2 |     1
   1 | Sporter  |     1
(2 rows)

/ 13	. 

/ one-to-many, bidir	, met 






/ 13	. 

/ many-to-one, bidir,  

/ we zien LazyInitializationException	,

<class name="Sporter" table="sporter2" >
    <id name="id" column="id_" >
        <generator class="increment"/>
    </id>
    <property name="name" column="name_" />
    <many-to-one name="club" column="club_" not-null="true" />
</class>

<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
 
    <property name="name" column="name_" />
    
    <set name="sporters" inverse="true">
    	<key column="club_"/>					/ adds fk aan de andere kant als er nog niet is	, klopt, het gaat hier over sporters	, letterlijk zien	,
																				/ club_ is column in sporters2	, 
    	<one-to-many class="Sporter"/>
    </set>
</class>

foo=> \d sporter2
           Table "public.sporter2"
 Column |          Type          | Modifiers 
--------+------------------------+-----------
 id_    | bigint                 | not null
 name_  | character varying(255) | 
 club_  | bigint                 | not null
Indexes:
    "sporter2_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_pg686i5419bhdfxmrhtxw7etk" FOREIGN KEY (club_) REFERENCES club2(id_)

foo=> \d club2
            Table "public.club2"
 Column |          Type          | Modifiers 
--------+------------------------+-----------
 id_    | bigint                 | not null
 name_  | character varying(255) | 
Indexes:
    "club2_pkey" PRIMARY KEY, btree (id_)

/ 1313	. 

/ we doen het expres fout	, 

<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
 
    <property name="name" column="name_" />
    
    <set name="sporters" inverse="true">
    	<key column="id_"/>									/ maakt fk aan de andere kant	, WH door inverse="true"	, 
																/ id_ is bestaande column aan andere kant	,
    	<one-to-many class="Sporter"/>
    </set>
</class>

foo=> \d sporter2
           Table "public.sporter2"
 Column |          Type          | Modifiers 
--------+------------------------+-----------
 id_    | bigint                 | not null
 name_  | character varying(255) | 
 club_  | bigint                 | not null
Indexes:
    "sporter2_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_f6sonuhkyt8sds19fgulakstu" FOREIGN KEY (id_) REFERENCES club2(id_)							<- heeft hij create	, en is niet de bedoeling	,
    "fk_pg686i5419bhdfxmrhtxw7etk" FOREIGN KEY (club_) REFERENCES club2(id_)

foo=> \d club2
            Table "public.club2"
 Column |          Type          | Modifiers 
--------+------------------------+-----------
 id_    | bigint                 | not null
 name_  | character varying(255) | 
Indexes:
    "club2_pkey" PRIMARY KEY, btree (id_)

foo=> \d+ sporter2_club2
                    Table "public.sporter2_club2"
  Column  |  Type  | Modifiers | Storage | Stats target | Description 
----------+--------+-----------+---------+--------------+-------------
 sporter_ | bigint | not null  | plain   |              | 
 club_    | bigint | not null  | plain   |              | 
Indexes:
    "sporter2_club2_pkey" PRIMARY KEY, btree (sporter_)
Foreign-key constraints:
    "fk_k9s18sb49y06jafv9mh8o80ic" FOREIGN KEY (sporter_) REFERENCES sporter2(id_)
    "fk_sub3kr63elnc77jil3u5tuna1" FOREIGN KEY (club_) REFERENCES club2(id_)

/	1313	. 

/ ook expres fout

/ we zien LazyInitializationException	, 

<class name="Sporter" table="sporter2" >
    <id name="id" column="id_" >
        <generator class="increment"/>
    </id>
    <property name="name" column="name_" />
    
    <!--  many-to-one undir, bidir -->
    <many-to-one name="club" column="club_" not-null="true" />

<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
 
    <property name="name" column="name_" />
    
       <set name="sporters" inverse="true">
    	<key column="club2_"/>							<- club2_ ipv club_	,
    	<one-to-many class="Sporter"/>
    </set>

/ we zien	, 

foo=> \d sporter2
           Table "public.sporter2"
 Column |          Type          | Modifiers 
--------+------------------------+-----------
 id_    | bigint                 | not null
 name_  | character varying(255) | 
 club_  | bigint                 | not null
 club2_ | bigint                 | 
Indexes:
    "sporter2_pkey" PRIMARY KEY, btree (id_)
Foreign-key constraints:
    "fk_l90ijdxmt7kxcegyx7chv9xi2" FOREIGN KEY (club2_) REFERENCES club2(id_)
    "fk_pg686i5419bhdfxmrhtxw7etk" FOREIGN KEY (club_) REFERENCES club2(id_)

foo=> select*from club2;
 id_ | name_ 
-----+-------
   1 | Club
(1 row)

foo=> select*from sporter2;
 id_ |  name_   | club_ | club2_ 
-----+----------+-------+--------
   1 | Sporter  |     1 |   NULL
   2 | Sporter2 |     1 |   NULL
(2 rows)

/ MORGENOCHTEND 2017-04-15	, 


/ 13	. 

/ many-to-one, bidir , join table

/ we doen het eerst expres fout	,

/ we noemen de join table sporter2_club2	, en de set  sporters2_club2	, 
/ we noemen de columns in de join club_ en sporter_ en in de set alter_club_ en alter_sporter 

/ inverse="true" geeft WH geen pk	?
/ TODO

<class name="Sporter" table="sporter2" >
    <id name="id" column="id_" >
        <generator class="increment"/>
    </id>
    <property name="name" column="name_" />
    <join table="sporter2_club2">					/ join is onveranderd	, logisch	, was toen ook een join table	,
       	<key column="sporter_"/>									/ sporter_ is column in join tbl	, we zijn in tbl sporter2	, dus weet hij dat dit fk is
																			/ naar sporter2.id_
      	<many-to-one name="club" column="club_" not-null="true" />	/ club_ is column in join tbl	, door name="club"  weet hij omdat Sporter.club van type Club
																						/ dat dit een fk is naar club2.id_	,
   	</join>
</class>


<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
    <property name="name" column="name_" />
																		/////////////////////////////////////////
    <set name="sporters" inverse="true" table="sporters2_club2">		/ set is veranderd: table attr	, en many-to-one heeft column attr	,	
																		
    	<key column="alter_club_"/>													/ add fk aan de andere kant, als er nog niet is	, vanwege inverse="true" 
																					/ de column is nu in join table	,
    	<many-to-many class="Sporter" column="alter_sporter_"/>						/ adds fk aan de andere kant, als er nog niet is	, vanwege inverse="true" 
																					/ de column is nu in join table	,
    </set>
</class>

/ we zien	, 

HibernateLog --> 15:02:45 DEBUG org.hibernate.SQL - create table sporter2_club2 (sporter_ int8 not null, club_ int8 not null, primary key (sporter_))
Hibernate: create table sporter2_club2 (sporter_ int8 not null, club_ int8 not null, primary key (sporter_))
HibernateLog --> 15:02:45 DEBUG org.hibernate.SQL - create table sporters2_club2 (alter_club_ int8 not null, alter_sporter_ int8 not null)
Hibernate: create table sporters2_club2 (alter_club_ int8 not null, alter_sporter_ int8 not null)
HibernateLog --> 15:02:45 DEBUG org.hibernate.SQL - alter table sporter2_club2 add constraint FK_k9s18sb49y06jafv9mh8o80ic foreign key (sporter_) references sporter2
Hibernate: alter table sporter2_club2 add constraint FK_k9s18sb49y06jafv9mh8o80ic foreign key (sporter_) references sporter2
HibernateLog --> 15:02:45 DEBUG org.hibernate.SQL - alter table sporter2_club2 add constraint FK_sub3kr63elnc77jil3u5tuna1 foreign key (club_) references club2
Hibernate: alter table sporter2_club2 add constraint FK_sub3kr63elnc77jil3u5tuna1 foreign key (club_) references club2
HibernateLog --> 15:02:45 DEBUG org.hibernate.SQL - alter table sporters2_club2 add constraint FK_tcw904ks8a586jpwi3vdh54k2 foreign key (alter_sporter_) references sporter2
Hibernate: alter table sporters2_club2 add constraint FK_tcw904ks8a586jpwi3vdh54k2 foreign key (alter_sporter_) references sporter2
HibernateLog --> 15:02:45 DEBUG org.hibernate.SQL - alter table sporters2_club2 add constraint FK_acxf9hud28xwcfo9e8a97nu01 foreign key (alter_club_) references club2
Hibernate: alter table sporters2_club2 add constraint FK_acxf9hud28xwcfo9e8a97nu01 foreign key (alter_club_) references club2

foo=> \d+ sporter2_club2
                    Table "public.sporter2_club2"
  Column  |  Type  | Modifiers | Storage | Stats target | Description 
----------+--------+-----------+---------+--------------+-------------
 sporter_ | bigint | not null  | plain   |              | 
 club_    | bigint | not null  | plain   |              | 
Indexes:
    "sporter2_club2_pkey" PRIMARY KEY, btree (sporter_)
Foreign-key constraints:
    "fk_k9s18sb49y06jafv9mh8o80ic" FOREIGN KEY (sporter_) REFERENCES sporter2(id_)
    "fk_sub3kr63elnc77jil3u5tuna1" FOREIGN KEY (club_) REFERENCES club2(id_)
Has OIDs: no

foo=> \d+ sporters2_club2
                       Table "public.sporters2_club2"
     Column     |  Type  | Modifiers | Storage | Stats target | Description 
----------------+--------+-----------+---------+--------------+-------------
 alter_club_    | bigint | not null  | plain   |              | 
 alter_sporter_ | bigint | not null  | plain   |              | 
Foreign-key constraints:																		/ geen pk	,
    "fk_acxf9hud28xwcfo9e8a97nu01" FOREIGN KEY (alter_club_) REFERENCES club2(id_)
    "fk_tcw904ks8a586jpwi3vdh54k2" FOREIGN KEY (alter_sporter_) REFERENCES sporter2(id_)
Has OIDs: no

/ Is er in deze tbl geen pk , vanwege inverse="true"	?
/ TODO


foo=> select*from  sporter2_club2;
 sporter_ | club_ 
----------+-------
        1 |     1
        2 |     1
(2 rows)

foo=> select*from  sporters2_club2;
 alter_club_ | alter_sporter_ 
-------------+----------------
(0 rows)

/ 13	. 

/ Nu noemen we de join en set gelijk	, sporter2_club2	, maar nog wel de columns in de set alter_club_ en alter_sporter_	, 

/ WH use we key als ref naar self	, en many-to-one bijv als naar een ander	, 
/ dus <key column="sporter_"/> staat in <class name="Sporter" table="sporter2" >	, 
/ als inverse="true" , is key geen pk, alleen fk	,
/ het maakt niet uit in welke tbl hij staat	, want <key column="alter_club_"/> staat in <class name="Club" table="club2" >	,  maar is fk naar club2.id_ in de join tbl	, en <key column="sporter_"/> in <class name="Sporter" table="sporter2" > is ook in join table en is fk naar sporter2.id_	, en is ook pk in de join table	, want is niet inverse="true"	,
/ om dezelfde reden moeten we in <many-to-one name="club" ... /> een name attr	, want dan weet H. het type	, en in waarnaar de fk moet point	,

/ in many-to-one staat name="club"	, in many-to-many class="Sporter"	, 
/ in beide gevallen gaat hij blijkbaar op zoek naar <id/>
/ TODO 

/ Dan ERR	,

<class name="Sporter" table="sporter2" >
    <id name="id" column="id_" >
        <generator class="increment"/>
    </id>
    <property name="name" column="name_" />
    <join table="sporter2_club2">
       	<key column="sporter_"/>
      	<many-to-one name="club" column="club_" not-null="true" />
   	</join>

</class>

<class name="Club" table="club2" >
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
 
    <property name="name" column="name_" />
    
    <set name="sporters" inverse="true" table="sporter2_club2">
    	<key column="alter_club_"/>
    	<many-to-many class="Sporter" column="alter_sporter_"/>
    </set>
</class>

HibernateLog --> 15:11:31 DEBUG org.hibernate.SQL - create table sporter2_club2 (sporter_ int8 not null, club_ int8 not null, alter_club_ int8 not null, alter_sporter_ int8 not null, primary key (sporter_))
Hibernate: create table sporter2_club2 (sporter_ int8 not null, club_ int8 not null, alter_club_ int8 not null, alter_sporter_ int8 not null, primary key (sporter_))
HibernateLog --> 15:11:31 DEBUG org.hibernate.SQL - alter table sporter2_club2 add constraint FK_k9s18sb49y06jafv9mh8o80ic foreign key (sporter_) references sporter2
Hibernate: alter table sporter2_club2 add constraint FK_k9s18sb49y06jafv9mh8o80ic foreign key (sporter_) references sporter2
HibernateLog --> 15:11:31 DEBUG org.hibernate.SQL - alter table sporter2_club2 add constraint FK_sub3kr63elnc77jil3u5tuna1 foreign key (club_) references club2
Hibernate: alter table sporter2_club2 add constraint FK_sub3kr63elnc77jil3u5tuna1 foreign key (club_) references club2
HibernateLog --> 15:11:31 DEBUG org.hibernate.SQL - alter table sporter2_club2 add constraint FK_gv4guq7u5cto4374k0uuxd5fg foreign key (alter_sporter_) references sporter2
Hibernate: alter table sporter2_club2 add constraint FK_gv4guq7u5cto4374k0uuxd5fg foreign key (alter_sporter_) references sporter2
HibernateLog --> 15:11:31 DEBUG org.hibernate.SQL - alter table sporter2_club2 add constraint FK_rg150p5u80knmw4exvo0utk17 foreign key (alter_club_) references club2
Hibernate: alter table sporter2_club2 add constraint FK_rg150p5u80knmw4exvo0utk17 foreign key (alter_club_) references club2
...
HibernateLog --> 15:11:31 ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - ERROR: null value in column "alter_club_" violates not-null constraint
  Detail: Failing row contains (1, 1, null, null).

foo=> \d+ sporter2_club2
                       Table "public.sporter2_club2"
     Column     |  Type  | Modifiers | Storage | Stats target | Description 
----------------+--------+-----------+---------+--------------+-------------
 sporter_       | bigint | not null  | plain   |              | 
 club_          | bigint | not null  | plain   |              | 
 alter_club_    | bigint | not null  | plain   |              | 
 alter_sporter_ | bigint | not null  | plain   |              | 
Indexes:
    "sporter2_club2_pkey" PRIMARY KEY, btree (sporter_)
Foreign-key constraints:
    "fk_gv4guq7u5cto4374k0uuxd5fg" FOREIGN KEY (alter_sporter_) REFERENCES sporter2(id_)
    "fk_k9s18sb49y06jafv9mh8o80ic" FOREIGN KEY (sporter_) REFERENCES sporter2(id_)
    "fk_rg150p5u80knmw4exvo0utk17" FOREIGN KEY (alter_club_) REFERENCES club2(id_)
    "fk_sub3kr63elnc77jil3u5tuna1" FOREIGN KEY (club_) REFERENCES club2(id_)

/ 13	. 

/ we hebben net als in scs	, CustomerOrderTrigger en TriggerAction	, 

/ undir many-to-many	,

/ nu WEL pk bij set	, omdat we NIET inverse="true"

/ Toch ook ERR	, aan het eind TODO

<class name="Sporter" table="sporter2" >						/ TriggerAction
    <id name="id" column="id_" >
        <generator class="increment"/>
    </id>
    <property name="name" column="name_" />

</class>

<class name="Club" table="club2" >								/ CustomerOrderTrigger
    <id name="id" column="id_" >
        <generator class="increment"/> 
    </id>
 
    <property name="name" column="name_" />
    
    <set name="sporters" table="sporter2_club2">				/ NIET inverse="true"
    	<key column="alter_club_"/>
    	<many-to-many class="Sporter" column="alter_sporter_"/>
    </set>
</class>

/ we zien	, 

foo=> \d+ sporter2_club2
                       Table "public.sporter2_club2"
     Column     |  Type  | Modifiers | Storage | Stats target | Description 
----------------+--------+-----------+---------+--------------+-------------
 alter_club_    | bigint | not null  | plain   |              | 
 alter_sporter_ | bigint | not null  | plain   |              | 
Indexes:
    "sporter2_club2_pkey" PRIMARY KEY, btree (alter_club_, alter_sporter_)		/ nu wel pk	, WH omdat NIET inverse="true"
Foreign-key constraints:
    "fk_gv4guq7u5cto4374k0uuxd5fg" FOREIGN KEY (alter_sporter_) REFERENCES sporter2(id_)
    "fk_rg150p5u80knmw4exvo0utk17" FOREIGN KEY (alter_club_) REFERENCES club2(id_)


/ Toch ERR	,
java.lang.NullPointerException
	at my.test.own.hibernate_xml_N_1_bidir_a.Main6_1.testBasicUsage(Main6_1.java:118)
	at my.test.own.hibernate_xml_N_1_bidir_a.Main6_1.<init>(Main6_1.java:54)
	at my.test.own.hibernate_xml_N_1_bidir_a.Main6_1.main(Main6_1.java:48)
/ TODO Afmaken	,

/ Einde EXERCISES LAZYINITIALIZATIONEXCEPTION

/ JAVASSIST

/ 13	. 

/ google: javassist handler target
/ Lees	, 
http://stackoverflow.com/questions/26165188/hibernate-entity-proxy-initialization

Hibernate uses Proxies to intercept calls to LAZY entities. That structure you see in debug is how a Proxy looks like.		

You don't need to call HibernateUtil.initialize, but simply use "fetch joins" to load all entities you are interested in a single query.

If the entity is attached to the current Session, the dirty checking mechanism will automatically translate all entity state transitions to database DML statements.

Session.update is meant to re-attach detached entities (entities that were loaded in a Session that's been closed).

Session.merge is for copying the entity state onto an already loaded entity (which is loaded on the fly, if not loaded previously).

Check if you have enabled transactions, as otherwise you can only select entities. For persist/merge and dirty checking updates you must use transactions (use Java EE or Spring @Transactional support).


/ 13	. 

/ Lees	, 
http://stackoverflow.com/questions/17431312/difference-between-join-and-join-fetch-in-hibernate

For example, if we have these two queries

FROM Employee emp
JOIN emp.department dep
and

FROM Employee emp
JOIN FETCH emp.department dep

But, the difference is: in the first query you are returning only the Employes for the Hibernate. In the second query, you are returning the Employes and all Departments associated.
You can use the second query when you are sure that you will need the Department of each Employee. If you not need the Department, use the first query.

f you don't use fetch and the Departments continue to be returned, is because your mapping between Employee and Department (a @OneToMany) are setted with FetchType.EAGER. In this case, any HQL (with fetch or not) query with FROM Employee will bring all Departments. Remember that all mapping *ToOne (@ManyToOne and @OneToOne) are EAGER by default.
/ -> 
http://stackoverflow.com/questions/5816417/how-to-properly-express-jpql-join-fetch-with-where-clause-as-jpa-2-criteriaq

/ 13	. 

/ Lees  ,
https://coderanch.com/t/615081/databases/Hibernate-handler-target

1. Hibernate objects that are lazily initialized are managed by javaassist (or cglib for older versions) proxy objects. Basically what happens is the proxy is generated by sub-classing your object. When a lazy initialized object becomes initialized the handler.target updates to reflect the initialized properties.

2. The reason you are having problems is because instance of does not work on the proxy object. This is a problem you will have with lazy loaded objects that are part of a type hierarchy. You have a couple options:

2a. Eagerly fetch the object
2b. Try de-proxying the object

public static <T> T unproxy(T entity) {
       if (entity == null) {
           return null;
       }

       if (entity instanceof HibernateProxy) {
           Hibernate.initialize(entity);
           entity = (T) ((HibernateProxy) entity).getHibernateLazyInitializer().getImplementation();
       }

       return entity;
   }
}

/ Einde JAVASSIST

/ WITH SPRING

/ Lees	,
https://www.intertech.com/Blog/spring-4-meta-annotations/



/ Einde WITH SPRING
