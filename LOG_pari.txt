/ INSTALL

/ Lees	, 
http://pari.math.u-bordeaux.fr/download.html

[eric@almond Devel]$ dnf list installed "*readline*"
Last metadata expiration check: 17 days, 11:01:26 ago on Thu Jun 22 21:47:37 2017.
Installed Packages
readline.x86_64                                                   6.3-6.fc23                                          @@commandline    
readline-debuginfo.x86_64                                         6.3-6.fc23                                          @fedora-debuginfo
readline-devel.x86_64                                             6.3-6.fc23                                          @fedora          

[eric@almond Devel]$ dnf list installed "*gmp*"
Last metadata expiration check: 17 days, 11:01:54 ago on Thu Jun 22 21:47:37 2017.
Installed Packages
gmp.x86_64                                                   1:6.0.0-12.fc23                                              @@commandline
gmp-devel.x86_64                                             1:6.0.0-12.fc23                                              @fedora      

[eric@almond Devel]$ dnf list available "*pari*"
Last metadata expiration check: 17 days, 11:02:23 ago on Thu Jun 22 21:47:37 2017.
Available Packages
pari.x86_64                                                         2.7.5-1.fc23                                                updates
pari-devel.x86_64                                                   2.7.5-1.fc23                                                updates
pari-elldata.noarch                                                 20140113-3.fc23                                             fedora 
pari-galdata.noarch                                                 20080411-8.fc23                                             fedora 
pari-galpol.noarch                                                  20140218-3.fc23                                             fedora 
pari-gp.x86_64                                                      2.7.5-1.fc23                                                updates
pari-seadata.noarch                                                 20090618-8.fc23                                             fedora 

/ Maar we proberen de src te install	,

[eric@almond Math]$ pwd
/home/eric/Devel/Math
[eric@almond Math]$ tar xvzf ~/Downloads/pari-2.9.2.tar.gz 

/ 13	. 

[eric@almond pari-2.9.2]$ pwd
/home/eric/Devel/Math/pari-2.9.2

[eric@almond pari-2.9.2]$ ./Configure   -g 
Configuring pari-2.9.2 (STABLE) 
Checking echo to see how to suppress newlines...
...using -n.
Looking for some tools first ...
...gzip is /usr/bin/gzip
...cc is /usr/bin/cc
...gcc is /usr/bin/gcc
...ld is /usr/bin/ld
...perl is /usr/bin/perl
...zcat is /usr/bin/zcat
Choosing C compiler ...
GNU compatible compiler: gcc version 5.3.1 20151207 (Red Hat 5.3.1-2) (GCC)
Using mt engine single
Given the previous choices, sizeof(long) is 8 chars.
The internal word representation of a double is not needed (64bit).
==========================================================================
Building for: amd64 running linux (x86-64/GMP kernel) 64-bit version
==========================================================================
C compiler is          /usr/bin/gcc -DMEMSTEP=1048576 -g -Wall    -fPIC
Executable linker is   /usr/bin/gcc  -DMEMSTEP=1048576 -g -Wall    -Wl,--export-dynamic 
Dynamic Lib linker is  /usr/bin/gcc  -shared  $(CFLAGS) $(DLCFLAGS) -Wl,-shared,-soname=$(LIBPARI_SONAME) 
Looking in C lib for some symbols...
...Found exp2.
...Found log2.
...Found strftime.
...Found getrusage.
...Found gettimeofday.
...Found sigaction.
...Found TIOCGWINSZ.
...Found getrlimit.
...Found stat.
...Found vsnprintf.
...Found mmap.
...Found waitpid.
...Found setsid.
...Found getenv.
...Found isatty.
...Found alarm.
...Found system.
...I did not find dlopen.
Try again, with -ldl this time...
...Found dlopen.
Checking for optional libraries and headers...
Using GNU MP, version 6.0.0
...Found X11 header files in /usr/include/X11
...X11 libraries: -lX11 
Hi-Res Graphics: X11
Using GNU readline, version 6.3
Installation prefix ? [/usr/local]
...for architecture-independent files (share-prefix) ? [/usr/local/share]
Installation directories for:
...executables (gp, gphelp) ? [/usr/local/bin]
...libraries (libpari) ? [/usr/local/lib]
...include files ? [/usr/local/include]
...manual pages ? [/usr/local/share/man/man1]
...other system-dependent data ? [/usr/local/lib/pari]
...other system-independent data ? [/usr/local/share/pari]
Default is static executable and archive library
==========================================================================
Extracting examples/Makefile.linux-x86_64
Extracting Olinux-x86_64.dbg/Makefile
Extracting Olinux-x86_64.dbg/paricfg.h
Extracting Makefile
Extracting scripts and macros
...in doc
...in misc
==========================================================================
Shall we try to build pari 2.9.2 (released) now (y/n)? [n]
Ok. Type "cd Olinux-x86_64.dbg; make install" when you are ready
Bye !

/ 13	. 

/ als we GEEN -g	, 
$ ./Configure
...
C compiler is          /usr/bin/gcc -O3 -Wall -fno-strict-aliasing -fomit-frame-pointer    -fPIC
Executable linker is   /usr/bin/gcc  -O3 -Wall -fno-strict-aliasing -fomit-frame-pointer    -Wl,--export-dynamic 
Dynamic Lib linker is  /usr/bin/gcc  -shared  $(CFLAGS) $(DLCFLAGS) -Wl,-shared,-soname=$(LIBPARI_SONAME) 

/ 13	. 

/ Als we --prefix	, 
[eric@almond pari-2.9.2]$ ./Configure  --prefix=$(pwd)-build
Installation directories for:
...executables (gp, gphelp) ? [/home/eric/Devel/Math/pari-2.9.2-build/bin]
...libraries (libpari) ? [/home/eric/Devel/Math/pari-2.9.2-build/lib]
...include files ? [/home/eric/Devel/Math/pari-2.9.2-build/include]
...manual pages ? [/home/eric/Devel/Math/pari-2.9.2-build/share/man/man1]
...other system-dependent data ? [/home/eric/Devel/Math/pari-2.9.2-build/lib/pari]
...other system-independent data ? [/home/eric/Devel/Math/pari-2.9.2-build/share/pari]

/ 13	. 

[eric@almond pari-2.9.2]$ pwd
/home/eric/Devel/Math/pari-2.9.2

[eric@almond Math]$ tar xvzf ~/Downloads/pari-2.9.2.tar.gz 
[eric@almond Math]$ cd pari-2.9.2 
[eric@almond pari-2.9.2]$ ls
AUTHORS  CHANGES-2.2  CHANGES-2.6  COMPAT  Configure  doc       INSTALL   misc  README      src
CHANGES  CHANGES-2.4  CHANGES-2.8  config  COPYING    examples  MACHINES  NEW   README-git

[eric@almond pari-2.9.2]$ ./Configure  -g --prefix=/home/eric/Devel/Math/pari-2.9.2-build
...
Extracting examples/Makefile.linux-x86_64
Extracting Olinux-x86_64.dbg/Makefile
Extracting Olinux-x86_64.dbg/paricfg.h
Extracting Makefile
Extracting scripts and macros
...in doc
...in misc

[eric@almond pari-2.9.2]$ ls
AUTHORS  CHANGES-2.2  CHANGES-2.6  COMPAT  Configure  doc       INSTALL   Makefile  NEW                README      src
CHANGES  CHANGES-2.4  CHANGES-2.8  config  COPYING    examples  MACHINES  misc      Olinux-x86_64.dbg  README-git

/ er is een dir create	,
[eric@almond pari-2.9.2]$ ls Olinux-x86_64.dbg/
config.log  Makefile  pari.cfg  paricfg.h

[eric@almond pari-2.9.2]$ cd Olinux-x86_64.dbg/
[eric@almond Olinux-x86_64.dbg]$ make all | tee LOG_make_all.txt
[eric@almond Olinux-x86_64.dbg]$ make bench | tee LOG_make_bench.txt
[eric@almond Olinux-x86_64.dbg]$ make install | tee LOG_make_install.txt

$ PATH=$PATH:/home/eric/Devel/Math/pari-2.9.2-build/bin
$ gp
Reading GPRC: /home/eric/.gprc ...Done.

                                              GP/PARI CALCULATOR Version 2.9.2 (released)
                               amd64 running linux (x86-64/GMP-6.0.0 kernel) 64-bit version -- debugging
                               compiled: Jul 10 2017, gcc version 5.3.1 20151207 (Red Hat 5.3.1-2) (GCC)
                                                       threading engine: single
                                            (readline v6.3 enabled, extended help enabled)

                                                Copyright (C) 2000-2017 The PARI Group

PARI/GP is free software, covered by the GNU General Public License, and comes WITHOUT ANY WARRANTY WHATSOEVER.

Type ? for help, \q to quit.
Type ?15 for how to get moral (and possibly technical) support.

parisize = 8000000, primelimit = 500000
? ?
Help topics: for a list of relevant subtopics, type ?n for n in
   0: user-defined functions (aliases, installed and user functions)
   1: Standard monadic or dyadic OPERATORS
   2: CONVERSIONS and similar elementary functions
   3: TRANSCENDENTAL functions
   4: NUMBER THEORETICAL functions
   5: ELLIPTIC CURVES
   6: L-FUNCTIONS
   7: MODULAR SYMBOLS
   8: General NUMBER FIELDS
   9: Associative and central simple ALGEBRAS
  10: POLYNOMIALS and power series
  11: Vectors, matrices, LINEAR ALGEBRA and sets
  12: SUMS, products, integrals and similar functions
  13: GRAPHIC functions
  14: PROGRAMMING under GP
  15: The PARI community
Also:
  ? functionname (short on-line help)
  ?\             (keyboard shortcuts)
  ?.             (member functions)
Extended help (if available):
  ??             (opens the full user's manual in a dvi previewer)
  ??  tutorial / refcard / libpari (tutorial/reference card/libpari manual)
  ??  keyword    (long help text about "keyword" from the user's manual)
  ??? keyword    (a propos: list of related functions).
? 
? ?11
algdep           charpoly         concat           forqfvec         lindep           matadjoint       matcompanion
matconcat        matdet           matdetint        matdiagonal      mateigen         matfrobenius     mathess
mathilbert       mathnf           mathnfmod        mathnfmodid      mathouseholder   matid            matimage
matimagecompl    matindexrank     matintersect     matinverseimage  matisdiagonal    matker           matkerint
matmuldiagonal   matmultodiagonal matpascal        matqr            matrank          matrix           matrixqz
matsize          matsnf           matsolve         matsolvemod      matsupplement    mattranspose     minpoly
norml2           normlp           qfauto           qfautoexport     qfbil            qfeval           qfgaussred
qfisom           qfisominit       qfjacobi         qflll            qflllgram        qfminim          qfnorm
qforbits         qfparam          qfperfection     qfrep            qfsign           qfsolve          seralgdep
setbinop         setintersect     setisset         setminus         setsearch        setunion         trace
vecextract       vecsearch        vecsort          vecsum           vector           vectorsmall      vectorv

? ?algdep
algdep(z,k,{flag=0}): algebraic relations up to degree n of z, using lindep([1,z,...,z^(k-1)], flag).

? \q
[eric@almond Olinux-x86_64.dbg]$ ls
algebras.o      buch4.o           Flx.o           groupid.o             mellininv.o      parse.o          rootpol.o
alglin1.o       char.o            FlxqE.o         hash.o                members.o        part.o           single.o
alglin2.o       compile.o         Flxq_log.o      Hensel.o              modsym.o         perm.o           stark.o
alglin3.o       concat.o          forprime.o      hnf_snf.o             mpinl.h          plotport.o       subcyclo.o
anal.o          config.log        FpE.o           hyperell.o            mpinl.o          plottty.o        subfield.o
analyz-dyn.dif  crvwtors.o        FpV.o           ifactor1.o            mpker.c          plotX.o          subgroup.o
analyz-sta.dif  default.o         FpX_factor.o    init.o                mpker.o          polarit1.o       sumiter-dyn.dif
aprcl.o         dirichlet.o       FpX.o           intnum.o              mpqs.o           polarit2.o       sumiter.o
arith1.o        ellanal.o         FpXQX_factor.o  krasner.o             mt.o             polarit3.o       sumiter-sta.dif
arith2.o        elldata.o         FpXX.o          kummer.o              nffactor.o       polclass.o       texmacs.o
base1.o         ellfromeqn.o      galconj.o       lfun.o                nfields-dyn.dif  polmodular.o     thue.o
base2.o         elliptic-dyn.dif  galois.o        lfunutils.o           nfields-sta.dif  polyser-dyn.dif  trans1.o
base3.o         elliptic.o        galpol.o        libpari.a             number-dyn.dif   polyser-sta.dif  trans2.o
base4.o         elliptic-sta.dif  gen1.o          libpari-gmp.so.2.9.2  number-sta.dif   prime.o          trans3.o
base5.o         ellisog.o         gen2.o          libpari-gmp.so.5      objets-dyn.dif   program-dyn.dif  trans-dyn.dif
bb_group.o      ellsea.o          gen3.o          libpari.so            objets-sta.dif   program-sta.dif  trans-sta.dif
Bench-2.9.2     elltors.o         genus2red.o     linear-dyn.dif        pari.cfg         Qfb.o            volcano.o
bibli1.o        emacs.o           gp-dyn          linear-sta.dif        paricfg.h        qfisom.o         whatnow.o
bibli2.o        es.o              gplib.o         lll.o                 paricfg.o        qfsolve.o        zetamult.o
bit.o           eval.o            gp.o            LOG_make_all.txt      pariinl.o        QX_factor.o      ZG.o
bnflog.o        F2x.o             gp_rl.o         LOG_make_bench.txt    parilvl0.h       random.o         ZV.o
buch1.o         F2xqE.o           gp-sta          LOG_make_install.txt  parilvl1.h       readline.o       ZX.o
buch2.o         FF.o              graph-dyn.dif   Makefile              parimt.h         RgV.o
buch3.o         Fle.o             graph-sta.dif   map.o                 pari.ps          RgX.o

/ Lees	, 
$ less ~/.gprc

/ Einde INSTALL

/ TUTORIAL

/ Lees	,
[eric@almond wicket]$ evince ~/Documents/pari-gp/tutorial.pdf 


[eric@almond Olinux-x86_64.dbg]$ PATH=$PATH:/home/eric/Devel/Math/pari-2.9.2-build/bin
[eric@almond Olinux-x86_64.dbg]$  gp

/ 7	. 

break> \p 20
   realprecision = 38 significant digits (20 digits displayed)
break> \p 10
   realprecision = 19 significant digits (10 digits displayed)
break> \p 11
break> \p 20
   realprecision = 38 significant digits (20 digits displayed)
break> \p 11
   realprecision = 19 significant digits (11 digits displayed)

/ WH net als bij OpenSSL	, stukken van 19 digits	,

? Pi
%1 = 3.1415926535897932384626433832795028842
/ 38 digits	,



/ 7	. 

/ integers must be in absolute value less than 2^536870815 (i.e. roughly 161614219 decimal digits).
/ Maar op mijn machine haal ik dat niet	,

?  2^5368705
/ OK
/ als je 2^9999999 
8 = 
  ***   the PARI stack overflows !
  current stack size: 8000000 (7.629 Mbytes)
  [hint] set 'parisizemax' to a non-zero value in your GPRC

/ 13	. 

/ je kunt de stack size aanpassen	,
$ vi ~/.gprc
\\ Set PARI stack size to 10 Mbytes = 10^7 bytes
parisize = 10M

/ Dan kun je een grotere exponent nemen, maar nog geen 9999999	, 

/ 13	. 

/ we kunnen ook op de command line,	

[eric@almond bin]$ gp -s 100M
/ of	,
[eric@almond bin]$ gp -s 1G
parisize = 1000000000, primelimit = 500000

/ of	,
[eric@almond bin]$ gp --default parisize=10M

/ Wat is verschil	,
-s 100M
--default parisize=100M
/ TODO

/ 13	. 

? a=2^(-100)
%2 = 1/1267650600228229401496703205376		/ breuk dus	,
? a+0.
%3 = 7.888609052210118054 E-31
? a*1.
%4 = 7.8886090522101180541172856528278622967 E-31

/ 13	. 

/ lees	,
https://math.stackexchange.com/questions/1597599/how-to-create-a-matrix-in-pari-gp

break> v=vector(10,n,n^2)
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
break> p=2^v
[2.0000000000000000000000000000000000000, 16.000000000000000000000000000000000000, 512.00000000000000000000000000000000000, 65535.999999999999999999999999999999999, 33554432.000000000000000000000000000000, 68719476735.999999999999999999999999999, 562949953421311.99999999999999999999998, 18446744073709551615.999999999999999999, 2417851639229258349412351.9999999999996, 1267650600228229401496703205376.0000000]

break> type(v)
"t_VEC"
break> type(p)
"t_VEC"
break> v[4]
16
break> p[4]
65535.999999999999999999999999999999999
break> type(v[4])
"t_INT"
break> type(p[4])
"t_REAL"

/ TODO Waarom worden het reals	?

/ Ook kunnen we	,

break> matrix(3,3,n,m,n+m)

[2 3 4]

[3 4 5]

[4 5 6]

break> matrix(3,3,n,m,n^m)

[1 1  1]

[2 4  8]

[3 9 27]

/ 13	. 

/ als je wilt weten welke fcts er zijn, zoals 'type' 	, 

/
?  ?\
#       : enable/disable timer
##      : print time for last result
\\      : comment up to end of line
\a {n}  : print result in raw format (readable by PARI)
\B {n}  : print result in beautified format
\c      : list all commands (same effect as ?*)
\d      : print all defaults
\e {n}  : enable/disable echo (set echo=n)
\g {n}  : set debugging level
\gf{n}  : set file debugging level
\gm{n}  : set memory debugging level
\h {m-n}: hashtable information
\l {f}  : enable/disable logfile (set logfile=f)
\m {n}  : print result in prettymatrix format
\o {n}  : set output method (0=raw, 1=prettymatrix, 2=prettyprint, 3=2-dim)
\p {n}  : change real precision
\pb{n}  : change real bit precision
\ps{n}  : change series precision
\q      : quit completely this GP session
\r {f}  : read in a file
\s      : print stack information
\t      : print the list of PARI types
\u      : print the list of user-defined functions
\um     : print the list of user-defined member functions
\v      : print current version of GP
\w {nf} : write to a file
\x {n}  : print complete inner structure of result
\y {n}  : disable/enable automatic simplification (set simplify=n)

{f}=optional filename. {n}=optional integer

/ we zien dus dat we \c moeten doen	, 

? \c

Catalan                Col                    Colrev
Euler                  I                      List
...
truncate               type                   uninline
...

? ?* is ook OK	,

/ 13	. 

/ kijk	,
http://www.texmacs.org/tmweb/home/videos.en.html

/ er is ook	,

[eric@almond pari-2.9.2]$ dnf list available *texstudio*
Last metadata expiration check: 3:56:19 ago on Sun Dec 31 11:56:05 2017.
Available Packages
texstudio.x86_64                      2.11.0-1.fc23                      updates

/ kijk	,
https://www.youtube.com/watch?v=b4BWlVQGNPg


/ 1	. Greetings!

? 1/7
%4 = 1/7
? 1/7.
%5 = 0.14285714285714285714285714285714285714
? 1/7+0.
%7 = 0.14285714285714285714285714285714285714
/ 38 decimals	,

? exp(1)
%8 = 2.7182818284590452353602874713526624978

? log(exp(1))
%9 = 1.0000000000000000000000000000000000000

? pi
%10 = pi
? Pi
%11 = 3.1415926535897932384626433832795028842

? ?Pi
Pi=Pi(): the constant pi, with current precision.
? ?pi
pi: user defined variable

? ??pi
/ we zien een extra window	,

As well, if it says something like “readline enabled” then you should
have a look at the readline introduction in the User’s Manual before you go on: it will be much
easier to type in examples and correct typos after you’ve done that.
/ TODO

? exp(Pi * sqrt(163))
%14 = 262537412640768743.99999999999925007259
? \p 50
   realprecision = 57 significant digits (50 digits displayed)
? exp(Pi * sqrt(163))
%15 = 262537412640768743.99999999999925007259719818568888
? (log(%) / Pi)^2
%19 = 163.00000000000000000000000000000000000000000000000
/ OK, dus 262537412640768743.99999999999925007259 is OK, en is dus GEEN int	,

break[3]> whatnow(log)
This function did not change

/ we hadden  moeten doen	,
break> break
$ 
/ Nu zitten we al in break niveau 3:

? 1/0
  ***   at top-level: 1/0
  ***                  ^--
  *** _/_: impossible inverse in gdiv: 0.
  ***   Break loop: type 'break' to go back to GP prompt
break> 1/0
  ***   at top-level: 1/0
  ***                  ^--
  ***   in anonymous function: 1/0
  ***                           ^--
  *** _/_: impossible inverse in gdiv: 0.
  ***   Break loop: type 'break' to go back to GP prompt
break[2]> 
/ break niveau 2 


/ 1.4 is een imprecise number	,

break[3]> 1000!
402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

/ Intermezzo

/ 38 significant digits betekent 38 digits en de .	, dat zijn er 39	,
/ integers worden oneindig lang,	

break[3]> \p 38
   realprecision = 38 significant digits
break[3]> sqrt(2)
1.4142135623730950488016887242096980786
break[3]> sqrt(121)
11.000000000000000000000000000000000000
break[3]> 10.4^36
4103932553980414755285422013078708232.5
break[3]> 10.4^37
4.2680898561396313454968388936018565618 E37


[eric@almond wildfly]$ echo -n 1.4142135623730950488016887242096980786 | wc
      0       1      39
[eric@almond wildfly]$ echo -n 11.000000000000000000000000000000000000 | wc
      0       1      39
[eric@almond wildfly]$ echo -n 4103932553980414755285422013078708232.5 | wc
      0       1      39


/ Einde Intermezzo

> \p 38
break[3]> exp(100)
2.6881171418161354484126255515800135874 E43
/ we zien dus 39 chars: 38 digits en een .	, dus 37 decimals	achter de ., dus hier staat	,  
26881171418161354484126255515800135874000000 
/ dit zijn 44 digits	, dus exp(100) heeft 44 integer digits	,
/ het tellen van het aantal digits achter de . is niet nodig: 2.68.. e43 : de . gaat 43 plaatsen naar rechts, dus 44 digits	,

/ check	, 
break[3]> \p 50
   realprecision = 57 significant digits (50 digits displayed)
break[3]> exp(100)
26881171418161354484126255515800135873611118.773742
/ geen e notatie	,

? exp(100)
%6 = 2.6881171418161354484126255515800135874 E43
? \p 50
   realprecision = 57 significant digits (50 digits displayed)
? %
%8 = 2.68811714181613544841262555158001358736 E43												/ TODO
? exp(100)
%10 = 26881171418161354484126255515800135873611118.773742

/ wat is de precision?
? \p
   realprecision = 57 significant digits (50 digits displayed)

/ zo kan het ook	,
? default(realprecision)
%11 = 57

/ set de precision, kan ook zo	,
? default(realprecision, 38)
/ check	,
? default(realprecision)
%13 = 38

%13 = 38
? default
   TeXstyle = 0 (bits 0x2/0x4 control output of \left/\PARIbreak)
   breakloop = 1 (on)
   colors = "no, no, no, no, no, no, no"
   compatible = 0 (no backward compatibility)
   datadir = "/home/eric/Devel/Math/pari-2.9.2-build/share/pari"
   debug = 0
   debugfiles = 0
   debugmem = 0
   echo = 0 (off)
   factor_add_primes = 0 (off)
   factor_proven = 0 (off)
   format = g.38
   graphcolormap = ["white", "black", "blue", "violetred", "red", "green", "grey", "gainsboro"]
   graphcolors = [4, 5]
   help = ""/home/eric/Devel/Math/pari-2.9.2-build/bin/gphelp""
   histfile = "<undefined>"
   histsize = 5000
   lines = 0
   linewrap = 0
   log = 0 (off)
   logfile = "pari.log"
   nbthreads = 1
   new_galois_format = 0 (off)
   output = 1 (prettymatrix)
   parisize = 8000000
   parisizemax = 0
   path = ".:~:~/gp"
   prettyprinter = "tex2mail -TeX -noindent -ragged -by_par"
   primelimit = 500000
   prompt = "? "
   prompt_cont = ""
   psfile = "pari.ps"
   readline = 4 (bits 0x2/0x4 control matched-insert/arg-complete)
   realbitprecision = 128 significant bits (38 decimal digits displayed)
   realprecision = 38 significant digits
   recover = 1 (on)
   secure = 0 (off)
   seriesprecision = 16 significant terms
   simplify = 1 (on)
   sopath = ""
   strictargs = 0 (off)
   strictmatch = 1 (on)
   threadsize = 0
   threadsizemax = 0
   timer = 0 (off)

/ als je eerder	,
? \p 50
/ dan zie je onder
? default
   realprecision = 57 significant digits (50 digits displayed)


/ lees	,
/ menu links: Version control	,
https://pari.math.u-bordeaux.fr/git.html

 ?default
default({key},{val}): returns the current value of the default key. If val is present, set opt to val first. If no argument is given, 
print a list of all defaults as well as their values.
/ tussen {} is optional arg	,

 \p 38
? exp(1)
%17 = 2.7182818284590452353602874713526624978 E0
? default(format)
%18 = "e.38"
? default(realprecision)
%19 = 38

? \p 100
   realprecision = 115 significant digits (100 digits displayed)
? default(realprecision)
%20 = 115
? default(format)
%21 = "e.100"
? exp(1)
%22 = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427 E0
/ en	,
[eric@almond wildfly]$ echo -n 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427 | wc
      0       1     101
/ altijd 1 meer: .

? \p 40
   realprecision = 57 significant digits (40 digits displayed)
? default(realprecision)
%19 = 57
? default(format)
%20 = "g.40"
? exp(1)
%21 = 2.718281828459045235360287471352662497757
[eric@almond wildfly]$ echo -n 2.718281828459045235360287471352662497757 | wc
      0       1      41
/ 1 voor de .

? \p 100
   realprecision = 115 significant digits (100 digits displayed)
? exp(1)
%22 = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427
? \p 38
   realprecision = 38 significant digits
? exp(100)
%23 = 2.6881171418161354484126255515800135874 E43
? default(format)
%24 = "g.38"
? exp(1)
%25 = 2.7182818284590452353602874713526624978
? default(format,"g.39")
? exp(1)
%27 = 2.71828182845904523536028747135266249776
? default(format,"g.40")
? exp(1)
%29 = 2.71828182845904523536028747135266249776
/ preciezer wordt hij niet	,

/ 13	. 

? default
realprecision = 57 significant digits (50 digits displayed)
? default(format,"e0.100")
? exp(1)
%18 = 2.718281828459045235360287471352662497757247093699959574967 E0
? \p 38
   realprecision = 38 significant digits
? exp(1)
%19 = 2.7182818284590452353602874713526624978 E0
? default(format,"g100")
? exp(1)
%21 = 2.7182818284590452353602874713526624978
? \p 100
   realprecision = 115 significant digits (100 digits displayed)
? exp(1)
%22 = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427

/ \p 100 doet en precision and format	, default(format,...) doet alleen format	,

/ 13	. 

? \p 100
   realprecision = 115 significant digits (100 digits displayed)
? exp(100)
%33 = 26881171418161354484126255515800135873611118.77374192241519160861528028703490956491415887109721984571
? default(format)
%34 = "g.100"
? \p 38
   realprecision = 38 significant digits
? exp(100)
%35 = 2.6881171418161354484126255515800135874 E43
? exp(1)
%36 = 2.7182818284590452353602874713526624978
? default(format)
%37 = "g.38"
? default(format)
%37 = "g.38"
? default(format,"g.39")
? exp(100)
%39 = 2.68811714181613544841262555158001358736 E43
? exp(1)
%40 = 2.71828182845904523536028747135266249776
? default(format,"g.40")
? exp(100)
%42 = 2.68811714181613544841262555158001358736 E43
? exp(1)
%43 = 2.71828182845904523536028747135266249776
/ Hier komt er een digit bij als we g.39 en hoger, 

/ 13	. 

/ uit break loop met break	,

? 1/0
  ***   at top-level: 1/0
  ***                  ^--
  *** _/_: impossible inverse in gdiv: 0.
  ***   Break loop: type 'break' to go back to GP prompt
break> break

? 


/ 13	. 

break> \p 100
   realprecision = 115 significant digits (100 digits displayed)
break> exp(200)
722597376812574925817747704218930569735687442852731928403269789123221909361473891661561.9265890625706
<																		87 digits                                         > < 13 digits >
? \p 38
? default(format)
%44 = "g.38"
? exp(200)
%45 = 7.2259737681257492581774770421893056974 E86
? default(format,"g.39")
? exp(200)
%47 = 7.2259737681257492581774770421893056974 E86
? default(format,"g.40")
? exp(200)
%49 = 7.2259737681257492581774770421893056974 E86
/ Geen verschil; logisch, hier ligt de grens helemaal niet	,
%9 = "g.87"
? exp(200)
%10 = 7.22597376812574925817747704218930569735687442852731928403269789123221909361473891661562 E86
/ klopt, de integer part is 87 digits	, see boven	,
/ ze geven e86 	, want de laatste 2 klopt niet	, is afronding, dat is altijd bij eNum	,
? default(format,"g.88")
? exp(200)
%12 = 722597376812574925817747704218930569735687442852731928403269789123221909361473891661561.9
/ de 1 is correct	, 







/ 7	. 

/ 2. Warming up

? 1/0
  ***   at top-level: 1/0
  ***                  ^--
  *** _/_: impossible inverse in gdiv: 0.
  ***   Break loop: type 'break' to go back to GP prompt
break> 
/ Aan de promt zien we dat we in een break loop zitten	,

break> break
? 
/ eruit	,
/ dan klopt % ook weer	,

Comment. You can enter the break loop at any time using Control-C: this freezes the current
computation and gets you a new prompt so that you may e.g., increase debugging level, inspect or
modify variables (again, run arbitrary commands), before letting the program go on.
/ TODO

? truncate(-5.7)
%22 = -5
/ afkappen	, 
? floor(-5.7)
%23 = -6
/ naar beneden	, 

? truncate(5.7)
%24 = 5
? floor(5.7)
%25 = 5

/ 13	. 

? \p 50
   realprecision = 57 significant digits (50 digits displayed)
? floor(exp(100))
%25 = 26881171418161354484126255515800135873611118
? exp(100)
%26 = 26881171418161354484126255515800135873611118.773742

? \p 38
   realprecision = 38 significant digits
? exp(100)
%27 = 2.6881171418161354484126255515800135874 E43
? floor(exp(100))
  ***   at top-level: floor(exp(100))
  ***                 ^---------------
  *** floor: precision too low in truncr (precision loss in truncation).
  ***   Break loop: type 'break' to go back to GP prompt


/ 13	. 


break> \p 44
   realprecision = 57 significant digits (44 digits displayed)
break> exp(100)
2.6881171418161354484126255515800135873611119 E43
break> \p 45
   realprecision = 57 significant digits (45 digits displayed)
break> exp(100)
26881171418161354484126255515800135873611118.8
/ en	,
[eric@almond wildfly]$ echo -n 2.6881171418161354484126255515800135873611119 | wc
      0       1      45
[eric@almond wildfly]$ echo -n 26881171418161354484126255515800135873611118.8 | wc
      0       1      46
/ Klopt	,
26881171418161354484126255515800135873611118.8			/ \p 45, string length=46
<										44 digits              >	
2.6881171418161354484126255515800135873611119		e43		/ \p 44	, string lenght=45
  <             43 digits                   >
/ omdat e^100' int part 44 digits is	, is \p 44 1 te klein, want de laatste digit is door afronding onzeker	, en dat zien we hier ook: de 9 klopt niet	,

? \p 45
? exp(100)
%30 = 26881171418161354484126255515800135873611118.8
      <                    44 digits             >
break> floor(exp(100))
26881171418161354484126255515800135873611118
? \p 44
? exp(100)
%28 = 2.6881171418161354484126255515800135873611119 E43
break> floor(exp(100))
26881171418161354484126255515800135873611118
? \p 43
? exp(100)
%31 = 2.688117141816135448412625551580013587361112 E43
break> floor(exp(100))
26881171418161354484126255515800135873611118
? \p 42
? exp(100)
%29 = 2.68811714181613544841262555158001358736111 E43
break> floor(exp(100))
26881171418161354484126255515800135873611118
? \p 41
? exp(100)
%32 = 2.6881171418161354484126255515800135873611 E43
? floor(exp(100))
%33 = 26881171418161354484126255515800135873611118
? \p 40
? exp(100)
%34 = 2.688117141816135448412625551580013587361 E43
? floor(exp(100))
%35 = 26881171418161354484126255515800135873611118
? \p 39
? exp(100)
%36 = 2.68811714181613544841262555158001358736 E43
? floor(exp(100))
%37 = 26881171418161354484126255515800135873611118
 \p 38
   realprecision = 38 significant digits
? exp(100)
%38 = 2.6881171418161354484126255515800135874 E43
? floor(exp(100))
  ***   at top-level: floor(exp(100))
  ***                 ^---------------
  *** floor: precision too low in truncr (precision loss in truncation).

/ floor(exp(100)) heeft 44 digits	, 
/ maar waarom gaan \p 39, ... \p  44 OK	?
/ TODO

? sqrt(-1)
%40 = 1.00000000000000000000000000000000000000000*I
? log(-2)
%41 = 0.693147180559945309417232121458176568075500 + 3.14159265358979323846264338327950288419717*I
? \p 100
   realprecision = 115 significant digits (100 digits displayed)
? sqrt(-1)
%42 = 1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000*I
? \p 1000
   realprecision = 1001 significant digits (1000 digits displayed)
? sqrt(-1)
%43 = 1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000*I

? \p 34
   realprecision = 38 significant digits (34 digits displayed)
? exp(Pi*I)
%45 = -1.000000000000000000000000000000000 + 0.E-37*I
/ TODO

? \p 38
   realprecision = 38 significant digits
? 6*zeta(2) / Pi^2.
%61 = 1.0000000000000000000000000000000000000

/ 13	. 

/ Taylor ontw	,

? exp(X)
%62 = 1 + X + 1/2*X^2 + 1/6*X^3 + 1/24*X^4 + 1/120*X^5 + 1/720*X^6 + 1/5040*X^7 + 1/40320*X^8 + 1/362880*X^9 + 1/3628800*X^10 + 1/39916800*X^11 + 1/479001600*X^12 + 1/6227020800*X^13 + 1/87178291200*X^14 + 1/1307674368000*X^15 + 1/20922789888000*X^16 + O(X^17)
? log(X)
  ***   at top-level: log(X)
  ***                 ^------
  *** log: domain error in log: series valuation != 0
  ***   Break loop: type 'break' to go back to GP prompt

/ ontw rond 1	,
break> log(1+X)
X - 1/2*X^2 + 1/3*X^3 - 1/4*X^4 + 1/5*X^5 - 1/6*X^6 + 1/7*X^7 - 1/8*X^8 + 1/9*X^9 - 1/10*X^10 + 1/11*X^11 - 1/12*X^12 + 1/13*X^13 - 1/14*X^14 + 1/15*X^15 + O(X^16)

/ Taylor ontwikkeling rond 0	, 
break> default(seriesprecision)
16

break> default(seriesprecision,32)
break> exp(X)
1 + X + 1/2*X^2 + 1/6*X^3 + 1/24*X^4 + 1/120*X^5 + 1/720*X^6 + 1/5040*X^7 + 1/40320*X^8 + 1/362880*X^9 + 1/3628800*X^10 + 1/39916800*X^11 + 1/479001600*X^12 + 1/6227020800*X^13 + 1/87178291200*X^14 + 1/1307674368000*X^15 + 1/20922789888000*X^16 + 1/355687428096000*X^17 + 1/6402373705728000*X^18 + 1/121645100408832000*X^19 + 1/2432902008176640000*X^20 + 1/51090942171709440000*X^21 + 1/1124000727777607680000*X^22 + 1/25852016738884976640000*X^23 + 1/620448401733239439360000*X^24 + 1/15511210043330985984000000*X^25 + 1/403291461126605635584000000*X^26 + 1/10888869450418352160768000000*X^27 + 1/304888344611713860501504000000*X^28 + 1/8841761993739701954543616000000*X^29 + 1/265252859812191058636308480000000*X^30 + 1/8222838654177922817725562880000000*X^31 + 1/263130836933693530167218012160000000*X^32 + O(X^33)
/ Inderdaad, allemaal breuken	,

In fact gp knows about Laurent series, but log(x) is not meromorphic either at 0.
/ TODO

/ ontw rond 2	,
break> log(X+2)
0.69314718055994530941723212145817656807 + 1/2*X - 1/8*X^2 + 1/24*X^3 - 1/64*X^4 + 1/160*X^5 - 1/384*X^6 + 1/896*X^7 - 1/2048*X^8 + 1/4608*X^9 - 1/10240*X^10 + 1/22528*X^11 - 1/49152*X^12 + 1/106496*X^13 - 1/229376*X^14 + 1/491520*X^15 + O(X^16)

break> tan(X)
X + 1/3*X^3 + 2/15*X^5 + 17/315*X^7 + 62/2835*X^9 + 1382/155925*X^11 + 21844/6081075*X^13 + 929569/638512875*X^15 + O(X^17)
break> 1/tan(X)
X^-1 - 1/3*X - 1/45*X^3 - 2/945*X^5 - 1/4725*X^7 - 2/93555*X^9 - 1382/638512875*X^11 - 4/18243225*X^13 + O(X^15)

break> exp(exp(X)-1)
1 + X + X^2 + 5/6*X^3 + 5/8*X^4 + 13/30*X^5 + 203/720*X^6 + 877/5040*X^7 + 23/224*X^8 + 1007/17280*X^9 + 4639/145152*X^10 + 22619/1330560*X^11 + 4213597/479001600*X^12 + 27644437/6227020800*X^13 + 95449661/43589145600*X^14 + 276591709/261534873600*X^15 + 10480142147/20922789888000*X^16 + O(X^17)

break> gamma(X+1)
1 - 0.57721566490153286060651209008240243104*X + 0.98905599532797255539539565150063470794*X^2 - 0.90747907608088628901656016735627511493*X^3 + 0.98172808683440018733638029402185085036*X^4 - 0.98199506890314520210470141379137467551*X^5 + 0.99314911462127619315386725332865849803*X^6 - 0.99600176044243153397007841966456668672*X^7 + 0.99810569378312892197857540308836723751*X^8 - 0.99902526762195486779467805964888808852*X^9 + 0.99951565607277744106705087759437019442*X^10 - 0.99975659750860128702584244914060923598*X^11 + 0.99987827131513327572617164259000321936*X^12 - 0.99993906420644431683585223136895513183*X^13 + 0.99996951776348210449861140509195350724*X^14 - 0.99998475269937704874370963172444753830*X^15 + O(X^16)
/ Geen breuken	,
break> \p 8
   realprecision = 19 significant digits (8 digits displayed)
break> gamma(X+1)
1 - 0.57721566*X + 0.98905600*X^2 - 0.90747908*X^3 + 0.98172809*X^4 - 0.98199507*X^5 + 0.99314911*X^6 - 0.99600176*X^7 + 0.99810569*X^8 - 0.99902527*X^9 + 0.99951566*X^10 - 0.99975660*X^11 + 0.99987827*X^12 - 0.99993906*X^13 + 0.99996952*X^14 - 0.99998475*X^15 + O(X^16)

/ 13	. 

/ machtreeksen	,

? (1+X)^3
%63 = X^3 + 3*X^2 + 3*X + 1

? (1+X)^-3
%64 = 1/(X^3 + 3*X^2 + 3*X + 1)
/ geen machtreeks	,

/ herinner	,
? 1/7
%68 = 1/7
? 1/7 +0.
%69 = 0.14285714285714285714285714285714285714

? (1+X)^-3 +O(X^16)
/ of	,
? (1+X)^-3 +O(X^default(seriesprecision))
%71 = 1 - 3*X + 6*X^2 - 10*X^3 + 15*X^4 - 21*X^5 + 28*X^6 - 36*X^7 + 45*X^8 - 55*X^9 + 66*X^10 - 78*X^11 + 91*X^12 - 105*X^13 + 120*X^14 - 136*X^15 + O(X^16)

/ Dit kan ook	,
? (1+X)^-3 * (1+O(X^16))
? (1+X+O(X^16))^-3
/ en	, 
? Ser((1+X)^-3)			 / Ser van power series	,

/ Ser werkt WH alleen met X	,

? (1+X)^(1/2)
%89 = 1 + 1/2*X - 1/8*X^2 + 1/16*X^3 - 5/128*X^4 + 7/256*X^5 - 21/1024*X^6 + 33/2048*X^7 - 429/32768*X^8 + 715/65536*X^9 - 2431/262144*X^10 + 4199/524288*X^11 - 29393/4194304*X^12 + 52003/8388608*X^13 - 185725/33554432*X^14 + 334305/67108864*X^15 + O(X^16)
/ we moeten () om 1/2	, want ^ is sterker	,
? (1+X)^1/2
%88 = 1/2*X + 1/2

? (1+X)^Pi
%90 = 1 + 3.1415926535897932384626433832795028842*X + 3.3640058737497826901859238082983241256*X^2 + 1.2801081307018884659830214723386579274*X^3 + 0.045313476776987564999415957710724384151*X^4 - 0.0077794842713508848217674857513846790336*X^5 + 0.0024095751201935231242923741882380588349*X^6 - 0.00098393531789834620669053791139372945412*X^7 + 0.00047455290737143015068291448802673587730*X^8 - 0.00025617459238151984510163668845869889808*X^9 + 0.00015007751139715360451171861364578050838*X^10 - 9.3572064245199983145760162855417296969 E-5*X^11 + 6.1277283090270615519675567940249845774 E-5*X^12 - 4.1755318053454704423054107069818901199 E-5*X^13 + 2.9402923874990899468440376892389950197 E-5*X^14 - 2.1284594974009416443583328338794444938 E-5*X^15 + O(X^16)

/ (1+X)^a heeft coeff 1, (a boven 1),  (a boven 2), ...
/ (1/2 3)=1/2*-1/2*-3/2 / 3! = 1/16
/ (π 1) = π/1=π,  (π 2) = π(π-1)/2	, 

/ Waarom bij 11 e-5	?
/ TODO

? n=3+0*X
%93 = 3
? type(n)
%94 = "t_POL"

? factor(8)
%98 = 
[2 3]
? eulerphi(15)
%97 = 8

? eulerphi(n)
  ***   at top-level: eulerphi(n)
  ***                 ^-----------
  *** eulerphi: incorrect type in eulerphi (t_POL).
  ***   Break loop: type 'break' to go back to GP prompt

? n
%106 = 3
? type(n)
%107 = "t_POL"
? n
%109 = 3
? type(%)
%111 = "t_INT"

/ rond 1	,
? Ser((X+1)^-3)
%124 = 1 - 3*X + 6*X^2 - 10*X^3 + 15*X^4 - 21*X^5 + 28*X^6 - 36*X^7 + 45*X^8 - 55*X^9 + 66*X^10 - 78*X^11 + 91*X^12 - 105*X^13 + 120*X^14 - 136*X^15 + O(X^16)

/ rond 2	, 
? Ser((X+2)^-3)
%126 = 1/8 - 3/16*X + 3/16*X^2 - 5/32*X^3 + 15/128*X^4 - 21/256*X^5 + 7/128*X^6 - 9/256*X^7 + 45/2048*X^8 - 55/4096*X^9 + 33/4096*X^10 - 39/8192*X^11 + 91/32768*X^12 - 105/65536*X^13 + 15/16384*X^14 - 17/32768*X^15 + O(X^16)
/ Het vervangen van X+1 door X+2 gaat OK , maar met meerdere termen niet	, daarom:

/ rond 0	,
? p = 1 / (X^4 + 3*X^3 + 5*X^2 - 6*X + 7)
? Ser(p)
/ of	, v=X is default	,
? Ser(p,v=X)
%129 = 1/7 + 6/49*X + 1/343*X^2 - 351/2401*X^3 - 3366/16807*X^4 - 10116/117649*X^5 + 108368/823543*X^6 + 1619463/5764801*X^7 + 8565488/40353607*X^8 - 17748585/282475249*X^9 - 681514875/1977326743*X^10 - 5282491320/13841287201*X^11 - 8170847684/96889010407*X^12 + 242132561376/678223072849*X^13 + 2749060863361/4747561509943*X^14 + 11032734664314/33232930569601*X^15 + O(X^16)

/ als we met y	,
? Ser(subst(p,X,y),v=y)
%136 = 1/7 + 6/49*y + 1/343*y^2 - 351/2401*y^3 - 3366/16807*y^4 - 10116/117649*y^5 + 108368/823543*y^6 + 1619463/5764801*y^7 + 8565488/40353607*y^8 - 17748585/282475249*y^9 - 681514875/1977326743*y^10 - 5282491320/13841287201*y^11 - 8170847684/96889010407*y^12 + 242132561376/678223072849*y^13 + 2749060863361/4747561509943*y^14 + 11032734664314/33232930569601*y^15 + O(y^16)

/ we 
/ ontw rond 1	,  we hoeven niet met de hand alle termen te vervangen	, 
? Ser(subst(p,X,z+1),v=z)
%139 = 1/10 - 17/100*z + 89/1000*z^2 + 1187/10000*z^3 - 27079/100000*z^4 + 177643/1000000*z^5 + 1475969/10000000*z^6 - 42851773/100000000*z^7 + 336015241/1000000000*z^8 + 1647274203/10000000000*z^9 - 66686437551/100000000000*z^10 + 611855702067/1000000000000*z^11 + 1446633391961/10000000000000*z^12 - 101930675994037/100000000000000*z^13 + 1081882259610529/1000000000000000*z^14 + 369637708988707/10000000000000000*z^15 + O(z^16)
/ we kunnen ook	,
? Ser(subst(p,X,X+1))
%140 = 1/10 - 17/100*X + 89/1000*X^2 + 1187/10000*X^3 - 27079/100000*X^4 + 177643/1000000*X^5 + 1475969/10000000*X^6 - 42851773/100000000*X^7 + 336015241/1000000000*X^8 + 1647274203/10000000000*X^9 - 66686437551/100000000000*X^10 + 611855702067/1000000000000*X^11 + 1446633391961/10000000000000*X^12 - 101930675994037/100000000000000*X^13 + 1081882259610529/1000000000000000*X^14 + 369637708988707/10000000000000000*X^15 + O(X^16)

/ ontw rond a	,

?  q=(1+X)^-3
%142 = 1/(X^3 + 3*X^2 + 3*X + 1)
? Ser(q)
%143 = 1 - 3*X + 6*X^2 - 10*X^3 + 15*X^4 - 21*X^5 + 28*X^6 - 36*X^7 + 45*X^8 - 55*X^9 + 66*X^10 - 78*X^11 + 91*X^12 - 105*X^13 + 120*X^14 - 136*X^15 + O(X^16)
/ ontw rond 1	,
? Ser(subst(q,X,X+1))
%144 = 1/8 - 3/16*X + 3/16*X^2 - 5/32*X^3 + 15/128*X^4 - 21/256*X^5 + 7/128*X^6 - 9/256*X^7 + 45/2048*X^8 - 55/4096*X^9 + 33/4096*X^10 - 39/8192*X^11 + 91/32768*X^12 - 105/65536*X^13 + 15/16384*X^14 - 17/32768*X^15 + O(X^16)
/ ontw rond a	,
? Ser(subst(q,X,X+a))
%145 = 1/(a^3 + 3*a^2 + 3*a + 1) - 3/(a^4 + 4*a^3 + 6*a^2 + 4*a + 1)*X + 6/(a^5 + 5*a^4 + 10*a^3 + 10*a^2 + 5*a + 1)*X^2 - 10/(a^6 + 6*a^5 + 15*a^4 + 20*a^3 + 15*a^2 + 6*a + 1)*X^3 + 15/(a^7 + 7*a^6 + 21*a^5 + 35*a^4 + 35*a^3 + 21*a^2 + 7*a + 1)*X^4 - 21/(a^8 + 8*a^7 + 28*a^6 + 56*a^5 + 70*a^4 + 56*a^3 + 28*a^2 + 8*a + 1)*X^5 + 28/(a^9 + 9*a^8 + 36*a^7 + 84*a^6 + 126*a^5 + 126*a^4 + 84*a^3 + 36*a^2 + 9*a + 1)*X^6 - 36/(a^10 + 10*a^9 + 45*a^8 + 120*a^7 + 210*a^6 + 252*a^5 + 210*a^4 + 120*a^3 + 45*a^2 + 10*a + 1)*X^7 + 45/(a^11 + 11*a^10 + 55*a^9 + 165*a^8 + 330*a^7 + 462*a^6 + 462*a^5 + 330*a^4 + 165*a^3 + 55*a^2 + 11*a + 1)*X^8 - 55/(a^12 + 12*a^11 + 66*a^10 + 220*a^9 + 495*a^8 + 792*a^7 + 924*a^6 + 792*a^5 + 495*a^4 + 220*a^3 + 66*a^2 + 12*a + 1)*X^9 + 66/(a^13 + 13*a^12 + 78*a^11 + 286*a^10 + 715*a^9 + 1287*a^8 + 1716*a^7 + 1716*a^6 + 1287*a^5 + 715*a^4 + 286*a^3 + 78*a^2 + 13*a + 1)*X^10 - 78/(a^14 + 14*a^13 + 91*a^12 + 364*a^11 + 1001*a^10 + 2002*a^9 + 3003*a^8 + 3432*a^7 + 3003*a^6 + 2002*a^5 + 1001*a^4 + 364*a^3 + 91*a^2 + 14*a + 1)*X^11 + 91/(a^15 + 15*a^14 + 105*a^13 + 455*a^12 + 1365*a^11 + 3003*a^10 + 5005*a^9 + 6435*a^8 + 6435*a^7 + 5005*a^6 + 3003*a^5 + 1365*a^4 + 455*a^3 + 105*a^2 + 15*a + 1)*X^12 - 105/(a^16 + 16*a^15 + 120*a^14 + 560*a^13 + 1820*a^12 + 4368*a^11 + 8008*a^10 + 11440*a^9 + 12870*a^8 + 11440*a^7 + 8008*a^6 + 4368*a^5 + 1820*a^4 + 560*a^3 + 120*a^2 + 16*a + 1)*X^13 + 120/(a^17 + 17*a^16 + 136*a^15 + 680*a^14 + 2380*a^13 + 6188*a^12 + 12376*a^11 + 19448*a^10 + 24310*a^9 + 24310*a^8 + 19448*a^7 + 12376*a^6 + 6188*a^5 + 2380*a^4 + 680*a^3 + 136*a^2 + 17*a + 1)*X^14 - 136/(a^18 + 18*a^17 + 153*a^16 + 816*a^15 + 3060*a^14 + 8568*a^13 + 18564*a^12 + 31824*a^11 + 43758*a^10 + 48620*a^9 + 43758*a^8 + 31824*a^7 + 18564*a^6 + 8568*a^5 + 3060*a^4 + 816*a^3 + 153*a^2 + 18*a + 1)*X^15 + O(X^16)

? subst(1+O(X),X,z+1)
%147 = O(z^0)
/ TODO (in tutorial: zou ERR geven)	,

? valuation(q,X)
%148 = 0
/ TODO

/ 3	. Remaining types

? p=X*exp(-X)
%152 = X - X^2 + 1/2*X^3 - 1/6*X^4 + 1/24*X^5 - 1/120*X^6 + 1/720*X^7 - 1/5040*X^8 + 1/40320*X^9 - 1/362880*X^10 + 1/3628800*X^11 - 1/39916800*X^12 + 1/479001600*X^13 - 1/6227020800*X^14 + 1/87178291200*X^15 - 1/1307674368000*X^16 + 1/20922789888000*X^17 + O(X^18)
/ Aut. machtreeks ontw	, met breuken!
/ TODO

? p(5)
  ***   at top-level: p(5)
  ***                 ^----
  ***   not a function in function call

/ 13	 .

/ serreverse berekent de inverse	, niet 1/...

/ inverse x+x^2+...

x+x^2+...= y

x/(1-x)=y

(1-x)/x=1/y

1/x - 1 = 1/y

1/x = (1+y)/y

x=y/(1+y)=y-y^2+...

? serreverse(x+x^2+O(x^3))
%41 = x - x^2 + O(x^3)



/ 13	. 

? pinv=serreverse(p)
153 = X + X^2 + 3/2*X^3 + 8/3*X^4 + 125/24*X^5 + 54/5*X^6 + 16807/720*X^7 + 16384/315*X^8 + 531441/4480*X^9 + 156250/567*X^10 + 2357947691/3628800*X^11 + 2985984/1925*X^12 + 1792160394037/479001600*X^13 + 7909306972/868725*X^14 + 320361328125/14350336*X^15 + 35184372088832/638512875*X^16 + 2862423051509815793/20922789888000*X^17 + O(X^18)

  pinv(p(X))
  ***   at top-level: pinv(p(X))
  ***                      ^-----
  ***   not a function in function call
/ Doe daarom	,
break> subst(p,X,pinv)
X + O(X^18)

? ?serlaplace 
serlaplace(x): replaces the power series sum of a_n*x^n/n! by sum of a_n*x^n. For the reverse operation, use serconvol(x,exp(X)).
? serlaplace(pinv)
%177 = X + 2*X^2 + 9*X^3 + 64*X^4 + 625*X^5 + 7776*X^6 + 117649*X^7 + 2097152*X^8 + 43046721*X^9 + 1000000000*X^10 + 25937424601*X^11 + 743008370688*X^12 + 23298085122481*X^13 + 793714773254144*X^14 + 29192926025390625*X^15 + 1152921504606846976*X^16 + 48661191875666868481*X^17 + O(X^18)
/ we zien nu : n^(n-1)	, 

/ Intermezzo

? p=X*exp(-X)
%167 = X - X^2 + 1/2*X^3 - 1/6*X^4 + 1/24*X^5 - 1/120*X^6 + 1/720*X^7 - 1/5040*X^8 + 1/40320*X^9 - 1/362880*X^10 + 1/3628800*X^11 - 1/39916800*X^12 + 1/479001600*X^13 - 1/6227020800*X^14 + 1/87178291200*X^15 - 1/1307674368000*X^16 + 1/20922789888000*X^17 + O(X^18)
? a=p^2
X^2 - 2*X^3 + 2*X^4 - 4/3*X^5 + 2/3*X^6 - 4/15*X^7 + 4/45*X^8 - 8/315*X^9 + 2/315*X^10 - 4/2835*X^11 + 4/14175*X^12 - 8/155925*X^13 + 4/467775*X^14 - 8/6081075*X^15 + 8/42567525*X^16 - 16/638512875*X^17 + 2/638512875*X^18 + O(X^19)

? type(p)
%163 = "t_SER" 	/ power series	,
? type(a)
%164 = "t_SER"

? p(1)
  ***   at top-level: p(1)
  ***                 ^----
  ***   not a function in function call
/ Hoe dan?
/ TODO

? subst(p,X,1)
  ***   at top-level: subst(p,X,1)
  ***                 ^------------
  *** subst: forbidden substitution t_SER , t_INT.
/ TODO

? pinv=serreverse(p)
%159 = X + X^2 + 3/2*X^3 + 8/3*X^4 + 125/24*X^5 + 54/5*X^6 + 16807/720*X^7 + 16384/315*X^8 + 531441/4480*X^9 + 156250/567*X^10 + 2357947691/3628800*X^11 + 2985984/1925*X^12 + 1792160394037/479001600*X^13 + 7909306972/868725*X^14 + 320361328125/14350336*X^15 + 35184372088832/638512875*X^16 + 2862423051509815793/20922789888000*X^17 + O(X^18)
? b=pinv^2
%160 = X^2 + 2*X^3 + 4*X^4 + 25/3*X^5 + 18*X^6 + 2401/60*X^7 + 4096/45*X^8 + 59049/280*X^9 + 31250/63*X^10 + 214358881/181440*X^11 + 497664/175*X^12 + 137858491849/19958400*X^13 + 1129900996/66825*X^14 + 21357421875/512512*X^15 + 4398046511104/42567525*X^16 + 168377826559400929/653837184000*X^17 + 564859072962/875875*X^18 + O(X^19)

? subst(p,X,pinv)
%161 = X + O(X^18)
? subst(pinv,X,p)
%162 = X + O(X^18)


/ Einde Intermezzo

/ Intermezzo

? f=X^2
%166 = X^2
? f(1)
  ***   at top-level: f(1)
  ***                 ^----
  ***   not a function in function call
? type(f)
"t_POL"
? subst(f,X,3)
9
? X=3
? subst(f,X,X)
9

/ Einde Intermezzo

/ Intermezzo


? ?\
#       : enable/disable timer
##      : print time for last result
\\      : comment up to end of line
\a {n}  : print result in raw format (readable by PARI)
\B {n}  : print result in beautified format
\c      : list all commands (same effect as ?*)									<-
\d      : print all defaults
\e {n}  : enable/disable echo (set echo=n)
\g {n}  : set debugging level
\gf{n}  : set file debugging level
\gm{n}  : set memory debugging level
\h {m-n}: hashtable information
\l {f}  : enable/disable logfile (set logfile=f)
\m {n}  : print result in prettymatrix format
\o {n}  : set output method (0=raw, 1=prettymatrix, 2=prettyprint, 3=2-dim)
\p {n}  : change real precision
\pb{n}  : change real bit precision
\ps{n}  : change series precision
\q      : quit completely this GP session
\r {f}  : read in a file
\s      : print stack information
\t      : print the list of PARI types
\u      : print the list of user-defined functions
\um     : print the list of user-defined member functions
\v      : print current version of GP
\w {nf} : write to a file
\x {n}  : print complete inner structure of result
\y {n}  : disable/enable automatic simplification (set simplify=n)

{f}=optional filename. {n}=optional integer

/ Einde Intermezzo

? [1,2,3]
%187 = [1, 2, 3]
? \B
(1 2 3)

? [1,2,3]~
%188 = [1, 2, 3]~
? \B
/ 1 \
| 2 |
\ 3 /

/ \B kent geen args	, behalve % WH	, 

/ matrix	,

? m=[a,b,c;d,e,f]
? m
%3 = 
[a b c]

[d e f]

? \a m
[a,b,c;d,e,f]
? \a %
[a,b,c;d,e,f]
? \a
[a,b,c;d,e,f]

? m[1,2]
%5 = b
? m[1,]
%6 = [a, b, c]
? m[,2]
%7 = [b, e]~
? \B
(b)
 e
/ TODO halve column tussen (),

? m[1,2]=5;m
%8 = 
[a 5 c]
[d e f]

? m[1,]=[15,7,8];m
[15 7 8]
[ d e f]

break> m[,2] = [j,k]~;m
[15 j 8]
[ d k f]

break> h5=mathilbert(5)

[  1 1/2 1/3 1/4 1/5]

[1/2 1/3 1/4 1/5 1/6]

[1/3 1/4 1/5 1/6 1/7]

[1/4 1/5 1/6 1/7 1/8]

[1/5 1/6 1/7 1/8 1/9]

? d5=matdet(h5)
1/266716800000

? h=mathilbert(20);
? d=matdet(h)
%14 = 1/2377454716768534509091644243427616440175419837753486493033185331234419759310644585187585766816573773440565759867265558971765638419710793303386582324149811241023554489166154717809635257797836800000000000000000000000000000000000
? sizedigit(1/d)
%15 = 226
? #Str(1/d)
%16 = 226

? h5r=1.*h5
%23 = 
[1.0000000000000000000000000000000000000 0.50000000000000000000000000000000000000 0.33333333333333333333333333333333333333 0.25000000000000000000000000000000000000 0.20000000000000000000000000000000000000]

[0.50000000000000000000000000000000000000 0.33333333333333333333333333333333333333 0.25000000000000000000000000000000000000 0.20000000000000000000000000000000000000 0.16666666666666666666666666666666666667]

[0.33333333333333333333333333333333333333 0.25000000000000000000000000000000000000 0.20000000000000000000000000000000000000 0.16666666666666666666666666666666666667 0.14285714285714285714285714285714285714]

[0.25000000000000000000000000000000000000 0.20000000000000000000000000000000000000 0.16666666666666666666666666666666666667 0.14285714285714285714285714285714285714 0.12500000000000000000000000000000000000]

[0.20000000000000000000000000000000000000 0.16666666666666666666666666666666666667 0.14285714285714285714285714285714285714 0.12500000000000000000000000000000000000 0.11111111111111111111111111111111111111]

? d5r=matdet(h5r)
%24 = 3.7492951325150871636132407107463788194 E-12
? 1.*d5
%26 = 3.7492951325150871636132407107463796806 E-12

? h=mathilbert(20)
? d=matdet(h)
%29 = 1/2377454716768534509091644243427616440175419837753486493033185331234419759310644585187585766816573773440565759867265558971765638419710793303386582324149811241023554489166154717809635257797836800000000000000000000000000000000000
? hr=1.*h;
? dr=matdet(hr);
? dr
%32 = 4.2061789566171547521205034622572311456 E-226
? 1.*d
%33 = 4.2061789566247226558820455733969413398 E-226
                  ^
/ we zien verschil	,
/ dat komt omdat hilbert matrix instable is	,

? h40=mathilbert(40)
? h40r=h40*1.;
? d40=matdet(h40)
%37 = 1/91148445317566258751264876699754732527370841154734052886449926733556811479408912156059842334588941578780273098553144167949448489528336803141772953236332459194497243601609507296388946266233062528595411175820228799938417775022913338714288588552485278925773157515869431921894493828321447577822636684274663059529149740493580999891430869202808515756322607727305994484227852766479158044297125202406142856301182540876335667576022316556769150079984456601875532363261652353495277151420824528221223209590100339041009139702891426368118406174050396400813767873460036972335023242261321455435085108585664753779398559394807080194265190638932894157867287281594472593028619718609003524355718945963579220161775267375998926853659378105451672709373388656591062091850744065803164410251281367091228073142835765650074817926193321512072501454051242014007288414616186752903472586959093760000000000000000000000000000000000000000000000000000000000000000000000
? d40r=matdet(h40r)
%38 = -3.4683963759849038463436659631139728430 E-856
? d40*1.
%39 = 1.0971114170032679314383625065777631300 E-932
/ totaal verschillend	,

/ 1/h is inverse van h	, h^-1 kan ook	,

? norml2(1/h-1/hr)
%56 = 913509335991560944174707746950643.68778
? sizedigit(floor(norml2(1/h-1/hr)))
%58 = 34
/ Dus van 1/hr is verschil coeff met 1/h  ~ e17	, 

/ 13	. 

break[2]> h=mathilbert(100);
break[2]> d=matdet(h)
break[2]> hr=1.*h;
break[2]> dr=matdet(hr)
/ groot verschil tijd berekening d en dr	,

break[2]> dr
-3.2084841207002794525058341919302755271 E-3072
break[2]> 1.*d
3.3700336774911741861999225672508298306 E-5942

break[2]> norml2(1/h-1/hr)
2.9935696238015216843217357835541228608 E300
/ 1/h is matrix met hele grote gehele getallen, pos en neg	,



/ 13	. 

? \p 57
? h=mathilbert(20);
? hr=h*1.;
? d=matdet(h);
? dr=matdet(hr);
? d*1.
%72 = 4.20617895662472265588204557339694133979789885227083865986 E-226
? dr
%73 = 4.20617895662472265588204557339613831015281100759205571917 E-226
                                      ^

? h40=mathilbert(40);
? h40r=h40*1.;
? d40=matdet(h40);
? d40r=matdet(h40r);
? d40*1.
%79 = 1.09711141700326793143836250657776312995723516016756394356 E-932
? d40r
%80 = 1.10784932304271044295499153393954524865773051120572545096 E-932
/ het verschil is minder groot	,

? vector(10,i,i^2)
%81 = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
? matrix(5,5,i,j,1/(i+j-1))
%82 = 
[  1 1/2 1/3 1/4 1/5]

[1/2 1/3 1/4 1/5 1/6]

[1/3 1/4 1/5 1/6 1/7]

[1/4 1/5 1/6 1/7 1/8]

[1/5 1/6 1/7 1/8 1/9]
/ Hilbert matrix	,

? matrix(5,5)
%83 = 
[0 0 0 0 0]

[0 0 0 0 0]

[0 0 0 0 0]

[0 0 0 0 0]

[0 0 0 0 0]

/ 13	. 

/ if(...)	, dus if(i%2,1,0)	, of extra () als het nodig is: if((i-j)%2,1,0)	, 

? matrix(8,8,i,j,if((i-j)%2,1,0))
%86 = 
[0 1 0 1 0 1 0 1]

[1 0 1 0 1 0 1 0]

[0 1 0 1 0 1 0 1]

[1 0 1 0 1 0 1 0]

[0 1 0 1 0 1 0 1]

[1 0 1 0 1 0 1 0]

[0 1 0 1 0 1 0 1]

[1 0 1 0 1 0 1 0]

? matrix(8,8,i,j,if(i%2,1,0))
%87 = 
[1 1 1 1 1 1 1 1]

[0 0 0 0 0 0 0 0]

[1 1 1 1 1 1 1 1]

[0 0 0 0 0 0 0 0]

[1 1 1 1 1 1 1 1]

[0 0 0 0 0 0 0 0]

[1 1 1 1 1 1 1 1]

[0 0 0 0 0 0 0 0]

? h=mathilbert(20)
? h[11..20,11..20]
%89 = 
[1/21 1/22 1/23 1/24 1/25 1/26 1/27 1/28 1/29 1/30]

[1/22 1/23 1/24 1/25 1/26 1/27 1/28 1/29 1/30 1/31]

[1/23 1/24 1/25 1/26 1/27 1/28 1/29 1/30 1/31 1/32]

[1/24 1/25 1/26 1/27 1/28 1/29 1/30 1/31 1/32 1/33]

[1/25 1/26 1/27 1/28 1/29 1/30 1/31 1/32 1/33 1/34]

[1/26 1/27 1/28 1/29 1/30 1/31 1/32 1/33 1/34 1/35]

[1/27 1/28 1/29 1/30 1/31 1/32 1/33 1/34 1/35 1/36]

[1/28 1/29 1/30 1/31 1/32 1/33 1/34 1/35 1/36 1/37]

[1/29 1/30 1/31 1/32 1/33 1/34 1/35 1/36 1/37 1/38]

[1/30 1/31 1/32 1/33 1/34 1/35 1/36 1/37 1/38 1/39]
/ en NIET h[11:20,11:20]	, 

/ 13	. 

/ modulo

? n=10^15+3
%90 = 1000000000000003

/ 1313	. 

? factor(n,200000)
%123 = 
[1000000000000003 1]

? factor(n,0) 	/= factor(n,500000)
%124 = 
[1000000000000003 1]

/ Dus totaan de primes <500000, geen ontbinding	,

? factor(n)
%125 = 
[14902357 1]

[67103479 1]

/ inderdaad	,

? factor(n,2000000)
%126 = 
[1000000000000003 1]

? factor(n,20000000)
%127 = 
[14902357 1]

[67103479 1]



/ 1313	. 

2^10=10^3							: 3 digits
2^(10^2)=10^(3*10)		: 3*10 digits 
2^(10^3)=10^(3*10^2)
2^(10^4)=10^(3*10^3)	: 3*10^3 digits
...
2^(10^15)=10^(3*10^14)	: 3*10^14 digits

? n=10^15+3
%82 = 1000000000000003
? n
%83 = 1000000000000003
? a=Mod(2,n)
%84 = Mod(2, 1000000000000003)
? a ^ (n-1)
%85 = Mod(70605991389233, 1000000000000003)
/ is niet Mod(1,n)	, dus is n niet priem	,

/ lees	,
http://www.alecjacobson.com/weblog/?p=443
ctrl+k, p*	: π
ctrl+shift+u, 03c0 : π
ctrl+k, RT	: √
ctrl+shift+u, 221a : √

/ we weten dat n niet prime; nu de primes vinden	,

/ 1 van de primes van n moet altijd < √n
? #
   timer = 1 (on)
?  for (i=2,ceil(sqrt(n)),if(n%i==0,print(i)) )
14902357
time = 10,673 ms.
? factor(n)
time = 3 ms.
%96 = 
[14902357 1]

[67103479 1]

?  #
   timer = 0 (off)

/ check	,
?  14902357*67103479
%98 = 1000000000000003



/ 1313	. 

/ Intermezzo

? factor(105,3)
%95 = 
[ 3 1]

[35 1]			/ 35 is not prime	, het is de rest	, dus 105/3	,

? factor(105,5)
%96 = 
[3 1]

[5 1]

[7 1]

/ 7 krijg je cadeau, omdat dat het result van de deling is	,	 en deze is wel prime	,

/ Einde Intermezzo

? n=10^15+3
? factor(n,20000)
%98 = 
[1000000000000003 1]

2^10=10^3
2^(10^15)=(10^3)^(10^14)=10^(3*10^14)	, dus  3*10^14 digits	, 

? a=Mod(2,n)
%99 = Mod(2, 1000000000000003)
? a^(n-1)
%100 = Mod(70605991389233, 1000000000000003)
/ ongelijk aan Mod(1,n)	, dus n is NIET prime	,

? #
   timer = 1 (on)
? for(i=2,ceil(sqrt(n)),if(i%n==0,print(i);break))
14902357
time = 4,745 ms.
/ break: als we er 1 hebben , dan is dat genoeg, we weten dat n niet prime is	,
/ duurt lang: 4 s	,

? fa=factor(n)
time = 4 ms.
%103 = 
[14902357 1]
[67103479 1]
/ Snel, 4 ms	,

? #
   timer = 0 (off)
/ timer uit	,

/ numbers in fa zijn strong pseudoprimes	, 

? fa[,1]
%109 = [14902357, 67103479]~
? \B
(14902357)
 67103479

/ Bij 2-vector toont \B de vector zo	, 
/ TODO

? isprime(fa[,1])	/ fa[,1] betekent de 1ste column	,
%125 = [1, 1]~

? isprime([2,3,4,5,6,7])
%130 = [1, 1, 0, 1, 0, 1]

/ 13	. 

? n=569+O(7^8)
%154 = 2 + 4*7 + 4*7^2 + 7^3 + O(7^8)
? s=log(n)
%155 = 6*7^2 + 4*7^4 + 3*7^5 + 3*7^6 + 3*7^7 + O(7^8)
? e=exp(s)
%156 = 1 + 6*7^2 + 7^4 + 6*7^5 + 2*7^7 + O(7^8)
? (n/e)^6
%158 = 1 + O(7^8)
? e*teichmuller(n)
%159 = 2 + 4*7 + 4*7^2 + 7^3 + O(7^8)
? n
%160 = 2 + 4*7 + 4*7^2 + 7^3 + O(7^8)

/ ζ =6_√1,  7-adisch 6de machtswortel van 1	, die = n mod 7 = teichmuller(n) 	, n is 7-adisch	, 
/ (n/e)⁶=1	-> n=e*ζ.

/ 13	. 

/ Lees Koblitz, p-adic (20)

/ teichmuller repr ipv 0,1,2,3,4 in Z₅, 0,1,i,-i,-1	, 
/ bepaal met Hensel √-1 die met 2 start 	, en bereken - deze ,die met 3 start	,
i=2121...
-i=3323...
/ In pari gp gaat dat zo:
? teichmuller(2+O(5^10))
%168 = 2 + 5 + 2*5^2 + 5^3 + 3*5^4 + 4*5^5 + 2*5^6 + 3*5^7 + 3*5^9 + O(5^10)
? teichmuller(3+O(5^10))
%169 = 3 + 3*5 + 2*5^2 + 3*5^3 + 5^4 + 2*5^6 + 5^7 + 4*5^8 + 5^9 + O(5^10)
/ of	,
? sqrt(-1+O(5^10))
%170 = 2 + 5 + 2*5^2 + 5^3 + 3*5^4 + 4*5^5 + 2*5^6 + 3*5^7 + 3*5^9 + O(5^10)
? -sqrt(-1+O(5^10))
%171 = 3 + 3*5 + 2*5^2 + 3*5^3 + 5^4 + 2*5^6 + 5^7 + 4*5^8 + 5^9 + O(5^10)

/ Hoe doen we in gp	,
2=i-5-i⋅5²+0⋅5³+...

/ 13	. 

/ lees	,
https://mathoverflow.net/questions/57315/why-use-teichmuller-representatives
https://www.dpmms.cam.ac.uk/~jat58/all.pdf


/ 13	. 

/ bij deling:
/ in teller of noemer moet staan dat het om p-adic getallen gaat	, de precision is ook die van het antwoord	, 
/ staat er in teller en noemer een precision, dan telt de kleinste	,

/ p-adic numbers	,

? type(O(3^1))
%127 = "t_PADIC"

? a=1+O(3^1) 
%133 = 1 + O(3)
? a+1
%135 = 2 + O(3)
? a+2
%136 = O(3)

? a=1+O(3^2) 
%137 = 1 + O(3^2)
? a+2
%138 = 3 + O(3^2)
? a+6
%139 = 1 + 2*3 + O(3^2)

? a=1+2*3+O(3^4)
%144 = 1 + 2*3 + O(3^4)
? a^2
%145 = 1 + 3 + 2*3^2 + 3^3 + O(3^4)
/ we noteren dit altijd zo:
12*12=1121
/ Kan deze notatie niet?
/ TODO

/ bij +,-,*,/  telt de minste precisie	,
? a
%117 = 1 + 2*3 + O(3^8)
? b
%118 = 1 + 2*3^2 + O(3^6)
? a/b
%114 = 1 + 2*3 + 3^2 + 3^3 + 2*3^4 + 2*3^5 + O(3^6)
? a*b
%115 = 1 + 2*3 + 2*3^2 + 3^3 + 3^4 + O(3^6)
? a+b
%116 = 2 + 2*3 + 2*3^2 + O(3^6)
 

? a^2
%145 = 1 + 3 + 2*3^2 + 3^3 + O(3^4)
? a=1+3+2*3^2+3^3+O(3^4)
%146 = 1 + 3 + 2*3^2 + 3^3 + O(3^4)
? b=1+2*3+O(3^2)
%147 = 1 + 2*3 + O(3^2)
? a/b
%148 = 1 + 2*3 + O(3^2)

? n=1+5+O(5^10)
%151 = 1 + 5 + O(5^10)
? sqrt(n)
%152 = 1 + 3*5 + 4*5^3 + 2*5^4 + 5^5 + 2*5^6 + 3*5^7 + 5^8 + 3*5^9 + O(5^10)
/ wortel van 6 in Z5

/ -1/3 in Z2
? a=3+O(2^10)										/ dit kan dus	,
%153 = 1 + 2 + O(2^10)
? -1/a
%155 = 1 + 2^2 + 2^4 + 2^6 + 2^8 + O(2^10)

? (-1+O(2^2))/a
%165 = 1 + O(2^2)
? (-1+O(2^4))/a
%166 = 1 + 2^3 + O(2^4)
? (-1+O(2^6))/a
%167 = 1 + 2^3 + O(2^6)

?  (-1+O(2^2))/(1+1*2+O(2^10))
%184 = 1 + O(2^2)
?  (-1)/(1+1*2+O(2^10))
%185 = 1 + 2^2 + 2^4 + 2^6 + 2^8 + O(2^10)
?  (-1+O(2^10))/(1+1*2)
%187 = 1 + 2^2 + 2^4 + 2^6 + 2^8 + O(2^10)
////////////////////////////////////////////////////////////
/ bij deling:
/ in teller of noemer moet staan dat het om p-adic getallen gaat	, de precision is ook die van het antwoord	, 
/ staat er in teller en noemer een precision, dan telt de kleinste	,

//////////////////
/ bij verm:
/ In linker of in rechterkant  moet een precision staan	, de kleinste telt<

? (1+1*2+O(2^10))*(1+1*2+O(2^5))
%189 = 1 + 2^3 + O(2^5)
? (1+1*2+O(2^10))*(1+1*2+O(2^50))
%190 = 1 + 2^3 + O(2^10)
? (1+1*2)*(1+1*2+O(2^50))
%191 = 1 + 2^3 + O(2^50)

? n=6+O(5^8)
%196 = 1 + 5 + O(5^8)
? s=sqrt(n)
%197 = 1 + 3*5 + 4*5^3 + 2*5^4 + 5^5 + 2*5^6 + 3*5^7 + O(5^8)
? s^2
%198 = 1 + 5 + O(5^8)
? s^2-n
%199 = O(5^8)

/ 13	.

? n
%200 = 1 + 5 + O(5^8)
? s=log(n)
%201 = 5 + 2*5^2 + 4*5^3 + 2*5^4 + 5^6 + 4*5^7 + O(5^8)
? e=exp(s)
%202 = 1 + 5 + O(5^8)
/ e == n	,

? n = 569 + O(7^8)
%203 = 2 + 4*7 + 4*7^2 + 7^3 + O(7^8)
? s=log(n)
%204 = 6*7^2 + 4*7^4 + 3*7^5 + 3*7^6 + 3*7^7 + O(7^8)
? e=exp(s)
%205 = 1 + 6*7^2 + 7^4 + 6*7^5 + 2*7^7 + O(7^8)
? (n/e)^6
%206 = 1 + O(7^8)
/ e != n
? teichmuller(n)
%207 = 2 + 4*7 + 6*7^2 + 3*7^3 + 2*7^5 + 6*7^6 + 2*7^7 + O(7^8)

If you know about p-adic logarithms, you will not be surprised that e is not equal to n. Type (n/e)^6: e is in fact equal to n times the (p − 1)-st root of unity teichmuller(n).
/ TODO 


? n
%209 = 2 + 4*7 + 4*7^2 + 7^3 + O(7^8)
? lift(n)
%208 = 569
/ of	, 
? truncate(n)
%210 = 569

/ 13	. 

/ quadratic field	,

/ Intermezzo

/ unicode √=\u221a

/ boek (142)
/ quadratic! field Q(√m)
/ discriminant field is 4m als m niet 1 mod 4	, m als m is 1 mod 4
/ Dus we moeten aan quadgen discr 12 geven voor Q(√3) en 5 voor Q(√5)	,

/ het arg van quadgen is de discr van de quadratic field 	, see book (142)	, 

/ we lezen in user guide	,
w = quadgen(d) assigns to w the “canonical” generator √ for the integer basis of the order of discriminant d, i.e. w = √ d/2 if d ≡ 0 mod 4, and w = (1 + d)/2 if d ≡ 1 mod 4.

? w=quadgen(5)			/ 5 is discr	,
%23 = w
? w5*1.
%31 = 1.6180339887498948482045868343656381177
/ (1+√5)/2

? p=charpoly(w)
%24 = x^2 - x - 1
/ discr van dit pol is 5	,

? w=quadgen(12)
%25 = w
? w12*1.
%35 = 1.7320508075688772935274463415058723670
/ √3

? p=charpoly(w)
%26 = x^2 - 3
/ discr van dit pol is 12	,
 
/ geven we toch 3	, dan ERR	,
? w=quadgen(3)
  ***   at top-level: w=quadgen(3)
  ***                   ^----------
  *** quadgen: domain error in quadpoly: disc % 4 > 1


/ Einde Intermezzo

/ Intermezzo

/ discr a1,a2,a3= met geconj	, 
| a1		a2		a3 |²
| σa1 	σa2 	σa3| 
| σ²a1 	σ²a2 	σ²a3| 

/ discr a = discr 1,a,a²	, zoals hierboven	, en dat is 
| 1		a		a² |²
| 1 	σa 	σa²| 
| 1 	σ²a 	σ²a²| 
=
[(a- σa)(a- σ²a)( σa - σ²a )]²

/ discr char poly = [(a- σa)(a- σ²a)( σa - σ²a )]²	, met extra a0^(n-2)	,



/ Einde Intermezzo



/ Intermezzo

/ unicode σ=3c3
/ unicode ²=b2
/ unicode ₀=2080

/ discr van een alg number field is discr of integral basis	, 
/ als field = Q(√m)	, en m is 1 mod 4	, dan is integral basis 1,1+√m/2 en deze heeft discr m
/ als m is niet 1 mod 4	, dan is integral basis 1,√m en deze heeft discr 4m

/ discr 1,a= met geconj	, 
| 1 a	|²
| 1 σa|

/ see book (126)
/ een deg n pol has discr a0^(2n-2) * product kwadraat verschil roots ( verschil in volgorde)
/ -> 
/ discr char pol =  product kwadraat verschil geconj ( verschil in volgorde)

/ Einde Intermezzo

/ quadgen geeft altijd w af	in de regel eronder	, maar het schijnt dat hiermee w niet is set	, doe dat dus zelf	,


/ -163=1(4)	, dus is de discr van de field -163,	 dus moeten we -163 geven aan quadgen	, om Q(√-163) te TODO
? w=quadgen(-163)
%211 = w
? w
w
? w*1.
%4 = 0.50000000000000000000000000000000000000 + 6.3835726674018523308554760048904461737*I
/ 1+√-163/2

? p=charpoly(w)	 				/ char pol van w 
%213 = x^2 - x + 41
/ de disc van dit pol is -163	,

/  we weten : de basis van de integers is 1,1+√-163/2	, en de 2 roots van het char poly zijn 1+-√-163/2	,

/ we kunnen ook	,
break> a=quadgen(-163)
w
break> a
w
/ TODO
break> p=charpoly(a)
x^2 - x + 41
/ OK

/ Einde Intermezzo


? subst(p,x,w)
%20 = 0
? subst(p,x,w*1.)
%21 = 0.E-36 + 0.E-37*I

? w^2
%37 = -41 + w
? w^3
%38 = -41 - 40*w
? w^4
%39 = 1640 - 81*w
? w^10
%3 = -88620680 + 12785359*w

? norm(w)
%41 = 41
/ -> norm 3+4w=9+12(w+w‾) + 16ww‾= 9+12*1+16*41=677	,
? norm(3+4*w)
%8 = 677

/ ‾=\u203e

/ Intermezzo

? 2*w
%10 = 2*w
? 2.*w
%11 = 1.0000000000000000000000000000000000000 + 12.767145334803704661710952009780892347*I

/ Einde Intermezzo

? 1/(4+w)
%12 = 5/61 - 1/61*w
/ want	, 
= 4+w‾/(4+w)(4+w‾)=4+w‾/61	, en w‾=1-w	,

? a=Mod(1,23)*w
%13 = Mod(0, 23) + Mod(1, 23)*w
? b=a^264
%14 = Mod(1, 23) + Mod(0, 23)*w
? lift(b)
%15 = 1
/ wnat w^22=1(23)	, en 264 is 22-voud	,

/ Intermezzo

/ google: algebraic number fileld characteristic polynomial minimal polynomial
/ lees	,
http://www.math.uiuc.edu/~r-ash/Ant/AntChapter2.pdf


/ Einde Intermezzo

/ 13	. 

/ Q(...) - Q(w) - Q
? q = x^2 + w*x + 5*w + 7
%44 = x^2 + w*x + (7 + 5*w)
? norm(q)
%45 = x^4 + x^3 + 60*x^2 + 417*x + 1109

/ Q(√-w) - Q(w) - Q
? q2=x^2+w
%46 = x^2 + w
? norm(q2)
%47 = x^4 + x^2 + 41

/ Q(√w) - Q(w) - Q
? q2=x^2-w
%48 = x^2 - w
? norm(q2)
%49 = x^4 - x^2 + 41

/ 13	. 

? w
%52 = w
? r=algdep(w,2)
%65 = x^2 - x + 41
? subst(r,x,w)
%67 = 0

? wr=sqrt(w^2)
%51 = 0.50000000000000000000000000000000000000 + 6.3835726674018523308554760048904461737*I
/ zien we ook als we w*1.	,
? r=algdep(wr,2)
%54 = x^2 - x + 41
? subst(r,x,wr)
%70 = 0.E-38 + 0.E-37*I
? subst(r,x,w)
%71 = 0

? r=algdep(sqrt(3*w + 5), 4)
%55 = x^4 - 13*x^2 + 409
? q=algdep(sqrt(3*w + 5), 2)
%56 = 10704414562744432386*x^2 - 78257614497002420806*x + 216483387059187261633
? subst(q,x,sqrt(3*w+5))
%75 = 1.6211478291945687302 E-10 - 6.754839034242937511 E-11*I
? subst(r,x,sqrt(3*w+5))
%76 = 5.240763259117728513 E-36 + 5.912118784585189451 E-36*I

/ 7	. 

/ zonet
w=quadgen(5) 	/ gen van de integral basis	, (1+√5)/2
p=charpoly(w)	/ x^2-x-1

? quadpoly(5)				/ discr 5	,	min pol w 
%77 = x^2 - x - 1		

/ TODO verschil	,

? w = quadgen(-163)		/ (1+√5)/2
%78 = w
? W=Mod(x, quadpoly(-163))
%79 = Mod(x, x^2 - x + 41)

? a=2+w
%84 = 2 + w
? A=2+W
%85 = Mod(x + 2, x^2 - x + 41)

? b=3+w
%86 = 3 + w
? B=3+W
%87 = Mod(x + 3, x^2 - x + 41)

? #
   timer = 1 (on)
? for(i=1,10^5,a+b)
time = 71 ms.
? for(i=1,10^5,A+B)
time = 81 ms.
? for(i=1,10^5,a*b)
time = 132 ms.
? for(i=1,10^5,A*B)			/ sneller	, TODO
time = 114 ms.
? for(i=1,10^5,a/b)
time = 223 ms.
? for(i=1,10^5,A/B)
time = 256 ms.

/ Met W zien we bij sqrt 2 branches, bij w maar 1	,
? W*1.
%109 = Mod(1.0000000000000000000000000000000000000*x, x^2 - x + 41)
? w*1.
%111 = 0.50000000000000000000000000000000000000 + 6.3835726674018523308554760048904461737*I
? W
%104 = Mod(x, x^2 - x + 41)
? sqrt(w)
%112 = 1.8578380227340661097486290394775385694 + 1.7180110938863067607266518282024667278*I
? sqrt(w)^2
%113 = 0.49999999999999999999999999999999999998 + 6.3835726674018523308554760048904461737*I
? sqrt(W)
%105 = [1.8578380227340661097486290394775385694 - 1.7180110938863067607266518282024667278*I, 1.8578380227340661097486290394775385694 + 1.7180110938863067607266518282024667278*I]~
? sqrt(W)[1]^2
%107 = 0.49999999999999999999999999999999999998 - 6.3835726674018523308554760048904461737*I
? sqrt(W)[2]^2
%108 = 0.49999999999999999999999999999999999998 + 6.3835726674018523308554760048904461737*I

/ 13	. 

? a=Mod(x,x^3-x-1)
%114 = Mod(x, x^3 - x - 1)
? subst(x^3-x-1,x,a)
%118 = Mod(0, x^3 - x - 1)

? b=a^5
%115 = Mod(x^2 + x + 1, x^3 - x - 1)
? p=modreverse(b)
%119 = Mod(x^2 - 4*x + 1, x^3 - 5*x^2 + 4*x - 1)
? subst(x^3 - 5*x^2 + 4*x - 1,x,b)
%120 = Mod(0, x^3 - x - 1)

/ 13	 .

/ user guide		, 
/ bij modreverse	,

/ ∛2 = x mod x^3-2 : Q(∛2)=Q[x]/x^3-2	,  
/ ∛4 = y mod x^3-4 : Q(∛4)=Q[y]/y^3-4	,  
/ maar deze 2 fields zijn gelijk	, 

? a=Mod(x,x^3-2)
%132 = Mod(x, x^3 - 2)
? b=a^2
%133 = Mod(x^2, x^3 - 2)	/ y=x^2						/ x is mod x^3-2
? c=modreverse(b)
%135 = Mod(1/2*x^2, x^3 - 4)	/ x=1/2 y^2		/ y is mod y^3-4
/ 

/ als x=1/2 y^2	, dan x^2=1/4 y^4 = 1/4 4y = y	, dus x = 1/2 y^2 mod y^3-4
/ omdat y = x^2 is y^2/2=x^4/2 = x							, dus y = x^2 mod x^3 -2 
/ dus we hebben de inverse rel gevonden (maar met x rekenen je mod  x^3-2, en met y moet je mod y^3 -4 rekenen) en kunen x door y^2/2 vervangen en hebben we de expressies in y	,

/ 13	. 

/  ffinit	,

/ gens een pol	,

/ \u2084=₄
/ \u2074=⁴
/ \u2082=₂
/ \ub2=²

/ F₄=F₂(a)	, a^2=a+1 
/ = F₂[X]/~X^2-X-1

? p=ffinit(2,2)																					/ default x
%153 = Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
? p=ffinit(2,2,y)
%154 = Mod(1, 2)*y^2 + Mod(1, 2)*y + Mod(1, 2)


/ 13	. 

/ ffgen
/ doet ook ffinit	, om het pol te gen	,

? g=ffgen([2,2],t)				/ [p,f]
%146 = t
? g.p
%147 = 2
? g.f
%148 = 2
? g.mod
%149 = t^2 + t + 1
? g^2
%150 = t + 1
? g^3
%151 = 1
? g^4
%152 = t

? g=ffgen([2,4],t)
%155 = t					 /g=t modulo g.mod	,
? g.mod
%156 = t^4 + t^3 + t^2 + t + 1		/ orde 5	, dus niet zo fijn, TODO
								/ Dus we rekenen modulo dit polynoom	, 
? g^2
%162 = t^2
? g^5
%164 = 1
/ Dus NIET OK	,

/ Wel OK	,
? P=Mod(x^4+x+1,2)
%173 = Mod(1, 2)*x^4 + Mod(1, 2)*x + Mod(1, 2)
? g=ffgen(P)
%174 = x
? g.mod
%175 = x^4 + x + 1
? g^5
%177 = x^2 + x
? g^15
%176 = 1

? Q=x^2+t*x+t^4
%187 = x^2 + t*x + t^4
? factor(subst(Q,t,g))
%188 = 
[      x + 1 1]

[x + (t + 1) 1]
/=
/ (x+t^4)(x+t)=x^2+t*x+t^4

/ 13	. 

/ email pari-users

? g=ffgen(16,t)
%193 = t
? g.mod
%194 = t^4 + t^3 + t^2 + t + 1
? h=ffprimroot(g)
%197 = t^3 + t^2 + t
? fforder(h)
%198 = 15

/ 13	. 

/ user guide ffprimroot	,

? i=ffinit(2,4)
%244 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
? t=ffgen(i)
%245 = x
? t.mod
%246 = x^4 + x^3 + x^2 + x + 1
? g=ffprimroot(t,&o)
%247 = x + 1
? g.mod
%248 = x^4 + x^3 + x^2 + x + 1
? fforder(t)
%249 = 5
? fforder(g)
%250 = 15

/ dus niet t=x met x^4 + x^3 + x^2 + x + 1=0	, maar g=x+1 met x^4 + x^3 + x^2 + x + 1=0 is group gen of F16*	, 

? g^4+g^3+1
%253 = 0
/ dus g is root x^4+x^3+1	, (wij doen altijd x^4+x+1)	, 

/ 13	.

/ ffprimroot is WH een prob alg	, 

/ Intermezzo

? i=ffinit(2,4,t)
  ***   at top-level: i=ffinit(2,4,t)
  ***                              ^--
  ***   incorrect type in evaluator [variable name expected] (t_POL).
? i=ffinit(2,4,'t)
%303 = Mod(1, 2)*t^4 + Mod(1, 2)*t^3 + Mod(1, 2)*t^2 + Mod(1, 2)*t + Mod(1, 2)

/ Einde Intermezzo


? i=ffinit(2,4)
%291 = Mod(1, 2)*x^4 + Mod(1, 2)*x^3 + Mod(1, 2)*x^2 + Mod(1, 2)*x + Mod(1, 2)
? g=ffgen(i)
%292 = x
? h=ffprimroot(g)
%293 = x^2 + x
? h=ffprimroot(g)
%294 = x^2 + 1
? h=ffprimroot(g)
%295 = x^2 + x
? h=ffprimroot(g)
%296 = x^3 + x + 1
? h=ffprimroot(g)
%297 = x^2 + x
? h=ffprimroot(g)
%298 = x^2 + 1
? h=ffprimroot(g)
%299 = x^3 + x + 1
? h=ffprimroot(g)
%300 = x^3 + x
? h=ffprimroot(g)
%301 = x + 1


/ 4 . Elementary Arithmetic Functions

? ?
Help topics: for a list of relevant subtopics, type ?n for n in
   4: NUMBER THEORETICAL functions

? ?4

addprimes          bestappr           bestapprPade       bezout             bigomega           binomial           charconj
...

?  ?11

algdep           charpoly         concat           forqfvec         lindep           matadjoint       matcompanion
...

? factor(x^20-1)
time = 4 ms.
%255 = 
[                    x - 1 1]

[                    x + 1 1]

[                  x^2 + 1 1]

[  x^4 - x^3 + x^2 - x + 1 1]

[  x^4 + x^3 + x^2 + x + 1 1]

[x^8 - x^6 + x^4 - x^2 + 1 1]

? factormod(x^2+1,2)
%258 = 
[Mod(1, 2)*x + Mod(1, 2) 2]

/ 13	. 

/ user manual, factorff	,

/ ze factor x^2+1 =(x+2)(x-2) in F5 en in F25	,

/ 1313	. 

/ ffinit geeft een irred pol	, 
/ ffgen maakt er een field gen van:

? t=ffinit(2,4,'t)
%280 = Mod(1, 2)*t^4 + Mod(1, 2)*t^3 + Mod(1, 2)*t^2 + Mod(1, 2)*t + Mod(1, 2)
? g=ffgen(t)
%282 = t
? g.mod
%283 = t^4 + t^3 + t^2 + t + 1

/ Dus ffinit geeft t^4 + t^3 + t^2 + t + 1, en ffgen geeft t mod t^4 + t^3 + t^2 + t + 1	, 

/ 1313	. 

/ F5

? factorff(x^2+1,5,y)
%273 = 
[Mod(Mod(1, 5), Mod(1, 5)*y)*x + Mod(Mod(2, 5), Mod(1, 5)*y) 1]

[Mod(Mod(1, 5), Mod(1, 5)*y)*x + Mod(Mod(3, 5), Mod(1, 5)*y) 1]

/ TODO

/ Lees user guide Rational functions (121)

? T=x^2+1
%274 = x^2 + 1
? factor(T) 				/ over Q
%275 = 
[x^2 + 1 1]

? factor(T*Mod(1,5))	/ over F_5
%276 = 
[Mod(1, 5)*x + Mod(2, 5) 1]

[Mod(1, 5)*x + Mod(3, 5) 1]

/ 1313	.

? i=ffinit(3,2,'t)
%308 = Mod(1, 3)*t^2 + Mod(1, 3)*t + Mod(2, 3)
? g=ffgen(i)
%309 = t
? g.mod
%310 = t^2 + t + 2
? h=ffprimroot(g)
%311 = t + 1
? h=ffprimroot(g)
%321 = t + 1
%316 = 2*t + 2
? fforder(g)
%324 = 8
? fforder(h)
%325 = 8
/ Maar ffprimroot geeft NIET t, terwijl die ook goed is	, 

/ 1313	. 

? T=x^2+1
%336 = x^2 + 1

/ 131313. 

? factor(T)					/ irred over Q
%337 = 
[x^2 + 1 1]

/ 131313. 

? factor(T*Mod(1,3)) 			/ irred over F_3
%335 = 
[Mod(1, 3)*x^2 + Mod(1, 3) 1]
/ x^2

/ 131313. 

? i=ffinit(3,2,'t)																				
%331 = Mod(1, 3)*t^2 + Mod(1, 3)*t + Mod(2, 3)
? g=ffgen(i)
%332 = t
? factor(T*g^0)					/ red over F_{3^2}
%334 = 
[  x + (t + 2) 1]

[x + (2*t + 1) 1]
/ Hier staat: x^2+1=(x+ t-1)(x-(t-1))
/ en (t-1)^2=t^2+t+1=t^2+t-1-1=-1

/ 131313	.

/ of zo	, over F_{3^2}	, 

? factor(T*Mod(Mod(1,3),s^2+s-1))
%343 = 
[Mod(Mod(1, 3), Mod(1, 3)*s^2 + Mod(1, 3)*s + Mod(2, 3))*x + Mod(Mod(1, 3)*s + Mod(2, 3), Mod(1, 3)*s^2 + Mod(1, 3)*s + Mod(2, 3)) 1]

[Mod(Mod(1, 3), Mod(1, 3)*s^2 + Mod(1, 3)*s + Mod(2, 3))*x + Mod(Mod(2, 3)*s + Mod(1, 3), Mod(1, 3)*s^2 + Mod(1, 3)*s + Mod(2, 3)) 1]

/ moeilijk lezen	, je steeds Mod(...,Mod(1, 3)*s^2 + Mod(1, 3)*s + Mod(2, 3))	, 
/ doe daarom	,
? lift(factor(T*Mod(Mod(1,3),s^2+s-1)))					/ red over F_{3^2}
%351 = 
[Mod(1, 3)*x + (Mod(1, 3)*s + Mod(2, 3)) 1]

[Mod(1, 3)*x + (Mod(2, 3)*s + Mod(1, 3)) 1]

/ 131313

/ we kunnen ook over F_{3^2}	, 

? lift(factorff(T,3,s^2+s-1))
%349 = 
[Mod(1, 3)*x + (Mod(1, 3)*s + Mod(2, 3)) 1]

[Mod(1, 3)*x + (Mod(2, 3)*s + Mod(1, 3)) 1]

/ 131313	.

? factor(T*(1+O(3^6)))			/ irred in Q_3, prec 6	, 
%357 = 
[(1 + O(3^6))*x^2 + O(3^6)*x + (1 + O(3^6)) 1]		/ WH staat hier  x^2 + 0x+1	,
/ TODO
? lift(factor(T*(1+O(3^6))))
%359 = 
[x^2 + 1 1]

/ 131313	. 

? factor(T*1.)			/ irred over R	, 
%366 = 
[x^2 + 0.E-38*x + 1.0000000000000000000000000000000000000 1]		/ hier staat x^2+0x+1

/ 131313	.

/ over C	, 

? factor(T*(1.+0.*I))			/ red over C	, (x+1)(x-1)
%367 = 
[x + (0.E-38 + 1.0000000000000000000000000000000000000*I) 1]

[x + (0.E-38 - 1.0000000000000000000000000000000000000*I) 1]

/ 131313	.

/ over Q(3th root of 2)

? factor(T*Mod(1, y^3-2))		/ irred	, 
time = 1 ms.
%368 = 
[x^2 + 1 1]

/ 131313

/ we kunnen ook ipv factor factorff, factorpadic use	,

in Q3: (x+12)^2=x^2+211x+1121

break> U=x^2+14*x+49
x^2 + 14*x + 49
break> factorpadic(U,3,4)

[(1 + O(3^4))*x + (1 + 2*3 + O(3^4)) 2]

/ of	,  maar dat is blijkbaar niet nodig, dat hoeft alleen als je met factor werkt WH TODO
break> S=(1+O(3^4))*x^2+(2+3+3^2+O(3^4))*x+(1+3+3^2+3^3+O(3^4))
(1 + O(3^4))*x^2 + (2 + 3 + 3^2 + O(3^4))*x + (1 + 3 + 3^2 + 3^3 + O(3^4))
break> factorpadic(U,3,4)

[(1 + O(3^4))*x + (1 + 2*3 + O(3^4)) 2]
 

/ 1313	. 

/ F25

/ F25=F5[t], t^2=2	, 
/ ontbind in F25: x^2+t+1=(x+(2*t+1))(x-(2*t+1))	, 
/ want = x^2 - (-t^2-t+1)=x^2-(-2-t+1)=x^2+t+1	.

? t = ffgen(y^2 + Mod(3,5), 't)
/ of	,
? t = ffgen(Mod(y^2 + 3,5), 't)
t
? t.mod
t^2 + 3
? t.p
5
? t.f
2

? factorff(x^2+1)
  ***   at top-level: factorff(x^2+1)
  ***                 ^---------------
  *** factorff: incorrect type in factorff (t_POL).
? factorff(x^2+t^0)

[x + 2 1]

[x + 3 1]

? factorff(x^2+t+1)

[x + (2*t + 1) 1]

[x + (3*t + 4) 1]

/ 13	. 

? gcd(15,21)
3
? gcd([15,21])
3
? gcd((x+1)^2,x^2+3*x+2)
%370 = x + 1
? gcd((t+1)^2,t^2+3*t+2)
%5 = t + 1
? gcd(x*y+x+y+1,x^2+2*x+1)
%2 = x + 1
? gcdext(15,21)
%3 = [3, -2, 3]

? chinese(Mod(1,2), Mod(2,3))
%6 = Mod(5, 6)
? chinese(Mod(x,x^2-1), Mod(x+1,x^2+1))
%7 = Mod(-1/2*x^2 + x + 1/2, x^4 - 1)

/ Intermezzo

? Mod(Mod(1,3),2)
%15 = Mod(0, 1)
/ want Mod(1,3)=...,-5,-2,1,4,7, ... en Mod(Mod(1,3),2)= ...,1,0,1,0,1,...

? Mod(Mod(1,6),4)
%19 = Mod(1, 2)
/ want Mod(1,6)=...,-11,-5,1,7,13, ... en Mod(Mod(1,6),4)= ...,1,3,1,3,1,...

/ Einde Intermezzo

? P = x+1; Q = x^2+2*x+1;
? chinese(P*Mod(1,2), Q*Mod(1,3))
%9 = Mod(1, 3)*x^2 + Mod(5, 6)*x + Mod(1, 6)

?  Vec(P,3)
%21 = [1, 1, 0]
? Vec(Q,3)
%27 = [1, 2, 1]
? P
%22 = x + 1
? Q
%28 = x^2 + 2*x + 1
? chinese(Vec(P,3)*Mod(1,2), Vec(Q,3)*Mod(1,3))
%25 = [Mod(1, 6), Mod(5, 6), Mod(4, 6)]
/ TODO

/ Afmaken

/ 5	. Performing Linear Algebra	.

/ Lees	,
http://www-users.math.umn.edu/~olver/num_/lnz.pdf

/ Gram matrix K=A^T*A	, 
/ K is semi pos def	, en is pos def is KerA=0

break> Mod(1/3,5)
Mod(2, 5)

? h=mathilbert(3)
%39 = 
[  1 1/2 1/3]

[1/2 1/3 1/4]

[1/3 1/4 1/5]

? m=h*Mod(1,7)
%40 = 
[Mod(1, 7) Mod(4, 7) Mod(5, 7)]

[Mod(4, 7) Mod(5, 7) Mod(2, 7)]

[Mod(5, 7) Mod(2, 7) Mod(3, 7)]

? m2=h*(1+O(7^2))
%41 = 
[      1 + O(7^2) 4 + 3*7 + O(7^2) 5 + 4*7 + O(7^2)]

[4 + 3*7 + O(7^2) 5 + 4*7 + O(7^2) 2 + 5*7 + O(7^2)]

[5 + 4*7 + O(7^2) 2 + 5*7 + O(7^2)   3 + 7 + O(7^2)]

/ Klopt	, bijv 1/2	: 
/ 7-adic: 766...=0	, dus 2/1 \ = 2/866...\=433... 

? m2=h*(1+O(7^8))
%45 = 
[1 + O(7^8) 4 + 3*7 + 3*7^2 + 3*7^3 + 3*7^4 + 3*7^5 + 3*7^6 + 3*7^7 + O(7^8) 5 + 4*7 + 4*7^2 + 4*7^3 + 4*7^4 + 4*7^5 + 4*7^6 + 4*7^7 + O(7^8)]

[4 + 3*7 + 3*7^2 + 3*7^3 + 3*7^4 + 3*7^5 + 3*7^6 + 3*7^7 + O(7^8) 5 + 4*7 + 4*7^2 + 4*7^3 + 4*7^4 + 4*7^5 + 4*7^6 + 4*7^7 + O(7^8) 2 + 5*7 + 7^2 + 5*7^3 + 7^4 + 5*7^5 + 7^6 + 5*7^7 + O(7^8)]

[5 + 4*7 + 4*7^2 + 4*7^3 + 4*7^4 + 4*7^5 + 4*7^6 + 4*7^7 + O(7^8) 2 + 5*7 + 7^2 + 5*7^3 + 7^4 + 5*7^5 + 7^6 + 5*7^7 + O(7^8) 3 + 7 + 4*7^2 + 5*7^3 + 2*7^4 + 7^5 + 4*7^6 + 5*7^7 + O(7^8)]

/ we zien elem 1,2 als 433...

/ we moeten een priemgetal, 7	, kiezen waar niet door gedeeld wordt in de matrix, 
/ 2, 3 of 5 kunnen we dus niet kiezen	,

? d=matdet(m)
%46 = Mod(2, 7)
? d2=matdet(m2)
%47 = 2 + 5*7 + 3*7^3 + 6*7^5 + 3*7^6 + 7^7 + O(7^8)

/ have p-adic rational repeating  decimals?
/ TODO

? H=1/h
%50 = 
[  9  -36   30]

[-36  192 -180]

[ 30 -180  180]

? matdet(H)
%55 = 2160

/ primes tussen	,
? primes([10,20])
%51 = [11, 13, 17, 19]

? L = primes([100,150])
%56 = [101, 103, 107, 109, 113, 127, 131, 137, 139, 149]
? #L
%59 = 10
? v=vector(#L, i, matdet(H * Mod(1,L[i])))
%57 = [Mod(39, 101), Mod(100, 103), Mod(20, 107), Mod(89, 109), Mod(13, 113), Mod(1, 127), Mod(64, 131), Mod(105, 137), Mod(75, 139), Mod(74, 149)]
? c=chinese(v)
%58 = Mod(2160, 647208138850831221463)
? centerlift(c)
2160
/ TODO Waarom die finite fields?

/ 131313	. 

/ Smith normal form	, 

? matsnf(H)
%68 = [60, 12, 3]

/ 131313	. 

/ iets kleiner voorbeeld	,

? h2=mathilbert(2)
%71 = 
[  1 1/2]

[1/2 1/3]

? H2=1/h2
%72 = 
[ 4 -6]

[-6 12]

? matsnf(H2)
%73 = [6, 2]
/ TODO

/ wat heeft dit te maken met Z^2/L	?
/ TODO

/ see boek(67)

/ 131313	. 

? H=[1,-1;1,1]
%6 = 
[1 -1]

[1  1]

? matsnf(H)
%7 = [2, 1]
/ TODO

/ Intermezzo

/ Lees	, 
https://en.wikipedia.org/wiki/Smith_normal_form

? m=[2,4,4;-6,6,12;10,-4,-16]
%76 = 
[ 2  4   4]

[-6  6  12]

[10 -4 -16]

? matsnf(m)
%77 = [12, 6, 2]
/ TODO



/ Einde Intermezzo

/ Intermezzo

? A1=[1,2;3,4]
%16 = 
[1 2]

[3 4]

? A1~			\\ transpose
%17 = 
[1 3]

[2 4]

? A1*[1,0]~
%18 = [1, 3]~
/ klopt	,


/ Einde Intermezzo

/ Intermezzo

/ hermite normal form	,

/ Lees	, 
https://en.wikipedia.org/wiki/Hermite_normal_form

/ daar doen ze um=h, wij doen mu=h	, 

break> ?mathnf
mathnf(M,{flag=0}): (upper triangular) Hermite normal form of M, basis for the lattice formed by the columns of M. flag is optional whose value range from 0 to 3 have a binary meaning. Bit 1: complete output, returns a 2-component vector [H,U] such that H is the HNF of M, and U is an invertible matrix such that MU=H.

/ mu=h is column style	,

? m=[3,3,1,4;0,1,0,0;0,0,19,16;0,0,0,3]
%19 = 
[3 3  1  4]

[0 1  0  0]

[0 0 19 16]

[0 0  0  3]

? hu=mathnf(m,1);
? h=hu[1]
%26 = 
[3 0  1  1]

[0 1  0  0]

[0 0 19 16]

[0 0  0  3]

? u=hu[2]
%27 = 
[1 -1 0 -1]

[0  1 0  0]

[0  0 1  0]

[0  0 0  1]

? h/u
%28 = 
[3 3  1  4]

[0 1  0  0]

[0 0 19 16]

[0 0  0  3]
/ Klopt, == m	,


? m*u
%69 = 
[3 0  1  1]

[0 1  0  0]

[0 0 19 16]

[0 0  0  3]
/ Dat ziet er beter uit	, zegt de tutorial	,


/ Hoe interpret	? we zien F altijd als de nieuwe basis	, en h de matrix in deze nieuwe basis
/ TODO


/ m=hv	, v=1/u	,

/ we nemen een kleiner voorbeeld	,

?  m=[2,-4;2,4]
%97 = 
[2 -4]

[2  4]

? h=mathnf(m,1)[1]
%95 = 
[8 2]

[0 2]

? u=mathnf(m,1)[2]
%96 = 
[ 2 1]

[-1 0]

? v=1/u
%98 = 
[0 -1]

[1  2]

/ m=hv

? m*[2,1]~
%99 = [0, 8]~

? v*[2,1]~
%100 = [-1, 4]~

? h*[-1,4]~
%101 = [0, 8]~

/ dus m*[2,1]~ is h*[-1,4]~ met v*[2,1]~=[-1,4]~

/ dus v is van canonical base to new one	, in tutorial staat dat u dat is	,
/ TODO


/ Einde Intermezzo


/ Intermezzo

/ Staat NIET in de tutorial	, 

/ smith normal form	,

/ Lees	,
https://en.wikipedia.org/wiki/Smith_normal_form

? ?matsnf
matsnf(X,{flag=0}): Smith normal form (i.e. elementary divisors) of the matrix X, expressed as a vector d. Binary digits of flag mean 1: returns [u,v,d] where d=u*X*v,

? m=[2,4,4;-6,6,12;10,-4,-16]
%31 = 
[ 2  4   4]

[-6  6  12]

[10 -4 -16]

? uvd=matsnf(m,1);
? u=uvd[1]
%47 = 
[1 0 -5]

[0 1  0]

[0 0  1]

? v=uvd[2]
%48 = 
[ 4 -2  3]

[-2  3 -1]

[ 3 -2  2]

? d=uvd[3]
%49 = 
[12 0 0]

[ 0 6 0]

[ 0 0 2]

? (1/u)*d*(1/v)		\\ m
%50 = 
[ 2  4   4]

[-6  6  12]

[10 -4 -16]

/ dus voor en na coord transf is de 

/ Einde Intermezzo

/ Intermezzo

? matsnf([2,0;0,2],1)
%53 = [[1, 0; 0, 1], [1, 0; 0, 1], [2, 0; 0, 2]]

? matsnf([4,0;0,2],1)
%55 = [[1, 0; 0, 1], [1, 0; 0, 1], [4, 0; 0, 2]]

? matsnf([2,0;0,4],1)
%54 = [[0, 1; 1, 0], [0, 1; 1, 0], [4, 0; 0, 2]]


/ Einde Intermezzo

/ 13	. 

/ Lees	, 
https://en.wikipedia.org/wiki/Lattice_reduction

/ lll reduction gives nearly orthogonal vectors	,

qflll(x,{flag=0}): LLL reduction of the vectors forming the matrix x (gives the unimodular transformation matrix T such that x*T is LLL-reduced). flag is optional, and can be 0: default, 1: assumes x is integral,

/ voobeeld	, 

? m= [1,0;1,1]~
%107 = 
[1 1]

[0 1]

? t=qflll(m,1)
%108 = 
[1 -1]

[0  1]

? m*t
%109 = 
[1 0]

[0 1]

/ voorbeeld	,

? m= [1,0;1,2]~
%110 = 
[1 1]

[0 2]

? t=qflll(m,1)
%111 = 
[1 -1]

[0  1]

? m*t
%112 = 
[1 0]

[0 2]

/ 1313	. 

? u = [log(15), log(5), log(3)]
%116 = [2.7080502011022100659960045701487133442, 1.6094379124341003746007593332261876395, 1.0986122886681096913952452369225257047]
? round(u * 10^25)
%117 = [27080502011022100659960046, 16094379124341003746007593, 10986122886681096913952452]

? matid(3)
%113 = 
[1 0 0]

[0 1 0]

[0 0 1]

/ we vervangen de 3de rij	,
? m[3,]=round(u * 10^25)
%122 = [27080502011022100659960046, 16094379124341003746007593, 10986122886681096913952452]
? m
%123 = 
[                         1                          0                          0]

[                         0                          1                          0]

[27080502011022100659960046 16094379124341003746007593 10986122886681096913952452]

?  qflll(m,1)
%124 = 
[-1 -927862937355  1255833311935]

[ 1 -293944506518  4344592399461]

[ 1 2717778490045 -9460308683878]

? v= qflll(m,1)[,1]
%125 = [-1, 1, 1]~

? u*v
-5.877471754111437540 E-39

/ Dus  -log15 + log3 + log5=0

/ lindep doet dit	, 
? lindep(u)
[-1, 1, 1]~

/ 1313	. 

? h=mathilbert(5)
%129 = 
[  1 1/2 1/3 1/4 1/5]

[1/2 1/3 1/4 1/5 1/6]

[1/3 1/4 1/5 1/6 1/7]

[1/4 1/5 1/6 1/7 1/8]

[1/5 1/6 1/7 1/8 1/9]

? H=1/h
%130 = 
[   25   -300    1050   -1400    630]

[ -300   4800  -18900   26880 -12600]

[ 1050 -18900   79380 -117600  56700]

[-1400  26880 -117600  179200 -88200]

[  630 -12600   56700  -88200  44100]

? M=H*qflll(H)
%134 = 
[ 0 -60 -20   0   15]

[60   0   0   0    0]

[ 0   0   0 420  210]

[ 0   0 280   0    0]

[ 0   0   0   0 -630]

/ almost orthogonal	,

? G=M~*M

[3600    0     0      0      0]

[   0 3600  1200      0   -900]

[   0 1200 78800      0   -300]

[   0    0     0 176400  88200]

[   0 -900  -300  88200 441225]

/ Gram matrix is matrix of inproducts of a set of vectors	,

? m = qfminim(G, norml2(M[,1]), 100, 2)
%145 = [4, 3600.000000000000000, [0, 1; 1, 0; 0, 0; 0, 0; 0, 0]]

? norml2(M[,1])
%146 = 3600

? ?qfminim
qfminim(x,{b},{m},{flag=0}): x being a square and symmetric matrix representing a positive definite quadratic form, this function deals with the vectors of x whose norm is less than or equal to b, enumerated using the Fincke-Pohst algorithm, storing at most m vectors (no limit if m is omitted). The function searches for the minimal non-zero vectors if b is omitted. The precise behavior depends on flag. 0: returns at most 2m vectors (unless m omitted), returns [N,M,mat] where N is the number of vectors enumerated, M the maximum norm among these, and mat lists half the vectors (the other half is given by -mat). 1: ignores m and returns the first vector whose norm is less than b. 2: as 0 but uses a more robust, slower implementation, valid for non integral quadratic forms.

/ 131313	.

? n=matid(2)*2
%147 = 
[2 0]

[0 2]

? qfminim(n,1)
%148 = [0, 0, [;]]
? qfminim(n,2)
%149 = [4, 2, [0, 1; 1, 0]]
? qfminim(n,2,1)
%150 = [4, 2, [0; 1]]

/ 131313	.

?  n=[1,2;2,5]~
%170 = 
[1 2]

[2 5]

? ?qfminim(x,{b},{m},{flag=0})

? qfminim(n,1,2)																/ 1 is max norm	, TODO	, 2 is max number of vectors	,
%173 = [4, 1, [2, 1; -1, 0]]		/ WH is 1ste column vector [2,-1]~
? qfminim(n,1,1)
%176 = [4, 1, [2; -1]]			/ WH is [2;-1] andere notatie voor [2,-1]~
? ?qfminim(n,5)

? qfminim(n,1,2,1)			/ laatste 1: ignore 2 ervoor	, geef de 1ste	,
%178 = [1, [2, -1]~]

/ WH [2;-1] = [2,-1]~	, want we nemen inproduct hieronder	,
? [3,4]*[2;-1]
%180 = [2]

? qfminim(n,,2)
%182 = [4, 1, [2, 1; -1, 0]]
/ omit b	,

/ 1313	 .

? n
%187 = 
[1 2]

[2 5]

? qfminim(n,1)
%183 = [4, 1, [2, 1; -1, 0]]
? qfminim(n,1)[3]
%188 = 
[ 2 1]

[-1 0]

? qfminim(n,2)
/ of	,
? qfminim(n,3)
%184 = [8, 2, [1, 2, 3, 1; -1, -1, -1, 0]]
? qfminim(n,2)[3]
/ of	,
? qfminim(n,3)[3]
%186 = 
[ 1  2  3 1]

[-1 -1 -1 0]


? qfminim(n,4)
%190 = [12, 4, [4, 1, 2, 3, 2, 1; -2, -1, -1, -1, 0, 0]]
? qfminim(n,4)[3]
%191 = 
[ 4  1  2  3 2 1]

[-2 -1 -1 -1 0 0]

/ 1313	.

? h5=mathilbert(5)
? H5=1/h5
? M5=H5*qflll(H5)
? G5=M5~*M5
%232 = 
[3600    0     0      0      0]

[   0 3600  1200      0   -900]

[   0 1200 78800      0   -300]

[   0    0     0 176400  88200]

[   0 -900  -300  88200 441225]

? m = qfminim(G, norml2(M[,1]),50 , 2)
%233 = [6, 54192375991353600.000000000000000000000, [0, 0, 1; 0, 1, 0; 1, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0]]
? m[3]
%234 = 
[0 0 1]

[0 1 0]

[1 0 0]

[0 0 0]
...

? m = qfminim(G, norml2(M[,4]),50 , 2)
%229 = [100, 28667766899426054400.000000000000000000, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8, 9, -9, 10, -10, 11, -11, 12, -12, 13, -13; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,...

? m[3]
%231 = 
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]

[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]

[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 0 1 -1 2 -2 3 -3 4 -4 5 -5 6 -6 7 -7 8 -8 9 -9 10 -10 11 -11 12 -12 13 -13]

[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
...


/ 13	. 

/ transcedental functions	,



























































/ Einde TUTORIAL
