/ Scala eclipse	, 
/ ws workspace-spring

/ See WHERE @CONFIGURATION
/ See WHERE @COMPONENTSCAN
/ See WHERE @COMPONENT
/ See STANDARD METHOD
/ See WHERE @BEAN
/ See SPEL

/ See DEBUG SPRING 
/ 	See WHERE @CONFIGURATION
/ 	See WHERE @COMPONENTSCAN
/ 	See ASM IN SPRING
/ 	See SET PROPERTIES IN BEAN
/ 	See WHERE @AUTOWIRED
/ 	See @AUTOWIRED ON CTOR
/ 	See TODO LOGGER IN ORDE MAKEN
/ 	See @POSTCONSTRUCT @PREDESTROY
/ 	See @WEBSERVICEREF @EJBREF @RESOURCE 
/ 	See FIND @AUTOWIRED
/ 	See LOGGING
/ 	See @QUALIFIER
/ 	See INJECTION IN CTOR IS RESOLVED MATCHING BEANS 

/ See LATER MET KNIGHTTESTCONFIG

/ See SPRING PROPERTY VALUES
/ See SPRING LOGGING
/ See SPRING THEORY
/ See CREATE BEAN WITH AUTOWIRED ARG

/ See SPRING API DOCS

/ See DEBUG @CONFIGURATTION
/ 	See WHERE @COMPONENTSCAN OF @BEAN

/ See METHOD WHERE @COMPONENETSCAN AND @BEAN

/ IMPORTANT METHODS

/ 13	. 

ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 100	
	...

/ 13	. 

DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 537	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
			populateBean(beanName, mbd, instanceWrapper);
				exposedObject = initializeBean(beanName, exposedObject, mbd);

/ 13	. 

/ stack	,

	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
ppName=org.springframework.context.annotation.internalConfigurationAnnotationProcessor
priorityOrderedPostProcessors=[org.springframework.context.annotation.ConfigurationClassPostProcessor@222114ba]

			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
/ ConfigurationClassPostProcessor moet meteen aan de bak	,
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	

/ See DEBUG @CONFIGURATION

/ 13	. 

ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	

/ WHERE @CONFIGURATTION
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));

		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
		parser.parse(configCandidates);
...
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 248	
/ WHERE @COMPONENTSCAN
		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			// The config class is annotated with @ComponentScan -> perform the scan immediately
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/ Op zoek naar @Component	?
/ TODO

/ anders	,
		// Process individual @Bean methods
/ WHERE @BEAN
		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}




/ Einde IMPORTANT METHODS

/ TODOS

/ 13	. 

DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1128	
		PropertyValues pvs = mbd.getPropertyValues();

/ Einde TODOS

/ VISITORS
AnnotationMetadataReadingVisitor(ClassMetadataReadingVisitor).visit(int, int, String, String, String, String[]) line: 72	
AnnotationMetadataReadingVisitor.visitAnnotation(String, boolean) line: 83	
AnnotationMetadataReadingVisitor(ClassMetadataReadingVisitor).visitField(int, String, String, String, Object) line: 124	
AnnotationMetadataReadingVisitor.visitMethod(int, String, String, String, String[]) line: 78	

class ClassMetadataReadingVisitor extends ClassVisitor implements ClassMetadata {

AnnotationAttributesReadingVisitor.<init>(String, MultiValueMap<String,AnnotationAttributes>, Map<String,Set<String>>, ClassLoader) line: 252	

MethodMetadataReadingVisitor.<init>(String, int, String, ClassLoader, Set<MethodMetadata>) line: 64	


/ Einde VISITORS


/ MARS

/ Mars eclipse	, 
/ ws workspace-spring
/ proj first-spring

/ we create in eclipse een Maven proj, maar niet met een archetype uit de catalog, maar zelf	, 
File, New Maven Project
Create a simple project (skip archetype selection) : check
/ Je krijgt de pom hieronder	, behalve <dependencies/>	, die maken we zelf	,

$ vi pom.xml

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>my.own</groupId>
  <artifactId>first-spring</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  
  <dependencies>
	  <dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-context</artifactId>
	    <version>4.3.2.RELEASE</version>
	</dependency>
  </dependencies>
</project>

$ vi MessageService.java
package intro;

public interface MessageService {
	String getMessage();
}

$ vi MessagePrinter.java
ackage intro;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MessagePrinter {
	private MessageService messageService;

	@Autowired
	public MessagePrinter(MessageService messageService) {
		this.messageService=messageService;
	}
	
	public void printMessage(){
		System.out.println(messageService.getMessage());
	}
}

$ vi Application.java
package intro;

import java.math.BigInteger;
import java.util.Random;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class Application {
	
	@Bean
	MessageService f(){
		return new MessageService() {
			
			public String getMessage() {
				return "Hello World";
			}
		};
	}

	public static void main(String[] args) {
		ApplicationContext  applicationContext=new AnnotationConfigApplicationContext(Application.class);
		MessagePrinter messagePrinter=applicationContext.getBean(MessagePrinter.class);
		messagePrinter.printMessage();
	}
}

/ OK

/ 7	.

/ Mars eclipse, 

/ we hadden een proj delete uit een ws, en wilden deze in een andere doen	, 
/ we zien 'invalid project description'	,


/ lees,	
http://stackoverflow.com/questions/5784652/eclipse-invalid-project-description-when-creating-new-project-from-existing-so
http://stackoverflow.com/questions/514833/how-to-delete-a-workspace-in-eclipse

/ in ws workspace-spring-a4-new a4/ 	, maar gradle build TODO

/ Einde MARS


/ STS INSTALL

[eric@almond STS]$ pwd
/home/eric/Devel/Eclipse/STS
[eric@almond STS]$ tar xvzf ~/Downloads/spring-tool-suite-3.8.2.RELEASE-e4.6.1-linux-gtk-x86_64.tar.gz 
/ In STS/ hebben we workspace/ create	,

/ we zien geen gradle plugin	,
/ we hebben buildship via marketplace installed	, 

/ lees	,  
http://www.vogella.com/tutorials/EclipseGradle/article.html#install-eclipse-gradle-buildship-tooling

[eric@almond sts-bundle]$ sts-3.8.2.RELEASE/STS 


/ Einde STS INSTALL

/ GRAIG BOOK

/ graig walls' spring in action: install bijv knight	, niet geheel a4	, 
/ TODO

/ 7	. 

/ ch2 , auto-config, met @Component	,

[eric@almond sts-bundle]$ sts-3.8.2.RELEASE/STS 
 /proj stereo-autoconfig


/ we set @Component op de beans zelf	, 
/ we set @Configuration , @ComponentScan op de config class	,

/ the annotations are on the beans, not on the interfaces	,

$ less CDPlayerConfig.java

@Configuration
@ComponentScan
public class CDPlayerConfig { 
}

$ less SgtPeppersDisc.java

@Component
public class SgtPeppersDisc implements IDisc {
	private String title = "Sgt. Pepper's Lonely Hearts Club Band";  
  private String artist = "The Beatles";

  public void play() {
    System.out.println("Playing " + title + " by " + artist);
  }
}

$ less CDPlayer.java

@Component
public class CDPlayer implements IPlayer {
  private IDisc cd;

  @Autowired
  public CDPlayer(IDisc cd) {
    this.cd = cd;
  }

  public void play() {
    cd.play();
  }


$ less CDPlayerTest.java

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=CDPlayerConfig.class)
public class CDPlayerTest {

  @Rule
  public final StandardOutputStreamLog log = new StandardOutputStreamLog();

///////////////////////////

  @Autowired
  private IDisc cd;
  
  @Test
  public void cdShouldNotBeNull() {
    assertNotNull(cd);
  }

  //////////////////////////////////////
  // For this test the @Autowired above was not necessary, 
  // but because Spring bean are singletons, it is the same SgtPeppersDisc bean.
  @Autowired
  private IPlayer player;

  @Test
  public void play() {
    player.play();
    assertEquals(
        "Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n", 
        log.getLog());
  }

}

/ 7	. 

/ java-config	, met @Bean	, 

/ de @Bean staat niet op de beans zelf, maar op producer fcts	, 

$ less CDPlayerConfig.java

@Configuration
public class CDPlayerConfig {
  
  @Bean
  public IDisc compactDisc() {
    return new SgtPeppersDisc();
  }
  
  @Bean
  public IPlayer cdPlayer(IDisc compactDisc) {
    return new CDPlayer(compactDisc);
  }
}
/ er wordt door cdPlayer() ook een SgtPepperDisc  @Autowired	, 
/ we hoeven dus NIET  @Autowired in CDPlayer	,

$ vi CDPlayer.java

public class CDPlayer implements IPlayer {
  private IDisc cd;

//  @Autowired
  public CDPlayer(IDisc cd) {
    this.cd = cd;
  }

  @Override
  public void play() {
    cd.play();
  }

}
 
$ less SgtPeppersDisc.java

public class SgtPeppersDisc implements IDisc {

  private String title = "Sgt. Pepper's Lonely Hearts Club Band";  
  private String artist = "The Beatles";
  
  public void play() {
    System.out.println("Playing " + title + " by " + artist);
  }

}


$ vi CDPlayerTest.java

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=CDPlayerConfig.class)
public class CDPlayerTest {

  @Rule
  public final StandardOutputStreamLog log = new StandardOutputStreamLog();

  @Autowired
  private IPlayer player;

  @Test
  public void play() {
    player.play();
    assertEquals(
        "Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n", 
        log.getLog());
  }

}

/ 7	. 

/ lees	,
https://blog.jayway.com/2012/02/25/mockito-and-dependency-injection/

/ moeten we @Autowired in de class voor @MockitoInject in de test	?

/ lees	,
http://stackoverflow.com/questions/20395158/why-field-injection-causes-class-is-difficult-to-test
http://olivergierke.de/2013/11/why-field-injection-is-evil/

/ 7	 .

[eric@almond Spring]$ pwd
/home/eric/Devel/Java/Spring
[eric@almond Spring]$ git clone http://sdg.repositoryhosting.com/git_public/sdg/sdg-blog.git
[eric@almond Spring]$ ls sdg-blog/sdg-mockitospring/
pom.xml  src

/lees	, 
https://spring.io/guides/gs/accessing-data-jpa/

$ vi Account.java

@Entity
public class Account {
	
	public Account() {
		// TODO Auto-generated constructor stub
	}
/ moet
/ TODO

/ 7	. 

/ right click project, properties , java compiler, 
/ we uncheck 'Enable project specific settings'
/ want de global settings staan al OK op 1.8	, 
/ Window, properties, Java , Compiler	, 

/ maar we moeten ook de project facets aanpassen, 
/ right click project, properties , project facets
Java 1.8
JPA 2.0 (al ok) 

/ 7	. 

/ DEBUG KNIGHTMAIN XML

/ Neem scala-eclipse , dat is Luna	, want dan kunnen we copy van variables en debug view	,

/ proj knight	,

 public static void main(String[] args) throws Exception {
    ClassPathXmlApplicationContext context = 		/ set b NIET op deze line	,
        new ClassPathXmlApplicationContext(			/ set b op deze line	, 
            "META-INF/spring/knight.xml");

Object
public class SimpleAliasRegistry implements AliasRegistry {
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry {
public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory {
public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory {
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
@Deprecated public class XmlBeanFactory extends DefaultListableBeanFactory {

public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {
	@Override
	protected final void refreshBeanFactory() throws BeansException {
		try {
			DefaultListableBeanFactory beanFactory = createBeanFactory();
			beanFactory.setSerializationId(getId());
			customizeBeanFactory(beanFactory);
			loadBeanDefinitions(beanFactory);
/s
public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {
	@Override
	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
		// Create a new XmlBeanDefinitionReader for the given BeanFactory.
		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

		// Configure the bean definition reader with this context's
		// resource loading environment.
		beanDefinitionReader.setEnvironment(this.getEnvironment());
		beanDefinitionReader.setResourceLoader(this);
		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

		// Allow a subclass to provide custom initialization of the reader,
		// then proceed with actually loading the bean definitions.
		initBeanDefinitionReader(beanDefinitionReader);
		loadBeanDefinitions(beanDefinitionReader);
	}
/s
public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {
	protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
		Resource[] configResources = getConfigResources();
null
		String[] configLocations = getConfigLocations();
[META-INF/spring/knight.xml]
		if (configLocations != null) {
			reader.loadBeanDefinitions(configLocations);
		}
/s
public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader {
	public int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {
		ResourceLoader resourceLoader = getResourceLoader();
org.springframework.context.support.ClassPathXmlApplicationContext@d8355a8: startup date [Sat Dec 10 14:55:41 CET 2016]; root of context hierarchy

/ verwar de app context niet met de bean factory	,

				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
/s
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		return this.resourcePatternResolver.getResources(locationPattern);
/s
public class PathMatchingResourcePatternResolver implements ResourcePatternResolver {
	public Resource[] getResources(String locationPattern) throws IOException {
			else {
				// a single resource with the given name
				return new Resource[] {getResourceLoader().getResource(locationPattern)};
/s
public class DefaultResourceLoader implements ResourceLoader {
	public Resource getResource(String location) {
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
/n
/ TODO
			try {
				// Try to parse the location as a URL...
				URL url = new URL(location);
/ EXC
			}
			catch (MalformedURLException ex) {
				// No URL -> resolve as resource path.
				return getResourceByPath(location);
/s
	protected Resource getResourceByPath(String path) {
		return new ClassPathContextResource(path, getClassLoader());

/ Dus toch classpath	, 
/ we hadden classpath: er ook voor kunnen zetten 	, WH	,
...
/t
public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader {
	public int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {
				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
/d
...
/s
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
			InputStream inputStream = encodedResource.getResource().getInputStream();
encodedResource=class path resource [META-INF/spring/knight.xml]
				InputSource inputSource = new InputSource(inputStream);		/ sax	,
				return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
/s
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			Document doc = doLoadDocument(inputSource, resource);
			return registerBeanDefinitions(doc, resource);
/s
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
		return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
				getValidationModeForResource(resource), isNamespaceAware());

/ TODO entity resolver
/s
public class DefaultDocumentLoader implements DocumentLoader {
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
/s
public class DefaultDocumentLoader implements DocumentLoader {
	protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware) throws ParserConfigurationException {

		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();	
com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl@3ec300f1

		factory.setNamespaceAware(namespaceAware);

		if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
			factory.setValidating(true);
			if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
				// Enforce namespace aware for XSD...
				factory.setNamespaceAware(true);
				try {
					factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
http://java.sun.com/xml/jaxp/properties/schemaLanguage : http://www.w3.org/2001/XMLSchema

		return factory;
/t
public class DefaultDocumentLoader implements DocumentLoader {
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {
		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);	 / javax.xml.parsers
com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl@3ec300f1
/d
		}
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
/s
public class DefaultDocumentLoader implements DocumentLoader {
	protected DocumentBuilder createDocumentBuilder( DocumentBuilderFactory factory, EntityResolver entityResolver, ErrorHandler errorHandler) throws ParserConfigurationException {

		DocumentBuilder docBuilder = factory.newDocumentBuilder();
factory=com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl@3ec300f1
docBuilder=com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl@482cd91f
		if (entityResolver != null) {
			docBuilder.setEntityResolver(entityResolver);
		if (errorHandler != null) {
			docBuilder.setErrorHandler(errorHandler);
		}
		return docBuilder;
/t
public class DefaultDocumentLoader implements DocumentLoader {
	public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
/d
com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl@482cd91f

		return builder.parse(inputSource);
/t
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
			Document doc = doLoadDocument(inputSource, resource);
/d
			return registerBeanDefinitions(doc, resource);
/s
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
/s
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {
		return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));
/ TODO .cast	,
this.documentReaderClass=class org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader
/s
public abstract class BeanUtils {
	public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {
		try {
			return instantiateClass(clazz.getDeclaredConstructor());
clazz=class org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader
/s
public abstract class BeanUtils {
	public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {
		try {
			ReflectionUtils.makeAccessible(ctor);
/ TODO
			return ctor.newInstance(args);
/t
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
/d
org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader@7f010382

		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
resouce=class org.springframework.core.io.DefaultResourceLoader$ClassPathContextResource	 class path resource [META-INF/spring/knight.xml]
/s
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	public XmlReaderContext createReaderContext(Resource resource) {
		return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver());
/t
public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {
	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
/pd
/s
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
		this.readerContext = readerContext;
		Element root = doc.getDocumentElement();
class com.sun.org.apache.xerces.internal.dom.DeferredElementNSImpl [beans: null]
		doRegisterBeanDefinitions(root);
/s
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	protected void doRegisterBeanDefinitions(Element root) {
		this.delegate = createDelegate(this.readerContext, root, parent);
		parseBeanDefinitions(root, this.delegate);
/s
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
		if (delegate.isDefaultNamespace(root)) {
			NodeList nl = root.getChildNodes();
			for (int i = 0; i < nl.getLength(); i++) {
5
				Node node = nl.item(i);
[#text: 

  ]
				if (node instanceof Element) {
/n
			for (int i = 0; i < nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
/j
[bean: null]
					if (delegate.isDefaultNamespace(ele)) {
						parseDefaultElement(ele, delegate);
/s
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
/s
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {

/ de stack trace =
class DefaultBeanDefinitionDocumentReader/superclass methods
class XmlBeanDefinitionReader/superclass methods 
class ClassPathXmlApplicationContext/superclass methods	,  

		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
class org.springframework.beans.factory.config.BeanDefinitionHolder
	beanDefinition GenericBeanDefinition
		beanClass "sia.knights.BraveKnight"
	beanName "knight"

		if (bdHolder != null) {
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
/s
public class BeanDefinitionReaderUtils {
	public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {

registry= org.springframework.beans.factory.support.DefaultListableBeanFactory@de3a06f: defining beans []; root of factory hierarchy
		// Register bean definition under primary name.
		String beanName = definitionHolder.getBeanName();
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
/s
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			else {
				this.beanDefinitionNames.add(beanName);
				this.frozenBeanDefinitionNames = null;
			}
			this.beanDefinitionMap.put(beanName, beanDefinition);
...
/t
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
/ volgende	,
			for (int i = 0; i < nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
					if (delegate.isDefaultNamespace(ele)) {
						parseDefaultElement(ele, delegate);
/d
this org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader@7f010382
	readerContext org.springframework.beans.factory.xml.XmlReaderContext@353d0772
		reader org.springframework.beans.factory.xml.XmlBeanDefinitionReader@70beb599
			registry org.springframework.beans.factory.support.DefaultListableBeanFactory@de3a06f: defining beans [knight]; root of factory hierarchy
				beanDefinitionNames [knight] 
				beanDefinitionMap {knight=Generic bean: class [sia.knights.BraveKnight]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [META-INF/spring/knight.xml]}

/ later	, 
														[knight, quest]
													{quest=Generic bean: class [sia.knights.SlayDragonQuest]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [META-INF/spring/knight.xml], knight=Generic bean: class [sia.knights.BraveKnight]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [META-INF/spring/knight.xml]}

/t
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
		parseBeanDefinitions(root, this.delegate);
		this.delegate = parent;
null
/t
public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {
	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
/d
		return getRegistry().getBeanDefinitionCount() - countBefore;
...
/t
public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {
	protected final void refreshBeanFactory() throws BeansException {
			loadBeanDefinitions(beanFactory);
/d
/ beanFactory is de registry hierboven	,
beanFactory org.springframework.beans.factory.support.DefaultListableBeanFactory@de3a06f: defining beans [knight,quest]; root of factory hierarchy
				beanDefinitionNames [knight, quest]
				beanDefinitionMap {quest=Generic bean: class [sia.knights.SlayDragonQuest]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [META-INF/spring/knight.xml], knight=Generic bean: class [sia.knights.BraveKnight]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [META-INF/spring/knight.xml]}

this org.springframework.context.support.ClassPathXmlApplicationContext@d8355a8: startup date [Sat Dec 10 14:55:41 CET 2016]; root of context hierarchy
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;

/t
public abstract class AbstractApplicationContext extends DefaultResourceLoader
	public void refresh() throws BeansException, IllegalStateException {
			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
/d
			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);



/ Einde DEBUG KNIGHTMAIN

/ BOOK WALLS

/ 7	. 

/ Chapter_01/knight		

/ KnightMain uses xml	, de tests use java config	,

/ Chapter_01/knight2	, copy of knight	,	

/ We kunnen 
$ vi  src/test/java/KnightConfig.java
@Configuration
public class KnightConfig {

  @Bean
  public Knight knight() {									<-
    return new BraveKnight(quest());
  }
/ of	,
  @Bean
  public Knight knight(Quest quest) {				<-
    return new BraveKnight(quest);
  }

/ In de 2de vorm krijgt de fct een arg	, 


/ 13	. 

/ Lees	, 
http://stackoverflow.com/questions/21358466/gradle-to-execute-java-class-without-modifying-build-gradle
apply plugin:'application'
mainClassName = "org.gradle.sample.Main"
And then simply gradle run.
/ TODO
/ Hoe in buildship	?

/ 13	. 

/ Lees	, 
https://www.mkyong.com/spring3/spring-3-javaconfig-example/
https://www.mkyong.com/spring3/spring-3-and-jsr-330-inject-and-named-example/

/ 13	. 

/ In knight2 we hebben KnightMainConfig in src/main/java en KnightTestConfig in src/main/test	, om te oefenen	, 

$ vi KnightMain.java

  public static void main(String[] args) throws Exception {
   
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);
    Knight knight = context.getBean(Knight.class);
    knight.embarkOnQuest();
    context.close();
  }

/ de originele config,	

$ vi KnightMainConfig.java

@Configuration
public class KnightMainConfig {

  @Bean
  public Knight knight() {
    return new BraveKnight(quest());
  }
  
  @Bean
  public Quest quest() {
    return new SlayDragonQuest(System.out);
  }

}
/ Er zijn geen multiple candidates	, omdat er precies staat wie er gekozen gaan worden	,

/ ook niet als we 

$ vi KnightMainConfig.java

@Configuration
public class KnightMainConfig {

  @Bean
  public Knight knight(Quest quest) {
    return new BraveKnight(quest);
  }
  
  @Bean
  public Quest quest(PrintStream stream) {
    return new SlayDragonQuest(stream);
  }

  @Bean
  public PrintStream stream(){
	  return new FakeMainPrintStream();
  }
}
/ Ook hier GEEN multiple candidates	, 

/ er zijn	, 

public class RescueDamselQuest implements Quest {
  private PrintStream stream;

  public  RescueDamselQuest(PrintStream stream) {
    this.stream = stream;
  }
  public void embark() {
	  System.out.println("Embarking on a quest to rescue the damsel.");
  }
}

public class SlayDragonQuest implements Quest {
  private PrintStream stream;

  public SlayDragonQuest(PrintStream stream) {
    this.stream = stream;
  }
  public void embark() {
    stream.println("Embarking on quest to slay the dragon!");
  }
}

/ WEL multiple candidates als we 	,

/ 13	 

/ ws workspace-spring
/ proj knight2

$ vi KnightMainConfig.java

@Configuration
@ComponentScan
public class KnightMainConfig {
}
/ Als we run	, 
Exception in thread "main" org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [sia.knights.Knight] is defined
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:319)
	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:987)
	at sia.knights.KnightMain.main(KnightMain.java:12)

/ Klopt, we moeten de beans @Component geven	, 

/ 1313	. 

@Component
public class RescueDamselQuest implements Quest {

  private PrintStream stream;

  public  RescueDamselQuest(PrintStream stream) {
    this.stream = stream;
  }

  public void embark() {
	  System.out.println("Embarking on a quest to rescue the damsel.");
  }
}


/ we zien	, 
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'rescueDamselQuest' defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [sia.knights.RescueDamselQuest]: No default constructor found; nested exception is java.lang.NoSuchMethodException: sia.knights.RescueDamselQuest.<init>()

/ 1313	. 

/ we geven @Autowired op de ctor 	, 

@Component
public class BraveKnight implements Knight {
  private Quest quest;

  @Autowired
  public BraveKnight(Quest quest) {
    this.quest = quest;
  }
  public void embarkOnQuest() {
    quest.embark();
  }
}

@Component
public class DamselRescuingKnight implements Knight {
  private Quest quest;

  @Autowired
  public DamselRescuingKnight(Quest quest) {
    this.quest = quest;
  }
  public void embarkOnQuest() {
    quest.embark();
  }
}

@Component
public class FakeMainPrintStream extends PrintStream {

  private static StringBuffer printBuffer = new StringBuffer();
  
  
  public FakeMainPrintStream() {
    super(new ByteArrayOutputStream());
  }
	...
/ Heeft default ctor	, 										/ !	, er is niets te inject	, 

@Component
public class RescueDamselQuest implements Quest {

 
  private PrintStream stream;

  @Autowired
  public  RescueDamselQuest(PrintStream stream) {
    this.stream = stream;
  }
	...

@Component
public class SlayDragonQuest implements Quest {

  private PrintStream stream;

  @Autowired
  public SlayDragonQuest(PrintStream stream) {
    this.stream = stream;
  }
	...

/ Maar nu de ERR	, dat er meerder kandidaten zijn	, 

Exception in thread "main" org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'damselRescuingKnight' defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/DamselRescuingKnight.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [sia.knights.Quest]: : No qualifying bean of type [sia.knights.Quest] is defined: expected single matching bean but found 2: rescueDamselQuest,slayDragonQuest; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [sia.knights.Quest] is defined: expected single matching bean but found 2: rescueDamselQuest,slayDragonQuest
Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [sia.knights.Quest] is defined: expected single matching bean but found 2: rescueDamselQuest,slayDragonQuest

/ 1313	 

/ qualifiers kunnen we alleen use bij injection	, 
/ bij getBean NIET	, we moeten getBean op name	, 


public class KnightMain {

  public static void main(String[] args) throws Exception {
   
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);
//    Knight knight = context.getBean(Knight.class);			/ multiple mogelijkheden	, 
    Knight knight=(Knight)context.getBean("braveKnight");	 /OK

@Component
public class BraveKnight implements Knight {

  private Quest quest;

  @Autowired
  public BraveKnight(@Qualifier("slayDragonQuest")Quest quest) {
    this.quest = quest;
  }

@Component
public class DamselRescuingKnight implements Knight {

  private Quest quest;

  @Autowired
  public DamselRescuingKnight(@Qualifier("rescueDamselQuest")Quest quest) {
    this.quest = quest;
  }


/ Einde BOOK WALLS

/ DEBUG KNIGHT2

/ ws workspace-spring
/ proj. knight2

$ vi KnightMain.java

    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);
//    Knight knight = context.getBean(Knight.class);
    Knight knight=(Knight)context.getBean("braveKnight");
    knight.embarkOnQuest();
    context.close();
  }

@Component
public class BraveKnight implements Knight {
  private Quest quest;
  @Autowired
  public BraveKnight(@Qualifier("slayDragonQuest")Quest quest) {
    this.quest = quest;
  }
  public void embarkOnQuest() {
    quest.embark();
  }
}

@Component
public class DamselRescuingKnight implements Knight {
  private Quest quest;
  @Autowired
  public DamselRescuingKnight(@Qualifier("rescueDamselQuest")Quest quest) {
    this.quest = quest;
  }
  public void embarkOnQuest() {
    quest.embark();
  }
}

Component
public class FakeMainPrintStream extends PrintStream {
  private static StringBuffer printBuffer = new StringBuffer();
  public FakeMainPrintStream() {
    super(new ByteArrayOutputStream());
  }
  @Override
  public void println(String string) {
    printBuffer.append(string).append("\n");
  }
  public String getPrintedString() {
    return printBuffer.toString();
  }
  public void clear() {
    printBuffer = new StringBuffer();
  }
}

@Configuration
@ComponentScan
public class KnightMainConfig {
}

@Component
public class RescueDamselQuest implements Quest {
  private PrintStream stream;
  @Autowired
  public  RescueDamselQuest(PrintStream stream) {
    this.stream = stream;
  }
  public void embark() {
	  System.out.println("Embarking on a quest to rescue the damsel.");
  }
}

@Component
public class SlayDragonQuest implements Quest {
  private PrintStream stream;
  @Autowired
  public SlayDragonQuest(PrintStream stream) {
    this.stream = stream;
  }
  public void embark() {
//    stream.println("Embarking on quest to slay the dragon!");
    System.out.println("Embarking on quest to slay the dragon!");
  }
}



/s
	AnnotationConfigUtils.processCommonDefinitionAnnotations(AnnotatedBeanDefinition, AnnotatedTypeMetadata) line: 287	
/=
	static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
abd	AnnotatedGenericBeanDefinition  (id=219)	
metadata	StandardAnnotationMetadata  (id=230)	
	introspectedClass	Class<T> (sia.knights.KnightMainConfig) (id=211)	
		annotationData	Class$AnnotationData  (id=240)	
			annotations	LinkedHashMap<K,V>  (id=249)	
				[0]	LinkedHashMap$Entry<K,V>  (id=254)	
					key	Class<T> (org.springframework.context.annotation.Configuration) (id=267)	
					value	$Proxy4  (id=268)	
				[1]	LinkedHashMap$Entry<K,V>  (id=265)	
					key	Class<T> (org.springframework.context.annotation.ComponentScan) (id=274)	
					value	$Proxy5  (id=275)	
			declaredAnnotations	LinkedHashMap<K,V>  (id=249)	
			redefinedCount	0	
/cb
	AnnotationConfigUtils.processCommonDefinitionAnnotations(AnnotatedBeanDefinition) line: 283	
	AnnotatedBeanDefinitionReader.registerBean(Class<?>, String, Class<Annotation>...) line: 147	
	AnnotatedBeanDefinitionReader.registerBean(Class<?>) line: 127	
	AnnotatedBeanDefinitionReader.register(Class<?>...) line: 122	
	AnnotationConfigApplicationContext.register(Class<?>...) line: 151	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 83	
	KnightMain.main(String[]) line: 10	

/ dus meta-data van KnightMainConfig zijn de 2 annot. @Configuration @ComponentScan

/c
/ stack	,
/ s
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 274	
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	
/ debug	, 
/s
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 274	

/ In deze method	,
/ WHERE @CONFIGURATION 

		for (String beanName : registry.getBeanDefinitionNames()) {
registry	DefaultListableBeanFactory  (id=33)	
		[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=25)	
		[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=51)	
		[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=52)	
		[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=53)	
		[4]	"knightMainConfig" (id=54)	
		[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=55)	
		[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=120)	
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
Generic bean: class [sia.knights.KnightMainConfig]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
/n
/ want	, 
/s
		return CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));
CONFIGURATION_CLASS_FULL="full"
CONFIGURATION_CLASS_ATTRIBUTE="org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass"
/t
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/s
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 67	
		// Check already loaded Class if present...
		// since we possibly can't even load the class file for this Class.
		if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass()) {
/j
			Class<?> beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();
class sia.knights.KnightMainConfig
			metadata = new StandardAnnotationMetadata(beanClass, true);
metadata	StandardAnnotationMetadata  (id=165)	
	introspectedClass	Class<T> (sia.knights.KnightMainConfig) (id=150)	
		annotationData	Class$AnnotationData  (id=171)	
			annotations	LinkedHashMap<K,V>  (id=173)	
				[0]	LinkedHashMap$Entry<K,V>  (id=177)	
					key	Class<T> (org.springframework.context.annotation.Configuration) (id=182)	
					value	$Proxy4  (id=183)	
				[1]	LinkedHashMap$Entry<K,V>  (id=178)	
					key	Class<T> (org.springframework.context.annotation.ComponentScan) (id=187)	
					value	$Proxy5  (id=188)	

		if (metadata != null) {
			if (isFullConfigurationCandidate(metadata)) {
/ WHERE @CONFIGURATION 
/s
					return metadata.isAnnotated(Configuration.class.getName());
/j
				beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
				return true;
			}
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 281	
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/d
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));

		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
/s
ConfigurationClassParser.<init>(MetadataReaderFactory, ProblemReporter, Environment, ResourceLoader, BeanNameGenerator, BeanDefinitionRegistry) line: 144	
		this.componentScanParser = new ComponentScanAnnotationParser(
				resourceLoader, environment, componentScanBeanNameGenerator, registry);
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
/d
		parser.parse(configCandidates);
/s
ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 151	
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition();
			try {
				if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
/s
ConfigurationClassParser.parse(Class<?>, String) line: 185	
		processConfigurationClass(new ConfigurationClass(clazz, beanName));
/s
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 190	
		// Recursively process the configuration class and its superclass hierarchy.
		SourceClass sourceClass = asSourceClass(configClass);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 235	
/  in deze method	,
/ WHERE @COMPONENTSCAN

		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
/ Hieronder volgt een diepe stack	, dat alles om de attributes van @ComponentScan te bepalen, in dit geval de defaults	, 
/s
AnnotationConfigUtils.attributesFor(AnnotatedTypeMetadata, Class<?>) line: 324	
		return attributesFor(metadata, annotationClass.getName());
/s
AnnotationConfigUtils.attributesFor(AnnotatedTypeMetadata, String) line: 328	
		return AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(annotationClassName, false));
/s
StandardAnnotationMetadata.getAnnotationAttributes(String, boolean) line: 112	
		return AnnotatedElementUtils.getAnnotationAttributes(getIntrospectedClass(), annotationType, classValuesAsString, this.nestedAnnotationsAsMap);
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 91	
		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {							<-
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				return AnnotationUtils.getAnnotationAttributes(annotation, classValuesAsString, nestedAnnotationsAsMap);
			}
/s
	/**
	 * Process all annotations of the specified {@code annotationType} and
	 * recursively all meta-annotations on the specified {@code element}.
	 * <p>If the {@code traverseClassHierarchy} flag is {@code true} and the sought
	 * annotation is neither <em>directly present</em> on the given element nor
	 * present on the given element as a meta-annotation, then the algorithm will
	 * recursively search through the class hierarchy of the given element.
	 */
AnnotatedElementUtils.process(AnnotatedElement, String, boolean, Processor<T>) line: 162	
		try {
			return doProcess(element, annotationType, traverseClassHierarchy, processor, new HashSet<AnnotatedElement>(), 0);
/s
	/**
	 * Perform the search algorithm for the {@link #process} method, avoiding
	 * endless recursion by tracking which annotated elements have already been
	 * <em>visited</em>.
	 * <p>The {@code metaDepth} parameter represents the depth of the annotation
	 * relative to the initial element. For example, an annotation that is
	 * <em>present</em> on the element will have a depth of 0; a meta-annotation
	 * will have a depth of 1; and a meta-meta-annotation will have a depth of 2.
   *
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 190	

element	Class<T> (sia.knights.KnightMainConfig) (id=150)	
annotationType	"org.springframework.context.annotation.ComponentScan" (id=347)	
traverseClassHierarchy	false	
processor	AnnotatedElementUtils$4  (id=1381)	
visited	HashSet<E>  (id=1382)	
metaDepth	0	

		if (visited.add(element)) {
			Annotation[] annotations =
					(traverseClassHierarchy ? element.getDeclaredAnnotations() : element.getAnnotations());

/ declared annots zijn die op de class, annots zijn ook die van de parent	erbij	, 
/ TODO

			for (Annotation annotation : annotations) {
				if (annotation.annotationType().getName().equals(annotationType) || metaDepth > 0) {
/ ComponentScan
					T result = processor.process(annotation, metaDepth);
/s
AnnotatedElementUtils$4.process(Annotation, int) line: 94	
/=
		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				return AnnotationUtils.getAnnotationAttributes(annotation, classValuesAsString, nestedAnnotationsAsMap);	<-
/s
AnnotationUtils.getAnnotationAttributes(Annotation, boolean, boolean) line: 556	
		Method[] methods = annotation.annotationType().getDeclaredMethods();
/=
public abstract java.lang.String[] org.springframework.context.annotation.ComponentScan.basePackages()
public abstract org.springframework.context.annotation.ComponentScan$Filter[] org.springframework.context.annotation.ComponentScan.includeFilters()
public abstract boolean org.springframework.context.annotation.ComponentScan.useDefaultFilters()
public abstract java.lang.String org.springframework.context.annotation.ComponentScan.resourcePattern()
public abstract org.springframework.context.annotation.ComponentScan$Filter[] org.springframework.context.annotation.ComponentScan.excludeFilters()
public abstract java.lang.Class org.springframework.context.annotation.ComponentScan.scopeResolver()
public abstract org.springframework.context.annotation.ScopedProxyMode org.springframework.context.annotation.ComponentScan.scopedProxy()
public abstract java.lang.Class org.springframework.context.annotation.ComponentScan.nameGenerator()
public abstract java.lang.Class[] org.springframework.context.annotation.ComponentScan.basePackageClasses()
public abstract java.lang.String[] org.springframework.context.annotation.ComponentScan.value()

		for (Method method : methods) {
			if (method.getParameterTypes().length == 0 && method.getReturnType() != void.class) {
				try {
					Object value = method.invoke(annotation);
					attrs.put(method.getName(), adaptValue(value, classValuesAsString, nestedAnnotationsAsMap));

		return attrs;
{basePackages=[], includeFilters=[], useDefaultFilters=true, resourcePattern=**/*.class, excludeFilters=[], scopeResolver=class org.springframework.context.annotation.AnnotationScopeMetadataResolver, scopedProxy=DEFAULT, nameGenerator=interface org.springframework.beans.factory.support.BeanNameGenerator, basePackageClasses=[], value=[]}
/t
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 196	
					T result = processor.process(annotation, metaDepth);
/d
						return result;
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 245	
		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
/d
/ Dit was de diepe stack om de attrs van @ComponentScan te bepalen, in dit geval de defaults	, 

			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/s
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 73	
		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/s
	/**
	 * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.
	 * <p>If the passed-in bean factory does not only implement the
	 * {@code BeanDefinitionRegistry} interface but also the {@code ResourceLoader}
	 * interface, it will be used as default {@code ResourceLoader} as well. This will
	 * usually be the case for {@link org.springframework.context.ApplicationContext}
	 * implementations.
	 * <p>If given a plain {@code BeanDefinitionRegistry}, the default {@code ResourceLoader}
	 * will be a {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.
	 * <p>If the the passed-in bean factory also implements {@link EnvironmentCapable} its
	 * environment will be used by this reader.  Otherwise, the reader will initialize and
	 * use a {@link org.springframework.core.env.StandardEnvironment}. All
	 * {@code ApplicationContext} implementations are {@code EnvironmentCapable}, while
	 * normal {@code BeanFactory} implementations are not.
	 * @param registry the {@code BeanFactory} to load bean definitions into, in the form
	 * of a {@code BeanDefinitionRegistry}
	 * @param useDefaultFilters whether to include the default filters for the
	 * {@link org.springframework.stereotype.Component @Component},
	 * {@link org.springframework.stereotype.Repository @Repository},
	 * {@link org.springframework.stereotype.Service @Service}, and
	 * {@link org.springframework.stereotype.Controller @Controller} stereotype
	 * annotations.
	 */
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean) line: 112	
		this(registry, useDefaultFilters, getOrCreateEnvironment(registry));
/s
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 138	
		super(useDefaultFilters, environment);
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 86	
	static final String DEFAULT_RESOURCE_PATTERN = "**/*.class";
	private String resourcePattern = DEFAULT_RESOURCE_PATTERN;
		if (useDefaultFilters) {
			registerDefaultFilters();
/s
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
/t
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 66	


		super(useDefaultFilters, environment);
/d
	private ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();
	private MetadataReaderFactory metadataReaderFactory =
			new CachingMetadataReaderFactory(this.resourcePatternResolver);
/ Dit zijn welke setResourceLoader ook set	, maar andere values straks,

		// Determine ResourceLoader to use.
		if (this.registry instanceof ResourceLoader) {
/n
			setResourceLoader((ResourceLoader) this.registry);
/n
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 80	
		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/d

this	ComponentScanAnnotationParser  (id=50)	
	registry	DefaultListableBeanFactory  (id=98)	
	resourceLoader	AnnotationConfigApplicationContext  (id=28)	

scanner	ClassPathBeanDefinitionScanner  (id=57)	
	metadataReaderFactory	CachingMetadataReaderFactory  (id=94)	
		cacheLimit	256	
		metadataReaderCache	CachingMetadataReaderFactory$1  (id=122)	
		resourceLoader	PathMatchingResourcePatternResolver  (id=115)	
	resourcePattern	"**/*.class" (id=114)	
	resourcePatternResolver	PathMatchingResourcePatternResolver  (id=115)	
		pathMatcher	AntPathMatcher  (id=124)	
		resourceLoader	DefaultResourceLoader  (id=127)	
	scopeMetadataResolver	AnnotationScopeMetadataResolver  (id=119)	

		scanner.setEnvironment(this.environment);
		scanner.setResourceLoader(this.resourceLoader);	/= AnnotationConfigApplicationContext
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).setResourceLoader(ResourceLoader) line: 132	
		this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);
		this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 82	
		scanner.setResourceLoader(this.resourceLoader);
/d
scanner	ClassPathBeanDefinitionScanner  (id=57)	
		cacheLimit	256	
		metadataReaderCache	CachingMetadataReaderFactory$1  (id=330)	
		resourceLoader	AnnotationConfigApplicationContext  (id=28)	
		resourcePatternResolver	PathMatchingResourcePatternResolver  (id=333)	
		scanner	ClassPathBeanDefinitionScanner  (id=334)	

		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
/ een attr van @ComponentScan	,
interface org.springframework.beans.factory.support.BeanNameGenerator

		boolean useInheritedGenerator = BeanNameGenerator.class.equals(generatorClass);
true
		scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : BeanUtils.instantiateClass(generatorClass));

		ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
		if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
/n
		else {
			Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
class org.springframework.context.annotation.AnnotationScopeMetadataResolver

			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));

		scanner.setResourcePattern(componentScan.getString("resourcePattern"));
**/*.class

		for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {
/n
		for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {
/n
		for (String pkg : componentScan.getStringArray("value")) {
/n
		for (String pkg : componentScan.getStringArray("basePackages")) {
/n
		for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
/n
		if (basePackages.isEmpty()) {
/j
			basePackages.add(ClassUtils.getPackageName(declaringClass));
[sia.knights]
/ dezelfde package als waar de config file KnightMainConfig is in	,

		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);
			}
		});
/ KnightMainConfig zelf willen we niet	, 

		return scanner.doScan(StringUtils.toStringArray(basePackages));
[sia.knights]
/s
	/**
	 * Perform a scan within the specified base packages,
	 * returning the registered bean definitions.
	 * <p>This method does <i>not</i> register an annotation config processor
	 * but rather leaves this up to the caller.
	 */
ClassPathBeanDefinitionScanner.doScan(String...) line: 239	
		for (String basePackage : basePackages) {
sia.knights
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 264	
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + "/" + this.resourcePattern;
classpath*:sia/knights/**/*.class

			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/s
AnnotationConfigApplicationContext(GenericApplicationContext).getResources(String) line: 223	
		if (this.resourceLoader instanceof ResourcePatternResolver) {
/n
null
		return super.getResources(locationPattern);
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).getResources(String) line: 1172	
		return this.resourcePatternResolver.getResources(locationPattern);
/s
PathMatchingResourcePatternResolver.getResources(String) line: 266	
locationPattern=classpath*:sia/knights/**/*.class

		if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
			// a class path resource (multiple resources for same name possible)
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
				// a class path resource pattern
				return findPathMatchingResources(locationPattern);
/s
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 340	
locationPattern=classpath*:sia/knights/**/*.class

		String rootDirPath = determineRootDir(locationPattern);
classpath*:sia/knights/
		String subPattern = locationPattern.substring(rootDirPath.length());
**/*.class
		Resource[] rootDirResources = getResources(rootDirPath);
/s
PathMatchingResourcePatternResolver.getResources(String) line: 266		/ recursive call	, met andere locationPattern	,
locationPattern=classpath*:sia/knights/

			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
/n																																																	/ net wel	,
			}
			else {
				// all class path resources with the given name
				return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
/s
PathMatchingResourcePatternResolver.findAllClassPathResources(String) line: 302	
location	"sia/knights/" (id=1577)	

		String path = location;
		ClassLoader cl = getClassLoader();
		Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));
/ TODO
		Set<Resource> result = new LinkedHashSet<Resource>(16);
		while (resourceUrls.hasMoreElements()) {
			URL url = resourceUrls.nextElement(); / file:/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/
			result.add(convertClassLoaderURL(url));
		return result.toArray(new Resource[result.size()]);
/t
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 343	
		Resource[] rootDirResources = getResources(rootDirPath);
/d
rootDirPath	"classpath*:sia/knights/" (id=1573)	
rootDirResources	Resource[1]  (id=1603)	URL [file:/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/]
		Set<Resource> result = new LinkedHashSet<Resource>(16);
		for (Resource rootDirResource : rootDirResources) {
			rootDirResource = resolveRootDirResource(rootDirResource);	/ doet NIETS	,
			if (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {
/n
			else if (isJarResource(rootDirResource)) {
/n
			else {
				result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
/s
subPattern	"**/*.class" (id=1642)	
/s
PathMatchingResourcePatternResolver.doFindPathMatchingFileResources(Resource, String) line: 532	
			rootDir = rootDirResource.getFile().getAbsoluteFile();
rootDir	File  (id=1646)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights

		return doFindMatchingFileSystemResources(rootDir, subPattern);
/s
PathMatchingResourcePatternResolver.doFindMatchingFileSystemResources(File, String) line: 558	
		Set<File> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);
/s
PathMatchingResourcePatternResolver.retrieveMatchingFiles(File, String) line: 576	
		String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, "/");
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights
		if (!pattern.startsWith("/")) {
/j
			fullPattern += "/";
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/

		fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, "/");
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/**/*.class

		doRetrieveMatchingFiles(fullPattern, rootDir, result);
/s
PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(String, File, Set<File>) line: 617	
		File[] dirContents = dir.listFiles();			/ STANDARD METHOD
this	PathMatchingResourcePatternResolver  (id=333)	
fullPattern	"/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/**/*.class" (id=1652)	
dir	File  (id=1646)	
result	LinkedHashSet<E>  (id=1653)	
dirContents	File[17]  (id=1654)	
	[0]	File  (id=1655)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class
	[1]	File  (id=1656)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightXMLInjectionTest.class
	[2]	File  (id=1657)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/Quest.class
	[3]	File  (id=1660)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightXMLInjectionTest-context.xml
	[4]	File  (id=1661)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightTestConfig.class
	[5]	File  (id=1662)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/DamselRescuingKnight.class
	[6]	File  (id=1663)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightJavaConfigInjectionTest.class
	[7]	File  (id=1664)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/FakePrintStream.class
	[8]	File  (id=1665)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/BraveKnight.class
	[9]	File  (id=1666)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightMainConfig.class
	[10]	File  (id=1667)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/Knight.class
	[11]	File  (id=1668)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/BraveKnightTest.class
	[12]	File  (id=1669)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/SlayDragonQuest.class
	[13]	File  (id=1670)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/config
	[14]	File  (id=1671)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/FakeMainPrintStream.class
	[15]	File  (id=1672)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/Minstrel.class
	[16]	File  (id=1673)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightMain.class

		for (File content : dirContents) {
			String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, "/");
			if (content.isDirectory() && getPathMatcher().matchStart(fullPattern, currPath + "/")) {
				else {
					doRetrieveMatchingFiles(fullPattern, content, result);		/ (*)
					}
			}
			if (getPathMatcher().match(fullPattern, currPath)) {	/ .class files, NIET .xml files	,
				result.add(content);

/ Intermezzo
/ (*)
					doRetrieveMatchingFiles(fullPattern, content, result);
fullPattern=/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/**/*.class
content=/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/config
/s
PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(String, File, Set<File>) line: 622	
		File[] dirContents = dir.listFiles();
dirContents	File[1]  (id=1712)	
	[0]	File  (id=1713)	
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/config/SoundSystemConfig.class
/ Deze hadden we eig. rm	,
		for (File content : dirContents) {
			String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, "/");
			}
			if (getPathMatcher().match(fullPattern, currPath)) {
				result.add(content);

/ einde Intermezzo

/t
PathMatchingResourcePatternResolver.doFindMatchingFileSystemResources(File, String) line: 559	
		Set<File> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);
/d
/ Alle .class files in rootDir & sub dirs	, 
		for (File file : matchingFiles) {
			result.add(new FileSystemResource(file));
		}
		return result;
/t
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 356	
			else {
				result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
/d
		return result.toArray(new Resource[result.size()]);
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 269	
/=
	public Set<BeanDefinition> findCandidateComponents(String basePackage) {
basePackage="sia.knights"
			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/d
			for (Resource resource : resources) {
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
/ WHERE @COMPONENT
/s
	/**
	 * Determine whether the given class does not match any exclude filter
	 * and does match at least one include filter.
	 * @param metadataReader the ASM ClassReader for the class
	 * @return whether the class qualifies as a candidate component
	 */
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 338	
		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/s
ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 65	
		ClassMetadata metadata = metadataReader.getClassMetadata();
metadata	AnnotationMetadataReadingVisitor  (id=1747)	
	annotationSet	LinkedHashSet<E>  (id=1751)							/ [org.springframework.stereotype.Component]
	className	"sia.knights.RescueDamselQuest" (id=1753)	
	interfaces	String[1]  (id=1757)											/ [sia.knights.Quest]

		if (matchClassName(metadata.getClassName())) {
/s
ComponentScanAnnotationParser$1.matchClassName(String) line: 131	
/=
		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);	
this	ComponentScanAnnotationParser$1  (id=1558)	
	val$declaringClass	"sia.knights.KnightMainConfig" (id=53)	
className	"sia.knights.RescueDamselQuest" (id=1753)	
/t
ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 69	
		// This method optimizes avoiding unnecessary creation of ClassReaders
		// as well as visiting over those readers.
		if (matchSelf(metadataReader)) {						/ return false	, see hieronder , andere impl	, 
/n
		if (matchClassName(metadata.getClassName())) {
/n
		if (this.considerInherited) {
/n
		if (this.considerInterfaces) {
/n
		return false;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 342	
		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/n
				return false;
			}
		}
		for (TypeFilter tf : this.includeFilters) {

this	ClassPathBeanDefinitionScanner  (id=1534)	
	excludeFilters	LinkedList<E>  (id=1656)	
		[0]	ComponentScanAnnotationParser$1  (id=1654)		/ TODO
	includeFilters	LinkedList<E>  (id=1661)	
		[0]	AnnotationTypeFilter  (id=1662)	
			annotationType	Class<T> (org.springframework.stereotype.Component) (id=309)		/ eis	, see hieronder	,
																								/ TODO Wanneer set	?
/ WHERE @COMPONENT	, def	

			if (tf.match(metadataReader, this.metadataReaderFactory)) {	
/s
AnnotationTypeFilter(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 61	
		// This method optimizes avoiding unnecessary creation of ClassReaders
		// as well as visiting over those readers.
		if (matchSelf(metadataReader)) {						/ see hierboven	, andere impl	,
/s
AnnotationTypeFilter.matchSelf(MetadataReader) line: 82	

this	AnnotationTypeFilter  (id=1830)	
	annotationType	Class<T> (org.springframework.stereotype.Component) (id=559)	
	considerInherited	false	
	considerInterfaces	false	
	considerMetaAnnotations	true	

		AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();
metadataReader	SimpleMetadataReader  (id=1739)	
	annotationMetadata	AnnotationMetadataReadingVisitor  (id=1747)	
	classMetadata	AnnotationMetadataReadingVisitor  (id=1747)	
	resource	FileSystemResource  (id=1730)	/ file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class]
metadata	AnnotationMetadataReadingVisitor  (id=1747)	
	annotationSet	LinkedHashSet<E>  (id=1751)	/ [org.springframework.stereotype.Component]

		return metadata.hasAnnotation(this.annotationType.getName()) || 	/ this.annotationType.getName()=org.springframework.stereotype.Component	/ see hierboven	, eis	, 
true
/ WHERE @COMPONENT	, check
				(this.considerMetaAnnotations && metadata.hasMetaAnnotation(this.annotationType.getName()));
false
/t
AnnotationTypeFilter(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 62	
		if (matchSelf(metadataReader)) {
/j
			return true;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 345	
		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/d
/j
				return isConditionMatch(metadataReader);
/s
	/**
	 * Determine whether the given class is a candidate component based on any
	 * {@code @Conditional} annotations.
	 * @param metadataReader the ASM ClassReader for the class
	 * @return whether the class qualifies as a candidate component
	 */
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isConditionMatch(MetadataReader) line: 359	
		if (this.conditionEvaluator == null) {
			this.conditionEvaluator = new ConditionEvaluator(getRegistry(), getEnvironment(), getResourceLoader());
		}
		return !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());
/s
ConditionEvaluator.shouldSkip(AnnotatedTypeMetadata, ConfigurationCondition$ConfigurationPhase) line: 72	
		if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {
/j
			return false;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 345	
		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
				return isConditionMatch(metadataReader);
/d
/j
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 279	
			for (Resource resource : resources) {
				if (traceEnabled) {
					logger.trace("Scanning " + resource);
				}
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
/d
/j
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
							sbd.setResource(resource);
file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class]
							sbd.setSource(resource);
							if (isCandidateComponent(sbd)) {
/s
	/**
	 * Determine whether the given bean definition qualifies as candidate.
	 * <p>The default implementation checks whether the class is concrete
	 * (i.e. not abstract and not an interface). Can be overridden in subclasses.
	 * @param beanDefinition the bean definition to check
	 * @return whether the bean definition qualifies as a candidate component
	 */
		return (beanDefinition.getMetadata().isConcrete() 	 / niet abstract, geen interface
			&& beanDefinition.getMetadata().isIndependent()); 
				/= return (this.enclosingClassName == null || this.independentInnerClass); /= true || false
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 286	
			for (Resource resource : resources) {
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
							sbd.setResource(resource);
							sbd.setSource(resource);
							if (isCandidateComponent(sbd)) {
/d
/j
								candidates.add(sbd);
/ volgende for loops	, 
		return candidates;
candidates	LinkedHashSet<E>  (id=1562)	
	[0]	ScannedGenericBeanDefinition  (id=1886)	
Generic bean: class [sia.knights.RescueDamselQuest]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class]
	[1]	ScannedGenericBeanDefinition  (id=1916)	
Generic bean: class [sia.knights.KnightTestConfig]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightTestConfig.class]
	[2]	ScannedGenericBeanDefinition  (id=1917)	
Generic bean: class [sia.knights.DamselRescuingKnight]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/DamselRescuingKnight.class]
	[3]	ScannedGenericBeanDefinition  (id=1918)	
Generic bean: class [sia.knights.BraveKnight]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/BraveKnight.class]
	[4]	ScannedGenericBeanDefinition  (id=1919)	
Generic bean: class [sia.knights.SlayDragonQuest]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/SlayDragonQuest.class]
	[5]	ScannedGenericBeanDefinition  (id=1920)	
Generic bean: class [sia.knights.config.SoundSystemConfig]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/config/SoundSystemConfig.class]
	[6]	ScannedGenericBeanDefinition  (id=1921)	
Generic bean: class [sia.knights.FakeMainPrintStream]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/FakeMainPrintStream.class]

/ Intermezzo

/ we zijn in 	,
/stack
/s
	ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 315	
	ClassPathBeanDefinitionScanner.doScan(String...) line: 242	
	ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 134	
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 248	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
	ConfigurationClassParser.parse(Class<?>, String) line: 185	
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 155	
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	

/ Einde Intermezzo
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 243	
		for (String basePackage : basePackages) {
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
basePackage	"sia.knights" (id=1555)	
candidates	LinkedHashSet<E>  (id=1562)	
	[0]	ScannedGenericBeanDefinition  (id=1886)	
	[1]	ScannedGenericBeanDefinition  (id=1916)	
	[2]	ScannedGenericBeanDefinition  (id=1917)	
	[3]	ScannedGenericBeanDefinition  (id=1918)	
	[4]	ScannedGenericBeanDefinition  (id=1919)	
	[5]	ScannedGenericBeanDefinition  (id=1920)	
	[6]	ScannedGenericBeanDefinition  (id=1921)	

			for (BeanDefinition candidate : candidates) {
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
scopeMetadata	ScopeMetadata  (id=2058)	
	scopedProxyMode	ScopedProxyMode  (id=222)		 NO
	scopeName	"singleton" (id=2060)	
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
rescueDamselQuest
				if (candidate instanceof AbstractBeanDefinition) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
/s
ClassPathBeanDefinitionScanner.postProcessBeanDefinition(AbstractBeanDefinition, String) line: 271	
		beanDefinition.applyDefaults(this.beanDefinitionDefaults);
/s
ScannedGenericBeanDefinition(AbstractBeanDefinition).applyDefaults(BeanDefinitionDefaults) line: 324	
		setLazyInit(defaults.isLazyInit());
		setAutowireMode(defaults.getAutowireMode());
		setDependencyCheck(defaults.getDependencyCheck());
		setInitMethodName(defaults.getInitMethodName());
		setEnforceInitMethod(false);
		setDestroyMethodName(defaults.getDestroyMethodName());
		setEnforceDestroyMethod(false);
defaults	BeanDefinitionDefaults  (id=69)	
	autowireMode	0	
	dependencyCheck	0	
	destroyMethodName	null	
	initMethodName	null	
	lazyInit	false	
/t
ClassPathBeanDefinitionScanner.postProcessBeanDefinition(AbstractBeanDefinition, String) line: 275	
		beanDefinition.applyDefaults(this.beanDefinitionDefaults);
		if (this.autowireCandidatePatterns != null) {
/n
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 250	
			for (BeanDefinition candidate : candidates) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
/d
				if (candidate instanceof AnnotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
/s
AnnotationConfigUtils.processCommonDefinitionAnnotations(AnnotatedBeanDefinition, AnnotatedTypeMetadata) line: 287	
		if (metadata.isAnnotated(Lazy.class.getName())) {
/n
		else if (abd.getMetadata().isAnnotated(Lazy.class.getName())) {
/n
		if (metadata.isAnnotated(Primary.class.getName())) {
/n
		if (metadata.isAnnotated(DependsOn.class.getName())) {
/n
		if (abd instanceof AbstractBeanDefinition) {
/n
			AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
			if (metadata.isAnnotated(Role.class.getName())) {
/n
			if (metadata.isAnnotated(Description.class.getName())) {
/n
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 253	
			for (BeanDefinition candidate : candidates) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);	/ NIETS
/d
				if (checkCandidate(beanName, candidate)) {
/s
	protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {
		if (!this.registry.containsBeanDefinition(beanName)) {	/ this.registry=DefaultListableBeanFactory
			return true;
		}
/t
/j 
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
					beanDefinitions.add(definitionHolder);		/ beanDefinitions is een local	,
					registerBeanDefinition(definitionHolder, this.registry);
/s
BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) line: 147	
		// Register bean definition under primary name.
		String beanName = definitionHolder.getBeanName();
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
/s
DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition) line: 737	
			else {
				this.beanDefinitionNames.add(beanName);
				this.frozenBeanDefinitionNames = null;
			}
			this.beanDefinitionMap.put(beanName, beanDefinition);

this	DefaultListableBeanFactory  (id=98)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=2133)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2153)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=2172)	
			value	RootBeanDefinition  (id=2173)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2154)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=2174)	
			value	RootBeanDefinition  (id=2175)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=2155)	
			key	"rescueDamselQuest" (id=2098)	
			value	ScannedGenericBeanDefinition  (id=1886)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=2156)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=2170)	
			value	RootBeanDefinition  (id=2171)	
		[4]	ConcurrentHashMap$MapEntry<K,V>  (id=2158)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=2168)	
			value	RootBeanDefinition  (id=2169)	
		[5]	ConcurrentHashMap$MapEntry<K,V>  (id=2159)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=2166)	
			value	RootBeanDefinition  (id=2167)	
		[6]	ConcurrentHashMap$MapEntry<K,V>  (id=2160)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=2164)	
			value	RootBeanDefinition  (id=2165)	
		[7]	ConcurrentHashMap$MapEntry<K,V>  (id=2161)	
			key	"knightMainConfig" (id=2162)	
			value	AnnotatedGenericBeanDefinition  (id=2163)	
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 243	
			for (BeanDefinition candidate : candidates) {
/ volgende	, 
/ we geloven het	, 
		return beanDefinitions;	 / dit is die local	,
/ ook,
this	ClassPathBeanDefinitionScanner  (id=57)	
	registry	DefaultListableBeanFactory  (id=98)	
		beanDefinitionNames	ArrayList<E>  (id=2134)	
			[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=2170)	
			[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=2166)	
			[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=2168)	
			[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=2172)	
			[4]	"knightMainConfig" (id=2162)	
			[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=2164)	
			[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=2174)	
			[7]	"rescueDamselQuest" (id=2098)	
			[8]	"knightTestConfig" (id=2237)	
			[9]	"damselRescuingKnight" (id=2238)	
			[10]	"braveKnight" (id=2239)	
			[11]	"slayDragonQuest" (id=2240)	
			[12]	"soundSystemConfig" (id=2241)	
			[13]	"fakeMainPrintStream" (id=2242)	
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 250	
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/d
this	ConfigurationClassParser  (id=47)	
componentScan	AnnotationAttributes  (id=51)	
scannedBeanDefinitions	LinkedHashSet<E>  (id=1560)	
	[0]	BeanDefinitionHolder  (id=2119)	
	[1]	BeanDefinitionHolder  (id=2230)	
	[2]	BeanDefinitionHolder  (id=2231)	
	[3]	BeanDefinitionHolder  (id=2232)	
	[4]	BeanDefinitionHolder  (id=2233)	
	[5]	BeanDefinitionHolder  (id=2234)	
	[6]	BeanDefinitionHolder  (id=2235)	
			// Check the set of scanned definitions for any further config classes and parse recursively if necessary
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
/s
ConfigurationClassParser.parse(String, String) line: 175	
/=
	protected final void parse(String className, String beanName) throws IOException {
className	"sia.knights.RescueDamselQuest" (id=1753)	
beanName	"rescueDamselQuest" (id=2098)	

		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);
reader	SimpleMetadataReader  (id=2323)	
	annotationMetadata	AnnotationMetadataReadingVisitor  (id=2324)	
		annotationSet	LinkedHashSet<E>  (id=2327)								/ 			@Component
	classMetadata	AnnotationMetadataReadingVisitor  (id=2324)	
	resource	ClassPathResource  (id=2325)		/ class path resource [sia/knights/RescueDamselQuest.class]	

		processConfigurationClass(new ConfigurationClass(reader, beanName));
/s
/**
 * Represents a user-defined {@link Configuration @Configuration} class.
 * Includes a set of {@link Bean} methods, including all such methods
 * defined in the ancestry of the class, in a 'flattened-out' manner.
 *
ConfigurationClass.<init>(MetadataReader, String) line: 63	
/t
ConfigurationClassParser.parse(String, String) line: 176	
		processConfigurationClass(new ConfigurationClass(reader, beanName));
/pd
/s
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 190	

/ Intermezzo

/ recursive call	, Hij gaat sia/knights/RescueDamselQuest.class als potentiele config class beschouwen	,

/ stack	,
Thread [main] (Suspended)	
	owns: Object  (id=37)	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 216	
ConfigurationClass:beanName=rescueDamselQuest,resource=class path resource [sia/knights/RescueDamselQuest.class]
	ConfigurationClassParser.parse(String, String) line: 176	
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 252	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
ConfigurationClass:beanName=knightMainConfig,resource=class sia.knights.KnightMainConfig

/ Einde Intermezzo

		// Recursively process the configuration class and its superclass hierarchy.
		SourceClass sourceClass = asSourceClass(configClass);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 235	
/ WHERE @COMPONENTSCAN
		// Process any @PropertySource annotations
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {
/n
		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
/n
		// Process any @Import annotations
		processImports(configClass, sourceClass, getImports(sourceClass), true);

		// Process any @ImportResource annotations
		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
/n

		// Process individual @Bean methods
		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());
		for (MethodMetadata methodMetadata : beanMethods) {
/n
/ WHERE @BEAN
		// Process superclass, if any
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();			/ java.lang.Object
			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
/n
		// No superclass -> processing is complete
		return null;
/t
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 222	
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/configClass= ConfigurationClass:beanName=rescueDamselQuest,resource=class path resource [sia/knights/RescueDamselQuest.class]
		}
		while (sourceClass != null);
/d
		this.configurationClasses.put(configClass, configClass);
/t
configurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 254	
ConfigurationClass:beanName=knightMainConfig,resource=class sia.knights.KnightMainConfig

		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			// The config class is annotated with @ComponentScan -> perform the scan immediately
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
			// Check the set of scanned definitions for any further config classes and parse recursively if necessary
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
/d
/ volgende, 
/ we geloven het	,

/ configClass=ConfigurationClass:beanName=knightMainConfig,resource=class sia.knights.KnightMainConfig

		// Process any @Import annotations
		processImports(configClass, sourceClass, getImports(sourceClass), true);

		// Process any @ImportResource annotations
		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
/n
		// Process individual @Bean methods
		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());
/ WHERE @BEAN
		for (MethodMetadata methodMetadata : beanMethods) {
/n
		// Process superclass, if any
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();
			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
/n
		// No superclass -> processing is complete
		return null;
/t
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 222	
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/d
		}
		while (sourceClass != null);

		this.configurationClasses.put(configClass, configClass);
/ alle classes die hij als configuration class beschouwde	, 
/t
ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 165	
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition();
			try {
				if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
/d
		processDeferredImportSelectors();	/ NIETS
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 306	
		parser.parse(configCandidates);
/d
		parser.validate();

		// Handle any @PropertySource annotations					/ Deze moet hij tijdens parse zijn tegengekomen	,
		List<PropertySource<?>> parsedPropertySources = parser.getPropertySources();
{}
		if (!parsedPropertySources.isEmpty()) {
/n
		// Read the model and create bean definitions based on its content
		if (this.reader == null) {
			this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,
					this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,
					this.importBeanNameGenerator);
		}
		this.reader.loadBeanDefinitions(parser.getConfigurationClasses());
/s
	/**
	 * Read a particular {@link ConfigurationClass}, registering bean definitions
	 * for the class itself and all of its {@link Bean} methods.
	 */
ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClass, ConfigurationClassBeanDefinitionReader$TrackedConditionEvaluator) line: 138	
		if (trackedConditionEvaluator.shouldSkip(configClass)) {
/n
		if (configClass.isImported()) {
/n
		for (BeanMethod beanMethod : configClass.getBeanMethods()) {
/n
		loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
{}
		loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
{}
/t
ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(Set<ConfigurationClass>) line: 116	
		for (ConfigurationClass configClass : configurationModel) {
			loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
/ volgende	, 
/ we geloven het	, 
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 333	
		this.reader.loadBeanDefinitions(parser.getConfigurationClasses());
/d 
/ NIETS

		// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
		if (singletonRegistry != null) {	/ DefaultListableBeanFactory
			if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {  / "org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry"
				singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
/s
	/**
	 * Add the given singleton object to the singleton cache of this factory.
	 * <p>To be called for eager registration of singletons.
	 * @param beanName the name of the bean
	 * @param singletonObject the singleton object
	 */
	protected void addSingleton(String beanName, Object singletonObject) {
		synchronized (this.singletonObjects) {
			this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
		}
	}
this	ConfigurationClassPostProcessor  (id=38)	
singletonRegistry	DefaultListableBeanFactory  (id=98)	
	registeredSingletons	LinkedHashSet<E>  (id=2221)	
		[0]	"environment" (id=2558)	
		[1]	"systemProperties" (id=2562)	
		[2]	"systemEnvironment" (id=2565)	
		[3]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=2170)	
		[4]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry" (id=2510)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=2226)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2552)	
			key	"systemProperties" (id=2562)	
			value	Properties  (id=2563)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2553)	
			key	"systemEnvironment" (id=2565)	
			value	Collections$UnmodifiableMap<K,V>  (id=2566)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=2554)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=2170)	
			value	ConfigurationClassPostProcessor  (id=38)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=2555)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry" (id=2510)	
			value	ConfigurationClassParser$ImportStack  (id=2422)	
		[4]	ConcurrentHashMap$MapEntry<K,V>  (id=2556)	
			key	"environment" (id=2558)	
			value	StandardEnvironment  (id=73)	
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 339	
				singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
/d
		if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
			((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 98	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
/d
			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
[org.springframework.context.annotation.internalConfigurationAnnotationProcessor]
			List<BeanDefinitionRegistryPostProcessor> orderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) 
/n
					&& beanFactory.isTypeMatch(ppName, Ordered.class)) {

			OrderComparator.sort(orderedPostProcessors);
[]
			registryPostProcessors.addAll(orderedPostProcessors);
			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);
/ NIETS
			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
/n
			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
/s
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(Collection<BeanFactoryPostProcessor>, ConfigurableListableBeanFactory) line: 265	
		for (BeanFactoryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanFactory(beanFactory);
/s
	/**
	 * Prepare the Configuration classes for servicing bean requests at runtime
	 * by replacing them with CGLIB-enhanced subclasses.
	 */
ConfigurationClassPostProcessor.postProcessBeanFactory(ConfigurableListableBeanFactory) line: 263	
		int factoryId = System.identityHashCode(beanFactory);
		if (this.factoriesPostProcessed.contains(factoryId)) {
/n
		this.factoriesPostProcessed.add(factoryId);
[1405747618]
		if (!this.registriesPostProcessed.contains(factoryId)) {		/ TODO Wanneer set	? WH in processConfigBeanDefinitions
/n
			// BeanDefinitionRegistryPostProcessor hook apparently not supported...
			// Simply call processConfigurationClasses lazily at this point then.
			processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
/n
		}
		enhanceConfigurationClasses(beanFactory);
/s
	/**
	 * Post-processes a BeanFactory in search of Configuration class BeanDefinitions;
	 * any candidates are then enhanced by a {@link ConfigurationClassEnhancer}.
	 * Candidate status is determined by BeanDefinition attribute metadata.
	 * @see ConfigurationClassEnhancer
	 */
ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurableListableBeanFactory) line: 351	
		Map<String, AbstractBeanDefinition> configBeanDefs = new LinkedHashMap<String, AbstractBeanDefinition>();
		for (String beanName : beanFactory.getBeanDefinitionNames()) {
this	ConfigurationClassPostProcessor  (id=40)	
beanFactory	DefaultListableBeanFactory  (id=67)	
	beanDefinitionNames	ArrayList<E>  (id=1308)	
		[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1303)	
		[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1313)	
		[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1314)	
		[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1315)	
		[4]	"knightMainConfig" (id=1316)	
		[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=1317)	
		[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=1318)	
		[7]	"rescueDamselQuest" (id=1319)	
		[8]	"knightTestConfig" (id=1320)	
		[9]	"damselRescuingKnight" (id=1321)	
		[10]	"braveKnight" (id=1322)	
		[11]	"slayDragonQuest" (id=1323)	
		[12]	"soundSystemConfig" (id=1324)	
		[13]	"fakeMainPrintStream" (id=1325)	

			BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
/s
					return CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));
/t
				if (!(beanDef instanceof AbstractBeanDefinition)) {
/n
				configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
this	ConfigurationClassPostProcessor  (id=40)	
configBeanDefs	LinkedHashMap<K,V>  (id=1304)	
	[0]	LinkedHashMap$Entry<K,V>  (id=1560)	
		key	"knightMainConfig" (id=1316)	
		value	AnnotatedGenericBeanDefinition  (id=1569)	
	[1]	LinkedHashMap$Entry<K,V>  (id=1564)	
		key	"knightTestConfig" (id=1320)	
		value	ScannedGenericBeanDefinition  (id=1572)	
	[2]	LinkedHashMap$Entry<K,V>  (id=1565)	
		key	"soundSystemConfig" (id=1324)	
		value	ScannedGenericBeanDefinition  (id=1575)	

		ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
		for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
			AbstractBeanDefinition beanDef = entry.getValue();
			// If a @Configuration class gets proxied, always proxy the target class
			beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
			try {
				// Set enhanced subclass of the user-specified bean class
				Class<?> configClass = beanDef.resolveBeanClass(this.beanClassLoader);
configClass	Class<T> (sia.knights.KnightMainConfig)
				Class<?> enhancedClass = enhancer.enhance(configClass);
enhanchedClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$7bfe4f03) (id=1607)	
/s
	/**
	 * Loads the specified class and generates a CGLIB subclass of it equipped with
	 * container-aware callbacks capable of respecting scoping and other bean semantics.
	 * @return the enhanced subclass
	 */
ConfigurationClassEnhancer.enhance(Class<?>) line: 89	
		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
/n
		Class<?> enhancedClass = createClass(newEnhancer(configClass));
/s
	/**
	 * Creates a new CGLIB {@link Enhancer} instance.
	 */
ConfigurationClassEnhancer.newEnhancer(Class<?>) line: 112	

/ Intermezzo

[eric@almond knight2]$ ls ~/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/4.0.7.RELEASE/15ddf3bafce1029c2e36d5b3863dfffc079d4e81/spring-core-4.0.7.RELEASE-sources.jar 

[eric@almond knight2]$ jar tvf  ~/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/4.0.7.RELEASE/777e9502c4c2de150918a746fa22734d3eff81e0/spring-core-4.0.7.RELEASE.jar | grep Enhancer
   549 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer$1.class
  1305 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer$2.class
  1261 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer$3.class
  1451 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer$4.class
  1994 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer$5.class
  4134 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer$6.class
   411 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer$EnhancerKey.class
 27753 Sat Dec 07 11:28:02 CET 2013 org/springframework/cglib/proxy/Enhancer.class

[eric@almond knight2]$ jar tvf  ~/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/4.0.7.RELEASE/15ddf3bafce1029c2e36d5b3863dfffc079d4e81/spring-core-4.0.7.RELEASE-sources.jar  | grep Enhancer
/ leeg	,
/ Want cglib is in spring-core set	, om een reden	, maar de source niet in de source jar	,

/**
 * Enhances {@link Configuration} classes by generating a CGLIB subclass which
 * interacts with the Spring container to respect bean scoping semantics for
 * {@code @Bean} methods. Each such {@code @Bean} method will be overridden in
 * the generated subclass, only delegating to the actual {@code @Bean} method
 * implementation if the container actually requests the construction of a new
 * instance. Otherwise, a call to such an {@code @Bean} method serves as a
 * reference back to the container, obtaining the corresponding bean by name.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.0
 * @see #enhance
 * @see ConfigurationClassPostProcessor
 */
class ConfigurationClassEnhancer {

	private static final Callback[] CALLBACKS = new Callback[] {
			new BeanMethodInterceptor(),
			new DisposableBeanMethodInterceptor(),
			new BeanFactoryAwareMethodInterceptor(),
			NoOp.INSTANCE
	};

	private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS); / nested class	,

	private static final DefaultGeneratorStrategy GENERATOR_STRATEGY = new BeanFactoryAwareGeneratorStrategy(); / nested class	,

	private static final String BEAN_FACTORY_FIELD = "$$beanFactory";



/ Einde Intermezzo

		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(superclass);
		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
		enhancer.setUseFactory(false);
		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
		enhancer.setStrategy(GENERATOR_STRATEGY);
		enhancer.setCallbackFilter(CALLBACK_FILTER);
		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
		return enhancer;
/t



				if (configClass != enhancedClass) {
/j
					beanDef.setBeanClass(enhancedClass);
beanDef	AnnotatedGenericBeanDefinition  (id=1569)	
	beanClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$7bfe4f03) (id=1607)	





			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);








































ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(AnnotatedBeanDefinition) line: 372	
		return (beanDefinition.getMetadata().isConcrete() && beanDefinition.getMetadata().isIndependent());











































































/ Einde DEBUG STEREO-AUTOCONFIG 

/ MKYOUNG 

http://www.mkyong.com/spring3/spring-3-mvc-hello-world-example/
http://www.mkyong.com/spring-mvc/spring-mvc-how-to-include-js-or-css-files-in-a-jsp-page/

/ imported in scala IDE	, workspace-spring	,

[eric@almond Spring]$ pwd
/home/eric/Devel/Java/Spring
[eric@almond Spring]$ git clone https://github.com/mkyong/spring3-mvc-maven-xml-hello-world.git

[eric@almond Spring]$ unzip  ~/Downloads/spring-mvc-css-example.zip 
[eric@almond Spring]$ rm -rf __MACOSX/
[eric@almond Spring]$ cd spring-css/
[eric@almond spring-css]$ rm -rf .classpath .DS_Store .project .settings/

[eric@almond apache-tomcat-8.5.8]$ pwd
/home/eric/Devel/Java/Tomcat/apache-tomcat-8.5.8
[eric@almond apache-tomcat-8.5.8]$ bin/catalina.sh jpda run
Description	Resource	Path	Location	Type
Project configuration is not up-to-date with pom.xml. Select: Maven->Update Project... from the project context menu or use Quick Fix.	spring-css		line 1	Maven Configuration Problem
/ TODO

$ vi pom.xml

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>my.own</groupId>
	<artifactId>spring-css</artifactId>
	<packaging>war</packaging>
	<version>1.0-SNAPSHOT</version>
	
	
	<properties>
	    <jdk.version>1.7</jdk.version>
		<spring.version>4.3.4.RELEASE</spring.version>
		<jstl.version>1.2</jstl.version>
		<tomcat.version>2.2</tomcat.version>
	</properties>

	<dependencies>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
		</dependency>

		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>${jstl.version}</version>
		</dependency>
		
		<dependency>
		    <groupId>org.apache.tomcat</groupId>
		    <artifactId>tomcat-servlet-api</artifactId>
		    <version>8.5.8</version>
		    <scope>provided</scope>
		</dependency>

	</dependencies>

	<build>
		<plugins>
		    <plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.0</version>
				<configuration>
					<source>${jdk.version}</source>
					<target>${jdk.version}</target>
				</configuration>
			</plugin>
			
			<plugin> 
                    <groupId>org.apache.tomcat.maven</groupId>
                    <artifactId>tomcat7-maven-plugin</artifactId>
                    <version>${tomcat.version}</version>
                    <configuration>
	                    <port>8080</port>
	                    <path>/${project.artifactId}</path>
	                    <url>http://localhost:8080/manager/text</url>
	                    <server>tomcat</server>
                    </configuration>
            </plugin>
			

		</plugins>
	</build>

</project>


/ we hoefden NIET voor de jsp pages dep. tomcat-servlet-api	, 
/ TODO
/ maar het moet wel voor debug	, als in DispatcherServlet(HttpServlet)	, 

/ maak in eclipse een debug config	, tomcat-remote-debug-spring-css	,  met project : spring-css	, 
/ anders krijgen we bij debug niet de sources te zien	,
/ TODO

[eric@almond apache-tomcat-8.5.8]$ cat ~/.m2/settings.xml 
<?xml version="1.0" encoding="UTF-8"?>
<settings>
	<servers>
		<server>
			<id>tomcat</id>
			<username>tomcat</username>
			<password>s3cret</password>
		</server>
	</servers>
</settings>

/ deze <id>tomcat</id> zien we terug in tomcat-maven-plugin's <server>tomcat</server>

/ tomcat's
$ vi conf/tomcat-user.xml
  <role rolename="manager-script"/>
  <user username="tomcat" password="s3cret" roles="manager-script"/>
</tomcat-users>

/ manager-script moet	, anders deploys niet	, met tomcat-maven-plugin	,


/ op de een of andere manier is JAVA_HOME def in env, en omdat we een upgrade hebben gedaan	, is deze naar een oude versie	, 
[eric@almond apache-tomcat-8.5.8]$ JAVA_HOME=/etc/alternatives/java_sdk
/ of 
[eric@almond apache-tomcat-8.5.8]$ unset JAVA_HOME

[eric@almond apache-tomcat-8.5.8]$ bin/catalina.sh jpda run
/ OK

/ Geef in eclipse
tomcat7:undeploy clean tomcat7:deploy
/ Geef in chrome	, 
http://localhost:8080/spring-css/



/ Einde MKYOUNG 

/ STS

/ we hebben 3.8.3 download	, 
/ TODO

/ Einde STS

/ SPEL

/ Lees	, 
https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html

/we kunnen System.out inject	, 

/ scala eclipse
/ ws workspace-spring
/ proj knight2

$ vi SlayDragonQuest.java

@Component
public class SlayDragonQuest implements Quest {

	@Value("#{T(java.lang.System).out}")
  private PrintStream stream;

  @Autowired
  public SlayDragonQuest(PrintStream stream) {
    this.stream = stream;
  }

  public void embark() {
    stream.println("Embarking on quest to slay the dragon!");
  }

}

/ Einde SPEL


/ DEBUG SPRING

/ 7	. 

/ stack
/s
	AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object) line: 226	
	AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry) line: 193	
	AnnotatedBeanDefinitionReader.<init>(BeanDefinitionRegistry, Environment) line: 83	
	AnnotatedBeanDefinitionReader.<init>(BeanDefinitionRegistry) line: 66	
	AnnotationConfigApplicationContext.<init>() line: 61	
		this.reader = new AnnotatedBeanDefinitionReader(this);		<-
		this.scanner = new ClassPathBeanDefinitionScanner(this);	/ straks	, scans classpath from base package	, 
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 82	
	KnightMain.main(String[]) line: 10	
/ debug	, 
	AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object) line: 226	

registry	AnnotationConfigApplicationContext  (id=29)	

		DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
				beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
				beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());

		if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME=="org.springframework.context.annotation.internalConfigurationAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
/ WH over @Configuration

		if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME="org.springframework.context.annotation.internalAutowiredAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
/ WH over @Autowired

		if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME="org.springframework.context.annotation.internalRequiredAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
/ wh over @Required

		if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
COMMON_ANNOTATION_PROCESSOR_BEAN_NAME="org.springframework.context.annotation.internalCommonAnnotationProcessor"
			RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
/ over @Resource, ...

/c
/ stack
/s
Thread [main] (Suspended)	
	ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 237	
	ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 116	
	ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 138	
		super(useDefaultFilters, environment);			
/cb
	ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean) line: 112	
	ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry) line: 83	
	AnnotationConfigApplicationContext.<init>() line: 62	
		this.reader = new AnnotatedBeanDefinitionReader(this);
/d
		this.scanner = new ClassPathBeanDefinitionScanner(this);		<- scans classpath, from base package
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 82	
	KnightMain.main(String[]) line: 10	
/ debug	, 
	ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 237	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
/ @Component
/t
	ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 138	
		super(useDefaultFilters, environment);			
/d
		this.registry = registry;							 
			setResourceLoader((ResourceLoader) this.registry); 
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).setResourceLoader(ResourceLoader) line: 132	
		this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);
		this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);
this	ClassPathBeanDefinitionScanner  (id=348)	
	metadataReaderFactory	CachingMetadataReaderFactory  (id=372)	
	resourcePatternResolver	AnnotationConfigApplicationContext  (id=29) / pointer back	, 

/ Intemezzo	


**
 * Standalone application context, accepting annotated classes as input - in particular
 * {@link Configuration @Configuration}-annotated classes, but also plain
 * {@link org.springframework.stereotype.Component @Component} types and JSR-330 compliant
 * classes using {@code javax.inject} annotations. Allows for registering classes one by
 * one using {@link #register(Class...)} as well as for classpath scanning using
 * {@link #scan(String...)}.
 *
 * <p>In case of multiple {@code @Configuration} classes, @{@link Bean} methods defined in
 * later classes will override those defined in earlier classes. This can be leveraged to
 * deliberately override certain bean definitions via an extra {@code @Configuration}
 * class.
 *
 * <p>See @{@link Configuration} Javadoc for usage examples.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.0
 * @see #register
 * @see #scan
 * @see AnnotatedBeanDefinitionReader
 * @see ClassPathBeanDefinitionScanner
 * @see org.springframework.context.support.GenericXmlApplicationContext
 */
public class AnnotationConfigApplicationContext extends GenericApplicationContext {

	private final AnnotatedBeanDefinitionReader reader;

	private final ClassPathBeanDefinitionScanner scanner;


	/**
	 * Create a new AnnotationConfigApplicationContext that needs to be populated
	 * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
	 */
	public AnnotationConfigApplicationContext() {
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);			<-
	}

/ Einde Intemezzo	

/t
AnnotationConfigApplicationContext.<init>(Class<?>...) line: 83	
		this();
/d
		register(annotatedClasses);	/ KnightMainConfig wordt ook een bean	, net als die hierboven	, 
		refresh();
/s

/ 7	. 

/ Intermezzo

/ 13	. 

 * {@link BeanFactoryPostProcessor} used for bootstrapping processing of
 * {@link Configuration @Configuration} classes.
 *
 * <p>Registered by default when using {@code <context:annotation-config/>} or
 * {@code <context:component-scan/>}. Otherwise, may be declared manually as
 * with any other BeanFactoryPostProcessor.
 *
 * <p>This post processor is {@link Ordered#HIGHEST_PRECEDENCE} as it is important
 * that any {@link Bean} methods declared in Configuration classes have their
 * respective bean definitions registered before any other BeanFactoryPostProcessor
 * executes.
 *
 */
public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
		PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {

/**
 * Extension to the standard {@link BeanFactoryPostProcessor} SPI, allowing for
 * the registration of further bean definitions <i>before</i> regular
 * BeanFactoryPostProcessor detection kicks in. In particular,
 * BeanDefinitionRegistryPostProcessor may register further bean definitions
 * which in turn define BeanFactoryPostProcessor instances.
 *
 */
public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
	 * Modify the application context's internal bean definition registry after its
	 * standard initialization. All regular bean definitions will have been loaded,
	 * but no beans will have been instantiated yet. This allows for adding further
	 * bean definitions before the next post-processing phase kicks in.
	 * @param registry the bean definition registry used by the application context
	 * @throws org.springframework.beans.BeansException in case of errors
	 */
	void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;
}


/**
 * Allows for custom modification of an application context's bean definitions,
 * adapting the bean property values of the context's underlying bean factory.
 *
 * <p>Application contexts can auto-detect BeanFactoryPostProcessor beans in
 * their bean definitions and apply them before any other beans get created.
 *
 * <p>Useful for custom config files targeted at system administrators that
 * override bean properties configured in the application context.
 *
 * <p>See PropertyResourceConfigurer and its concrete implementations
 * for out-of-the-box solutions that address such configuration needs.
 *
 * <p>A BeanFactoryPostProcessor may interact with and modify bean
 * definitions, but never bean instances. Doing so may cause premature bean
 * instantiation, violating the container and causing unintended side-effects.
 * If bean instance interaction is required, consider implementing
 * {@link BeanPostProcessor} instead.
 *
 * @author Juergen Hoeller
 * @since 06.07.2003
 * @see BeanPostProcessor
 * @see PropertyResourceConfigurer
 */
public interface BeanFactoryPostProcessor {

	/**
	 * Modify the application context's internal bean factory after its standard
	 * initialization. All bean definitions will have been loaded, but no beans
	 * will have been instantiated yet. This allows for overriding or adding
	 * properties even to eager-initializing beans.
	 * @param beanFactory the bean factory used by the application context
	 * @throws org.springframework.beans.BeansException in case of errors
	 */
	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

/ 13	. 

/**
 * Subinterface of {@link BeanPostProcessor} that adds a before-instantiation callback,
 * and a callback after instantiation but before explicit properties are set or
 * autowiring occurs.
 *
 * <p>Typically used to suppress default instantiation for specific target beans,
 * for example to create proxies with special TargetSources (pooling targets,
 * lazily initializing targets, etc), or to implement additional injection strategies
 * such as field injection.
 *
 * <p><b>NOTE:</b> This interface is a special purpose interface, mainly for
 * internal use within the framework. It is recommended to implement the plain
 * {@link BeanPostProcessor} interface as far as possible, or to derive from
 * {@link InstantiationAwareBeanPostProcessorAdapter} in order to be shielded
 * from extensions to this interface.
 *
 * @author Juergen Hoeller
 * @author Rod Johnson
 * @since 1.2
 * @see org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#setCustomTargetSourceCreators
 * @see org.springframework.aop.framework.autoproxy.target.LazyInitTargetSourceCreator
 */
public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {

	/**
	 * Apply this BeanPostProcessor <i>before the target bean gets instantiated</i>.
	 * The returned bean object may be a proxy to use instead of the target bean,
	 * effectively suppressing default instantiation of the target bean.
	 * <p>If a non-null object is returned by this method, the bean creation process
	 * will be short-circuited. The only further processing applied is the
	 * {@link #postProcessAfterInitialization} callback from the configured
	 * {@link BeanPostProcessor BeanPostProcessors}.
	 * <p>This callback will only be applied to bean definitions with a bean class.
	 * In particular, it will not be applied to beans with a "factory-method".
	 * <p>Post-processors may implement the extended
	 * {@link SmartInstantiationAwareBeanPostProcessor} interface in order
	 * to predict the type of the bean object that they are going to return here.
	 * @param beanClass the class of the bean to be instantiated
	 * @param beanName the name of the bean
	 * @return the bean object to expose instead of a default instance of the target bean,
	 * or {@code null} to proceed with default instantiation
	 * @throws org.springframework.beans.BeansException in case of errors
	 * @see org.springframework.beans.factory.support.AbstractBeanDefinition#hasBeanClass
	 * @see org.springframework.beans.factory.support.AbstractBeanDefinition#getFactoryMethodName
	 */
	Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException;

	/**
	 * Perform operations after the bean has been instantiated, via a constructor or factory method,
	 * but before Spring property population (from explicit properties or autowiring) occurs.
	 * <p>This is the ideal callback for performing field injection on the given bean instance.
	 * See Spring's own {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor}
	 * for a typical example.
	 * @param bean the bean instance created, with properties not having been set yet
	 * @param beanName the name of the bean
	 * @return {@code true} if properties should be set on the bean; {@code false}
	 * if property population should be skipped. Normal implementations should return {@code true}.
	 * Returning {@code false} will also prevent any subsequent InstantiationAwareBeanPostProcessor
	 * instances being invoked on this bean instance.
	 * @throws org.springframework.beans.BeansException in case of errors
	 */
	boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;

	/**
	 * Post-process the given property values before the factory applies them
	 * to the given bean. Allows for checking whether all dependencies have been
	 * satisfied, for example based on a "Required" annotation on bean property setters.
	 * <p>Also allows for replacing the property values to apply, typically through
	 * creating a new MutablePropertyValues instance based on the original PropertyValues,
	 * adding or removing specific values.
	 * @param pvs the property values that the factory is about to apply (never {@code null})
	 * @param pds the relevant property descriptors for the target bean (with ignored
	 * dependency types - which the factory handles specifically - already filtered out)
	 * @param bean the bean instance created, but whose properties have not yet been set
	 * @param beanName the name of the bean
	 * @return the actual property values to apply to to the given bean
	 * (can be the passed-in PropertyValues instance), or {@code null}
	 * to skip property population
	 * @throws org.springframework.beans.BeansException in case of errors
	 * @see org.springframework.beans.MutablePropertyValues
	 */
	PropertyValues postProcessPropertyValues(
			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)
			throws BeansException;

}

/**
 * Factory hook that allows for custom modification of new bean instances,
 * e.g. checking for marker interfaces or wrapping them with proxies.
 *
 * <p>ApplicationContexts can autodetect BeanPostProcessor beans in their
 * bean definitions and apply them to any beans subsequently created.
 * Plain bean factories allow for programmatic registration of post-processors,
 * applying to all beans created through this factory.
 *
 * <p>Typically, post-processors that populate beans via marker interfaces
 * or the like will implement {@link #postProcessBeforeInitialization},
 * while post-processors that wrap beans with proxies will normally
 * implement {@link #postProcessAfterInitialization}.
 *
 * @author Juergen Hoeller
 * @since 10.10.2003
 * @see InstantiationAwareBeanPostProcessor
 * @see DestructionAwareBeanPostProcessor
 * @see ConfigurableBeanFactory#addBeanPostProcessor
 * @see BeanFactoryPostProcessor
 */
public interface BeanPostProcessor {

	/**
	 * Apply this BeanPostProcessor to the given new bean instance <i>before</i> any bean
	 * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
	 * or a custom init-method). The bean will already be populated with property values.
	 * The returned bean instance may be a wrapper around the original.
	 * @param bean the new bean instance
	 * @param beanName the name of the bean
	 * @return the bean instance to use, either the original or a wrapped one; if
	 * {@code null}, no subsequent BeanPostProcessors will be invoked
	 * @throws org.springframework.beans.BeansException in case of errors
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
	 */
	Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;

	/**
	 * Apply this BeanPostProcessor to the given new bean instance <i>after</i> any bean
	 * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
	 * or a custom init-method). The bean will already be populated with property values.
	 * The returned bean instance may be a wrapper around the original.
	 * <p>In case of a FactoryBean, this callback will be invoked for both the FactoryBean
	 * instance and the objects created by the FactoryBean (as of Spring 2.0). The
	 * post-processor can decide whether to apply to either the FactoryBean or created
	 * objects or both through corresponding {@code bean instanceof FactoryBean} checks.
	 * <p>This callback will also be invoked after a short-circuiting triggered by a
	 * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,
	 * in contrast to all other BeanPostProcessor callbacks.
	 * @param bean the new bean instance
	 * @param beanName the name of the bean
	 * @return the bean instance to use, either the original or a wrapped one; if
	 * {@code null}, no subsequent BeanPostProcessors will be invoked
	 * @throws org.springframework.beans.BeansException in case of errors
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
	 * @see org.springframework.beans.factory.FactoryBean
	 */
	Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;

}

class ApplicationContextAwareProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {

/ 13

public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {

/ doe in Display	, 
org.springframework.beans.factory.support.BeanDefinitionRegistry.class.isAssignableFrom(org.springframework.beans.factory.support.DefaultListableBeanFactory.class)
true
org.springframework.core.io.ResourceLoader.class.isAssignableFrom(org.springframework.beans.factory.support.DefaultListableBeanFactory.class)
false


/**
 * A bean definition scanner that detects bean candidates on the classpath,
 * registering corresponding bean definitions with a given registry ({@code BeanFactory}
 * or {@code ApplicationContext}).
 *
 * <p>Candidate classes are detected through configurable type filters. The
 * default filters include classes that are annotated with Spring's
 * {@link org.springframework.stereotype.Component @Component},
 * {@link org.springframework.stereotype.Repository @Repository},
 * {@link org.springframework.stereotype.Service @Service}, or
 * {@link org.springframework.stereotype.Controller @Controller} stereotype.
 *
 * <p>Also supports Java EE 6's {@link javax.annotation.ManagedBean} and
 * JSR-330's {@link javax.inject.Named} annotations, if available.
 *
 */
public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {

	/**
	 * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory.
	 * <p>If the passed-in bean factory does not only implement the
	 * {@code BeanDefinitionRegistry} interface but also the {@code ResourceLoader}
	 * interface, it will be used as default {@code ResourceLoader} as well. This will
	 * usually be the case for {@link org.springframework.context.ApplicationContext}
	 * implementations.
	 * <p>If given a plain {@code BeanDefinitionRegistry}, the default {@code ResourceLoader}
	 * will be a {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.
	 * <p>If the the passed-in bean factory also implements {@link EnvironmentCapable} its
	 * environment will be used by this reader.  Otherwise, the reader will initialize and
	 * use a {@link org.springframework.core.env.StandardEnvironment}. All
	 * {@code ApplicationContext} implementations are {@code EnvironmentCapable}, while
	 * normal {@code BeanFactory} implementations are not.
	 * @param registry the {@code BeanFactory} to load bean definitions into, in the form
	 * of a {@code BeanDefinitionRegistry}
	 * @param useDefaultFilters whether to include the default filters for the
	 * {@link org.springframework.stereotype.Component @Component},
	 * {@link org.springframework.stereotype.Repository @Repository},
	 * {@link org.springframework.stereotype.Service @Service}, and
	 * {@link org.springframework.stereotype.Controller @Controller} stereotype
	 * annotations.
	 * @see #setResourceLoader
	 * @see #setEnvironment
	 */
	public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {





/ Einde Intermezzo

/c

/ de bean factory heeft in beanDefinitionMap de classes	, in singletonObjects de instances	, als ze al gemaakt zijn	, 
/ we gaan nu een inst maken van 
beanName="org.springframework.context.annotation.internalConfigurationAnnotationProcessor"	
mdb=Root bean: class [org.springframework.context.annotation.ConfigurationClassPostProcessor]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null

Thread [main] (Suspended (breakpoint at line 302 in AbstractBeanFactory$1))	
	AbstractBeanFactory$1.getObject() line: 302	
/=
	protected <T> T doGetBean(
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);						<-
/cb
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
					singletonObject = singletonFactory.getObject();
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {			<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class<T>) line: 198	
		return doGetBean(name, requiredType, null, false);
/cb
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 88	
			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			List<BeanDefinitionRegistryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	/**
	 * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
	 * respecting explicit order if given.
	 * <p>Must be called before singleton instantiation.
	 */
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
		refresh();
/cb
	KnightMain.main(String[]) line: 10	
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);

/c
/ stack
/ Create singleton bean 
/ we waren hier al boven	, bij AbstractBeanFactory$1.getObject() line: 302
/s
Thread [main] (Suspended)	
	BeanUtils.instantiateClass(Constructor<T>, Object...) line: 148	
			return ctor.newInstance(args);
/cb
	CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory) line: 89	
			return BeanUtils.instantiateClass(constructorToUse); / constructorToUse=public org.springframework.context.annotation.ConfigurationClassPostProcessor()
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1070	
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1022	
		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
		Object beanInstance = doCreateBean(beanName, mbd, args);
/cb
	AbstractBeanFactory$1.getObject() line: 302	
/=
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);				<-
/cb
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class<T>) line: 198	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 88	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	

/ 1313	. 

/c
/ debug
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1073	
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/d
			}
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
			initBeanWrapper(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).initBeanWrapper(BeanWrapper) line: 1093	
		registerCustomEditors(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).registerCustomEditors(PropertyEditorRegistry) line: 1105	
/=
	protected void registerCustomEditors(PropertyEditorRegistry registry) {

registry	BeanWrapperImpl  (id=1757)	
	object	ConfigurationClassPostProcessor  (id=1745)		
	overriddenDefaultEditors	HashMap<K,V>  (id=1808)		<- hier komen de editors in	,
		[0]	HashMap$Node<K,V>  (id=1813)	
			key	Class<T> (org.springframework.core.io.Resource) (id=1804)	
			value	ResourceEditor  (id=1796)	
		...

					registrar.registerCustomEditors(registry);
/s
ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 114	

this	ResourceEditorRegistrar  (id=1381)	
	propertyResolver	StandardEnvironment  (id=74)	
	resourceLoader	AnnotationConfigApplicationContext  (id=29)	

		ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
		doRegisterEditor(registry, Resource.class, baseEditor);		<- sets  in beanWrapper's overriddenDefaultEditors 
		doRegisterEditor(registry, ContextResource.class, baseEditor);
		doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
		doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
		doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
		doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

		ClassLoader classLoader = this.resourceLoader.getClassLoader();
		doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
		doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
		doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

		if (this.resourceLoader instanceof ResourcePatternResolver) {
			doRegisterEditor(registry, Resource[].class,
					new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
		}

/ 1313	 .

/c
/debug
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 512	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/d
		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 916	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {	/ bp=org.springframework.context.support.ApplicationContextAwareProcessor@6973bf95
/ TODO
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
/n

/ 1313	

/c
/ debug
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 537	
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/d
				mbd.postProcessed = true;
			populateBean(beanName, mbd, instanceWrapper);
/ NIETS	
/ deze bean heeft geen property values	, 

			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	

		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {	/ beanProcessor=org.springframework.context.support.ApplicationContextAwareProcessor@6973bf95
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
ApplicationContextAwareProcessor.postProcessBeforeInitialization(Object, String) line: 94	
		else {
			invokeAwareInterfaces(bean);
/s
ApplicationContextAwareProcessor.invokeAwareInterfaces(Object) line: 103	
			if (bean instanceof EnvironmentAware) {
				((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
			}
			if (bean instanceof ResourceLoaderAware) {
				((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
			}
/t
...
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1550	
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/d
		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
/ NIETS
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsAfterInitialization(Object, String) line: 421	
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
			result = beanProcessor.postProcessAfterInitialization(result, beanName);
/s
ApplicationContextAwareProcessor.postProcessAfterInitialization(Object, String) line: 126	
		return bean;
/ NIETS
/t
...
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 244	
					singletonObject = singletonFactory.getObject();
/d
org.springframework.context.annotation.ConfigurationClassPostProcessor@7ff95560

				addSingleton(beanName, singletonObject);

this	DefaultListableBeanFactory  (id=84)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=1475)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=1898)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=1899)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=1900)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=274)	
			value	ConfigurationClassPostProcessor  (id=1745)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=1901)	
/t
...
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 89	
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
/d
					processedBeans.add(ppName);
			registryPostProcessors.addAll(priorityOrderedPostProcessors);

/ 1313	 .

/c
/ debug
/s
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			OrderComparator.sort(priorityOrderedPostProcessors);
			registryPostProcessors.addAll(priorityOrderedPostProcessors);
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
/s
PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {	/ postProcessor=org.springframework.context.annotation.ConfigurationClassPostProcessor@7ff95560
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/s
ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
/=
	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
registry=org.springframework.beans.factory.support.DefaultListableBeanFactory@6295d394: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,knightMainConfig,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]; root of factory hierarchy

		int registryId = System.identityHashCode(registry);
1653986196
		this.registriesPostProcessed.add(registryId);
		processConfigBeanDefinitions(registry);
/s
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 271	

		for (String beanName : registry.getBeanDefinitionNames()) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
/n
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/s
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 61	

beanDef	AnnotatedGenericBeanDefinition  (id=97)	Generic bean: class [sia.knights.KnightMainConfig]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null

			metadata = new StandardAnnotationMetadata(beanClass, true);
metadata	StandardAnnotationMetadata  (id=116)	
	introspectedClass	Class<T> (sia.knights.KnightMainConfig) (id=109)	
	nestedAnnotationsAsMap	true	

			if (isFullConfigurationCandidate(metadata)) {
/s
ConfigurationClassUtils.isFullConfigurationCandidate(AnnotationMetadata) line: 117	
		return metadata.isAnnotated(Configuration.class.getName());
/s
StandardAnnotationMetadata.isAnnotated(String) line: 102	
		return AnnotatedElementUtils.isAnnotated(getIntrospectedClass(), annotationType);
/s
AnnotatedElementUtils.isAnnotated(AnnotatedElement, String) line: 73	
/=
	public static boolean isAnnotated(AnnotatedElement element, String annotationType) {
element	Class<T> (sia.knights.KnightMainConfig) (id=77)	
annotationType	"org.springframework.context.annotation.Configuration" (id=93)	

		return Boolean.TRUE.equals(process(element, annotationType, false, new Processor<Boolean>() {	<-
			@Override
			public Boolean process(Annotation annotation, int metaDepth) {
				return Boolean.TRUE;
			}
/s
AnnotatedElementUtils.process(AnnotatedElement, String, boolean, Processor<T>) line: 162	

			return doProcess(element, annotationType, traverseClassHierarchy, processor,
					new HashSet<AnnotatedElement>(), 0);
/s
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 193	

		if (visited.add(element)) {
			Annotation[] annotations =
					(traverseClassHierarchy ? element.getDeclaredAnnotations() : element.getAnnotations());
annotations	Annotation[2]  (id=114)	
	[0]	$Proxy4  (id=127)	
		h	AnnotationInvocationHandler  (id=135)	
			memberMethods	null	
			memberValues	LinkedHashMap<K,V>  (id=140)	
			type	Class<T> (org.springframework.context.annotation.Configuration) (id=92)	
	[1]	$Proxy5  (id=128)	
		h	AnnotationInvocationHandler  (id=144)	
			memberMethods	null	
			memberValues	LinkedHashMap<K,V>  (id=147)	
			type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=132)	

/ WHERE @CONFIGURATION

			for (Annotation annotation : annotations) {
				if (annotation.annotationType().getName().equals(annotationType) || metaDepth > 0) {
/j
annotationType	"org.springframework.context.annotation.Configuration" (id=93)	

					T result = processor.process(annotation, metaDepth);
/s
AnnotatedElementUtils$3.process(Annotation, int) line: 76	
/=
		return Boolean.TRUE.equals(process(element, annotationType, false, new Processor<Boolean>() {
			@Override
			public Boolean process(Annotation annotation, int metaDepth) {
				return Boolean.TRUE;																						<-
			}
/t
...
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 87	
			if (isFullConfigurationCandidate(metadata)) {
/d
/j
				beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);

beanDef	AnnotatedGenericBeanDefinition  (id=70)	/ Generic bean: class [sia.knights.KnightMainConfig]; ... 
	attributes	LinkedHashMap<K,V>  (id=203)	
		[0]	LinkedHashMap$Entry<K,V>  (id=211)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass" (id=197)	
			value	BeanMetadataAttribute  (id=216)		full

				return true;
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 281	
		for (String beanName : registry.getBeanDefinitionNames()) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
/d
/j
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));

		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
/s
ConfigurationClassParser.<init>(MetadataReaderFactory, ProblemReporter, Environment, ResourceLoader, BeanNameGenerator, BeanDefinitionRegistry) line: 144	
		...
		this.componentScanParser = new ComponentScanAnnotationParser(								<-
				resourceLoader, environment, componentScanBeanNameGenerator, registry);
registry	DefaultListableBeanFactory  (id=45)	

/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
/d
		parser.parse(configCandidates);
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 235	
/=
	/**
	 * Apply processing and build a complete {@link ConfigurationClass} by reading the
	 * annotations, members and methods from the source class. This method can be called
	 * multiple times as relevant sources are discovered.
	 * @param configClass the configuration class being build
	 * @param sourceClass a source class
	 * @return the superclass, or {@code null} if none found or previously processed
	 */
	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {

/ WHERE @COMPONENTSCAN
		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
...
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 91	
		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {		<-
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				return AnnotationUtils.getAnnotationAttributes(annotation, classValuesAsString, nestedAnnotationsAsMap);
			}
...
/s
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 190	
			Annotation[] annotations =
					(traverseClassHierarchy ? element.getDeclaredAnnotations() : element.getAnnotations());
annotations	Annotation[2]  (id=327)	
	[0]	$Proxy4  (id=127)	
		h	AnnotationInvocationHandler  (id=135)	
			memberMethods	null	
			memberValues	LinkedHashMap<K,V>  (id=140)	
			type	Class<T> (org.springframework.context.annotation.Configuration) (id=92)	
	[1]	$Proxy5  (id=128)	
		h	AnnotationInvocationHandler  (id=144)	
			memberMethods	null	
			memberValues	LinkedHashMap<K,V>  (id=147)	
			type	Class<T> (org.springframework.context.annotation.ComponentScan) (id=132)	

			for (Annotation annotation : annotations) {
				if (annotation.annotationType().getName().equals(annotationType) || metaDepth > 0) {
/j
annotation	$Proxy5  (id=128)	
					T result = processor.process(annotation, metaDepth);
/s
AnnotatedElementUtils$4.process(Annotation, int) line: 94	
/=
		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				return AnnotationUtils.getAnnotationAttributes(annotation, classValuesAsString, nestedAnnotationsAsMap);		<-
annotation	$Proxy5  (id=128)	
this	AnnotatedElementUtils$4  (id=325)	
	val$classValuesAsString	false	
	val$nestedAnnotationsAsMap	true	
/s
AnnotationUtils.getAnnotationAttributes(Annotation, boolean, boolean) line: 558	
		Method[] methods = annotation.annotationType().getDeclaredMethods();
methods	Method[10]  (id=456)	
	[0]	Method  (id=457)	
public abstract java.lang.String[] org.springframework.context.annotation.ComponentScan.basePackages()
	[1]	Method  (id=458)	
public abstract org.springframework.context.annotation.ComponentScan$Filter[] org.springframework.context.annotation.ComponentScan.includeFilters()
	[2]	Method  (id=459)	
public abstract java.lang.String org.springframework.context.annotation.ComponentScan.resourcePattern()
	[3]	Method  (id=463)	
public abstract org.springframework.context.annotation.ComponentScan$Filter[] org.springframework.context.annotation.ComponentScan.excludeFilters()
	[4]	Method  (id=464)	
public abstract boolean org.springframework.context.annotation.ComponentScan.useDefaultFilters()
	[5]	Method  (id=465)	
public abstract java.lang.Class org.springframework.context.annotation.ComponentScan.nameGenerator()
	[6]	Method  (id=466)	
public abstract java.lang.Class org.springframework.context.annotation.ComponentScan.scopeResolver()
	[7]	Method  (id=467)	
public abstract java.lang.Class[] org.springframework.context.annotation.ComponentScan.basePackageClasses()
	[8]	Method  (id=468)	
public abstract org.springframework.context.annotation.ScopedProxyMode org.springframework.context.annotation.ComponentScan.scopedProxy()
	[9]	Method  (id=469)	
public abstract java.lang.String[] org.springframework.context.annotation.ComponentScan.value()

			if (method.getParameterTypes().length == 0 && method.getReturnType() != void.class) {
				try {
					Object value = method.invoke(annotation);
					attrs.put(method.getName(), adaptValue(value, classValuesAsString, nestedAnnotationsAsMap));
		return attrs;
attrs	AnnotationAttributes  (id=454)	
	[0]	LinkedHashMap$Entry<K,V>  (id=509)	
		key	"basePackages" (id=557)	
		value	String[0]  (id=501)	
	[1]	LinkedHashMap$Entry<K,V>  (id=510)	
		key	"includeFilters" (id=554)	
		value	AnnotationAttributes[0]  (id=555)	
	[2]	LinkedHashMap$Entry<K,V>  (id=511)	
		key	"resourcePattern" (id=551)	
		value	"**/*.class" (id=552)	
	[3]	LinkedHashMap$Entry<K,V>  (id=512)	
		key	"excludeFilters" (id=547)	
		value	AnnotationAttributes[0]  (id=548)	
	[4]	LinkedHashMap$Entry<K,V>  (id=513)	
		key	"useDefaultFilters" (id=542)	
		value	Boolean  (id=543)	
	[5]	LinkedHashMap$Entry<K,V>  (id=514)	
		key	"nameGenerator" (id=539)	
		value	Class<T> (org.springframework.beans.factory.support.BeanNameGenerator) (id=265)	
	[6]	LinkedHashMap$Entry<K,V>  (id=515)	
		key	"scopeResolver" (id=535)	
		value	Class<T> (org.springframework.context.annotation.AnnotationScopeMetadataResolver) (id=536)	
	[7]	LinkedHashMap$Entry<K,V>  (id=516)	
		key	"basePackageClasses" (id=531)	
		value	Class<T>[0]  (id=532)	
	[8]	LinkedHashMap$Entry<K,V>  (id=517)	
		key	"scopedProxy" (id=525)	
		value	ScopedProxyMode  (id=526)	
	[9]	LinkedHashMap$Entry<K,V>  (id=518)	
		key	"value" (id=520)	
		value	String[0]  (id=521)	
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 245	
		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
/d
componentScan	AnnotationAttributes  (id=454)	

			// The config class is annotated with @ComponentScan -> perform the scan immediately
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/s
...
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).<init>(boolean, Environment) line: 86	
/=
	public ClassPathScanningCandidateComponentProvider(boolean useDefaultFilters, Environment environment) {
useDefaultFilters=true
		if (useDefaultFilters) {
			registerDefaultFilters();
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).registerDefaultFilters() line: 237	
		this.includeFilters.add(new AnnotationTypeFilter(Component.class));
/t
ClassPathBeanDefinitionScanner.<init>(BeanDefinitionRegistry, boolean, Environment) line: 147	
		super(useDefaultFilters, environment);
/d
		this.registry = registry;	/ org.springframework.beans.factory.support.DefaultListableBeanFactory@53ca01a2: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,knightMainConfig,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]; root of factory hierarchy

		if (this.registry instanceof ResourceLoader) {
/n
			setResourceLoader((ResourceLoader) this.registry);
/n
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 76	
/=
	public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {

componentScan	AnnotationAttributes  (id=454)	
	[0]	LinkedHashMap$Entry<K,V>  (id=509)	
	[1]	LinkedHashMap$Entry<K,V>  (id=510)	
	[2]	LinkedHashMap$Entry<K,V>  (id=511)	
	[3]	LinkedHashMap$Entry<K,V>  (id=512)	
	[4]	LinkedHashMap$Entry<K,V>  (id=513)	
	[5]	LinkedHashMap$Entry<K,V>  (id=514)	
	[6]	LinkedHashMap$Entry<K,V>  (id=515)	
	[7]	LinkedHashMap$Entry<K,V>  (id=516)	
	[8]	LinkedHashMap$Entry<K,V>  (id=517)	
	[9]	LinkedHashMap$Entry<K,V>  (id=518)	
/ attrs van @ComponentScan	, 

		ClassPathBeanDefinitionScanner scanner =
				new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"));
/d
scanner	ClassPathBeanDefinitionScanner  (id=630)	
	autowireCandidatePatterns	null	
	beanDefinitionDefaults	BeanDefinitionDefaults  (id=637)	
	beanNameGenerator	AnnotationBeanNameGenerator  (id=638)	
	conditionEvaluator	null	
	environment	StandardEnvironment  (id=631)	
	excludeFilters	LinkedList<E>  (id=639)	
	includeAnnotationConfig	true	
	includeFilters	LinkedList<E>  (id=633)	
		[0]	AnnotationTypeFilter  (id=643)	
			annotationType	Class<T> (org.springframework.stereotype.Component) (id=620)		<-
			considerInherited	false	
			considerInterfaces	false	
			considerMetaAnnotations	true	
			logger	Log4JLogger  (id=621)	
	logger	Log4JLogger  (id=599)	
	metadataReaderFactory	CachingMetadataReaderFactory  (id=640)	
	registry	DefaultListableBeanFactory  (id=45)	
	resourcePattern	"**/*.class" (id=603)	
	resourcePatternResolver	PathMatchingResourcePatternResolver  (id=665)	
	scopeMetadataResolver	AnnotationScopeMetadataResolver  (id=666)	


		scanner.setEnvironment(this.environment);
environment=StandardEnvironment {activeProfiles=[], defaultProfiles=[default], propertySources=[systemProperties,systemEnvironment]}

		scanner.setResourceLoader(this.resourceLoader);
resourceLoader=org.springframework.context.annotation.AnnotationConfigApplicationContext@47c62251: startup date [Sat Apr 08 11:42:18 CEST 2017]; root of context hierarchy

		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
		boolean useInheritedGenerator = BeanNameGenerator.class.equals(generatorClass);
true
		scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :

		ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
		if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
/n
		else {
			Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
		}

		scanner.setResourcePattern(componentScan.getString("resourcePattern"));

		if (basePackages.isEmpty()) {
/j
			basePackages.add(ClassUtils.getPackageName(declaringClass));

		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);
			}
		});
/ TODO

		return scanner.doScan(StringUtils.toStringArray(basePackages));
basePackages=[sia.knights]
/s
ClassPathBeanDefinitionScanner.doScan(String...) line: 239	
		Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<BeanDefinitionHolder>();
		for (String basePackage : basePackages) {
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 268	
			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					resolveBasePackage(basePackage) + "/" + this.resourcePattern;
classpath*:sia/knights/**/*.class

			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/s
...
PathMatchingResourcePatternResolver.getResources(String) line: 266	
/=
	public Resource[] getResources(String locationPattern) throws IOException {
locationPattern	"classpath*:sia/knights/**/*.class" (id=1083)	

		if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
			// a class path resource (multiple resources for same name possible)
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
/s
AntPathMatcher.isPattern(String) line: 112	
path=sia/knights/**/*.class
		return (path.indexOf('*') != -1 || path.indexOf('?') != -1);
/t
PathMatchingResourcePatternResolver.getResources(String) line: 266	
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
/j
				return findPathMatchingResources(locationPattern);  / locationPattern	"classpath*:sia/knights/**/*.class" (id=1083)	
/s
	/**
	 * Find all resources that match the given location pattern via the
	 * Ant-style PathMatcher. Supports resources in jar files and zip files
	 * and in the file system.
	 */
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 340	
/=
	protected Resource[] findPathMatchingResources(String locationPattern) throws IOException {
locationPattern	"classpath*:sia/knights/**/*.class" (id=1083)	

		String rootDirPath = determineRootDir(locationPattern);	/ classpath*:sia/knights/
		String subPattern = locationPattern.substring(rootDirPath.length());	/ **/*.class
		Resource[] rootDirResources = getResources(rootDirPath); 
/s
PathMatchingResourcePatternResolver.getResources(String) line: 269	
/=
	public Resource[] getResources(String locationPattern) throws IOException {
locationPattern	"classpath*:sia/knights/" (id=1093)	

/ recursive call	, met iets andere locationPattern	, 

		if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
/j
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
/n
			else {
				// all class path resources with the given name
				return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
/s
/=
	protected Resource[] findAllClassPathResources(String location) throws IOException {
location	"sia/knights/" (id=1109)	

		ClassLoader cl = getClassLoader();

/ Intermezzo

/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.111-1.b16.fc23.x86_64/bin/java 
	-agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:43405 
	-Dfile.encoding=UTF-8 
	-classpath 
		/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin:
		/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context/4.0.7.RELEASE/8a4aa735f3691a1985381b3c6c69d32b835f51b4/spring-context-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.7.2/d3b191a99d2c34dfd5311ef3110f096f5bc0a10e/aspectjweaver-1.7.2.jar:/home/eric/.gradle/caches/modules-2/files-2.1/log4j/log4j/1.2.14/3b254c872b95141751f414e353a25c2ac261b51/log4j-1.2.14.jar:/home/eric/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/1.9.5/c3264abeea62c4d2f367e21484fbb40c7e256393/mockito-core-1.9.5.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-test/4.0.7.RELEASE/148c20e5170e6081dfcc5afefa613e27a7b1b814/spring-test-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-aop/4.0.7.RELEASE/caadec5dc4ea4899d89004ff46053f8e391e0343/spring-aop-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-beans/4.0.7.RELEASE/fdd041f086972cc16f9b09ee420a98604cd0bc07/spring-beans-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/4.0.7.RELEASE/777e9502c4c2de150918a746fa22734d3eff81e0/spring-core-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/4.0.7.RELEASE/46a4cfe181b1f15940b5ea7530fcad1f8b98c561/spring-expression-4.0.7.RELEASE.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/eric/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/1.0/9b473564e792c2bdf1449da1f0b1b5bff9805704/objenesis-1.0.jar:/home/eric/.gradle/caches/modules-2/files-2.1/aopalliance/aopalliance/1.0/235ba8b489512805ac13a8f9ea77a1ca5ebe3e8/aopalliance-1.0.jar:/home/eric/.gradle/caches/modules-2/files-2.1/commons-logging/commons-logging/1.1.3/f6f66e966c70a83ffbdb6f17a0919eaf7c8aca7f/commons-logging-1.1.3.jar 
	sia.knights.KnightMain

/ Einde Intermezzo

		Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));
		Set<Resource> result = new LinkedHashSet<Resource>(16);
		while (resourceUrls.hasMoreElements()) {
			URL url = resourceUrls.nextElement();  file:/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/
			result.add(convertClassLoaderURL(url));
/s
						return new UrlResource(url);
/t
			result.add(convertClassLoaderURL(url)); / [URL [file:/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/]]
/d
/t
PathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 343	
		Resource[] rootDirResources = getResources(rootDirPath);
/d
rootDirResources	Resource[1]  (id=1128)	/ [URL [file:/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/]]
			if (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {
/n
			else if (isJarResource(rootDirResource)) {
/n
			else {
				result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));
/s
PathMatchingResourcePatternResolver.doFindPathMatchingFileResources(Resource, String) line: 540	
		File rootDir;
			rootDir = rootDirResource.getFile().getAbsoluteFile(); / /home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights
		return doFindMatchingFileSystemResources(rootDir, subPattern);
subPattern	"**/*.class" (id=1094)	

[eric@almond byte-buddy]$ ls /home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/ -1
BraveKnight.class
BraveKnightTest.class
DamselRescuingKnight.class
FakeMainPrintStream.class
FakePrintStream.class
Knight.class
KnightJavaConfigInjectionTest.class
KnightMain.class
KnightMainConfig.class
KnightTestConfig.class
KnightXMLInjectionTest.class
KnightXMLInjectionTest-context.xml
Minstrel.class
Quest.class
RescueDamselQuest.class
SlayDragonQuest.class

/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 269	
			Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
/d
/ Alle .class files	, 

/ Intermezzo

@Component
public class BraveKnight implements Knight {

@Component
public class DamselRescuingKnight implements Knight {

@Component
public class FakeMainPrintStream extends PrintStream {

@Component
public class RescueDamselQuest implements Quest {

@Component
public class SlayDragonQuest implements Quest {

/ Einde Intermezzo

			for (Resource resource : resources) {	/ file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class]

/ Intermezzo

@Component
public class RescueDamselQuest implements Quest {

 
  private PrintStream stream;

  @Autowired
  public  RescueDamselQuest(PrintStream stream) {
    this.stream = stream;
  }

  public void embark() {
	  System.out.println("Embarking on a quest to rescue the damsel.");
  }
}

[eric@almond bin]$  pwd
/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin

[eric@almond bin]$ javap -c -verbose -p sia/knights/RescueDamselQuest.class 
Classfile /home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class
  Last modified Mar 5, 2017; size 815 bytes
  MD5 checksum 83c20066be608190626bb85fbf632d6e
  Compiled from "RescueDamselQuest.java"
public class sia.knights.RescueDamselQuest implements sia.knights.Quest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Class              #2             // sia/knights/RescueDamselQuest
   #2 = Utf8               sia/knights/RescueDamselQuest
   #3 = Class              #4             // java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Class              #6             // sia/knights/Quest
   #6 = Utf8               sia/knights/Quest
   #7 = Utf8               stream
   #8 = Utf8               Ljava/io/PrintStream;
   #9 = Utf8               <init>
  #10 = Utf8               (Ljava/io/PrintStream;)V
  #11 = Utf8               RuntimeVisibleAnnotations
  #12 = Utf8               Lorg/springframework/beans/factory/annotation/Autowired;
  #13 = Utf8               Code
  #14 = Methodref          #3.#15         // java/lang/Object."<init>":()V
  #15 = NameAndType        #9:#16         // "<init>":()V
  #16 = Utf8               ()V
  #17 = Fieldref           #1.#18         // sia/knights/RescueDamselQuest.stream:Ljava/io/PrintStream;
  #18 = NameAndType        #7:#8          // stream:Ljava/io/PrintStream;
  #19 = Utf8               LineNumberTable
  #20 = Utf8               LocalVariableTable
  #21 = Utf8               this
  #22 = Utf8               Lsia/knights/RescueDamselQuest;
  #23 = Utf8               embark
  #24 = Fieldref           #25.#27        // java/lang/System.out:Ljava/io/PrintStream;
  #25 = Class              #26            // java/lang/System
  #26 = Utf8               java/lang/System
  #27 = NameAndType        #28:#8         // out:Ljava/io/PrintStream;
  #28 = Utf8               out
  #29 = String             #30            // Embarking on a quest to rescue the damsel.
  #30 = Utf8               Embarking on a quest to rescue the damsel.
  #31 = Methodref          #32.#34        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #32 = Class              #33            // java/io/PrintStream
  #33 = Utf8               java/io/PrintStream
  #34 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V
  #35 = Utf8               println
  #36 = Utf8               (Ljava/lang/String;)V
  #37 = Utf8               SourceFile
  #38 = Utf8               RescueDamselQuest.java
  #39 = Utf8               Lorg/springframework/stereotype/Component;
{
  private java.io.PrintStream stream;
    descriptor: Ljava/io/PrintStream;
    flags: ACC_PRIVATE

  public sia.knights.RescueDamselQuest(java.io.PrintStream);
    descriptor: (Ljava/io/PrintStream;)V
    flags: ACC_PUBLIC
    RuntimeVisibleAnnotations:
      0: #12()
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokespecial #14                 // Method java/lang/Object."<init>":()V
         4: aload_0
         5: aload_1
         6: putfield      #17                 // Field stream:Ljava/io/PrintStream;
         9: return
      LineNumberTable:
        line 15: 0
        line 16: 4
        line 17: 9
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lsia/knights/RescueDamselQuest;
            0      10     1 stream   Ljava/io/PrintStream;

  public void embark();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #24                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #29                 // String Embarking on a quest to rescue the damsel.
         5: invokevirtual #31                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 20: 0
        line 21: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lsia/knights/RescueDamselQuest;
}
SourceFile: "RescueDamselQuest.java"
RuntimeVisibleAnnotations:
  0: #39()
[eric@almond bin]$ javap -c -verbose -p sia/knights/RescueDamselQuest.class 
Classfile /home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class
  Last modified Mar 5, 2017; size 815 bytes
  MD5 checksum 83c20066be608190626bb85fbf632d6e
  Compiled from "RescueDamselQuest.java"
public class sia.knights.RescueDamselQuest implements sia.knights.Quest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Class              #2             // sia/knights/RescueDamselQuest
   #2 = Utf8               sia/knights/RescueDamselQuest
   #3 = Class              #4             // java/lang/Object
   #4 = Utf8               java/lang/Object
   #5 = Class              #6             // sia/knights/Quest
   #6 = Utf8               sia/knights/Quest
   #7 = Utf8               stream
   #8 = Utf8               Ljava/io/PrintStream;
   #9 = Utf8               <init>
  #10 = Utf8               (Ljava/io/PrintStream;)V
  #11 = Utf8               RuntimeVisibleAnnotations
  #12 = Utf8               Lorg/springframework/beans/factory/annotation/Autowired;
  #13 = Utf8               Code
  #14 = Methodref          #3.#15         // java/lang/Object."<init>":()V
  #15 = NameAndType        #9:#16         // "<init>":()V
  #16 = Utf8               ()V
  #17 = Fieldref           #1.#18         // sia/knights/RescueDamselQuest.stream:Ljava/io/PrintStream;
  #18 = NameAndType        #7:#8          // stream:Ljava/io/PrintStream;
  #19 = Utf8               LineNumberTable
  #20 = Utf8               LocalVariableTable
  #21 = Utf8               this
  #22 = Utf8               Lsia/knights/RescueDamselQuest;
  #23 = Utf8               embark
  #24 = Fieldref           #25.#27        // java/lang/System.out:Ljava/io/PrintStream;
  #25 = Class              #26            // java/lang/System
  #26 = Utf8               java/lang/System
  #27 = NameAndType        #28:#8         // out:Ljava/io/PrintStream;
  #28 = Utf8               out
  #29 = String             #30            // Embarking on a quest to rescue the damsel.
  #30 = Utf8               Embarking on a quest to rescue the damsel.
  #31 = Methodref          #32.#34        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #32 = Class              #33            // java/io/PrintStream
  #33 = Utf8               java/io/PrintStream
  #34 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V
  #35 = Utf8               println
  #36 = Utf8               (Ljava/lang/String;)V
  #37 = Utf8               SourceFile
  #38 = Utf8               RescueDamselQuest.java
  #39 = Utf8               Lorg/springframework/stereotype/Component;
{
  private java.io.PrintStream stream;
    descriptor: Ljava/io/PrintStream;
    flags: ACC_PRIVATE

  public sia.knights.RescueDamselQuest(java.io.PrintStream);
    descriptor: (Ljava/io/PrintStream;)V
    flags: ACC_PUBLIC
    RuntimeVisibleAnnotations:
      0: #12()
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokespecial #14                 // Method java/lang/Object."<init>":()V
         4: aload_0
         5: aload_1
         6: putfield      #17                 // Field stream:Ljava/io/PrintStream;
         9: return
      LineNumberTable:
        line 15: 0
        line 16: 4
        line 17: 9
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lsia/knights/RescueDamselQuest;
            0      10     1 stream   Ljava/io/PrintStream;

  public void embark();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #24                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #29                 // String Embarking on a quest to rescue the damsel.
         5: invokevirtual #31                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 20: 0
        line 21: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lsia/knights/RescueDamselQuest;
}
SourceFile: "RescueDamselQuest.java"
RuntimeVisibleAnnotations:
  0: #39()



/ Einde Intermezzo

						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
/s
...
							return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
/s
SimpleMetadataReader.<init>(Resource, ClassLoader) line: 50	
		InputStream is = new BufferedInputStream(resource.getInputStream());
/ ASM IN SPRING
			classReader = new ClassReader(is);			/ ASM
			is.close();
		AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);
		classReader.accept(visitor, ClassReader.SKIP_DEBUG);
/s
ClassReader.accept(ClassVisitor, int) line: 508	
        accept(classVisitor, new Attribute[0], flags);
/s
ClassReader.accept(ClassVisitor, Attribute[], int) line: 643	
        int u = header; // current offset in the class file
606
        char[] c = new char[maxStringLength]; // buffer used to read strings

        Context context = new Context();

        // reads the class declaration
        int access = readUnsignedShort(u); / 33
        String name = readClass(u + 2, c); / sia/knights/RescueDamselQuest
        String superClass = readClass(u + 4, c);	/ java/lang/Object
        String[] interfaces = new String[readUnsignedShort(u + 6)];	 / [null]
        u += 8;

        for (int i = 0; i < interfaces.length; ++i) {
            interfaces[i] = readClass(u, c);						/ [sia/knights/Quest]
            u += 2;
        }

        u = getAttributes();																/ 793
        for (int i = readUnsignedShort(u); i > 0; --i) {
            String attrName = readUTF8(u + 2, c); 						/ SourceFile
            // tests are sorted in decreasing frequency order
            // (based on frequencies observed on typical classes)
            if ("SourceFile".equals(attrName)) {
                sourceFile = readUTF8(u + 8, c);	/ RescueDamselQuest.java
            u += 6 + readInt(u + 4);
       for (int i = readUnsignedShort(u); i > 0; --i) {
            String attrName = readUTF8(u + 2, c);	/ RuntimeVisibleAnnotations
            } else if (ANNOTATIONS
                    && "RuntimeVisibleAnnotations".equals(attrName)) {
                anns = u + 8;
            u += 6 + readInt(u + 4);

        // visits the class declaration
        classVisitor.visit(readInt(items[1] - 7), access, name, signature,
                superClass, interfaces);
/s
AnnotationMetadataReadingVisitor(ClassMetadataReadingVisitor).visit(int, int, String, String, String, String[]) line: 72	
		this.className = ClassUtils.convertResourcePathToClassName(name);	/ sia.knights.RescueDamselQuest
		this.isInterface = ((access & Opcodes.ACC_INTERFACE) != 0);		/ false
		this.isAbstract = ((access & Opcodes.ACC_ABSTRACT) != 0);		/ false
		this.isFinal = ((access & Opcodes.ACC_FINAL) != 0);	/ false
		if (supername != null) {
			this.superClassName = ClassUtils.convertResourcePathToClassName(supername);	/ java.lang.Object
		}
		this.interfaces = new String[interfaces.length];
		for (int i = 0; i < interfaces.length; i++) {
			this.interfaces[i] = ClassUtils.convertResourcePathToClassName(interfaces[i]);/ [sia.knights.Quest]
		}
/t
ClassReader.accept(ClassVisitor, Attribute[], int) line: 628	
        // visits the class declaration
        classVisitor.visit(readInt(items[1] - 7), access, name, signature,
                superClass, interfaces);
/d
        // visits the class annotations and type annotations
        if (ANNOTATIONS && anns != 0) {
            for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = readAnnotationValues(v + 2, c, true,
                        classVisitor.visitAnnotation(readUTF8(v, c), true));	/ classVisitor=org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor@6ca8564a
/s
AnnotationMetadataReadingVisitor.visitAnnotation(String, boolean) line: 83	
/=
	public AnnotationVisitor visitAnnotation(final String desc, boolean visible) {
desc	"Lorg/springframework/stereotype/Component;" (id=1256)	

		String className = Type.getType(desc).getClassName();	/ org.springframework.stereotype.Component
		this.annotationSet.add(className);
		return new AnnotationAttributesReadingVisitor(className, this.attributesMap, this.metaAnnotationMap, this.classLoader);
/s
AnnotationAttributesReadingVisitor.<init>(String, MultiValueMap<String,AnnotationAttributes>, Map<String,Set<String>>, ClassLoader) line: 252	
		super(annotationType, new AnnotationAttributes(), classLoader);
		this.annotationType = annotationType;	/ org.springframework.stereotype.Component
		this.attributesMap = attributesMap;	/ {}
		this.metaAnnotationMap = metaAnnotationMap; / {}
/t
ClassReader.accept(ClassVisitor, Attribute[], int) line: 642	
        if (ANNOTATIONS && anns != 0) {
            for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = readAnnotationValues(v + 2, c, true,
                        classVisitor.visitAnnotation(readUTF8(v, c), true));
/pd
/s
ClassReader.readAnnotationValues(int, char[], boolean, AnnotationVisitor) line: 1788	
        if (av != null) {
            av.visitEnd(); / av	AnnotationAttributesReadingVisitor  (id=1265)	
/s
AnnotationAttributesReadingVisitor(RecursiveAnnotationAttributesVisitor).visitEnd() line: 182	
			Class<?> annotationClass = this.classLoader.loadClass(this.annotationType);	 /interface org.springframework.stereotype.Component
			doVisitEnd(annotationClass);
/s
AnnotationAttributesReadingVisitor.doVisitEnd(Class<?>) line: 260	
		super.doVisitEnd(annotationClass);
/s
AnnotationAttributesReadingVisitor(RecursiveAnnotationAttributesVisitor).doVisitEnd(Class<?>) line: 191	
		registerDefaultValues(annotationClass);
/s
AnnotationAttributesReadingVisitor(RecursiveAnnotationAttributesVisitor).registerDefaultValues(Class<?>) line: 201	
		// Only do further scanning for public annotations; we'd run into
		// IllegalAccessExceptions otherwise, and we don't want to mess with
		// accessibility in a SecurityManager environment.
		if (Modifier.isPublic(annotationClass.getModifiers())) {
			// Check declared default values of attributes in the annotation type.
			Method[] annotationAttributes = annotationClass.getMethods();
annotationAttributes	Method[5]  (id=1288)	
	[0]	Method  (id=1289)	
public abstract java.lang.String org.springframework.stereotype.Component.value()
	[1]	Method  (id=1290)	
public abstract boolean java.lang.annotation.Annotation.equals(java.lang.Object)
	[2]	Method  (id=1291)	
public abstract java.lang.String java.lang.annotation.Annotation.toString()
	[3]	Method  (id=1292)	
public abstract int java.lang.annotation.Annotation.hashCode()
	[4]	Method  (id=1293)	
public abstract java.lang.Class java.lang.annotation.Annotation.annotationType()

			for (Method annotationAttribute : annotationAttributes) {
				String attributeName = annotationAttribute.getName();
value
equals
toString
hashCode
annotationType
				Object defaultValue = annotationAttribute.getDefaultValue();
""
null
null
null
null
				if (defaultValue != null && !this.attributes.containsKey(attributeName)) {
					this.attributes.put(attributeName, defaultValue);

/t
AnnotationAttributesReadingVisitor.doVisitEnd(Class<?>) line: 261	
		super.doVisitEnd(annotationClass);
/d
this	AnnotationAttributesReadingVisitor  (id=1265)	
	attributes	AnnotationAttributes  (id=1285)	/ {value=}

		List<AnnotationAttributes> attributes = this.attributesMap.get(this.annotationType);
		if (attributes == null) {
			this.attributesMap.add(this.annotationType, this.attributes);

		for (Annotation metaAnnotation : annotationClass.getAnnotations()) {
annotationClass	Class<T> (org.springframework.stereotype.Component) (id=620)	
annotationClass.getAnnotations()= [
	@java.lang.annotation.Target(value=[TYPE]), 
	@java.lang.annotation.Retention(value=RUNTIME), 
	@java.lang.annotation.Documented()]
			if (!AnnotationUtils.isInJavaLangAnnotationPackage(metaAnnotation)) {
/n

		if (this.metaAnnotationMap != null) {
			this.metaAnnotationMap.put(annotationClass.getName(), metaAnnotationTypeNames);	[]

/ dus	, 
this	AnnotationAttributesReadingVisitor  (id=1265)	
	attributesMap	LinkedMultiValueMap<K,V>  (id=1253)	
		[0]	LinkedHashMap$Entry<K,V>  (id=1414)	
			key	"org.springframework.stereotype.Component" (id=1258)	
			value	LinkedList<E>  (id=1416)														{value=}
	metaAnnotationMap	LinkedHashMap<K,V>  (id=1269)	
		[0]	LinkedHashMap$Entry<K,V>  (id=1405)	
			key	"org.springframework.stereotype.Component" (id=1407)	
			value	LinkedHashSet<E>  (id=1389)													[]	

ClassReader.accept(ClassVisitor, Attribute[], int) line: 691	
        // visits the class annotations and type annotations
        if (ANNOTATIONS && anns != 0) {
            for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = readAnnotationValues(v + 2, c, true,
                        classVisitor.visitAnnotation(readUTF8(v, c), true));
            }
        }
/d
classVisitor	AnnotationMetadataReadingVisitor  (id=1246)	
	className	"sia.knights.RescueDamselQuest" (id=1274)	
	attributesMap	LinkedMultiValueMap<K,V>  (id=1253)	/ {org.springframework.stereotype.Component=[{value=}]}
	metaAnnotationMap	LinkedHashMap<K,V>  (id=1269)	{org.springframework.stereotype.Component=[]}


        // visits the fields and methods
        u = header + 10 + 2 * interfaces.length;
        for (int i = readUnsignedShort(u - 2); i > 0; --i) {
            u = readField(classVisitor, context, u);
/s
ClassReader.readField(ClassVisitor, Context, int) line: 772	
        String name = readUTF8(u + 2, c);
stream
        // visits the field declaration
        FieldVisitor fv = classVisitor.visitField(access, name, desc,
                signature, value);
/s
AnnotationMetadataReadingVisitor(ClassMetadataReadingVisitor).visitField(int, String, String, String, Object) line: 124	
		// no-op
		return new EmptyFieldVisitor();
/t
ClassReader.readField(ClassVisitor, Context, int) line: 815	
        // visits the field declaration
        FieldVisitor fv = classVisitor.visitField(access, name, desc,
                signature, value);
/d
        // visits the end of the field
        fv.visitEnd();
/s
EmptyFieldVisitor(FieldVisitor).visitEnd() line: 151	
        if (fv != null) {
/n
/t
ClassReader.readField(ClassVisitor, Context, int) line: 817	
       // visits the end of the field
        fv.visitEnd();
/d
/ NIETS
        return u;
/t

ClassReader.accept(ClassVisitor, Attribute[], int) line: 695	
       // visits the fields and methods
        u = header + 10 + 2 * interfaces.length;
        for (int i = readUnsignedShort(u - 2); i > 0; --i) {
            u = readField(classVisitor, context, u);
/d
/ geen volgende for loop	, 

        u += 2;
        for (int i = readUnsignedShort(u - 2); i > 0; --i) {
            u = readMethod(classVisitor, context, u);
/s
ClassReader.readMethod(ClassVisitor, Context, int) line: 834	

        context.access = readUnsignedShort(u);
        context.name = readUTF8(u + 2, c);
        context.desc = readUTF8(u + 4, c);

context	Context  (id=1456)	
	desc	"(Ljava/io/PrintStream;)V" (id=1486)	
	name	"<init>" (id=1484)	

/ Intermezzo

  @Autowired
  public SlayDragonQuest(PrintStream stream) {
    this.stream = stream;
  }

/ Einde Intermezzo

        for (int i = readUnsignedShort(u); i > 0; --i) {
            String attrName = readUTF8(u + 2, c);
            } else if (ANNOTATIONS
                    && "RuntimeVisibleAnnotations".equals(attrName)) {
                anns = u + 8;		/ 8
            u += 6 + readInt(u + 4);

        for (int i = readUnsignedShort(u); i > 0; --i) {
            String attrName = readUTF8(u + 2, c);
            if ("Code".equals(attrName)) {
                if ((context.flags & SKIP_CODE) == 0) {
                    code = u + 8;	 /	654
            u += 6 + readInt(u + 4);

        u += 2;
        // visits the method declaration
        MethodVisitor mv = classVisitor.visitMethod(context.access,
                context.name, context.desc, signature, exceptions);
/s
AnnotationMetadataReadingVisitor.visitMethod(int, String, String, String, String[]) line: 78	
		return new MethodMetadataReadingVisitor(name, access, getClassName(), this.classLoader, this.methodMetadataSet);
/s
MethodMetadataReadingVisitor.<init>(String, int, String, ClassLoader, Set<MethodMetadata>) line: 64	
		super(SpringAsmInfo.ASM_VERSION);
		this.name = name;	/ <init>
		this.access = access;
		this.declaringClassName = declaringClassName; / sia.knights.RescueDamselQuest
		this.classLoader = classLoader;
		this.methodMetadataSet = methodMetadataSet;	/ []
/t
ClassReader.readMethod(ClassVisitor, Context, int) line: 929	
        // visits the method declaration
        MethodVisitor mv = classVisitor.visitMethod(context.access,
                context.name, context.desc, signature, exceptions);
/d
        if (ANNOTATIONS && anns != 0) {
            for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = readAnnotationValues(v + 2, c, true,
                        mv.visitAnnotation(readUTF8(v, c), true));
/s
MethodMetadataReadingVisitor.visitAnnotation(String, boolean) line: 75	
		String className = Type.getType(desc).getClassName();	/ org.springframework.beans.factory.annotation.Autowired
		this.methodMetadataSet.add(this);
		return new AnnotationAttributesReadingVisitor(className, this.attributeMap, null, this.classLoader);
/s
AnnotationAttributesReadingVisitor.<init>(String, MultiValueMap<String,AnnotationAttributes>, Map<String,Set<String>>, ClassLoader) line: 252	
		super(annotationType, new AnnotationAttributes(), classLoader);
/s
AnnotationAttributesReadingVisitor(RecursiveAnnotationAttributesVisitor).<init>(String, AnnotationAttributes, ClassLoader) line: 174	
		super(classLoader, attributes);
/s
AnnotationAttributesReadingVisitor(AbstractRecursiveAnnotationVisitor).<init>(ClassLoader, AnnotationAttributes) line: 58	
		super(SpringAsmInfo.ASM_VERSION);
		this.classLoader = classLoader;
		this.attributes = attributes;	/ {}
/t
AnnotationAttributesReadingVisitor(RecursiveAnnotationAttributesVisitor).<init>(String, AnnotationAttributes, ClassLoader) line: 175	
		super(classLoader, attributes);
/d
		this.annotationType = annotationType;	/ org.springframework.beans.factory.annotation.Autowired
/t
AnnotationAttributesReadingVisitor.<init>(String, MultiValueMap<String,AnnotationAttributes>, Map<String,Set<String>>, ClassLoader) line: 253	
		super(annotationType, new AnnotationAttributes(), classLoader);
/d
		this.annotationType = annotationType;/ org.springframework.beans.factory.annotation.Autowired
		this.attributesMap = attributesMap;	/ {}
		this.metaAnnotationMap = metaAnnotationMap; / null
/t
ClassReader.readMethod(ClassVisitor, Context, int) line: 975	
                v = readAnnotationValues(v + 2, c, true,
                        mv.visitAnnotation(readUTF8(v, c), true));
/ pd
/s
ClassReader.readAnnotationValues(int, char[], boolean, AnnotationVisitor) line: 1776	
/=
    private int readAnnotationValues(int v, final char[] buf,
            final boolean named, final AnnotationVisitor av) {
v=648
av=org.springframework.core.type.classreading.AnnotationAttributesReadingVisitor@21de60b4

        int i = readUnsignedShort(v);
0
        v += 2;
        if (named) {
            for (; i > 0; --i) {
/n
                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);
/n
        if (av != null) {
            av.visitEnd();
/s
AnnotationAttributesReadingVisitor(RecursiveAnnotationAttributesVisitor).visitEnd() line: 181	
			Class<?> annotationClass = this.classLoader.loadClass(this.annotationType);
interface org.springframework.beans.factory.annotation.Autowired
			doVisitEnd(annotationClass);
/s
AnnotationAttributesReadingVisitor.doVisitEnd(Class<?>) line: 260	
		super.doVisitEnd(annotationClass);
/s
AnnotationAttributesReadingVisitor(RecursiveAnnotationAttributesVisitor).registerDefaultValues(Class<?>) line: 198	
		registerDefaultValues(annotationClass);
/ see hierboven	, 
/t
AnnotationAttributesReadingVisitor.doVisitEnd(Class<?>) line: 261	
		super.doVisitEnd(annotationClass);
/d
this	AnnotationAttributesReadingVisitor  (id=243)	
	attributes	AnnotationAttributes  (id=245)		/ {required=true}

		List<AnnotationAttributes> attributes = this.attributesMap.get(this.annotationType);
		if (attributes == null) {
			this.attributesMap.add(this.annotationType, this.attributes);

		Set<String> metaAnnotationTypeNames = new LinkedHashSet<String>();
		for (Annotation metaAnnotation : annotationClass.getAnnotations()) {
/ annotationClass.getAnnotations()=[
	@java.lang.annotation.Target(value=[CONSTRUCTOR, FIELD, METHOD, ANNOTATION_TYPE]), 
	@java.lang.annotation.Retention(value=RUNTIME), 
	@java.lang.annotation.Documented()]
			if (!AnnotationUtils.isInJavaLangAnnotationPackage(metaAnnotation)) {
/n
/ NIETS
/t
ClassReader.readAnnotationValues(int, char[], boolean, AnnotationVisitor) line: 1790	
        if (av != null) {
            av.visitEnd();
        }
/d
        return v;
/t
ClassReader.readMethod(ClassVisitor, Context, int) line: 979	
        if (ANNOTATIONS && anns != 0) {
            for (int i = readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = readAnnotationValues(v + 2, c, true,
                        mv.visitAnnotation(readUTF8(v, c), true));
/d
/ @Autowired annotation is voorbij	, nu de code van <init>	, 

        // visits the method code
        if (code != 0) {
            mv.visitCode();
/s
MethodMetadataReadingVisitor(MethodVisitor).visitCode() line: 234	
        if (mv != null) {
/n
            mv.visitCode();
/n
/t
ClassReader.readMethod(ClassVisitor, Context, int) line: 1019	
            mv.visitCode();
/d
            readCode(mv, context, code);
/s
ClassReader.readCode(MethodVisitor, Context, int) line: 1040	

/ Intermezzo

/ stack
/s
	ClassReader.readCode(MethodVisitor, Context, int) line: 1040	
	ClassReader.readMethod(ClassVisitor, Context, int) line: 1019	
	ClassReader.accept(ClassVisitor, Attribute[], int) line: 695	
	ClassReader.accept(ClassVisitor, int) line: 508	
	SimpleMetadataReader.<init>(Resource, ClassLoader) line: 64	
	CachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(Resource) line: 82	
	CachingMetadataReaderFactory.getMetadataReader(Resource) line: 102	
	ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 277	
	ClassPathBeanDefinitionScanner.doScan(String...) line: 242	
	ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 134	
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 248	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
	ConfigurationClassParser.parse(Class<?>, String) line: 185	
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 155	
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	


/ Einde Intermezzo

/=
    private void readCode(final MethodVisitor mv, final Context context, int u) {
        u += 8;
662
        // reads the bytecode to find the labels
        int codeStart = u;
        int codeEnd = u + codeLength;

/ Intermezzo

[eric@almond bin]$ javap -c -verbose -p sia/knights/RescueDamselQuest.class 

  public sia.knights.RescueDamselQuest(java.io.PrintStream);
    descriptor: (Ljava/io/PrintStream;)V
    flags: ACC_PUBLIC
    RuntimeVisibleAnnotations:
      0: #12()
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokespecial #14                 // Method java/lang/Object."<init>":()V
         4: aload_0
         5: aload_1
         6: putfield      #17                 // Field stream:Ljava/io/PrintStream;
         9: return
      LineNumberTable:
        line 15: 0
        line 16: 4
        line 17: 9
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lsia/knights/RescueDamselQuest;
            0      10     1 stream   Ljava/io/PrintStream;

/ Einde Intermezzo


            // visits the instruction at this offset
            int opcode = b[u] & 0xFF;							/ 42=0x2a=aload_0
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.IMPLVAR_INSN:
                u += 1;
                break;
        while (u < codeEnd) {
            int offset = u - codeStart;
            int opcode = b[u] & 0xFF;	/ 183=0xb7=invokespecial
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.IINC_INSN:
                u += 3;
                break;
       while (u < codeEnd) {
            int offset = u - codeStart;
            int opcode = b[u] & 0xFF;	/ 42=aload_0
            case ClassWriter.IMPLVAR_INSN:
                u += 1;
                break;
        while (u < codeEnd) {
            int offset = u - codeStart;
            int opcode = b[u] & 0xFF;	/ 43=0x2b = aload_1
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.IMPLVAR_INSN:
                u += 1;
                break;
        while (u < codeEnd) {
            int offset = u - codeStart;
            int opcode = b[u] & 0xFF;			/ 181=b5=putfield
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.IINC_INSN:
                u += 3;
                break;
        while (u < codeEnd) {
            int offset = u - codeStart;
            int opcode = b[u] & 0xFF;		/ 177=0xb1=return
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.IMPLVAR_INSN:
                u += 1;
                break;
        u += 2;

        // reads the code attributes
        for (int i = readUnsignedShort(u); i > 0; --i) {
            String attrName = readUTF8(u + 2, c);
            } else if ("LineNumberTable".equals(attrName)) {
/j
                if ((context.flags & SKIP_DEBUG) == 0) {
/n
        for (int i = readUnsignedShort(u); i > 0; --i) {
            String attrName = readUTF8(u + 2, c);
            String attrName = readUTF8(u + 2, c);
            } else if ("LineNumberTable".equals(attrName)) {
/j
                if ((context.flags & SKIP_DEBUG) == 0) {
/n
        u += 2;

        // visits the instructions
        u = codeStart;
        while (u < codeEnd) {
            int offset = u - codeStart;

            // visits the label and line number for this offset, if any
            Label l = labels[offset];		/ null
            // visits the instruction at this offset
            int opcode = b[u] & 0xFF;	/ 42=aload_0
            case ClassWriter.IMPLVAR_INSN:
                } else {
                    opcode -= 26; // ILOAD_0			/ 16
                    mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3); / iload=0x15=21+16>>2=4=25=aload
/s
MethodMetadataReadingVisitor(MethodVisitor).visitVarInsn(int, int) line: 385	
/=
    public void visitVarInsn(int opcode, int var) {	/ opcode=aload	, var=0
        if (mv != null) {
/n
/t
ClassReader.readCode(MethodVisitor, Context, int) line: 1335	
                   mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);
/d
                }
                u += 1;
                break;
/ volgende	,
        while (u < codeEnd) {
            int offset = u - codeStart;

            // visits the label and line number for this offset, if any
            Label l = labels[offset];
null
            // visits the instruction at this offset
            int opcode = b[u] & 0xFF;	 								/ 183=invokespecial
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.ITFMETH_INSN: {
                int cpIndex = items[readUnsignedShort(u + 1)];
                boolean itf = b[cpIndex - 1] == ClassWriter.IMETH;
                String iowner = readClass(cpIndex, c);						/ java/lang/Object
                cpIndex = items[readUnsignedShort(cpIndex + 2)];
                String iname = readUTF8(cpIndex, c);							/ <init>
                String idesc = readUTF8(cpIndex + 2, c);				/ ()V
                if (opcode < Opcodes.INVOKEVIRTUAL) {
/n
                } else {
                    mv.visitMethodInsn(opcode, iowner, iname, idesc, itf);
/s
MethodMetadataReadingVisitor(MethodVisitor).visitMethodInsn(int, String, String, String, boolean) line: 487	
        if (mv != null) {
/n
/t
ClassReader.readCode(MethodVisitor, Context, int) line: 1423	
                } else {
                    mv.visitMethodInsn(opcode, iowner, iname, idesc, itf);
/d
                }
                if (opcode == Opcodes.INVOKEINTERFACE) {
/n
                } else {
                    u += 3;
                break;
/ volgende	 	,
/ aload_0 en aload_1 net zo	, 
/ volgende, 	
        while (u < codeEnd) {
            int offset = u - codeStart;

            // visits the label and line number for this offset, if any
            Label l = labels[offset];
null
            // visits the instruction at this offset
            int opcode = b[u] & 0xFF;						/ 181=putfield
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.ITFMETH_INSN: {
                int cpIndex = items[readUnsignedShort(u + 1)];
                boolean itf = b[cpIndex - 1] == ClassWriter.IMETH;
                String iowner = readClass(cpIndex, c);						/ sia/knights/RescueDamselQuest
                cpIndex = items[readUnsignedShort(cpIndex + 2)];
                String iname = readUTF8(cpIndex, c);						/ stream 
                String idesc = readUTF8(cpIndex + 2, c);		/ Ljava/io/PrintStream;
                if (opcode < Opcodes.INVOKEVIRTUAL) {
/j
                    mv.visitFieldInsn(opcode, iowner, iname, idesc);
/s
MethodMetadataReadingVisitor(MethodVisitor).visitFieldInsn(int, String, String, String) line: 428	
        if (mv != null) {
/n
/t
ClassReader.readCode(MethodVisitor, Context, int) line: 1423	
                    mv.visitFieldInsn(opcode, iowner, iname, idesc);
/d
                if (opcode == Opcodes.INVOKEINTERFACE) {
/n
                } else {
                    u += 3;
						break;
/ volgende	, 
        while (u < codeEnd) {
            int offset = u - codeStart;

            // visits the label and line number for this offset, if any
            Label l = labels[offset];
null
            // visits the instruction at this offset
            int opcode = b[u] & 0xFF;		/ 177=return
            switch (ClassWriter.TYPE[opcode]) {
            case ClassWriter.NOARG_INSN:
                mv.visitInsn(opcode);
/s
MethodMetadataReadingVisitor(MethodVisitor).visitInsn(int) line: 346	
        if (mv != null) {
/n
/t
ClassReader.readCode(MethodVisitor, Context, int) line: 1423	
                mv.visitInsn(opcode);
/d
                u += 1;
                break;
/ Geen volgende	, 
        // visits the max stack and max locals values
        mv.visitMaxs(maxStack, maxLocals);		/ 2,2
/s
MethodMetadataReadingVisitor(MethodVisitor).visitMaxs(int, int) line: 875	
        if (mv != null) {
/n
/t
ClassReader.readMethod(ClassVisitor, Context, int) line: 1023	
            readCode(mv, context, code);
/d
       // visits the end of the method
        mv.visitEnd();
/s
MethodMetadataReadingVisitor(MethodVisitor).visitEnd() line: 886	
        if (mv != null) {
/n
/t
ClassReader.readMethod(ClassVisitor, Context, int) line: 1023	
        mv.visitEnd();
/d
        return u;
/t
ClassReader.accept(ClassVisitor, Attribute[], int) line: 695	
        for (int i = readUnsignedShort(u - 2); i > 0; --i) {
            u = readMethod(classVisitor, context, u);
/d
/ volgende	, 
        for (int i = readUnsignedShort(u - 2); i > 0; --i) {
            u = readMethod(classVisitor, context, u);
/ we geloven het	, 
        // visits the end of the class
        classVisitor.visitEnd();
/s
AnnotationMetadataReadingVisitor(ClassMetadataReadingVisitor).visitEnd() line: 136	
		// no-op
/t
SimpleMetadataReader.<init>(Resource, ClassLoader) line: 66	
		classReader.accept(visitor, ClassReader.SKIP_DEBUG);
/d
		this.annotationMetadata = visitor;
		// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)
		this.classMetadata = visitor;
		this.resource = resource;	/ file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class]

this	SimpleMetadataReader  (id=72)	
	annotationMetadata	AnnotationMetadataReadingVisitor  (id=76)	
		annotationSet	LinkedHashSet<E>  (id=102)	
		attributesMap	LinkedMultiValueMap<K,V>  (id=112)	
			[0]	LinkedHashMap$Entry<K,V>  (id=124)	
				key	"org.springframework.stereotype.Component" (id=128)	
				value	LinkedList<E>  (id=129)	
		className	"sia.knights.RescueDamselQuest" (id=116)	
		methodMetaDataSet 	LinkedHashSet<E>  (id=102)	
			[0] MethodMetadataReadingVisitor
				attributesMap	LinkedMultiValueMap<K,V>  (id=112)	
					[0]	LinkedHashMap$Entry<K,V>  (id=124)	
						key "org.springframework.beans.factory.annotation.Autowired"
						value	LinkedList<E>  (id=129)	 	[{required=true}]
/t
CachingMetadataReaderFactory.getMetadataReader(Resource) line: 103	
				metadataReader = super.getMetadataReader(resource);
/d
metadataReader	SimpleMetadataReader  (id=72)	

				this.metadataReaderCache.put(resource, metadataReader);
			return metadataReader;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 278	
			for (Resource resource : resources) {
/ resource=file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/RescueDamselQuest.class]
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
/d
						if (isCandidateComponent(metadataReader)) {
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 338	
		for (TypeFilter tf : this.excludeFilters) {

/ Intermezzo

/ tf=
class ComponentScanAnnotationParser {
	public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {		<-
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);
			}
		});
val$declaringClass	"sia.knights.KnightMainConfig" (id=1371)	

/ je wilt sia.knights.KnightMainConfig uitsluiten, want dat is de config file	, 

/ Einde Intermezzo

			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/n
/ want
/s
ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 61	
		ClassMetadata metadata = metadataReader.getClassMetadata();
		if (matchClassName(metadata.getClassName())) {
/s
ComponentScanAnnotationParser$1.matchClassName(String) line: 131	
				return declaringClass.equals(className);
/n
val$declaringClass	"sia.knights.KnightMainConfig" (id=1371)	
className	"sia.knights.RescueDamselQuest" (id=116)	

ComponentScanAnnotationParser$1(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 117	
		if (matchClassName(metadata.getClassName())) {
/d
/n
		return false;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 342	
		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/n
		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/s
AnnotationTypeFilter(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 61	
		AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();
metadataReader	SimpleMetadataReader  (id=72)	
	annotationMetadata	AnnotationMetadataReadingVisitor
		annotationSet
		methodMetadataSet
/ see hierboven	,

/ WHERE @COMPONENT

		return metadata.hasAnnotation(this.annotationType.getName()) || 
/s
				return this.annotationSet.contains(annotationType);
/t
/j
				(this.considerMetaAnnotations && metadata.hasMetaAnnotation(this.annotationType.getName()));
/ this.annotationType=interface org.springframework.stereotype.Component
/t
AnnotationTypeFilter(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 62	
		if (matchSelf(metadataReader)) {
/d
/j
			return true;
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 345	
		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
/d
/j
				return isConditionMatch(metadataReader);
/s
	/**
	 * Determine whether the given class is a candidate component based on any
	 * {@code @Conditional} annotations.
	 * @param metadataReader the ASM ClassReader for the class
	 * @return whether the class qualifies as a candidate component
	 */
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isConditionMatch(MetadataReader) line: 361	
		if (this.conditionEvaluator == null) {
/j
			this.conditionEvaluator = new ConditionEvaluator(getRegistry(), getEnvironment(), getResourceLoader());
		}
		return !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());
/s
ConditionEvaluator.shouldSkip(AnnotatedTypeMetadata) line: 62	
		return shouldSkip(metadata, null);
/s
ConditionEvaluator.shouldSkip(AnnotatedTypeMetadata, ConfigurationCondition$ConfigurationPhase) line: 73	
		if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {
/j
			return false;
/t
	private boolean isConditionMatch(MetadataReader metadataReader) {
		return !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());
true
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 345	
		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) {
				return isConditionMatch(metadataReader);
true
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 279	
			for (Resource resource : resources) {
				if (resource.isReadable()) {
					try {
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
/j
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
/s
ScannedGenericBeanDefinition.<init>(MetadataReader) line: 61	
		this.metadata = metadataReader.getAnnotationMetadata();
		setBeanClassName(this.metadata.getClassName());
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 279	
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
/d
sbd	ScannedGenericBeanDefinition  (id=1409)	
	metadata	AnnotationMetadataReadingVisitor  (id=76)	

							sbd.setResource(resource);
							sbd.setSource(resource);
							if (isCandidateComponent(sbd)) {
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(AnnotatedBeanDefinition) line: 372	
		return (beanDefinition.getMetadata().isConcrete() && beanDefinition.getMetadata().isIndependent());
/s
AnnotationMetadataReadingVisitor(ClassMetadataReadingVisitor).isConcrete() line: 156	
		return !(this.isInterface || this.isAbstract);
/t
/s
AnnotationMetadataReadingVisitor(ClassMetadataReadingVisitor).isIndependent() line: 166	
		return (this.enclosingClassName == null || this.independentInnerClass);
true || false
/t
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 286	
							if (isCandidateComponent(sbd)) {
/j
								candidates.add(sbd);
/ volgende	, 
			for (Resource resource : resources) { / file [/home/eric/Devel/Eclipse/scala/workspace-spring/knight2/bin/sia/knights/KnightXMLInjectionTest.class]
/ we geloven het	, 
			return candidates;
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 243	
		for (String basePackage : basePackages) {
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/d
this	ClassPathBeanDefinitionScanner  (id=75)	
candidates	LinkedHashSet<E>  (id=236)	
	[0]	ScannedGenericBeanDefinition  (id=1409)	
Generic bean: class [sia.knights.RescueDamselQuest]; ...
	[1]	ScannedGenericBeanDefinition  (id=1442)	
Generic bean: class [sia.knights.KnightTestConfig]; ... 		/ TODO
	[2]	ScannedGenericBeanDefinition  (id=1443)	
Generic bean: class [sia.knights.DamselRescuingKnight];  ...
	[3]	ScannedGenericBeanDefinition  (id=1444)	
Generic bean: class [sia.knights.BraveKnight]; ... 
	[4]	ScannedGenericBeanDefinition  (id=1445)	
Generic bean: class [sia.knights.SlayDragonQuest]; ... 
	[5]	ScannedGenericBeanDefinition  (id=1446)	
Generic bean: class [sia.knights.config.SoundSystemConfig];	...	/ TODO
	[6]	ScannedGenericBeanDefinition  (id=1447)	
Generic bean: class [sia.knights.FakeMainPrintStream]; ... 

/ Intermezzo

/ Op bijna allen staat @Component	, 
/ maar 
@Configuration
@ComponentScan
public class KnightTestConfig {

@Configuration
@ComponentScan(basePackages = "com.habuma.soundsystem", 
               excludeFilters = { @Filter(Configuration.class) })
public class SoundSystemConfig {

/ Maar	, 
/s
ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 278	
			for (Resource resource : resources) { / resource=KnightTestConfig.class]
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
						if (isCandidateComponent(metadataReader)) {
...
/s
AnnotationTypeFilter.matchSelf(MetadataReader) line: 83	
		AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();
		return metadata.hasAnnotation(this.annotationType.getName()) ||
false
				(this.considerMetaAnnotations && metadata.hasMetaAnnotation(this.annotationType.getName()));
true

metadata	AnnotationMetadataReadingVisitor  (id=1352)	
	annotationSet	LinkedHashSet<E>  (id=1353)	
		[0]	"org.springframework.context.annotation.Configuration" (id=1357)	
		[1]	"org.springframework.context.annotation.ComponentScan" (id=1358)	

$ vi Configuration.java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component														<-
public @interface Configuration {

$ vi ComponentScanj.java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface ComponentScan { 	/ niet	, 


/ Einde Intermezzo


/ we zijn in	, 

/ stack
/s
	ClassPathBeanDefinitionScanner.doScan(String...) line: 243	
		for (String basePackage : basePackages) {
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/d
	ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 134	
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 248	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
	ConfigurationClassParser.parse(Class<?>, String) line: 185	
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 155	
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	
/ debug	, 
/s
ClassPathBeanDefinitionScanner.doScan(String...) line: 243	
		for (String basePackage : basePackages) {
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
/d
			for (BeanDefinition candidate : candidates) {
sia.knights.RescueDamselQuest
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
scopeMetadata	ScopeMetadata  (id=1389)	
	scopedProxyMode	ScopedProxyMode  (id=101)	
	scopeName	"singleton" (id=128)	

				candidate.setScope(scopeMetadata.getScopeName());
candidate
	scope "singleton"
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
rescueDamselQuest
				if (candidate instanceof AbstractBeanDefinition) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
/s
ClassPathBeanDefinitionScanner.postProcessBeanDefinition(AbstractBeanDefinition, String) line: 271	

this	ClassPathBeanDefinitionScanner  (id=64)	
	beanDefinitionDefaults	BeanDefinitionDefaults  (id=1456)	
		autowireMode	0	
		dependencyCheck	0	
		destroyMethodName	null	
		initMethodName	null	
		lazyInit	false	

		beanDefinition.applyDefaults(this.beanDefinitionDefaults);
/s
ScannedGenericBeanDefinition(AbstractBeanDefinition).applyDefaults(BeanDefinitionDefaults) line: 324	
		setLazyInit(defaults.isLazyInit());
		setAutowireMode(defaults.getAutowireMode());
		setDependencyCheck(defaults.getDependencyCheck());
		setInitMethodName(defaults.getInitMethodName());
		setEnforceInitMethod(false);
		setDestroyMethodName(defaults.getDestroyMethodName());
		setEnforceDestroyMethod(false);
/t
ClassPathBeanDefinitionScanner.postProcessBeanDefinition(AbstractBeanDefinition, String) line: 275	
		beanDefinition.applyDefaults(this.beanDefinitionDefaults);
		if (this.autowireCandidatePatterns != null) {
/n
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 250	
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
/d
				if (candidate instanceof AnnotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
/s
AnnotationConfigUtils.processCommonDefinitionAnnotations(AnnotatedBeanDefinition, AnnotatedTypeMetadata) line: 287	
		if (metadata.isAnnotated(Lazy.class.getName())) {
/n
		else if (abd.getMetadata().isAnnotated(Lazy.class.getName())) {
/n
		if (metadata.isAnnotated(Primary.class.getName())) {
/n
		if (metadata.isAnnotated(DependsOn.class.getName())) {
/n
		if (abd instanceof AbstractBeanDefinition) {
			AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
			if (metadata.isAnnotated(Role.class.getName())) {
/n
			if (metadata.isAnnotated(Description.class.getName())) {
/n
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 253	
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
/d
				if (checkCandidate(beanName, candidate)) {
/ TODO
/ volgende	, 
			for (BeanDefinition candidate : candidates) {
sia.knights.KnightTestConfig
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
				if (candidate instanceof AbstractBeanDefinition) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
				}
				if (candidate instanceof AnnotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
				}
				if (checkCandidate(beanName, candidate)) {
/j
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
/s
AnnotationConfigUtils.applyScopedProxyMode(ScopeMetadata, BeanDefinitionHolder, BeanDefinitionRegistry) line: 315	
		ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();	/ NO
		if (scopedProxyMode.equals(ScopedProxyMode.NO)) {
			return definition;
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 257	
					definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
/d
					beanDefinitions.add(definitionHolder);
					registerBeanDefinition(definitionHolder, this.registry);
/s
ClassPathBeanDefinitionScanner.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) line: 285	
		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
/s
BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) line: 147	
		// Register bean definition under primary name.
		String beanName = definitionHolder.getBeanName();
knightTestConfig
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
/s
DefaultListableBeanFactory.registerBeanDefinition(String, BeanDefinition) line: 760	
			else {
				this.beanDefinitionNames.add(beanName);
				this.frozenBeanDefinitionNames = null;
			}
			this.beanDefinitionMap.put(beanName, beanDefinition);

this	DefaultListableBeanFactory  (id=44)	
	beanDefinitionNames	ArrayList<E>  (id=1531)	
		[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1535)	
		[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1536)	
		[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1537)	
		[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1538)	
		[4]	"knightMainConfig" (id=1539)	
		[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=1540)	
		[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=1541)	
		[7]	"rescueDamselQuest" (id=113)	
		[8]	"knightTestConfig" (id=1486)	
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 243	
			for (BeanDefinition candidate : candidates) {
sia.knights.DamselRescuingKnight
				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
				candidate.setScope(scopeMetadata.getScopeName());
				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
				if (candidate instanceof AbstractBeanDefinition) {
					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
				}
				if (candidate instanceof AnnotatedBeanDefinition) {
					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
				}
				if (checkCandidate(beanName, candidate)) {
/s
ClassPathBeanDefinitionScanner.checkCandidate(String, BeanDefinition) line: 302	
		if (!this.registry.containsBeanDefinition(beanName)) {
/j
			return true;
/t
ClassPathBeanDefinitionScanner.doScan(String...) line: 254	
				if (checkCandidate(beanName, candidate)) {
/j
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
					beanDefinitions.add(definitionHolder);
					registerBeanDefinition(definitionHolder, this.registry);
/ volgende	,
/ we geloven het	, 
		return beanDefinitions;

beanDefinitions	LinkedHashSet<E>  (id=139)	
	[0]	BeanDefinitionHolder  (id=1520)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1409)	
		beanName	"knightTestConfig" (id=1486)	
	[1]	BeanDefinitionHolder  (id=1584)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1410)	
		beanName	"damselRescuingKnight" (id=1567)	
	[2]	BeanDefinitionHolder  (id=1585)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1411)	
		beanName	"braveKnight" (id=1589)	
	[3]	BeanDefinitionHolder  (id=1586)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1448)	
		beanName	"slayDragonQuest" (id=1590)	
	[4]	BeanDefinitionHolder  (id=1587)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1449)	
		beanName	"soundSystemConfig" (id=1591)	
	[5]	BeanDefinitionHolder  (id=1588)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1450)	
		beanName	"fakeMainPrintStream" (id=1592)	

this	ClassPathBeanDefinitionScanner  (id=64)	
	registry	DefaultListableBeanFactory  (id=44)	
		beanDefinitionNames	ArrayList<E>  (id=1531)	
			[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=1535)	
			[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1536)	
			[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=1537)	
			[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=1538)	
			[4]	"knightMainConfig" (id=1539)	
			[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=1540)	
			[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=1541)	
			[7]	"rescueDamselQuest" (id=113)	
			[8]	"knightTestConfig" (id=1486)	
			[9]	"damselRescuingKnight" (id=1567)	
			[10]	"braveKnight" (id=1589)	
			[11]	"slayDragonQuest" (id=1590)	
			[12]	"soundSystemConfig" (id=1591)	
			[13]	"fakeMainPrintStream" (id=1592)	
/t
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 134	
		return scanner.doScan(StringUtils.toStringArray(basePackages));
/d
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 248	

		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
		if (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			// The config class is annotated with @ComponentScan -> perform the scan immediately
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/d
scannedBeanDefinitions	LinkedHashSet<E>  (id=139)	
/*
	[0]	BeanDefinitionHolder  (id=1520)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1409)	
		beanName	"knightTestConfig" (id=1486)	
*/
	[1]	BeanDefinitionHolder  (id=1584)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1410)	
		beanName	"damselRescuingKnight" (id=1567)	
	[2]	BeanDefinitionHolder  (id=1585)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1411)	
		beanName	"braveKnight" (id=1589)	
	[3]	BeanDefinitionHolder  (id=1586)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1448)	
		beanName	"slayDragonQuest" (id=1590)	
/*
	[4]	BeanDefinitionHolder  (id=1587)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1449)	
		beanName	"soundSystemConfig" (id=1591)	
*/
	[5]	BeanDefinitionHolder  (id=1588)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=1450)	
		beanName	"fakeMainPrintStream" (id=1592)	
/ TODO Waar is de rest	?

/ We hebben @Configuration en @ComponentScan van KnightTestConfig out comment	, (en ook die op SoundSystemConfig  

/ LATER MET KNIGHTTESTCONFIG

			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
Generic bean: class [sia.knights.KnightTestConfig]; ... 
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
/s
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 73	
		else {
			String className = beanDef.getBeanClassName();
sia.knights.KnightTestConfig
			if (className != null) {
				try {
					MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
/s
CachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(String) line: 75	
		String resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX +
				ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;
classpath:sia/knights/KnightTestConfig.class

		return getMetadataReader(this.resourceLoader.getResource(resourcePath));
this	CachingMetadataReaderFactory  (id=1742)	
	resourceLoader	DefaultResourceLoader  (id=1745)	
		classLoader	Launcher$AppClassLoader  (id=95)	
/s
DefaultResourceLoader.getResource(String) line: 95	
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
			return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
/t
/s
CachingMetadataReaderFactory.getMetadataReader(Resource) line: 96	
/=
	public MetadataReader getMetadataReader(Resource resource) throws IOException {
resource	ClassPathResource  (id=1786)	
	classLoader	Launcher$AppClassLoader  (id=95)	
	clazz	null	
	path	"sia/knights/KnightTestConfig.class" (id=1788)	

			MetadataReader metadataReader = this.metadataReaderCache.get(resource);
metadataReader	SimpleMetadataReader  (id=1750)	
	annotationMetadata	AnnotationMetadataReadingVisitor  (id=1752)	
		annotationSet	LinkedHashSet<E>  (id=1756)	
			[0]	"org.springframework.context.annotation.Configuration" (id=1768)	
			[1]	"org.springframework.context.annotation.ComponentScan" (id=1769)	


/ Intermezzo

/ we vonden hem in de cache	, maar als hij daar niet in had gezeten, dan was eerst	, 

			if (metadataReader == null) {
				metadataReader = super.getMetadataReader(resource);
/s
/ (*)
public class SimpleMetadataReaderFactory implements MetadataReaderFactory {
	public MetadataReader getMetadataReader(Resource resource) throws IOException {
		return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
/s
final class SimpleMetadataReader implements MetadataReader {
	/* With ASM */
	SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException {
		InputStream is = new BufferedInputStream(resource.getInputStream());
		ClassReader classReader;
		try {
			classReader = new ClassReader(is);
		}
		catch (IllegalArgumentException ex) {
			throw new NestedIOException("ASM ClassReader failed to parse class file - " +
					"probably due to a new Java class file version that isn't supported yet: " + resource, ex);
		}
		finally {
			is.close();
		}

		AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);
		classReader.accept(visitor, ClassReader.SKIP_DEBUG);

		this.annotationMetadata = visitor;
		// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)
		this.classMetadata = visitor;
		this.resource = resource;
	}

/ Bij (*) waren we net ook 	, 

public class SimpleMetadataReaderFactory implements MetadataReaderFactory {

	@Override
	public MetadataReader getMetadataReader(String className) throws IOException {
		String resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX +
				ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;
		return getMetadataReader(this.resourceLoader.getResource(resourcePath));
	}
/ Zonet	, 

	@Override
	public MetadataReader getMetadataReader(Resource resource) throws IOException {
		return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
	}
/ Nu

/ Einde Intermezzo

			return metadataReader;
/t
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 74	
					MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
					metadata = metadataReader.getAnnotationMetadata();

		if (metadata != null) {
			if (isFullConfigurationCandidate(metadata)) {
/s
					return metadata.isAnnotated(Configuration.class.getName());
/t
/j
				beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
				return true;
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 252	
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
/j
					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());

/ Einde LATER MET KNIGHTTESTCONFIG

/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 250	
			// The config class is annotated with @ComponentScan -> perform the scan immediately
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
sourceClass	ConfigurationClassParser$SourceClass  (id=69)	sia.knights.KnightMainConfig
/d
scannedBeanDefinitions	LinkedHashSet<E>  (id=60)	
	[0]	BeanDefinitionHolder  (id=81)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=88)	
		beanName	"rescueDamselQuest" (id=90)	
	[1]	BeanDefinitionHolder  (id=82)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=106)	
		beanName	"damselRescuingKnight" (id=107)	
	[2]	BeanDefinitionHolder  (id=83)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=104)	
		beanName	"braveKnight" (id=105)	
	[3]	BeanDefinitionHolder  (id=84)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=102)	
		beanName	"slayDragonQuest" (id=103)	
	[4]	BeanDefinitionHolder  (id=85)	
		aliases	null	
		beanDefinition	ScannedGenericBeanDefinition  (id=101)	
		beanName	"fakeMainPrintStream" (id=108)	

			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
/s
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 73	
		else {
			String className = beanDef.getBeanClassName(); / sia.knights.RescueDamselQuest
			if (className != null) {
				try {
					MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
/s
CachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(String) line: 77	
		String resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX +
				ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;
classpath:sia/knights/RescueDamselQuest.class

		return getMetadataReader(this.resourceLoader.getResource(resourcePath));
/s
DefaultResourceLoader.getResource(String) line: 90	
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
			return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
/t
/s
CachingMetadataReaderFactory.getMetadataReader(Resource) line: 96	
		synchronized (this.metadataReaderCache) {
			MetadataReader metadataReader = this.metadataReaderCache.get(resource);
			if (metadataReader == null) {
				metadataReader = super.getMetadataReader(resource);
/s
CachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(Resource) line: 82	
		return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
/s
/ ASM
SimpleMetadataReader.<init>(Resource, ClassLoader) line: 49	
		InputStream is = new BufferedInputStream(resource.getInputStream());
		ClassReader classReader;
		try {
			classReader = new ClassReader(is);
/ TODO Afmaken	,
/t
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 92	
		else {
			String className = beanDef.getBeanClassName();
			if (className != null) {
				try {
					MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
/d
					metadata = metadataReader.getAnnotationMetadata();

		if (metadata != null) {
			if (isFullConfigurationCandidate(metadata)) {
/n 	, geen @Configuration	, 
			else if (isLiteConfigurationCandidate(metadata)) {
/s
				return (!metadata.isInterface() && (metadata.isAnnotated(Component.class.getName()) ||
						metadata.isAnnotated(Import.class.getName()) || metadata.hasAnnotatedMethods(Bean.class.getName())));
/ sia.knights.RescueDamselQuest heeft @Component
/t
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 92	
			else if (isLiteConfigurationCandidate(metadata)) {
/d
/j
				beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
				return true;
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 251	

			// Check the set of scanned definitions for any further config classes and parse recursively if necessary
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) { 
holder=Bean definition with name 'rescueDamselQuest':
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
/d
/j
					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());

/ spring ziet dus een @Component class ook als een config file	, 	maar dat is ons geval niet zo	, er is geen @Configuration, geen methods met @Bean	, ... 

/s
ConfigurationClassParser.parse(String, String) line: 175	
/=
	protected final void parse(String className, String beanName) throws IOException {
className	"sia.knights.RescueDamselQuest" (id=1290)	
beanName	"rescueDamselQuest" (id=1292)	

/ Intermezzo

	ConfigurationClassParser.parse(String, String) line: 175	
className	"sia.knights.RescueDamselQuest" (id=1290)	
beanName	"rescueDamselQuest" (id=1292)	
/cb
	ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 252	
	ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
	ConfigurationClassParser.parse(Class<?>, String) line: 185	
clazz	Class<T> (sia.knights.KnightMainConfig) (id=1293)	
beanName	"knightMainConfig" (id=1294)	
/cb
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 155	
	ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
	ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	

/ Einde Intermezzo

		MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);
/ is er al	, 
reader	SimpleMetadataReader  (id=1302)	
	annotationMetadata	AnnotationMetadataReadingVisitor  (id=1304)	
		annotationSet	LinkedHashSet<E>  (id=1312)	
			[0]	"org.springframework.stereotype.Component" (id=1317)	
		...
		processConfigurationClass(new ConfigurationClass(reader, beanName));
/s
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 190	

		// Recursively process the configuration class and its superclass hierarchy.
		SourceClass sourceClass = asSourceClass(configClass);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 235	
		// Recursively process any member (nested) classes first
		processMemberClasses(configClass, sourceClass);
/ NIETS
		// Process any @PropertySource annotations
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {
/ NEE
		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
null
		// Process any @Import annotations
		processImports(configClass, sourceClass, getImports(sourceClass), true);
/ GEEN	,
		// Process any @ImportResource annotations
		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
/ NEE
		// Process individual @Bean methods
		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());
/ NEE
		// Process superclass, if any
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();
java.lang.Object
			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
/n
		// No superclass -> processing is complete
		return null;
/t
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 222	
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
		}
		while (sourceClass != null);
/d
		this.configurationClasses.put(configClass, configClass);
configClass	ConfigurationClass  (id=1332)	
	beanName	"rescueDamselQuest" (id=1292)	
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 251	
/=
	protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {
configClass	ConfigurationClass  (id=1265)	ConfigurationClass:beanName=knightMainConfig,resource=class sia.knights.KnightMainConfig
sourceClass	ConfigurationClassParser$SourceClass  (id=1266)	 sia.knights.KnightMainConfig

			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
holder=Bean definition with name 'rescueDamselQuest':

				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
/d
/ volgende	, 
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
holder=Bean definition with name 'damselRescuingKnight': 
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
/s
...
CachingMetadataReaderFactory.getMetadataReader(Resource) line: 102	
			if (metadataReader == null) {
/j
				metadataReader = super.getMetadataReader(resource);
/s
CachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(Resource) line: 82	
		return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
/s
/ ASM method
SimpleMetadataReader.<init>(Resource, ClassLoader) line: 50	

		InputStream is = new BufferedInputStream(resource.getInputStream());
		ClassReader classReader;
		try {
			classReader = new ClassReader(is);
		}
		finally {
			is.close();
		}

		AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);
/s
/* ASM */
AnnotationMetadataReadingVisitor.<init>(ClassLoader) line: 67	

/ Intermezzo

/ visits de class	,
public class AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor implements AnnotationMetadata {
	@Override
	public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
		return new MethodMetadataReadingVisitor(name, access, getClassName(), this.classLoader, this.methodMetadataSet);
								^^^^^
	}
/ als je een method visits, krijg je een method visitor, die de @'s registers op de method	, see hier beneden	,

	@Override
	public AnnotationVisitor visitAnnotation(final String desc, boolean visible) {
		String className = Type.getType(desc).getClassName();
		this.annotationSet.add(className);
		return new AnnotationAttributesReadingVisitor(className, this.attributesMap, this.metaAnnotationMap, this.classLoader);
	}
/ registers @'s on classes	,
}

/ visits de method	,
public class MethodMetadataReadingVisitor extends MethodVisitor implements MethodMetadata {
	@Override
	public AnnotationVisitor visitAnnotation(final String desc, boolean visible) {
		String className = Type.getType(desc).getClassName();
		this.methodMetadataSet.add(this);
		return new AnnotationAttributesReadingVisitor(className, this.attributeMap, null, this.classLoader);
	}
/	 registers @'s op methods
}

/ Einde Intermezzo

		classReader.accept(visitor, ClassReader.SKIP_DEBUG);
		this.annotationMetadata = visitor;
this	SimpleMetadataReader  (id=1418)	
	annotationMetadata	AnnotationMetadataReadingVisitor  (id=1419)	
		annotationSet	LinkedHashSet<E>  (id=1422)	
			[0]	"org.springframework.stereotype.Component" (id=1426)	
		...
		// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)
		this.classMetadata = visitor;
		this.resource = resource;
/t
ConfigurationClassUtils.checkConfigurationClassCandidate(BeanDefinition, MetadataReaderFactory) line: 74	
				try {
					MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
/d
					metadata = metadataReader.getAnnotationMetadata();

		if (metadata != null) {
			if (isFullConfigurationCandidate(metadata)) {
/n
			else if (isLiteConfigurationCandidate(metadata)) {
/j
				beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
/ Dit is de bedoeling van deze check method	, daarvoor is die metadatReader created	,  beanDef is 1ste arg van deze check method	,

				return true;
/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 251	
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
/j
					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
/ NIETS
/ spring vindt een @Component class ook een config class	, maar bij ons is er geen @Configuration of een method met @Bean	, 

/ volgende,	
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
/ sets attribute in older.getBeanDefinition()

					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
/ bij ons NIETS	, want er is geen @Configuration en methods met @Bean	, ...
				}
/ we geloven het	, 

		// Process any @Import annotations
		processImports(configClass, sourceClass, getImports(sourceClass), true);
/ NIETS
		// Process any @ImportResource annotations
		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
/ NEE
		// Process individual @Bean methods
		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());
/ GEEN
		// Process superclass, if any
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();
java.lang.Object
			if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
/n
/t
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/d
		}
		while (sourceClass != null);

		this.configurationClasses.put(configClass, configClass);
{
[
...
 ConfigurationClass:beanName=knightMainConfig, resource=class sia.knights.KnightMainConfig=ConfigurationClass:beanName=knightMainConfig, resource=class sia.knights.KnightMainConfig}
/t
ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 155	
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition(); / Generic bean: class [sia.knights.KnightMainConfig]; ... 
				if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
/j
					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
/d
		processDeferredImportSelectors();
/ NIETS
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 306	
		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
		parser.parse(configCandidates);
/d
		parser.validate();
/ NIETS
		// Handle any @PropertySource annotations
		List<PropertySource<?>> parsedPropertySources = parser.getPropertySources();
		if (!parsedPropertySources.isEmpty()) {
/n
		this.reader.loadBeanDefinitions(parser.getConfigurationClasses());
/s
ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(Set<ConfigurationClass>) line: 115	
		TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
		for (ConfigurationClass configClass : configurationModel) {
			loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
/s
ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClass, ConfigurationClassBeanDefinitionReader$TrackedConditionEvaluator) line: 127	
		if (trackedConditionEvaluator.shouldSkip(configClass)) {
/n
		if (configClass.isImported()) {
/n
		for (BeanMethod beanMethod : configClass.getBeanMethods()) {
/n
		loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
/ NIETS
		loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
/ NIETS
/t
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 333	
		this.reader.loadBeanDefinitions(parser.getConfigurationClasses());
/d
/ NIETS
		// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
		if (singletonRegistry != null) {
			if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
/j
IMPORT_REGISTRY_BEAN_NAME=org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry
				singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());

		if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
			((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
/t
ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 244	
		processConfigBeanDefinitions(registry);
/d
/t
PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 256	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
postProcessor=org.springframework.context.annotation.ConfigurationClassPostProcessor@1d9b7cce
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/d
/ GEEN volgende	, 
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 97	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
/d
			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
/ Dit is bij ons voor NIETS	, want er is er 1 	, [org.springframework.context.annotation.internalConfigurationAnnotationProcessor]	, die van type BeanDefinitionRegistryPostProcessor.class is	, maar die is niet Ordered.class	, TODO (hij is PriorityOrdered, dus Ordered)
/s
DefaultListableBeanFactory.getBeanNamesForType(Class<?>, boolean, boolean) line: 353	
		if (!isConfigurationFrozen() || type == null || !allowEagerInit) {
/j
			return doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);
/s
DefaultListableBeanFactory.doGetBeanNamesForType(Class<?>, boolean, boolean) line: 370	
		// Check all bean definitions.
		String[] beanDefinitionNames = getBeanDefinitionNames();
		for (String beanName : beanDefinitionNames) {
beanDefinitionNames	String[12]  (id=266)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
	[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
	[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=270)	
	[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=280)	
	[4]	"knightMainConfig" (id=163)	
	[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=281)	
	[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=282)	
	[7]	"rescueDamselQuest" (id=205)	
	[8]	"damselRescuingKnight" (id=210)	
	[9]	"braveKnight" (id=215)	
	[10]	"slayDragonQuest" (id=220)	
	[11]	"fakeMainPrintStream" (id=225)	

					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
beanName	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
mbd	RootBeanDefinition  (id=297)	
	beanClass	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=47)	
	factoryBeanName	null	

					// Only check bean definition if it is complete.
					if (!mbd.isAbstract() && 
/j
						(allowEagerInit || ((mbd.hasBeanClass() || !mbd.isLazyInit() || this.allowEagerClassLoading)) &&
/j
									!requiresEagerInitForType(mbd.getFactoryBeanName()))) {
/j
/s
	/**
	 * Check whether the specified bean would need to be eagerly initialized
	 * in order to determine its type.
	 */
DefaultListableBeanFactory.requiresEagerInitForType(String) line: 454	
/=
	private boolean requiresEagerInitForType(String factoryBeanName) {
factoryBeanName==null
		return (factoryBeanName != null && isFactoryBean(factoryBeanName) && !containsSingleton(factoryBeanName));
/t
DefaultListableBeanFactory.doGetBeanNamesForType(Class<?>, boolean, boolean) line: 385	
          if (!mbd.isAbstract() &&
            (allowEagerInit || ((mbd.hasBeanClass() || !mbd.isLazyInit() || this.allowEagerClassLoading)) &&
                  !requiresEagerInitForType(mbd.getFactoryBeanName()))) {
/d
/j
						// In case of FactoryBean, match object created by FactoryBean.
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).predictBeanType(String, RootBeanDefinition, Class<?>...) line: 593	
/=
	protected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {
typesToMatch	Class<T>[1]  (id=344)	[interface org.springframework.beans.factory.FactoryBean]

		Class<?> targetType = mbd.getTargetType();
		if (targetType == null) {
			targetType = (mbd.getFactoryMethodName() != null ? getTypeForFactoryMethod(beanName, mbd, typesToMatch) :
/n
mbd	RootBeanDefinition  (id=297)	
	factoryBeanName	null	

					resolveBeanClass(mbd, beanName, typesToMatch));
/s
DefaultListableBeanFactory(AbstractBeanFactory).resolveBeanClass(RootBeanDefinition, String, Class<?>...) line: 1305	
			if (mbd.hasBeanClass()) {
				return mbd.getBeanClass();
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).predictBeanType(String, RootBeanDefinition, Class<?>...) line: 595	
			targetType = (mbd.getFactoryMethodName() != null ? getTypeForFactoryMethod(beanName, mbd, typesToMatch) :
					resolveBeanClass(mbd, beanName, typesToMatch));
/d
targetType	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=47)	

			if (ObjectUtils.isEmpty(typesToMatch) || getTempClassLoader() == null) {
/n || j == j
				mbd.setTargetType(targetType);

		// Apply SmartInstantiationAwareBeanPostProcessors to predict the
		// eventual type after a before-instantiation shortcut.
		if (targetType != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
/j && j && n == n
this	DefaultListableBeanFactory  (id=44)	
hasInstantiationAwareBeanPostProcessors	false	

		return targetType;
targetType  Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=47)
/t
DefaultListableBeanFactory(AbstractBeanFactory).isFactoryBean(String, RootBeanDefinition) line: 1395	
		Class<?> beanType = predictBeanType(beanName, mbd, FactoryBean.class);
/d
beanType  Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor) (id=47)

		return (beanType != null && FactoryBean.class.isAssignableFrom(beanType));
/t
DefaultListableBeanFactory.doGetBeanNamesForType(Class<?>, boolean, boolean) line: 386	
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
/d
/n
						boolean matchFound = (allowEagerInit || !isFactoryBean || containsSingleton(beanName)) &&
								(includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type);
beanName	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
type	Class<T> (org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor) (id=184)	

/ Intermezzo

public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
		PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {

/ Einde Intermezzo

/s
DefaultListableBeanFactory(AbstractBeanFactory).isTypeMatch(String, Class<?>) line: 482	
		// Check manually registered singletons.
		Object beanInstance = getSingleton(beanName, false);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, boolean) line: 184	
		Object singletonObject = this.singletonObjects.get(beanName);
org.springframework.context.annotation.ConfigurationClassPostProcessor@1d9b7cce

		return (singletonObject != NULL_OBJECT ? singletonObject : null);
/t
DefaultListableBeanFactory(AbstractBeanFactory).isTypeMatch(String, Class<?>) line: 487	
		// Check manually registered singletons.
		Object beanInstance = getSingleton(beanName, false);
/d
		if (beanInstance != null) {
/j
			if (beanInstance instanceof FactoryBean) {
/n
			else {
				return !BeanFactoryUtils.isFactoryDereference(name) &&
						ClassUtils.isAssignableValue(typeToMatch, beanInstance);
name	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
typeToMatch	Class<T> (org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor) (id=184)	
/s
	public static boolean isFactoryDereference(String name) {
		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));		/ &
/t
/s
ClassUtils.isAssignableValue(Class<?>, Object) line: 934	
		return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());
/t
DefaultListableBeanFactory.doGetBeanNamesForType(Class<?>, boolean, boolean) line: 388	
						boolean matchFound = (allowEagerInit || !isFactoryBean || containsSingleton(beanName)) &&
								(includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type);
/d
true
						if (matchFound) {
							result.add(beanName);

/ volgende	, 
		for (String beanName : beanDefinitionNames) {
beanName	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
			...
						if (matchFound) {
							result.add(beanName);

/ volgende,	
		for (String beanName : beanDefinitionNames) {
beanName	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=270)	

					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
mbd	RootBeanDefinition  (id=521)	
	beanClass	Class<T> (org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor) (id=523)	

					if (!mbd.isAbstract() && (allowEagerInit ||
							((mbd.hasBeanClass() || !mbd.isLazyInit() || this.allowEagerClassLoading)) &&
									!requiresEagerInitForType(mbd.getFactoryBeanName()))) {
						// In case of FactoryBean, match object created by FactoryBean.
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
						boolean matchFound = (allowEagerInit || !isFactoryBean || containsSingleton(beanName)) &&
								(includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type);
false
/ want	, 
type	Class<T> (org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor) (id=184)	

/ intermezzo

public class RequiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter
		implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware {

/ Einde intermezzo

						if (!matchFound && isFactoryBean) {
/n

/ volgende	, 

		for (String beanName : beanDefinitionNames) {
beanName	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=280)	
beanName=knightMainConfig
beanName=org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor
beanName=org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor
beanName=rescueDamselQuest

					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
mbd	RootBeanDefinition  (id=540)	
	beanClass	Class<T> (org.springframework.context.annotation.CommonAnnotationBeanPostProcessor) (id=552)	
	beanClass	Class<T> (sia.knights.KnightMainConfig) (id=104)	
	beanClass	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor) (id=51)	
	beanClass	Class<T> (org.springframework.context.annotation.ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor) (id=52)	
	beanClass	"sia.knights.RescueDamselQuest" (id=619)	


					// Only check bean definition if it is complete.
					if (!mbd.isAbstract() && (allowEagerInit ||
							((mbd.hasBeanClass() || !mbd.isLazyInit() || this.allowEagerClassLoading)) &&
									!requiresEagerInitForType(mbd.getFactoryBeanName()))) {
						// In case of FactoryBean, match object created by FactoryBean.
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
						boolean matchFound = (allowEagerInit || !isFactoryBean || containsSingleton(beanName)) &&
								(includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type);
false
type	Class<T> (org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor) (id=184)	

/ we geloven het	, 
/c
		// Check singletons too, to catch manually registered singletons.
		String[] singletonNames = getSingletonNames();

result	ArrayList<E>  (id=277)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	

singletonNames	String[5]  (id=1711)	
	[0]	"environment" (id=1715)	
	[1]	"systemProperties" (id=1716)	
	[2]	"systemEnvironment" (id=1718)	
	[3]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
	[4]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry" (id=243)	

		for (String beanName : singletonNames) {
environment
systemProperties
systemEnvironment
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry
			// Only check if manually registered.
			if (!containsBeanDefinition(beanName)) {
/j
/n voor org.springframework.context.annotation.internalConfigurationAnnotationProcessor
				// In case of FactoryBean, match object created by FactoryBean.
				if (isFactoryBean(beanName)) {
/n
				// Match raw bean instance (might be raw FactoryBean).
				if (isTypeMatch(beanName, type)) {
/n
type	Class<T> (org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor) (id=184)	

		return StringUtils.toStringArray(result);
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 98	
			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
/d
postProcessorNames	String[1]  (id=1785)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	

			List<BeanDefinitionRegistryPostProcessor> orderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
/n
/ TODO

/ intermezzo

public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
		PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {

public interface PriorityOrdered extends Ordered {

/ Einde intermezzo

			OrderComparator.sort(orderedPostProcessors);
[]
			registryPostProcessors.addAll(orderedPostProcessors);
			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);
/s
PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 253	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
/n
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/n
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 110	

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
/ TODO
postProcessorNames	String[1]  (id=1846)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
/n
      while (reiterate) {
/n

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
/s
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(Collection<BeanFactoryPostProcessor>, ConfigurableListableBeanFactory) line: 265	
		for (BeanFactoryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanFactory(beanFactory);
/s
	/**
	 * Prepare the Configuration classes for servicing bean requests at runtime
	 * by replacing them with CGLIB-enhanced subclasses.
	 */
ConfigurationClassPostProcessor.postProcessBeanFactory(ConfigurableListableBeanFactory) line: 252	

		int factoryId = System.identityHashCode(beanFactory);
		if (this.factoriesPostProcessed.contains(factoryId)) {
/n
		this.factoriesPostProcessed.add(factoryId);
		if (!this.registriesPostProcessed.contains(factoryId)) {
/n
			// BeanDefinitionRegistryPostProcessor hook apparently not supported...
			// Simply call processConfigurationClasses lazily at this point then.
			processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);		/ al gedaan	, 
/n
		enhanceConfigurationClasses(beanFactory); / beanFactory	DefaultListableBeanFactory  (id=44)	
/s
ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurableListableBeanFactory) line: 351	
		for (String beanName : beanFactory.getBeanDefinitionNames()) {
			BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
/j	,	
beanName	"knightMainConfig" (id=163)	
beanDef	AnnotatedGenericBeanDefinition  (id=164)	

				if (!(beanDef instanceof AbstractBeanDefinition)) {
/n
					throw new BeanDefinitionStoreException("Cannot enhance @Configuration bean definition '" + beanName + "' since it is not stored in an AbstractBeanDefinition subclass");
/n
				configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);

		ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();

		for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
			AbstractBeanDefinition beanDef = entry.getValue();
Generic bean: class [sia.knights.KnightMainConfig]; scope

			// If a @Configuration class gets proxied, always proxy the target class
			beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
			try {
				// Set enhanced subclass of the user-specified bean class
				Class<?> configClass = beanDef.resolveBeanClass(this.beanClassLoader);
class sia.knights.KnightMainConfig
				Class<?> enhancedClass = enhancer.enhance(configClass);
/s
ConfigurationClassEnhancer.enhance(Class<?>) line: 100	
		Class<?> enhancedClass = createClass(newEnhancer(configClass));
/s
ConfigurationClassEnhancer.newEnhancer(Class<?>) line: 113	
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(superclass);
		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
		enhancer.setUseFactory(false);
		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
		enhancer.setStrategy(GENERATOR_STRATEGY);
		enhancer.setCallbackFilter(CALLBACK_FILTER);
		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
		return enhancer;


/ Intermezzo

/c

Thread [main] (Suspended (breakpoint at line 273 in ClassVisitor))	
	DebuggingClassWriter(ClassVisitor).visitField(int, String, String, String, Object) line: 273	
	ClassEmitter.declare_field(int, String, Type, Object) line: 193	
	KeyFactory$Generator.generateClass(ClassVisitor) line: 190	
	DefaultGeneratorStrategy.generate(ClassGenerator) line: 25	
	KeyFactory$Generator(AbstractClassGenerator).create(Object) line: 216	
	KeyFactory$Generator.create() line: 144	
	KeyFactory.create(ClassLoader, Class, Customizer) line: 116	
	KeyFactory.create(Class, Customizer) line: 108	
	KeyFactory.create(Class) line: 104	
	Enhancer.<clinit>() line: 69	
	ConfigurationClassEnhancer.newEnhancer(Class<?>) line: 112	
		Enhancer enhancer = new Enhancer();															<-
/cb
	ConfigurationClassEnhancer.enhance(Class<?>) line: 100	
		Class<?> enhancedClass = createClass(newEnhancer(configClass));
/cb
	ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurableListableBeanFactory) line: 374	
				Class<?> enhancedClass = enhancer.enhance(configClass);
/cb
	ConfigurationClassPostProcessor.postProcessBeanFactory(ConfigurableListableBeanFactory) line: 263	
		enhanceConfigurationClasses(beanFactory);
/cb
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(Collection<BeanFactoryPostProcessor>, ConfigurableListableBeanFactory) line: 265	
		for (BeanFactoryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanFactory(beanFactory);
/cb
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 126	
			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	


/ Einde Intermezzo


/ we waren in	,
/s
ConfigurationClassEnhancer.newEnhancer(Class<?>) line: 113	
		Enhancer enhancer = new Enhancer();
/d
		enhancer.setSuperclass(superclass);
		enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
		enhancer.setUseFactory(false);
		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
		enhancer.setStrategy(GENERATOR_STRATEGY);
		enhancer.setCallbackFilter(CALLBACK_FILTER);
		enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
		return enhancer;
/t
ConfigurationClassEnhancer.enhance(Class<?>) line: 100	
		Class<?> enhancedClass = createClass(newEnhancer(configClass));
/pd
/s
ConfigurationClassEnhancer.createClass(Enhancer) line: 128	
		Class<?> subclass = enhancer.createClass();					/ cglib 	,
/s
Enhancer.createClass() line: 317	
/s
Enhancer.createHelper() line: 377	
/s
Enhancer(AbstractClassGenerator).create(Object) line: 216	
/s
ConfigurationClassEnhancer$BeanFactoryAwareGeneratorStrategy(DefaultGeneratorStrategy).generate(ClassGenerator) line: 25	
/s
ConfigurationClassEnhancer$BeanFactoryAwareGeneratorStrategy.transform(ClassGenerator) line: 205	
			ClassEmitterTransformer transformer = new ClassEmitterTransformer() {
				@Override
				public void end_class() {
					declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory.class), null);
					super.end_class();
				}
			};
			return new TransformingClassGenerator(cg, transformer);
/t
ConfigurationClassEnhancer.createClass(Enhancer) line: 131	
		Class<?> subclass = enhancer.createClass();
/d
		// Registering callbacks statically (as opposed to thread-local)
		// is critical for usage in an OSGi environment (SPR-5932)...
		Enhancer.registerStaticCallbacks(subclass, CALLBACKS);
		return subclass;
/t
ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurableListableBeanFactory) line: 380	
				Class<?> enhancedClass = enhancer.enhance(configClass);
/d
class sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$38f73d6a

					beanDef.setBeanClass(enhancedClass);

////////////////////
/ We hebben dus de enhanched class create	, in beanDefinitions	, er is nog geen inst create in singletonObjects	, 

		for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
/ GEEN volgende	, 
/t
ConfigurationClassPostProcessor.postProcessBeanFactory(ConfigurableListableBeanFactory) line: 264	
		enhanceConfigurationClasses(beanFactory);
/d
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(Collection<BeanFactoryPostProcessor>, ConfigurableListableBeanFactory) line: 267	
		for (BeanFactoryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanFactory(beanFactory);
/d
postProcessor=org.springframework.context.annotation.ConfigurationClassPostProcessor@1d9b7cce
beanFactory=org.springframework.beans.factory.support.DefaultListableBeanFactory@53ca01a2: defining beans [
org.springframework.context.annotation.internalConfigurationAnnotationProcessor,
org.springframework.context.annotation.internalAutowiredAnnotationProcessor,
org.springframework.context.annotation.internalRequiredAnnotationProcessor,
org.springframework.context.annotation.internalCommonAnnotationProcessor,
knightMainConfig,
org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,
org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor,
rescueDamselQuest,
damselRescuingKnight,
braveKnight,
slayDragonQuest,
fakeMainPrintStream]; root of factory hierarchy
/d
/ Er is geen volgende	,
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 127	
			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
/d
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
[]
/ niets	,

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
[org.springframework.context.annotation.internalConfigurationAnnotationProcessor]

		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
		List<String> orderedPostProcessorNames = new ArrayList<String>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
		for (String ppName : postProcessorNames) {
			if (processedBeans.contains(ppName)) {
/j
				// skip - already processed in first phase above
			}

		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
		OrderComparator.sort(priorityOrderedPostProcessors);
[]
		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
/ niets	,

		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
[]
		for (String postProcessorName : orderedPostProcessorNames) {
/n

		// Finally, invoke all other BeanFactoryPostProcessors.
		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
[]
		for (String postProcessorName : nonOrderedPostProcessorNames) {
/n
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 467	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/d
				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).registerBeanPostProcessors(ConfigurableListableBeanFactory) line: 620	
		PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
/s
PostProcessorRegistrationDelegate.registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext) line: 183	
		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
postProcessorNames	String[5]  (id=2094)	
	[0]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
	[1]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=270)	
	[2]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=280)	
	[3]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=281)	
	[4]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=282)	

		// Register BeanPostProcessorChecker that logs an info message when
		// a bean is created during BeanPostProcessor instantiation, i.e. when
		// a bean is not eligible for getting processed by all BeanPostProcessors.
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
/s
DefaultListableBeanFactory(AbstractBeanFactory).getBeanPostProcessorCount() line: 820	
		return this.beanPostProcessors.size();
1
/ want	, 
this	DefaultListableBeanFactory  (id=44)	
	beanPostProcessors	ArrayList<E>  (id=457)	
		[0]	ApplicationContextAwareProcessor  (id=2107)	
/t
PostProcessorRegistrationDelegate.registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext) line: 189	
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
/d
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();
		List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();
		List<String> orderedPostProcessorNames = new ArrayList<String>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<String>();

		for (String ppName : postProcessorNames) {	/ er zijn er 5	, see boven	,
ppName	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
/s
DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class<T>) line: 198	
		return doGetBean(name, requiredType, null, false);
/s
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 235	
		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
null
		else {
			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
null
			if (!typeCheckOnly) {
				markBeanAsCreated(beanName);
/s
					this.alreadyCreated.add(beanName);
/t
			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
/s
DefaultListableBeanFactory(AbstractBeanFactory).getMergedLocalBeanDefinition(String) line: 1157	
		// Quick check on the concurrent map first, with minimal locking.
		RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);
null
		if (mbd != null) {
/n
		return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
/s
DefaultListableBeanFactory.getBeanDefinition(String) line: 643	
		BeanDefinition bd = this.beanDefinitionMap.get(beanName);
bd	RootBeanDefinition  (id=2205)	
	beanClass	Class<T> (org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor) (id=733)	
		return bd;
/t
/s
DefaultListableBeanFactory(AbstractBeanFactory).getMergedBeanDefinition(String, BeanDefinition) line: 1171	
		return getMergedBeanDefinition(beanName, bd, null);
/s
DefaultListableBeanFactory(AbstractBeanFactory).getMergedBeanDefinition(String, BeanDefinition, BeanDefinition) line: 1188	
/=
	protected RootBeanDefinition getMergedBeanDefinition( String beanName, BeanDefinition bd, BeanDefinition containingBd) throws BeanDefinitionStoreException {
beanName	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
bd	RootBeanDefinition  (id=2205)		<- root bean def	TODO	,
containingBd	null	

		synchronized (this.mergedBeanDefinitions) {
			RootBeanDefinition mbd = null;

			// Check with full lock now in order to enforce the same merged instance.
			if (containingBd == null) {
				mbd = this.mergedBeanDefinitions.get(beanName);
null
				if (bd.getParentName() == null) {
/j
/ altijd  bij een root bean def	,
					// Use copy of given root bean definition.
					if (bd instanceof RootBeanDefinition) {
						mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();

				// Set default singleton scope, if not configured before.
				if (!StringUtils.hasLength(mbd.getScope())) {
					mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);

				// A bean contained in a non-singleton bean cannot be a singleton itself.
				// Let's correct this on the fly here, since this might be the result of
				// parent-child merging for the outer bean, in which case the original inner bean
				// definition will not have inherited the merged outer bean's singleton status.
				if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {
/n
containingBd==null, een van de args	, 

				// Only cache the merged bean definition if we're already about to create an
				// instance of the bean, or at least have already created an instance before.
				if (containingBd == null && isCacheBeanMetadata() && isBeanEligibleForMetadataCaching(beanName)) {
/j
/ want	, 
/s
DefaultListableBeanFactory.isBeanEligibleForMetadataCaching(String) line: 666	
		return (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));
/s
DefaultListableBeanFactory(AbstractBeanFactory).isBeanEligibleForMetadataCaching(String) line: 1457	
		return this.alreadyCreated.contains(beanName);
this	DefaultListableBeanFactory  (id=44)	
	alreadyCreated	Collections$SetFromMap<E>  (id=436)	
		[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
		[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
/t
				if (containingBd == null && isCacheBeanMetadata() && isBeanEligibleForMetadataCaching(beanName)) {
/d
					this.mergedBeanDefinitions.put(beanName, mbd);
			return mbd;
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 281	
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
/d
				// Guarantee initialization of beans that the current bean depends on.
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
/n
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {		<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 210	
		synchronized (this.singletonObjects) {

this	DefaultListableBeanFactory  (id=44)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=40)		/ hier zit knightMainConfig NIET bij	, 
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2289)	
			key	"systemProperties" (id=1716)	
			value	Properties  (id=2300)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2290)	
			key	"systemEnvironment" (id=1718)	
			value	Collections$UnmodifiableMap<K,V>  (id=2304)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=2291)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
			value	ConfigurationClassPostProcessor  (id=50)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=2292)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry" (id=243)	
			value	ConfigurationClassParser$ImportStack  (id=149)	
		[4]	ConcurrentHashMap$MapEntry<K,V>  (id=2293)	
			key	"environment" (id=1715)	
			value	StandardEnvironment  (id=145)	

			Object singletonObject = this.singletonObjects.get(beanName);
beanName	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
null
			if (singletonObject == null) {
				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
true
/ TODO
				if (recordSuppressedExceptions) {
					this.suppressedExceptions = new LinkedHashSet<Exception>();
				}
				try {
					singletonObject = singletonFactory.getObject();
/s
AbstractBeanFactory$1.getObject() line: 302	
/=
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {		<- net waren we hier	, 
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);				<- nu hier	,
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 448	
		// Make sure bean class is actually resolved at this point.
		resolveBeanClass(mbd, beanName);
/ niets	, want mdb.beanClass is er al	,

		// Prepare method overrides.
		try {
			mbd.prepareMethodOverrides();
/ niets	, 
/ TODO

		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			Object bean = resolveBeforeInstantiation(beanName, mbd);
null
			if (bean != null) {
/n
		Object beanInstance = doCreateBean(beanName, mbd, args);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 499	
/=
	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {
beanName	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
mbd	RootBeanDefinition  (id=2282)	
	beanClass	Class<T> (org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor) (id=733)	
args	null	

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
/j
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
{}	/ al	, 
		}
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 982	
		Class<?> beanClass = resolveBeanClass(mbd, beanName);
beanClass	Class<T> (org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor) (id=733)	

		if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
/n
		if (mbd.getFactoryMethodName() != null)  {
/n

		// Shortcut when re-creating the same bean...
/ TODO
		boolean resolved = false;
		boolean autowireNecessary = false;
		if (args == null) {
			synchronized (mbd.constructorArgumentLock) {
				if (mbd.resolvedConstructorOrFactoryMethod != null) {
/n
		if (resolved) {
/n
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1037	
		if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {
/n
		return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1014	
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		if (ctors != null ||
/n
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
/n 
public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;		/ WH

				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
/n
		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1060	
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/s
CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory) line: 61	
		// Don't override the class with CGLIB if no overrides.
		if (beanDefinition.getMethodOverrides().isEmpty()) {
/j
			Constructor<?> constructorToUse;
			synchronized (beanDefinition.constructorArgumentLock) {
				constructorToUse = (Constructor<?>) beanDefinition.resolvedConstructorOrFactoryMethod;
				if (constructorToUse == null) {
					final Class<?> clazz = beanDefinition.getBeanClass();
clazz	Class<T> (org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor) (id=733)	

						else {
							constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);
public org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor()

			return BeanUtils.instantiateClass(constructorToUse);
/s
BeanUtils.instantiateClass(Constructor<T>, Object...) line: 145	
			ReflectionUtils.makeAccessible(ctor);
/ TODO
			return ctor.newInstance(args);
/s
AutowiredAnnotationBeanPostProcessor.<init>() line: 136	
		this.autowiredAnnotationTypes.add(Autowired.class);
		this.autowiredAnnotationTypes.add(Value.class);
		try {
			this.autowiredAnnotationTypes.add((Class<? extends Annotation>)
					ClassUtils.forName("javax.inject.Inject", AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));
/n
/ TODO
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1072	
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/d
			}
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
/s
		registerDefaultEditors();
		setWrappedInstance(object);
/s
BeanWrapperImpl.setWrappedInstance(Object, String, Object) line: 215	
		this.object = object;
object	AutowiredAnnotationBeanPostProcessor  (id=2532)	
		this.nestedPath = (nestedPath != null ? nestedPath : "");
""
		this.rootObject = (!"".equals(this.nestedPath) ? rootObject : object);
		this.nestedBeanWrappers = null;
		this.typeConverterDelegate = new TypeConverterDelegate(this, object);
		setIntrospectionClass(object.getClass());
/ NIETS, 	want this.cachedIntrospectionResults==null

/ Intermezzo

public class BeanWrapperImpl extends AbstractPropertyAccessor implements BeanWrapper {
public abstract class AbstractPropertyAccessor extends TypeConverterSupport implements ConfigurablePropertyAccessor {
public abstract class TypeConverterSupport extends PropertyEditorRegistrySupport implements TypeConverter {
public class PropertyEditorRegistrySupport implements PropertyEditorRegistry {

/ Einde Intermezzo

/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1073	
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
/d
			initBeanWrapper(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).initBeanWrapper(BeanWrapper) line: 1092	
this	DefaultListableBeanFactory  (id=44)	
bw	BeanWrapperImpl  (id=2540)	

		bw.setConversionService(getConversionService());	/ null
		registerCustomEditors(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).registerCustomEditors(PropertyEditorRegistry) line: 1105	

		PropertyEditorRegistrySupport registrySupport =
				(registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);
registry	BeanWrapperImpl  (id=2540)	
registrySupport	BeanWrapperImpl  (id=2540)	

		if (registrySupport != null) {
			registrySupport.useConfigValueEditors();
/s
		this.configValueEditorsActive = true;
/t
		if (!this.propertyEditorRegistrars.isEmpty()) {
			for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) {	/ er is er 1	,
registrar	ResourceEditorRegistrar  (id=2564)	
				try {
					registrar.registerCustomEditors(registry);
/s
ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 114	
/=
	public void registerCustomEditors(PropertyEditorRegistry registry) {
registry	BeanWrapperImpl  (id=2540)	
this	ResourceEditorRegistrar  (id=2564)	
	propertyResolver	StandardEnvironment  (id=145)	
	resourceLoader	AnnotationConfigApplicationContext  (id=46)	

		ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
		doRegisterEditor(registry, Resource.class, baseEditor);
/s
	/**
	 * Override default editor, if possible (since that's what we really mean to do here);
	 * otherwise register as a custom editor.
	 */
ResourceEditorRegistrar.doRegisterEditor(PropertyEditorRegistry, Class<?>, PropertyEditor) line: 138	
/=
	private void doRegisterEditor(PropertyEditorRegistry registry, Class<?> requiredType, PropertyEditor editor) {

		if (registry instanceof PropertyEditorRegistrySupport) {
			((PropertyEditorRegistrySupport) registry).overrideDefaultEditor(requiredType, editor);
/s
BeanWrapperImpl(PropertyEditorRegistrySupport).overrideDefaultEditor(Class<?>, PropertyEditor) line: 170	
this	BeanWrapperImpl  (id=2540)	
	customEditorCache	null	
	customEditors	null	
	customEditorsForPath	null	
	defaultEditors	null	
	defaultEditorsActive	true	
	overriddenDefaultEditors	HashMap<K,V>  (id=2592)	

		if (this.overriddenDefaultEditors == null) {
			this.overriddenDefaultEditors = new HashMap<Class<?>, PropertyEditor>();
		}
		this.overriddenDefaultEditors.put(requiredType, propertyEditor);
/t
ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 116	
		doRegisterEditor(registry, ContextResource.class, baseEditor);
		doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
/s
InputStreamEditor.<init>(ResourceEditor) line: 62	

/ Intermezzo

/ Lees	, 
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html

Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");

classpath: classpath:com/myapp/config.xml Loaded from the classpath.
file: file:///data/config.xml Loaded as a URL, from the filesystem. [1]
http: http://myserver/logo.png Loaded as a URL.
(none) /data/config.xml Depends on the underlying ApplicationContext.


 * One-way PropertyEditor which can convert from a text String to a
 * {@code java.io.InputStream}, interpreting the given String
 * as Spring resource location (e.g. a URL String).
 *
 * <p>Supports Spring-style URL notation: any fully qualified standard URL
 * ("file:", "http:", etc) and Spring's special "classpath:" pseudo-URL.
 *
public class InputStreamEditor extends PropertyEditorSupport {

	public InputStreamEditor(ResourceEditor resourceEditor) {
		Assert.notNull(resourceEditor, "ResourceEditor must not be null");
		this.resourceEditor = resourceEditor;
	}

	@Override
	public void setAsText(String text) throws IllegalArgumentException {
		this.resourceEditor.setAsText(text);
		Resource resource = (Resource) this.resourceEditor.getValue();
		try {
			setValue(resource != null ? resource.getInputStream() : null);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException(
					"Could not retrieve InputStream for " + resource + ": " + ex.getMessage());
		}
	}
	/**
	 * This implementation returns {@code null} to indicate that
	 * there is no appropriate text representation.
	 */
	@Override
	public String getAsText() {
		return null;
	}

**
 * Editor for {@code java.io.File}, to directly populate a File property
 * from a Spring resource location.
 *
 * <p>Supports Spring-style URL notation: any fully qualified standard URL
 * ("file:", "http:", etc) and Spring's special "classpath:" pseudo-URL.
 *
 * <p><b>NOTE:</b> The behavior of this editor has changed in Spring 2.0.
 * Previously, it created a File instance directly from a filename.
 * As of Spring 2.0, it takes a standard Spring resource location as input;
 * this is consistent with URLEditor and InputStreamEditor now.
 *
 * <p><b>NOTE:</b> In Spring 2.5 the following modification was made.
 * If a file name is specified without a URL prefix or without an absolute path
 * then we try to locate the file using standard ResourceLoader semantics.
 * If the file was not found, then a File instance is created assuming the file
 * name refers to a relative file location.
 *
 * @author Juergen Hoeller
 * @author Thomas Risberg
 * @since 09.12.2003
 * @see java.io.File
 * @see org.springframework.core.io.ResourceEditor
 * @see org.springframework.core.io.ResourceLoader
 * @see URLEditor
 * @see InputStreamEditor
 */
public class FileEditor extends PropertyEditorSupport {

	private final ResourceEditor resourceEditor;


	/**
	 * Create a new FileEditor,
	 * using the default ResourceEditor underneath.
	 */
	public FileEditor() {
		this.resourceEditor = new ResourceEditor();
	}

	/**
	 * Create a new FileEditor,
	 * using the given ResourceEditor underneath.
	 * @param resourceEditor the ResourceEditor to use
	 */
	public FileEditor(ResourceEditor resourceEditor) {
		Assert.notNull(resourceEditor, "ResourceEditor must not be null");
		this.resourceEditor = resourceEditor;
	}


	@Override
	public void setAsText(String text) throws IllegalArgumentException {
		if (!StringUtils.hasText(text)) {
			setValue(null);
			return;
		}

		// Check whether we got an absolute file path without "file:" prefix.
		// For backwards compatibility, we'll consider those as straight file path.
		if (!ResourceUtils.isUrl(text)) {
			File file = new File(text);
			if (file.isAbsolute()) {
				setValue(file);
				return;
			}
		}

		// Proceed with standard resource location parsing.
		this.resourceEditor.setAsText(text);
		Resource resource = (Resource) this.resourceEditor.getValue();

		// If it's a URL or a path pointing to an existing resource, use it as-is.
		if (ResourceUtils.isUrl(text) || resource.exists()) {
			try {
				setValue(resource.getFile());
			}
			catch (IOException ex) {
				throw new IllegalArgumentException(
						"Could not retrieve File for " + resource + ": " + ex.getMessage());
			}
		}
		else {
			// Create a relative File reference and hope for the best.
			setValue(new File(text));
		}
	}

	@Override
	public String getAsText() {
		File value = (File) getValue();
		return (value != null ? value.getPath() : "");
	}

}

package java.beans;
public class PropertyEditorSupport implements PropertyEditor {
    public void setValue(Object value) {
        this.value = value;
        firePropertyChange();
    }

/**
 * Editor for {@code java.net.URL}, to directly populate a URL property
 * instead of using a String property as bridge.
 *
 * <p>Supports Spring-style URL notation: any fully qualified standard URL
 * ("file:", "http:", etc) and Spring's special "classpath:" pseudo-URL,
 * as well as Spring's context-specific relative file paths.
 *
 * <p>Note: A URL must specify a valid protocol, else it will be rejected
 * upfront. However, the target resource does not necessarily have to exist
 * at the time of URL creation; this depends on the specific resource type.
 *
 * @author Juergen Hoeller
 * @since 15.12.2003
 * @see java.net.URL
 * @see org.springframework.core.io.ResourceEditor
 * @see org.springframework.core.io.ResourceLoader
 * @see FileEditor
 * @see InputStreamEditor
 */
public class URLEditor extends PropertyEditorSupport {

	private final ResourceEditor resourceEditor;


	/**
	 * Create a new URLEditor, using the default ResourceEditor underneath.
	 */
	public URLEditor() {
		this.resourceEditor = new ResourceEditor();
	}

	/**
	 * Create a new URLEditor, using the given ResourceEditor underneath.
	 * @param resourceEditor the ResourceEditor to use
	 */
	public URLEditor(ResourceEditor resourceEditor) {
		Assert.notNull(resourceEditor, "ResourceEditor must not be null");
		this.resourceEditor = resourceEditor;
	}


	@Override
	public void setAsText(String text) throws IllegalArgumentException {
		this.resourceEditor.setAsText(text);
		Resource resource = (Resource) this.resourceEditor.getValue();
		try {
			setValue(resource != null ? resource.getURL() : null);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException("Could not retrieve URL for " + resource + ": " + ex.getMessage());
		}
	}

	@Override
	public String getAsText() {
		URL value = (URL) getValue();
		return (value != null ? value.toExternalForm() : "");
	}

}

/**
 * Editor for {@code java.net.URI}, to directly populate a URI property
 * instead of using a String property as bridge.
 *
 * <p>Supports Spring-style URI notation: any fully qualified standard URI
 * ("file:", "http:", etc) and Spring's special "classpath:" pseudo-URL,
 * which will be resolved to a corresponding URI.
 *
 * <p>By default, this editor will encode Strings into URIs. For instance,
 * a space will be encoded into {@code %20}. This behavior can be changed
 * by calling the {@link #URIEditor(boolean)} constructor.
 *
 * <p>Note: A URI is more relaxed than a URL in that it does not require
 * a valid protocol to be specified. Any scheme within a valid URI syntax
 * is allowed, even without a matching protocol handler being registered.
 *
 * @author Juergen Hoeller
 * @since 2.0.2
 * @see java.net.URI
 * @see URLEditor
 */
public class URIEditor extends PropertyEditorSupport {

	private final ClassLoader classLoader;

	private final boolean encode;



	/**
	 * Create a new, encoding URIEditor, converting "classpath:" locations into
	 * standard URIs (not trying to resolve them into physical resources).
	 */
	public URIEditor() {
		this.classLoader = null;
		this.encode = true;
	}

	/**
	 * Create a new URIEditor, converting "classpath:" locations into
	 * standard URIs (not trying to resolve them into physical resources).
	 * @param encode indicates whether Strings will be encoded or not
	 */
	public URIEditor(boolean encode) {
		this.classLoader = null;
		this.encode = encode;
	}


	/**
	 * Create a new URIEditor, using the given ClassLoader to resolve
	 * "classpath:" locations into physical resource URLs.
	 * @param classLoader the ClassLoader to use for resolving "classpath:" locations
	 * (may be {@code null} to indicate the default ClassLoader)
	 */
	public URIEditor(ClassLoader classLoader) {
		this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());
		this.encode = true;
	}

	/**
	 * Create a new URIEditor, using the given ClassLoader to resolve
	 * "classpath:" locations into physical resource URLs.
	 * @param classLoader the ClassLoader to use for resolving "classpath:" locations
	 * (may be {@code null} to indicate the default ClassLoader)
	 * @param encode indicates whether Strings will be encoded or not
	 */
	public URIEditor(ClassLoader classLoader, boolean encode) {
		this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());
		this.encode = encode;
	}


	@Override
	public void setAsText(String text) throws IllegalArgumentException {
		if (StringUtils.hasText(text)) {
			String uri = text.trim();
			if (this.classLoader != null && uri.startsWith(ResourceUtils.CLASSPATH_URL_PREFIX)) {
				ClassPathResource resource =
						new ClassPathResource(uri.substring(ResourceUtils.CLASSPATH_URL_PREFIX.length()), this.classLoader);
				try {
					String url = resource.getURL().toString();
					setValue(createURI(url));
				}
				catch (IOException ex) {
					throw new IllegalArgumentException("Could not retrieve URI for " + resource + ": " + ex.getMessage());
				}
				catch (URISyntaxException ex) {
					throw new IllegalArgumentException("Invalid URI syntax: " + ex);
				}
			}
			else {
				try {
					setValue(createURI(uri));
				}
				catch (URISyntaxException ex) {
					throw new IllegalArgumentException("Invalid URI syntax: " + ex);
				}
			}
		}
		else {
			setValue(null);
		}
	}

	/**
	 * Create a URI instance for the given (resolved) String value.
	 * <p>The default implementation encodes the value into a RFC
	 * 2396 compliant URI.
	 * @param value the value to convert into a URI instance
	 * @return the URI instance
	 * @throws java.net.URISyntaxException if URI conversion failed
	 */
	protected URI createURI(String value) throws URISyntaxException {
		int colonIndex = value.indexOf(':');
		if (this.encode && colonIndex != -1) {
			int fragmentIndex = value.indexOf('#', colonIndex + 1);
			String scheme = value.substring(0, colonIndex);
			String ssp = value.substring(colonIndex + 1, (fragmentIndex > 0 ? fragmentIndex : value.length()));
			String fragment = (fragmentIndex > 0 ? value.substring(fragmentIndex + 1) : null);
			return new URI(scheme, ssp, fragment);
		}
		else {
			// not encoding or the value contains no scheme - fallback to default
			return new URI(value);
		}
	}


	@Override
	public String getAsText() {
		URI value = (URI) getValue();
		return (value != null ? value.toString() : "");
	}

}


/ Einde Intermezzo

		doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
		doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
		doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

		ClassLoader classLoader = this.resourceLoader.getClassLoader();
		doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
		doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
		doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

		if (this.resourceLoader instanceof ResourcePatternResolver) {
			doRegisterEditor(registry, Resource[].class,
					new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1074	
			initBeanWrapper(bw);
/d
bw	BeanWrapperImpl  (id=2540)	
	object	AutowiredAnnotationBeanPostProcessor  (id=2532)	
	overriddenDefaultEditors	HashMap<K,V>  (id=2592)	
		[0]	HashMap$Node<K,V>  (id=2620)	
			key	Class<T> (java.io.InputStream) (id=1652)	
			value	InputStreamEditor  (id=2603)	
		[1]	HashMap$Node<K,V>  (id=2621)	
			key	Class<T> (org.xml.sax.InputSource) (id=2634)	
			value	InputSourceEditor  (id=2635)	
		[2]	HashMap$Node<K,V>  (id=2622)	
			key	Class<T> (org.springframework.core.io.Resource[]) (id=679)	
			value	ResourceArrayPropertyEditor  (id=2633)	
		[3]	HashMap$Node<K,V>  (id=2623)	
			key	Class<T> (org.springframework.core.io.Resource) (id=918)	
			value	ResourceEditor  (id=2588)	
		[4]	HashMap$Node<K,V>  (id=2624)	
			key	Class<T> (org.springframework.core.io.ContextResource) (id=2632)	
			value	ResourceEditor  (id=2588)	
		[5]	HashMap$Node<K,V>  (id=2625)	
			key	Class<T> (java.io.File) (id=1650)	
			value	FileEditor  (id=2609)	
		[6]	HashMap$Node<K,V>  (id=2626)	
			key	Class<T> (java.net.URL) (id=1649)	
			value	URLEditor  (id=2610)	
		[7]	HashMap$Node<K,V>  (id=2627)	
			key	Class<T> (java.lang.Class[]) (id=345)	
			value	ClassArrayEditor  (id=2631)	
		[8]	HashMap$Node<K,V>  (id=2628)	
			key	Class<T> (java.net.URI) (id=964)	
			value	URIEditor  (id=2617)	
		[9]	HashMap$Node<K,V>  (id=2629)	
			key	Class<T> (java.lang.Class) (id=105)	
			value	ClassEditor  (id=2630)	

			return bw;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1022	
		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
/d
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 506	
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/d
		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 906	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
[org.springframework.context.support.ApplicationContextAwareProcessor@7bedc48a, 
org.springframework.context.support.PostProcessorRegistrationDelegate$BeanPostProcessorChecker@43c1b556]

				if (bp instanceof MergedBeanDefinitionPostProcessor) {
/n
/t
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/d
				mbd.postProcessed = true;

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
/ TODO
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
true
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).addSingletonFactory(String, ObjectFactory<?>) line: 160	
/=
	protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {

beanName	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
singletonFactory	AbstractAutowireCapableBeanFactory$2  (id=2692)	

		synchronized (this.singletonObjects) {
			if (!this.singletonObjects.containsKey(beanName)) {
				this.singletonFactories.put(beanName, singletonFactory);
				this.earlySingletonObjects.remove(beanName);
				this.registeredSingletons.add(beanName);
			}
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 537	
		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
/ SET PROPERTIES IN BEAN
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1142	
		PropertyValues pvs = mbd.getPropertyValues();
pvs	MutablePropertyValues  (id=2476)	
	converted	false	
	processedProperties	null	
	propertyValueList	ArrayList<E>  (id=2709)	
[]
		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
		// state of the bean before properties are set. This can be used, for example,
		// to support styles of field injection.
		boolean continueWithPropertyPopulation = true;
		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
/n
		if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
/n
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
f
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);
f
		applyPropertyValues(beanName, mbd, bw, pvs);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyPropertyValues(String, BeanDefinition, BeanWrapper, PropertyValues) line: 1410	
		if (pvs == null || pvs.isEmpty()) {
			return;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 539	
			populateBean(beanName, mbd, instanceWrapper);
/d
			if (exposedObject != null) {
/j
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1541	
		else {
			invokeAwareMethods(beanName, bean);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).invokeAwareMethods(String, Object) line: 1573	
beanName=org.springframework.context.annotation.internalAutowiredAnnotationProcessor

		if (bean instanceof Aware) {
			if (bean instanceof BeanNameAware) {
/n
			if (bean instanceof BeanClassLoaderAware) {
/n
			if (bean instanceof BeanFactoryAware) {
/j
				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1546	
			invokeAwareMethods(beanName, bean);
/d
		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	

		Object result = existingBean;

		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
[org.springframework.context.support.ApplicationContextAwareProcessor@7bedc48a, 
org.springframework.context.support.PostProcessorRegistrationDelegate$BeanPostProcessorChecker@43c1b556]

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
/**
 * {@link org.springframework.beans.factory.config.BeanPostProcessor}
 * implementation that passes the ApplicationContext to beans that
 * implement the {@link EnvironmentAware}, {@link EmbeddedValueResolverAware},
 * {@link ResourceLoaderAware}, {@link ApplicationEventPublisherAware},
 * {@link MessageSourceAware} and/or {@link ApplicationContextAware} interfaces.
 *
 * <p>Implemented interfaces are satisfied in order of their mention above.
 *
 * <p>Application contexts will automatically register this with their
 * underlying bean factory. Applications do not use this directly.
 *
ApplicationContextAwareProcessor.postProcessBeforeInitialization(Object, String) line: 94	
		else {
			invokeAwareInterfaces(bean);
/s
ApplicationContextAwareProcessor.invokeAwareInterfaces(Object) line: 101	
		if (bean instanceof Aware) {
			if (bean instanceof EnvironmentAware) {
/n
				((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
/n
			}
			if (bean instanceof EmbeddedValueResolverAware) {
/n
				((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(
						new EmbeddedValueResolver(this.applicationContext.getBeanFactory()));
/n
			}
			if (bean instanceof ResourceLoaderAware) {
/n
				((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
/n
			}
			if (bean instanceof ApplicationEventPublisherAware) {
/n
				((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
/n
			}
			if (bean instanceof MessageSourceAware) {
/n
				((MessageSourceAware) bean).setMessageSource(this.applicationContext);
/n
			}
			if (bean instanceof ApplicationContextAware) {
/n
				((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
/n
			}
/t
ApplicationContextAwareProcessor.postProcessBeforeInitialization(Object, String) line: 97	
		else {
			invokeAwareInterfaces(bean);
/d
		return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 408	
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgend	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=2122)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
				return bean;
/t
		return result;
/ Herinner: Object result = existingBean;
org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@37ceb1df
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1550	
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/d
		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).invokeInitMethods(String, Object, RootBeanDefinition) line: 1594	
		boolean isInitializingBean = (bean instanceof InitializingBean);
f
		if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
/n
		if (mbd != null) {
			String initMethodName = mbd.getInitMethodName();
null
			if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
					!mbd.isExternallyManagedInitMethod(initMethodName)) {
/n
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1559	
		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
/d
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
/ NIETS
		return wrappedBean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 539	
		try {
			populateBean(beanName, mbd, instanceWrapper);
			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/d
		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
/n
		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
/ TODO niets bij ons	,
		return exposedObject;
/d
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 476	
		Object beanInstance = doCreateBean(beanName, mbd, args);
/d
		return beanInstance;
/t
AbstractBeanFactory$1.getObject() line: 302	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);			<-
/d
/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 239	
				try {
					singletonObject = singletonFactory.getObject();
/d
singletonObject	AutowiredAnnotationBeanPostProcessor  (id=2532)	

				addSingleton(beanName, singletonObject);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).addSingleton(String, Object) line: 143	
		synchronized (this.singletonObjects) {
			this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 246	
				addSingleton(beanName, singletonObject);
/d
			return (singletonObject != NULL_OBJECT ? singletonObject : null);
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 313	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {			<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/d
sharedInstance	AutowiredAnnotationBeanPostProcessor  (id=2532)		/ shared, want singleton	,

					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
/s
	/**
	 * Get the object for the given bean instance, either the bean
	 * instance itself or its created object in case of a FactoryBean.
	 */
DefaultListableBeanFactory(AbstractBeanFactory).getObjectForBeanInstance(Object, String, String, RootBeanDefinition) line: 1489	
/=
	protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) {


/ geef	, 
spring reference factorybean ampersand
/ Lees	, 
https://spring.io/blog/2011/08/09/what-s-a-factorybean
http://stackoverflow.com/questions/1655140/spring-getting-factorybean-object-instead-of-factorybean-getobject
http://stackoverflow.com/questions/3441438/how-to-inject-factorybean-instead-of-object-it-produces
http://stackoverflow.com/questions/5541094/factorybeans-and-the-annotation-based-configuration-in-spring-3-0

		// Now we have the bean instance, which may be a normal bean or a FactoryBean.
		// If it's a FactoryBean, we use it to create a bean instance, unless the
		// caller actually wants a reference to the factory.
		if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
			return beanInstance;
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 365	
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
/d
bean	AutowiredAnnotationBeanPostProcessor  (id=2532)	

		return (T) bean;
/t
DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class<T>) line: 198	
/=
	public <T> T getBean(String name, Class<T> requiredType) throws BeansException {		/ TODO <T> T

		return doGetBean(name, requiredType, null, false);
/d
PostProcessorRegistrationDelegate.registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext) line: 199	
		for (String ppName : postProcessorNames) {
postProcessorNames	String[5]  (id=2094)	
	[0]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
	[1]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=270)	
	[2]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=280)	
	[3]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=281)	
	[4]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=282)	
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
/d
pp	AutowiredAnnotationBeanPostProcessor  (id=2532)	

				priorityOrderedPostProcessors.add(pp);
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);

/ volgende	,
		for (String ppName : postProcessorNames) {
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor
org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				priorityOrderedPostProcessors.add(pp);
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);

priorityOrderedPostProcessors	ArrayList<E>  (id=2127)	
	[0]	AutowiredAnnotationBeanPostProcessor  (id=2532)	
	[1]	RequiredAnnotationBeanPostProcessor  (id=2787)	
	[2]	CommonAnnotationBeanPostProcessor  (id=2788)	
	[3]	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=2789)	
	[4]	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	
internalPostProcessors	ArrayList<E>  (id=2128)	
	[0]	AutowiredAnnotationBeanPostProcessor  (id=2532)	
	[1]	RequiredAnnotationBeanPostProcessor  (id=2787)	
	[2]	CommonAnnotationBeanPostProcessor  (id=2788)	

		// First, register the BeanPostProcessors that implement PriorityOrdered.
		OrderComparator.sort(priorityOrderedPostProcessors);
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
/s
PostProcessorRegistrationDelegate.registerBeanPostProcessors(ConfigurableListableBeanFactory, List<BeanPostProcessor>) line: 276	
		for (BeanPostProcessor postProcessor : postProcessors) {
			beanFactory.addBeanPostProcessor(postProcessor);
/s
DefaultListableBeanFactory(AbstractBeanFactory).addBeanPostProcessor(BeanPostProcessor) line: 807	
/=
	public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {

this	DefaultListableBeanFactory  (id=44)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=450)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2923)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=280)	
			value	RootBeanDefinition  (id=2965)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2924)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=282)	
			value	RootBeanDefinition  (id=2967)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=2925)	
			key	"rescueDamselQuest" (id=205)	
			value	ScannedGenericBeanDefinition  (id=2986)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=2926)	
			key	"slayDragonQuest" (id=220)	
			value	ScannedGenericBeanDefinition  (id=2984)	
		[4]	ConcurrentHashMap$MapEntry<K,V>  (id=2927)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
			value	RootBeanDefinition  (id=2982)	
		[5]	ConcurrentHashMap$MapEntry<K,V>  (id=2928)	
			key	"fakeMainPrintStream" (id=225)	
			value	ScannedGenericBeanDefinition  (id=2980)	
		[6]	ConcurrentHashMap$MapEntry<K,V>  (id=2930)	
			key	"braveKnight" (id=215)	
			value	ScannedGenericBeanDefinition  (id=2978)	
		[7]	ConcurrentHashMap$MapEntry<K,V>  (id=2931)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=270)	
			value	RootBeanDefinition  (id=2976)	
		[8]	ConcurrentHashMap$MapEntry<K,V>  (id=2933)	
			key	"damselRescuingKnight" (id=210)	
			value	ScannedGenericBeanDefinition  (id=2974)	
		[9]	ConcurrentHashMap$MapEntry<K,V>  (id=2935)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
			value	RootBeanDefinition  (id=2205)	
		[10]	ConcurrentHashMap$MapEntry<K,V>  (id=2937)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=281)	
			value	RootBeanDefinition  (id=2971)	
		[11]	ConcurrentHashMap$MapEntry<K,V>  (id=2939)	
			key	"knightMainConfig" (id=163)	
			value	AnnotatedGenericBeanDefinition  (id=164)	

/ voor de calls	,
	beanPostProcessors	ArrayList<E>  (id=457)	
		[0]	ApplicationContextAwareProcessor  (id=2107)	
		[1]	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=2122)	

/ hier zit knightMainConfig NIET bij	,
	singletonObjects	ConcurrentHashMap<K,V>  (id=40)
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=3011)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=280)	
			value	CommonAnnotationBeanPostProcessor  (id=2788)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=3012)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=282)	
			value	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=3013)	
			key	"systemProperties" (id=1716)	
			value	Properties  (id=2300)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=3014)	
			key	"systemEnvironment" (id=1718)	
			value	Collections$UnmodifiableMap<K,V>  (id=2304)	
		[4]	ConcurrentHashMap$MapEntry<K,V>  (id=3016)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
			value	ConfigurationClassPostProcessor  (id=50)	
		[5]	ConcurrentHashMap$MapEntry<K,V>  (id=3017)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=270)	
			value	RequiredAnnotationBeanPostProcessor  (id=2787)	
		[6]	ConcurrentHashMap$MapEntry<K,V>  (id=3018)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
			value	AutowiredAnnotationBeanPostProcessor  (id=2532)	
		[7]	ConcurrentHashMap$MapEntry<K,V>  (id=3020)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry" (id=243)	
			value	ConfigurationClassParser$ImportStack  (id=149)	
		[8]	ConcurrentHashMap$MapEntry<K,V>  (id=3021)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=281)	
			value	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=2789)	
		[9]	ConcurrentHashMap$MapEntry<K,V>  (id=3023)	
			key	"environment" (id=1715)	
			value	StandardEnvironment  (id=145)	

beanPostProcessor	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=2789)	
beanPostProcessor	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	
beanPostProcessor	CommonAnnotationBeanPostProcessor  (id=2788)	
beanPostProcessor	AutowiredAnnotationBeanPostProcessor  (id=2532)	
beanPostProcessor	RequiredAnnotationBeanPostProcessor  (id=2787)	

		this.beanPostProcessors.remove(beanPostProcessor);
		this.beanPostProcessors.add(beanPostProcessor);
/ TODO
		if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
/n
/j voor ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor
/j voor org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@7530ad9c
/j voor AutowiredAnnotationBeanPostProcessor 
/j voor RequiredAnnotationBeanPostProcessor
			this.hasInstantiationAwareBeanPostProcessors = true;
		]
		if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
/n
/j voor org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@7530ad9c
			this.hasDestructionAwareBeanPostProcessors = true;
/t
PostProcessorRegistrationDelegate.registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext) line: 226	

		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
/d
beanFactory	DefaultListableBeanFactory  (id=44)	
		[0]	ApplicationContextAwareProcessor  (id=2107)	
		[1]	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=2122)	
		[2]	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=2789)	
		[3]	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	
		[4]	CommonAnnotationBeanPostProcessor  (id=2788)	
		[5]	AutowiredAnnotationBeanPostProcessor  (id=2532)	
		[6]	RequiredAnnotationBeanPostProcessor  (id=2787)	

		// Next, register the BeanPostProcessors that implement Ordered.
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();
		for (String ppName : orderedPostProcessorNames) {
/n
		OrderComparator.sort(orderedPostProcessors);
[]
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);
/ niets	,

		// Now, register all regular BeanPostProcessors.
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();
[]
		for (String ppName : nonOrderedPostProcessorNames) {
/n
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);
/ niets	,

		// Finally, re-register all internal BeanPostProcessors.
		OrderComparator.sort(internalPostProcessors);
		registerBeanPostProcessors(beanFactory, internalPostProcessors);
beanFactory	DefaultListableBeanFactory  (id=44)	
internalPostProcessors	ArrayList<E>  (id=2128)	
	[0]	CommonAnnotationBeanPostProcessor  (id=2788)	
	[1]	AutowiredAnnotationBeanPostProcessor  (id=2532)	
	[2]	RequiredAnnotationBeanPostProcessor  (id=2787)	
/ zijn er al	, 

		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
/ erbij	, 

beanFactory	DefaultListableBeanFactory  (id=44)	
	beanPostProcessors	ArrayList<E>  (id=457)	
		[0]	ApplicationContextAwareProcessor  (id=2107)	
		[1]	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=2122)	
		[2]	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=2789)	
		[3]	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	
		[4]	CommonAnnotationBeanPostProcessor  (id=2788)	
		[5]	AutowiredAnnotationBeanPostProcessor  (id=2532)	
		[6]	RequiredAnnotationBeanPostProcessor  (id=2787)	
		[7]	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=3378)	

/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 470	
				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);
/d
				// Initialize message source for this context.
				initMessageSource();
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).initMessageSource() line: 646	
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
/n
		else {
			// Use empty MessageSource to be able to accept getMessage calls.
			DelegatingMessageSource dms = new DelegatingMessageSource();
/s
/**
 * Empty {@link MessageSource} that delegates all calls to the parent MessageSource.
 * If no parent is available, it simply won't resolve any message.
 *
 * <p>Used as placeholder by AbstractApplicationContext, if the context doesn't
 * define its own MessageSource. Not intended for direct use in applications.
 *
DelegatingMessageSource.<init>() line: 37	
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).initMessageSource() line: 646	
			DelegatingMessageSource dms = new DelegatingMessageSource();
/d
			dms.setParentMessageSource(getInternalParentMessageSource());
null
			this.messageSource = dms;
			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 473	
				// Initialize message source for this context.
				initMessageSource();
/d
				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).initApplicationEventMulticaster() line: 672	
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
/n
		else {
			this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
/s
/**
 * Simple implementation of the {@link ApplicationEventMulticaster} interface.
 *
 * <p>Multicasts all events to all registered listeners, leaving it up to
 * the listeners to ignore events that they are not interested in.
 * Listeners will usually perform corresponding {@code instanceof}
 * checks on the passed-in event object.
 *
 * <p>By default, all listeners are invoked in the calling thread.
 * This allows the danger of a rogue listener blocking the entire application,
 * but adds minimal overhead. Specify an alternative TaskExecutor to have
 * listeners executed in different threads, for example from a thread pool.
 *
SimpleApplicationEventMulticaster.<init>(BeanFactory) line: 56	
		setBeanFactory(beanFactory);
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).initApplicationEventMulticaster() line: 673	
			this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 476	
				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();
/d
				// Initialize other special beans in specific context subclasses.
				onRefresh();
/s
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext, DisposableBean {
	/**
	 * Template method which can be overridden to add context-specific refresh work.
	 * Called on initialization of special beans, before instantiation of singletons.
	 * <p>This implementation is empty.
	 * @throws BeansException in case of errors
	 * @see #refresh()
	 */
	protected void onRefresh() throws BeansException {
		// For subclasses: do nothing by default.
	}
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 479	
				// Initialize other special beans in specific context subclasses.
				onRefresh();
/d
				// Check for listener beans and register them.
				registerListeners();
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).registerListeners() line: 731	
		// Register statically specified listeners first.
		for (ApplicationListener<?> listener : getApplicationListeners()) {
/n
		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let post-processors apply to them!
/ TODO
		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
[]
		for (String lisName : listenerBeanNames) {
/n
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 482	
				// Check for listener beans and register them.
				registerListeners();
d/
				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 743	
		// Initialize conversion service for this context.
		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
/n
		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
		for (String weaverAwareName : weaverAwareNames) {
/n
		// Stop using the temporary ClassLoader for type matching.
		beanFactory.setTempClassLoader(null);

		// Allow for caching all bean definition metadata, not expecting further changes.
		beanFactory.freezeConfiguration();
/s
DefaultListableBeanFactory.freezeConfiguration() line: 651	
 		this.configurationFrozen = true;
		synchronized (this.beanDefinitionMap) {
			this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);
/ this.beanDefinitionNames is an Array<String>
/ this.frozenBeanDefinitionNames is a String[]	, 
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
		// Allow for caching all bean definition metadata, not expecting further changes.
		beanFactory.freezeConfiguration();
/d
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/s
DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
		List<String> beanNames;
		synchronized (this.beanDefinitionMap) {
			// Iterate over a copy to allow for init methods which in turn register new bean definitions.
			// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
			beanNames = new ArrayList<String>(this.beanDefinitionNames);
		}

		// Trigger initialization of all non-lazy singleton beans...
		for (String beanName : beanNames) {
beanNames	ArrayList<E>  (id=3514)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=268)	
	[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	
	[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=270)	
	[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=280)	
	[4]	"knightMainConfig" (id=163)	
	[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=281)	
	[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=282)	
	[7]	"rescueDamselQuest" (id=205)	
	[8]	"damselRescuingKnight" (id=210)	
	[9]	"braveKnight" (id=215)	
	[10]	"slayDragonQuest" (id=220)	
	[11]	"fakeMainPrintStream" (id=225)	

beanName	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=269)	

			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
/j
				if (isFactoryBean(beanName)) {
/n
				else {
					getBean(beanName);
/s
DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
		return doGetBean(name, null, null, false);
/s
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 250	
		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null && args == null) {
/j
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
/s
DefaultListableBeanFactory(AbstractBeanFactory).getObjectForBeanInstance(Object, String, String, RootBeanDefinition) line: 1497	
		// Don't let calling code try to dereference the factory if the bean isn't a factory.
		if (BeanFactoryUtils.isFactoryDereference(name) && !(beanInstance instanceof FactoryBean)) {
/n
		// Now we have the bean instance, which may be a normal bean or a FactoryBean.
		// If it's a FactoryBean, we use it to create a bean instance, unless the
		// caller actually wants a reference to the factory.
		if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
/j
			return beanInstance;
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 377	
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
/d
		return (T) bean;
/t
DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
				else {
					getBean(beanName);
/d
/ volgende,
/ de volgenden lopen net zo	, 
/ todat
		for (String beanName : beanNames) {
beanName	"knightMainConfig" (id=163)	

			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
/n
				else {
					getBean(beanName);
/s
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 240	
beanName	"knightMainConfig" (id=163)	

		Object sharedInstance = getSingleton(beanName);
/null
		if (sharedInstance != null && args == null) {
/n
/ zonet kwamen we hier	,  nu niet	, 
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
/n
			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);	 /die was er al	,
mbd	RootBeanDefinition  (id=3535)	
	beanClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$38f73d6a) (id=1997)	
				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {	<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 210	

/ we hebben eerder in beanDefinitions de enhanched class class sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$38f73d6a created	, maar nog geen inst in singletonObjects	, 

				try {
					singletonObject = singletonFactory.getObject();
/s
AbstractBeanFactory$1.getObject() line: 302	
/=
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {	 <- zonet	,
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);					<- nu hier	,
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 448	
		// Make sure bean class is actually resolved at this point.
		resolveBeanClass(mbd, beanName);
/ de class met deze beanName zit is beanDefinitions	,

		// Prepare method overrides.
		try {
			mbd.prepareMethodOverrides();
[]
		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			Object bean = resolveBeforeInstantiation(beanName, mbd);
/s
	/**
	 * Apply before-instantiation post-processors, resolving whether there is a
	 * before-instantiation shortcut for the specified bean.
	 */
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).resolveBeforeInstantiation(String, RootBeanDefinition) line: 931	
/=
	protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {

		if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
/j
			// Make sure bean class is actually resolved at this point.
			if (mbd.hasBeanClass() && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
/j
				bean = applyBeanPostProcessorsBeforeInstantiation(mbd.getBeanClass(), beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInstantiation(Class<?>, String) line: 956	
		for (BeanPostProcessor bp : getBeanPostProcessors()) {

getBeanPostProcessors()
	elementData	Object[10]  (id=2110)	
		[0]	ApplicationContextAwareProcessor  (id=2107)	
		[1]	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=2122)	
		[2]	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=2789)	
		[3]	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	
		[4]	CommonAnnotationBeanPostProcessor  (id=2788)	
		[5]	AutowiredAnnotationBeanPostProcessor  (id=2532)	
		[6]	RequiredAnnotationBeanPostProcessor  (id=2787)	
		[7]	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=3378)	
	size	8	

			if (bp instanceof InstantiationAwareBeanPostProcessor) {
/j
bp	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	

				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
/s
					return null;

/ volgende,	
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
/j
bp	CommonAnnotationBeanPostProcessor  (id=2788)	

				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
/s
					return null;

/ volgende,	
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
/j
bp	AutowiredAnnotationBeanPostProcessor  (id=2532)	

				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
/s
					return null;
/ volgende,	
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
/j
bp	RequiredAnnotationBeanPostProcessor  (id=2787)	

				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
/s
					return null;
/ Geen volgende	, 
		return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).resolveBeforeInstantiation(String, RootBeanDefinition) line: 936	
				bean = applyBeanPostProcessorsBeforeInstantiation(mbd.getBeanClass(), beanName);
/d
				if (bean != null) {
/n
					bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
/n
				}
			}
			mbd.beforeInstantiationResolved = (bean != null);
		return bean;
null
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 466	
		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			Object bean = resolveBeforeInstantiation(beanName, mbd);
null
			if (bean != null) {
/n
				return bean;
/n
		Object beanInstance = doCreateBean(beanName, mbd, args);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 499	
		if (mbd.isSingleton()) {
/j
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 982	
		Class<?> beanClass = resolveBeanClass(mbd, beanName);
beanClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$38f73d6a) (id=1997)	

		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
/ @AUTOWIRED ON CTOR
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1041	
		if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
bp	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=2790)	

					Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
/s
ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).determineCandidateConstructors(Class<?>, String) line: 49	
		return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1042	
					Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
null
					if (ctors != null) {
/n
						return ctors;
/n
/ volgende	, 
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
bp	AutowiredAnnotationBeanPostProcessor  (id=1425)	

					Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
/s
AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(Class<?>, String) line: 229	
		// Quick check on the concurrent map first, with minimal locking.
		Constructor<?>[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);
		if (candidateConstructors == null) {
			synchronized (this.candidateConstructorsCache) {
				candidateConstructors = this.candidateConstructorsCache.get(beanClass);
null
				if (candidateConstructors == null) {
					Constructor<?>[] rawCandidates = beanClass.getDeclaredConstructors();
[public sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28()]
					List<Constructor<?>> candidates = new ArrayList<Constructor<?>>(rawCandidates.length);
					Constructor<?> requiredConstructor = null;
					Constructor<?> defaultConstructor = null;
					for (Constructor<?> candidate : rawCandidates) {
						AnnotationAttributes annotation = findAutowiredAnnotation(candidate);
/s
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject) line: 382	
/ WHERE @AUTOWIRED
this	AutowiredAnnotationBeanPostProcessor  (id=1425)	
	autowiredAnnotationTypes	LinkedHashSet<E>  (id=1452)	
		[0]	Class<T> (org.springframework.beans.factory.annotation.Autowired) (id=239)	
		[1]	Class<T> (org.springframework.beans.factory.annotation.Value) (id=1459)	

		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String) line: 85	
/=
	public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element, String annotationType) {
element	Constructor<T>  (id=1433)	
annotationType	"org.springframework.beans.factory.annotation.Autowired" (id=1487)	

		return getAnnotationAttributes(element, annotationType, false, false);
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 91	
/=
		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {		<-
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				...
			@Override
			public void postProcess(Annotation annotation, AnnotationAttributes result) {
				...
/s
AnnotatedElementUtils.process(AnnotatedElement, String, boolean, Processor<T>) line: 162	
		try {
			return doProcess(element, annotationType, traverseClassHierarchy, processor,
					new HashSet<AnnotatedElement>(), 0);
/s
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 190	
		if (visited.add(element)) {
			Annotation[] annotations =
					(traverseClassHierarchy ? element.getDeclaredAnnotations() : element.getAnnotations());
/ [], element	Constructor<T>  (id=1433)	

		return null;
/t
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject) line: 384	
		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
/d
null
/ volgende	, 
/ maar @Value is er ook niet	, 
	return null;
/t
AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(Class<?>, String) line: 240	
					for (Constructor<?> candidate : rawCandidates) {
						AnnotationAttributes annotation = findAutowiredAnnotation(candidate);
null
						if (annotation != null) {
/n
						else if (candidate.getParameterTypes().length == 0) {
							defaultConstructor = candidate;
public sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28()
/ maar doet niets mee	,

/ volgende	, 
					for (Constructor<?> candidate : rawCandidates) {
/ is er niet	,

					if (!candidates.isEmpty()) {
/n
					else {
						candidateConstructors = new Constructor<?>[0];

					this.candidateConstructorsCache.put(beanClass, candidateConstructors);

		return (candidateConstructors.length > 0 ? candidateConstructors : null);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1042	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	AutowiredAnnotationBeanPostProcessor  (id=1425)	

				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
					SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
					Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
null

/ volgende	, 
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	RequiredAnnotationBeanPostProcessor  (id=1520)	

					SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
					Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
RequiredAnnotationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).determineCandidateConstructors(Class<?>, String) line: 49	
		return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1042	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
/n
/ volgende is er niet	, 

		return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1015	
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
null
beanClass=class sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28
/ TODO Er is een ctor, 	maar zonder @'s?

		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
/n
			return autowireConstructor(beanName, mbd, ctors, args);
/n
		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1060	
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/s
CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory) line: 61	
						else {
							constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);
public sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28()

						beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;
			return BeanUtils.instantiateClass(constructorToUse);
/s
BeanUtils.instantiateClass(Constructor<T>, Object...) line: 148	
			ReflectionUtils.makeAccessible(ctor);
			return ctor.newInstance(args);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1072	
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
/d
			}
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
			initBeanWrapper(bw);
/s
	/**
	 * Initialize the given BeanWrapper with the custom editors registered
	 * with this factory. To be called for BeanWrappers that will create
	 * and populate bean instances.
	 */
DefaultListableBeanFactory(AbstractBeanFactory).initBeanWrapper(BeanWrapper) line: 1092	
		bw.setConversionService(getConversionService());
		registerCustomEditors(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).registerCustomEditors(PropertyEditorRegistry) line: 1113	
		PropertyEditorRegistrySupport registrySupport =
				(registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);
		if (registrySupport != null) {
			registrySupport.useConfigValueEditors();
		}
		if (!this.propertyEditorRegistrars.isEmpty()) {
			for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) {
				try {
					registrar.registerCustomEditors(registry);
/s
ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 114	
		ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
		doRegisterEditor(registry, Resource.class, baseEditor);
		doRegisterEditor(registry, ContextResource.class, baseEditor);
		doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
		doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
		doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
		doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

		ClassLoader classLoader = this.resourceLoader.getClassLoader();
		doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
		doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
		doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

		if (this.resourceLoader instanceof ResourcePatternResolver) {
			doRegisterEditor(registry, Resource[].class,
					new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
		}
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateBean(String, RootBeanDefinition) line: 1074	
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
			initBeanWrapper(bw);
/d
			return bw;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 506	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/d
		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 906	
		try {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {

"getBeanPostProcessors()"	 (pending)	
	elementData	Object[10]  (id=1545)	
		[0]	ApplicationContextAwareProcessor  (id=1546)	
		[1]	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=1547)	
		[2]	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=1548)	
		[3]	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=1549)	
		[4]	CommonAnnotationBeanPostProcessor  (id=1550)	
		[5]	AutowiredAnnotationBeanPostProcessor  (id=1425)	
		[6]	RequiredAnnotationBeanPostProcessor  (id=1520)	
		[7]	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=1551)	
	size	8	

				if (bp instanceof MergedBeanDefinitionPostProcessor) {
org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@65d09a04

					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 282	
		super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
/s
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 124	
		if (beanType != null) {
			LifecycleMetadata metadata = findLifecycleMetadata(beanType);
/s
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).findLifecycleMetadata(Class<?>) line: 181	
		// Quick check on the concurrent map first, with minimal locking.
		LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz);
		if (metadata == null) {
			synchronized (this.lifecycleMetadataCache) {
				metadata = this.lifecycleMetadataCache.get(clazz);
				if (metadata == null) {
					metadata = buildLifecycleMetadata(clazz);
clazz	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=113)	
/s
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).buildLifecycleMetadata(Class<?>) line: 191	
/ @POSTCONSTRUCT @PREDESTROY
		final boolean debug = logger.isDebugEnabled();
f
/ TODO LOGGER IN ORDE MAKEN

		do {
			for (Method method : targetClass.getDeclaredMethods()) {
"targetClass.get...claredMethods()"	 (pending)	
	[0]	Method  (id=1602)	
public final void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.setBeanFactory(org.springframework.beans.factory.BeanFactory) throws org.springframework.beans.BeansException
	[1]	Method  (id=1603)	
private static final void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$BIND_CALLBACKS(java.lang.Object)
	[2]	Method  (id=1604)	
final void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$setBeanFactory$6(org.springframework.beans.factory.BeanFactory) throws org.springframework.beans.BeansException
	[3]	Method  (id=1605)	
final void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$destroy$5() throws java.lang.Exception
	[4]	Method  (id=1606)	
static void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$STATICHOOK1()
	[5]	Method  (id=1611)	
static void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$STATICHOOK2()
	[6]	Method  (id=1612)	
public static org.springframework.cglib.proxy.MethodProxy sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$findMethodProxy(org.springframework.cglib.core.Signature)
	[7]	Method  (id=1613)	
public static void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$SET_THREAD_CALLBACKS(org.springframework.cglib.proxy.Callback[])
	[8]	Method  (id=1614)	
public static void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$SET_STATIC_CALLBACKS(org.springframework.cglib.proxy.Callback[])
	[9]	Method  (id=1615)	
public final void sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.destroy() throws java.lang.Exception

this	CommonAnnotationBeanPostProcessor  (id=1550)	
	initAnnotationType	Class<T> (javax.annotation.PostConstruct) (id=1568)	
	destroyAnnotationType	Class<T> (javax.annotation.PreDestroy) (id=1570)	

				if (this.initAnnotationType != null) {
					if (method.getAnnotation(this.initAnnotationType) != null) {
/n
				if (this.destroyAnnotationType != null) {
					if (method.getAnnotation(this.destroyAnnotationType) != null) {
/n

			initMethods.addAll(0, currInitMethods);
[]
			destroyMethods.addAll(currDestroyMethods);
[]
			targetClass = targetClass.getSuperclass();
targetClass	Class<T> (sia.knights.KnightMainConfig) (id=560)	
		while (targetClass != null && targetClass != Object.class);
/ we geloven het	, 
		return new LifecycleMetadata(clazz, initMethods, destroyMethods);
initMethods	LinkedList<E>  (id=1660)	
[]
destroyMethods	LinkedList<E>  (id=1661)	
[]
/t
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).findLifecycleMetadata(Class<?>) line: 182	
					metadata = buildLifecycleMetadata(clazz);
/d
					this.lifecycleMetadataCache.put(clazz, metadata);
clazz=class sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28
				}
				return metadata;
/t
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 125	
			LifecycleMetadata metadata = findLifecycleMetadata(beanType);
			metadata.checkConfigMembers(beanDefinition);
/ NIETS
/t
CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 284	
		super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
/d
		if (beanType != null) {
			InjectionMetadata metadata = findResourceMetadata(beanName, beanType);
/s
CommonAnnotationBeanPostProcessor.findResourceMetadata(String, Class<?>) line: 327	
/ @WEBSERVICEREF @EJBREF @RESOURCE 
		// Quick check on the concurrent map first, with minimal locking.
		// Fall back to class name as cache key, for backwards compatibility with custom callers.
		String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
knightMainConfig
		InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
		if (InjectionMetadata.needsRefresh(metadata, clazz)) {
			synchronized (this.injectionMetadataCache) {
				metadata = this.injectionMetadataCache.get(cacheKey);
null
				if (InjectionMetadata.needsRefresh(metadata, clazz)) {
/j, omdat metadata==null
					LinkedList<InjectionMetadata.InjectedElement> elements = new LinkedList<InjectionMetadata.InjectedElement>();
					Class<?> targetClass = clazz;

					do {
						LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<InjectionMetadata.InjectedElement>();
						for (Field field : targetClass.getDeclaredFields()) {

"targetClass.get...eclaredFields()"	 (pending)	
	[0]	Field  (id=1876)	
private boolean sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$BOUND
	[1]	Field  (id=1877)	
private static final java.lang.ThreadLocal sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$THREAD_CALLBACKS
	[2]	Field  (id=1878)	
private static final org.springframework.cglib.proxy.Callback[] sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$STATIC_CALLBACKS
	[3]	Field  (id=1879)	
private org.springframework.cglib.proxy.MethodInterceptor sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$CALLBACK_0
	[4]	Field  (id=1880)	
private org.springframework.cglib.proxy.MethodInterceptor sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$CALLBACK_1
	[5]	Field  (id=1881)	
private org.springframework.cglib.proxy.MethodInterceptor sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$CALLBACK_2
	[6]	Field  (id=1882)	
private org.springframework.cglib.proxy.NoOp sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$CALLBACK_3
	[7]	Field  (id=1883)	
private static final java.lang.reflect.Method sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$destroy$5$Method
	[8]	Field  (id=1884)	
private static final org.springframework.cglib.proxy.MethodProxy sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$destroy$5$Proxy
	[9]	Field  (id=1885)	
private static final java.lang.Object[] sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$emptyArgs
	[10]	Field  (id=1886)	
private static final java.lang.reflect.Method sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$setBeanFactory$6$Method
	[11]	Field  (id=1887)	
private static final org.springframework.cglib.proxy.MethodProxy sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.CGLIB$setBeanFactory$6$Proxy
	[12]	Field  (id=1888)	
public org.springframework.beans.factory.BeanFactory sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.$$beanFactory

							if (webServiceRefClass != null && field.isAnnotationPresent(webServiceRefClass)) {
interface javax.xml.ws.WebServiceRef

							else if (ejbRefClass != null && field.isAnnotationPresent(ejbRefClass)) {
/n
ejbRefClass==null
/ TODO

							else if (field.isAnnotationPresent(Resource.class)) {
/n

						for (Method method : targetClass.getDeclaredMethods()) {
							method = BridgeMethodResolver.findBridgedMethod(method);
							Method mostSpecificMethod = BridgeMethodResolver.findBridgedMethod(ClassUtils.getMostSpecificMethod(method, clazz));
							if (method.equals(mostSpecificMethod)) {
								if (webServiceRefClass != null && method.isAnnotationPresent(webServiceRefClass)) {
/n
								else if (ejbRefClass != null && method.isAnnotationPresent(ejbRefClass)) {
/n
								else if (method.isAnnotationPresent(Resource.class)) {
/n

						elements.addAll(0, currElements);
[]
						targetClass = targetClass.getSuperclass();
					}
					while (targetClass != null && targetClass != Object.class);

					metadata = new InjectionMetadata(clazz, elements);
clazz	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=113)	
elements	LinkedList<E>  (id=1932)	
[]
					this.injectionMetadataCache.put(cacheKey, metadata);
cacheKey	"knightMainConfig" (id=1424)	

		return metadata;
metadata	InjectionMetadata  (id=1943)	
	checkedElements	null	
	injectedElements	LinkedList<E>  (id=1932)	
[]
	logger	Log4JLogger  (id=1946)	
	targetClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=113)	
/t
CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 285	
			InjectionMetadata metadata = findResourceMetadata(beanName, beanType);
/d
			metadata.checkConfigMembers(beanDefinition);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 906	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/d
/ volgende	, 
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	AutowiredAnnotationBeanPostProcessor  (id=1425)	
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 220	
		if (beanType != null) {
			InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType);
/ FIND @AUTOWIRED
/s
AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata(String, Class<?>) line: 319	
		InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
null
cacheKey="knightMainConfig"
		if (InjectionMetadata.needsRefresh(metadata, clazz)) {
			synchronized (this.injectionMetadataCache) {
				metadata = this.injectionMetadataCache.get(cacheKey);
null
				if (InjectionMetadata.needsRefresh(metadata, clazz)) {
/j
					metadata = buildAutowiringMetadata(clazz);
/s
AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(Class<?>) line: 334	
		do {
			LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<InjectionMetadata.InjectedElement>();
			for (Field field : targetClass.getDeclaredFields()) {
				AnnotationAttributes annotation = findAutowiredAnnotation(field);
/s
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject) line: 382	

		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
[interface org.springframework.beans.factory.annotation.Autowired, 
interface org.springframework.beans.factory.annotation.Value]
			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String) line: 85	
		return getAnnotationAttributes(element, annotationType, false, false);
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 91	
		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {		<-
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				...
			@Override
			public void postProcess(Annotation annotation, AnnotationAttributes result) {
				...
/s
AnnotatedElementUtils.process(AnnotatedElement, String, boolean, Processor<T>) line: 162	
			return doProcess(element, annotationType, traverseClassHierarchy, processor,
					new HashSet<AnnotatedElement>(), 0);
/s
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 190	
			Annotation[] annotations =
					(traverseClassHierarchy ? element.getDeclaredAnnotations() : element.getAnnotations());
[]
			for (Annotation annotation : annotations) {
/n
				if (annotation.annotationType().getName().equals(annotationType) || metaDepth > 0) {
/n
/ annotationType=Autowired of Value	,

			for (Annotation annotation : annotations) {
[]
 					if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation)) {
/= niet in java.lang.annotation pkg	,

			if (traverseClassHierarchy && element instanceof Class) {
/n
traverseClassHierarchy==false

		return null;
/t
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject) line: 383	
		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
null
			if (annotation != null) {
/n
/ ook niet voor @Value	, 

		return null;
/t
AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(Class<?>) line: 341	

		do {
			LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<InjectionMetadata.InjectedElement>();
			for (Field field : targetClass.getDeclaredFields()) {
				AnnotationAttributes annotation = findAutowiredAnnotation(field);
/d
null
/ voor alle fields null	, 

			for (Method method : targetClass.getDeclaredMethods()) {
				Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
				AnnotationAttributes annotation = BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod) ?  findAutowiredAnnotation(bridgedMethod) : findAutowiredAnnotation(method);
true
null
				if (annotation != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
/n

			elements.addAll(0, currElements);
[]
			targetClass = targetClass.getSuperclass();
		}
		while (targetClass != null && targetClass != Object.class);

		return new InjectionMetadata(clazz, elements);
elements=[]
/t
AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata(String, Class<?>) line: 326	
					metadata = buildAutowiringMetadata(clazz);
metadata	InjectionMetadata  (id=1976)	
	checkedElements	null	
	injectedElements	LinkedList<E>  (id=1975)	
[]
	logger	Log4JLogger  (id=1946)	
	targetClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=113)	

					this.injectionMetadataCache.put(cacheKey, metadata);
cacheKey	"knightMainConfig" (id=1424)	

				}
			}
		}
		return metadata;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 911	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/d
/ volgende	, 
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	RequiredAnnotationBeanPostProcessor  (id=1520)	
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
RequiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 140	
	}
/ method is leeg	, 
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 908	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	RequiredAnnotationBeanPostProcessor  (id=1520)	
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/d

/ Intermezzo

/ De PostProcessors check for @Autowired	, ...
/ De beans die worden onderzocht is bijv KnightMainConfig, maar NIET DamselRequestKnight	, 

/ stack
/s
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 908	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 512	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
	AbstractBeanFactory$1.getObject() line: 302	
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
	DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
		// Trigger initialization of all non-lazy singleton beans...
		for (String beanName : beanNames) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
mergedBeanDefinitions	ConcurrentHashMap<K,V>  (id=1993)	
	[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2031)	
org.springframework.context.annotation.internalCommonAnnotationProcessor=Root bean: ... 
	[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2032)	
org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor=Root bean: ... 
	[2]	ConcurrentHashMap$MapEntry<K,V>  (id=2033)	
org.springframework.context.annotation.internalConfigurationAnnotationProcessor=Root bean: ...
	[3]	ConcurrentHashMap$MapEntry<K,V>  (id=2034)	
org.springframework.context.annotation.internalRequiredAnnotationProcessor=Root bean: ... 
	[4]	ConcurrentHashMap$MapEntry<K,V>  (id=2035)	
org.springframework.context.annotation.internalAutowiredAnnotationProcessor=Root bean: ... 
	[5]	ConcurrentHashMap$MapEntry<K,V>  (id=2037)	
org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor=Root bean: ...
	[6]	ConcurrentHashMap$MapEntry<K,V>  (id=2038)	
knightMainConfig=Root bean: ... 
/ Dus NIET DamselRescuingKnight,  ... 
/ TODO
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
				else {
					getBean(beanName);
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 482	
				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	


/ Einde Intermezzo

/ volgende	,
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=1551)	

				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
PostProcessorRegistrationDelegate$ApplicationListenerDetector.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 338	
			if (beanDefinition.isSingleton()) {
				this.singletonNames.put(beanName, Boolean.TRUE);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 916	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/d
/ geen volgende meer	, 
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 513	
beanName=knightMainConfig

				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/d
				mbd.postProcessed = true;

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName));
true
		if (earlySingletonExposure) {
/j

			if (logger.isDebugEnabled()) {
				logger.debug("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}

/ Intermezzo

/ Lees	, 
http://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance

The guard statement (checking isDebugEnabled()) is there to prevent potentially expensive computation of the log message when it involves invocation of the toString() methods of various objects and concatenating the results.

In the given example, the log message is a constant string, so letting the logger discard it is just as efficient as checking whether the logger is enabled, and it lowers the complexity of the code because there are fewer branches.

Better yet is to use a more up-to-date logging framework where the log statements take a format specification and a list of arguments to be substituted by the logger—but "lazily," only if the logger is enabled. This is the approach taken by slf4j.

See my answer to a related question for more information, and an example of doing something like this with log4j.

/ lees	,
http://javarevisited.blogspot.nl/2011/05/top-10-tips-on-logging-in-java.html

/ LOGGING
/ Lees	, 
https://www.mkyong.com/spring-mvc/spring-mvc-log4j-integration-example/		<-


/ Einde Intermezzo

			addSingletonFactory(beanName, new ObjectFactory<Object>() {
				@Override
				public Object getObject() throws BeansException {
					return getEarlyBeanReference(beanName, mbd, bean);
				}
			});
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).addSingletonFactory(String, ObjectFactory<?>) line: 163	
		synchronized (this.singletonObjects) {
			if (!this.singletonObjects.containsKey(beanName)) {	/ knightMainConfig
/j
				this.singletonFactories.put(beanName, singletonFactory);
				this.earlySingletonObjects.remove(beanName);
				this.registeredSingletons.add(beanName);

/ De bean is al created	, see instanceWrapper hierboven	, 

/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 537	
			addSingletonFactory(beanName, new ObjectFactory<Object>() {
				...
/d
		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
/s
		PropertyValues pvs = mbd.getPropertyValues();
length:0

		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
		// state of the bean before properties are set. This can be used, for example,
		// to support styles of field injection.
		boolean continueWithPropertyPopulation = true;

		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
/n
/ die ibp's postProcessAfterInstantiation geven true	, 

		if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
/n
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

		if (hasInstAwareBpps || needsDepCheck) {
			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
			if (hasInstAwareBpps) {
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
bp	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=1549)	

						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/s 
ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 448	
			// Inject the BeanFactory before AutowiredAnnotationBeanPostProcessor's
			// postProcessPropertyValues method attempts to auto-wire other configuration beans.
			if (bean instanceof EnhancedConfiguration) {
				((EnhancedConfiguration) bean).setBeanFactory(this.beanFactory);
/s
KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.setBeanFactory(BeanFactory) line: not available	
/s
ConfigurationClassEnhancer$BeanFactoryAwareMethodInterceptor.intercept(Object, Method, Object[], MethodProxy) line: 226	
/=
	private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor, ConditionalCallback {
		@Override
		public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {

obj	KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28  (id=1534)	
method	Method  (id=2165)	 public abstract void org.springframework.beans.factory.BeanFactoryAware.setBeanFactory(org.springframework.beans.factory.BeanFactory) throws org.springframework.beans.BeansException
args	Object[1]  (id=2166)	
	[0]	DefaultListableBeanFactory  (id=44)	
proxy	MethodProxy  (id=2167)	

			Field field = obj.getClass().getDeclaredField(BEAN_FACTORY_FIELD);
BEAN_FACTORY_FIELD=$$beanFactory
public org.springframework.beans.factory.BeanFactory sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.$$beanFactory

			field.set(obj, args[0]);

			// Does the actual (non-CGLIB) superclass actually implement BeanFactoryAware?
			// If so, call its setBeanFactory() method. If not, just exit.
			if (BeanFactoryAware.class.isAssignableFrom(obj.getClass().getSuperclass())) {
/n
				return proxy.invokeSuper(obj, args);
/n
			}
			return null;
/t
ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 450	
			if (bean instanceof EnhancedConfiguration) {
				((EnhancedConfiguration) bean).setBeanFactory(this.beanFactory);
/d
			}
			return pvs;
PropertyValues: length=0
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1187	
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=1549)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/d
						if (pvs == null) {
/n	, pvs= PropertyValues: length=0
							return;
/n
/ volgende, 	
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	CommonAnnotationBeanPostProcessor  (id=1550)	
          if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/s
CommonAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 303	
		InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass());
metadata	InjectionMetadata  (id=1943)	
	checkedElements	LinkedHashSet<E>  (id=2219)	
	injectedElements	LinkedList<E>  (id=1932)	
	logger	Log4JLogger  (id=1946)	
	targetClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=113)	

		try {
			metadata.inject(bean, beanName, pvs);
/s
InjectionMetadata.inject(Object, String, PropertyValues) line: 79	
		Collection<InjectedElement> elementsToIterate =
				(this.checkedElements != null ? this.checkedElements : this.injectedElements);
true	/ want this.checkedElements==[]
[]
		if (!elementsToIterate.isEmpty()) {
/n
/ returns
/ t
CommonAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 310	
			metadata.inject(bean, beanName, pvs);
/d
		return pvs;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1184	
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	CommonAnnotationBeanPostProcessor  (id=1550)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/d
/ volgende	, 
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	AutowiredAnnotationBeanPostProcessor  (id=1425)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/s
AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 288	
		InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass());
			metadata.inject(bean, beanName, pvs);
		return pvs;
/t
/ volgende	, 
		if (hasInstAwareBpps || needsDepCheck) {
			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
filteredPds	PropertyDescriptor[1]  (id=2143)	
	[0]	GenericTypeAwarePropertyDescriptor  (id=2262)	

			if (hasInstAwareBpps) {

				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	RequiredAnnotationBeanPostProcessor  (id=1520)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/s
RequiredAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 151	
		if (!this.validatedBeanNames.contains(beanName)) {
			if (!shouldSkip(this.beanFactory, beanName)) {
				List<String> invalidProperties = new ArrayList<String>();
				for (PropertyDescriptor pd : pds) {
pd=org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]
					if (isRequiredProperty(pd) && !pvs.contains(pd.getName())) {
/s
	/**
	 * Is the supplied property required to have a value (that is, to be dependency-injected)?
	 * <p>This implementation looks for the existence of a
	 * {@link #setRequiredAnnotationType "required" annotation}
	 * on the supplied {@link PropertyDescriptor property}.
	 */
RequiredAnnotationBeanPostProcessor.isRequiredProperty(PropertyDescriptor) line: 198	
propertyDescriptor	GenericTypeAwarePropertyDescriptor  (id=2262)	
	beanClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=113)	
	name	"class" (id=2294)	
	readMethod	Method  (id=2300)	
	writeMethod	null	

		Method setter = propertyDescriptor.getWriteMethod();
null
		return (setter != null && AnnotationUtils.getAnnotation(setter, getRequiredAnnotationType()) != null);
f
getRequiredAnnotationType()=@Required
/t
RequiredAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 161	
				for (PropertyDescriptor pd : pds) {
					if (isRequiredProperty(pd) && !pvs.contains(pd.getName())) {
/n
/ geen volgende	, 
			this.validatedBeanNames.add(beanName);
		return pvs;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1193	
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/d
/ geen volgende	, 
		applyPropertyValues(beanName, mbd, bw, pvs);
/ NIETS	,
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 539	
			populateBean(beanName, mbd, instanceWrapper);
/d
			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1541	
		else {
			invokeAwareMethods(beanName, bean);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).invokeAwareMethods(String, Object) line: 1573	
		if (bean instanceof Aware) {
			if (bean instanceof BeanNameAware) {
/n
			if (bean instanceof BeanClassLoaderAware) {
/n
			if (bean instanceof BeanFactoryAware) {
/j
bean	KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28  (id=1534)	
	$$beanFactory	DefaultListableBeanFactory  (id=44)	
	CGLIB$BOUND	true	
	CGLIB$CALLBACK_0	ConfigurationClassEnhancer$BeanMethodInterceptor  (id=2159)	
	CGLIB$CALLBACK_1	ConfigurationClassEnhancer$DisposableBeanMethodInterceptor  (id=2160)	
	CGLIB$CALLBACK_2	ConfigurationClassEnhancer$BeanFactoryAwareMethodInterceptor  (id=2161)	

				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
/ al	, 
/s
KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28.setBeanFactory(BeanFactory) line: not available	
/s
ConfigurationClassEnhancer$BeanFactoryAwareMethodInterceptor.intercept(Object, Method, Object[], MethodProxy) line: 226	
/=
	private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor, ConditionalCallback {
		@Override
		public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {

obj	KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28  (id=1534)	
method	Method  (id=2165)	public abstract void org.springframework.beans.factory.BeanFactoryAware.setBeanFactory(org.springframework.beans.factory.BeanFactory) throws org.springframework.beans.BeansException
args	Object[1]  (id=2353)	
	[0]	DefaultListableBeanFactory  (id=44)	
proxy	MethodProxy  (id=2167)	

			Field field = obj.getClass().getDeclaredField(BEAN_FACTORY_FIELD);
			Assert.state(field != null, "Unable to find generated BeanFactory field");
			field.set(obj, args[0]);
/ al eerder	, 

			// Does the actual (non-CGLIB) superclass actually implement BeanFactoryAware?
			// If so, call its setBeanFactory() method. If not, just exit.
			if (BeanFactoryAware.class.isAssignableFrom(obj.getClass().getSuperclass())) {
/n
				return proxy.invokeSuper(obj, args);
/n
			}
			return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1544	
		else {
			invokeAwareMethods(beanName, bean);
/d
		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/ al eerder		,
		}
		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
/ al eerder		,
		}
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
/ al eerder		,
		}
		return wrappedBean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 549	
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/d
exposedObject	KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28  (id=1534)	

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
/ TODO
		return exposedObject;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 479	
		Object beanInstance = doCreateBean(beanName, mbd, args);
/d
		return beanInstance;
/t
AbstractBeanFactory$1.getObject() line: 302	
/=
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);						<-
/d
/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
				try {
					singletonObject = singletonFactory.getObject();
/d
				addSingleton(beanName, singletonObject);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).addSingleton(String, Object) line: 143	
		synchronized (this.singletonObjects) {
			this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 246	
				addSingleton(beanName, singletonObject);
/d
			return (singletonObject != NULL_OBJECT ? singletonObject : null);
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 313	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {		<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/d
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
bean	KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28  (id=1534)	
		return (T) bean;
/t
DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
		// Trigger initialization of all non-lazy singleton beans...
		for (String beanName : beanNames) {
knightMainConfig
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
/n
				else {
					getBean(beanName); / created, singleton	, 

/ volgende,	 
		for (String beanName : beanNames) {
[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=2446)	
/ geloven we	, 

/ volgende	,
[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=2456)	
/ geloven we	, 

/ volgende	,
		for (String beanName : beanNames) {
beanName	"rescueDamselQuest" (id=2467)	
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
/n
				else {
					getBean(beanName);

/ Intermezzo

/ stack	,
/s
	DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
		for (String beanName : beanNames) {
beanName	"rescueDamselQuest" (id=2467)	
			...
					getBean(beanName);
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 482	
				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
		refresh();
/b
	KnightMain.main(String[]) line: 10	
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);


/ Einde Intermezzo

/s
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 235	
		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
null
		else {
			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
mbd	RootBeanDefinition  (id=2471)	
	beanClass	Class<T> (sia.knights.RescueDamselQuest) (id=2475)	
	attributes	LinkedHashMap<K,V>  (id=2474)	
		[0]	LinkedHashMap$Entry<K,V>  (id=2480)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass" (id=2483)	
			value	BeanMetadataAttribute  (id=2484)	
				name	"org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass" (id=2483)	
				source	null	
				value	"lite" (id=2488)	
	scope "singleton"

				// Create bean instance.
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {	<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 210	

		synchronized (this.singletonObjects) {
			Object singletonObject = this.singletonObjects.get(beanName);
null
			if (singletonObject == null) {
				try{
					singletonObject = singletonFactory.getObject();
/s
AbstractBeanFactory$1.getObject() line: 302	
/=
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);		<-
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 452	
		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			Object bean = resolveBeforeInstantiation(beanName, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).resolveBeforeInstantiation(String, RootBeanDefinition) line: 931	
		if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
f!=null
			// Make sure bean class is actually resolved at this point.
			if (mbd.hasBeanClass() && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
				bean = applyBeanPostProcessorsBeforeInstantiation(mbd.getBeanClass(), beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInstantiation(Class<?>, String) line: 956	

/ 0de beanpostprocessor

		for (BeanPostProcessor bp : getBeanPostProcessors()) {
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
bp=org.springframework.context.annotation.ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor@5aebe890
bp=org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@65d09a04
bp	AutowiredAnnotationBeanPostProcessor  (id=1425)	
bp	RequiredAnnotationBeanPostProcessor  (id=1520)	

				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
/s
ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).postProcessBeforeInstantiation(Class<?>, String) line: 59	
		return null;
/s
CommonAnnotationBeanPostProcessor.postProcessBeforeInstantiation(Class<?>, String) line: 291	
		return null;
/s
AutowiredAnnotationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).postProcessBeforeInstantiation(Class<?>, String) line: 59	
		return null;
/s
RequiredAnnotationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).postProcessBeforeInstantiation(Class<?>, String) line: 59	
		return null;

/ geen bp's meer	, 
		return null;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).resolveBeforeInstantiation(String, RootBeanDefinition) line: 936	
				bean = applyBeanPostProcessorsBeforeInstantiation(mbd.getBeanClass(), beanName);
null
			mbd.beforeInstantiationResolved = (bean != null);
f
		}
		return bean;
null
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 466	
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			Object bean = resolveBeforeInstantiation(beanName, mbd);
/d
null
		Object beanInstance = doCreateBean(beanName, mbd, args);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 499	
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/s
	/**
	 * Create a new instance for the specified bean, using an appropriate instantiation strategy:
	 * factory method, constructor autowiring, or simple instantiation.
	 */
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 982	
		// Need to determine the constructor...
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1041	

/ 0-2de beanpostprocessor

		if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	AutowiredAnnotationBeanPostProcessor  (id=1425)					/ @Autowired, @Value	

				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
					SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
					Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);		/ 
/s
AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(Class<?>, String) line: 239	
		// Quick check on the concurrent map first, with minimal locking.
		Constructor<?>[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);
null
/ later zien we alleen voor RescueDamselQuest een entry, deze heeft een ctor met @Autowired of @Value	, see (*) vlak onder,	 
		if (candidateConstructors == null) {
			synchronized (this.candidateConstructorsCache) {
				candidateConstructors = this.candidateConstructorsCache.get(beanClass);
null
				if (candidateConstructors == null) {
					Constructor<?>[] rawCandidates = beanClass.getDeclaredConstructors();
					List<Constructor<?>> candidates = new ArrayList<Constructor<?>>(rawCandidates.length);
					Constructor<?> requiredConstructor = null;
					Constructor<?> defaultConstructor = null;
					for (Constructor<?> candidate : rawCandidates) {
@Autowired
public sia.knights.RescueDamselQuest(java.io.PrintStream)
						AnnotationAttributes annotation = findAutowiredAnnotation(candidate);	 / (*)
/s
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject) line: 383	
		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {	/ @Autowired	, @Value
			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String) line: 85	
		return getAnnotationAttributes(element, annotationType, false, false);
/s
AnnotatedElementUtils.getAnnotationAttributes(AnnotatedElement, String, boolean, boolean) line: 91	
/=
	public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element, String annotationType,
			final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {

element	Constructor<T>  (id=2573)	
annotationType	"org.springframework.beans.factory.annotation.Autowired" (id=1487)	
classValuesAsString	false	
nestedAnnotationsAsMap	false	

		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {		<-
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				...
			@Override
			public void postProcess(Annotation annotation, AnnotationAttributes result) {
				...
/s
AnnotatedElementUtils.process(AnnotatedElement, String, boolean, Processor<T>) line: 162	
			return doProcess(element, annotationType, traverseClassHierarchy, processor,
					new HashSet<AnnotatedElement>(), 0);
/s
	/**
	 * Perform the search algorithm for the {@link #process} method, avoiding
	 * endless recursion by tracking which annotated elements have already been
	 * <em>visited</em>.
	 * <p>The {@code metaDepth} parameter represents the depth of the annotation
	 * relative to the initial element. For example, an annotation that is
	 * <em>present</em> on the element will have a depth of 0; a meta-annotation
	 * will have a depth of 1; and a meta-meta-annotation will have a depth of 2.
	 */
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 195	
/=
	private static <T> T doProcess(AnnotatedElement element, String annotationType, boolean traverseClassHierarchy, Processor<T> processor, Set<AnnotatedElement> visited, int metaDepth) {

		if (visited.add(element)) {
			Annotation[] annotations = (traverseClassHierarchy 
f
				? element.getDeclaredAnnotations() 
				: element.getAnnotations());						<-
annotations	Annotation[1]  (id=2584)	
	[0]	$Proxy8  (id=2587)	
			for (Annotation annotation : annotations) {
				if (annotation.annotationType().getName().equals(annotationType) || metaDepth > 0) {
/j
annotationType==@Autowired
					T result = processor.process(annotation, metaDepth);
/s
AnnotatedElementUtils$4.process(Annotation, int) line: 91	
/=
		return process(element, annotationType, false, new Processor<AnnotationAttributes>() {
			@Override
			public AnnotationAttributes process(Annotation annotation, int metaDepth) {
				return AnnotationUtils.getAnnotationAttributes(annotation, classValuesAsString, nestedAnnotationsAsMap);
/s
AnnotationUtils.getAnnotationAttributes(Annotation, boolean, boolean) line: 556	
		AnnotationAttributes attrs = new AnnotationAttributes();
		Method[] methods = annotation.annotationType().getDeclaredMethods();
annotation	$Proxy8  (id=1436)	
methods	Method[1]  (id=1439)	
	[0]	Method  (id=1440)		public abstract boolean org.springframework.beans.factory.annotation.Autowired.required()
		for (Method method : methods) {
			if (method.getParameterTypes().length == 0 && method.getReturnType() != void.class) {
				try {
					Object value = method.invoke(annotation);
true
					attrs.put(method.getName(), adaptValue(value, classValuesAsString, nestedAnnotationsAsMap));
		return attrs;
{required=true}
/t
AnnotatedElementUtils.doProcess(AnnotatedElement, String, boolean, Processor<T>, Set<AnnotatedElement>, int) line: 196	
			for (Annotation annotation : annotations) {
				if (annotation.annotationType().getName().equals(annotationType) || metaDepth > 0) {
					T result = processor.process(annotation, metaDepth);
/d
true
					if (result != null) {
/j
						return result;
/t
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject) line: 384	
		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
{required=true}
			if (annotation != null) {
				return annotation;
/t
AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(Class<?>, String) line: 240	
					for (Constructor<?> candidate : rawCandidates) {
						AnnotationAttributes annotation = findAutowiredAnnotation(candidate);
/d
{required=true}
							boolean required = determineRequiredStatus(annotation);
/s
	/**
	 * Determine if the annotated field or method requires its dependency.
	 * <p>A 'required' dependency means that autowiring should fail when no beans
	 * are found. Otherwise, the autowiring process will simply bypass the field
	 * or method when no beans are found.
	 * @param annotation the Autowired annotation
	 * @return whether the annotation indicates that a dependency is required
	 */

AutowiredAnnotationBeanPostProcessor.determineRequiredStatus(AnnotationAttributes) line: 400	
/=
	protected boolean determineRequiredStatus(AnnotationAttributes annotation) {
		return (!annotation.containsKey(this.requiredParameterName) ||
f
				this.requiredParameterValue == annotation.getBoolean(this.requiredParameterName));
t 	, want t==t
/t
AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(Class<?>, String) line: 252	
							boolean required = determineRequiredStatus(annotation);
/d
t
							if (required) {
								requiredConstructor = candidate;
							}
							candidates.add(candidate);

					for (Constructor<?> candidate : rawCandidates) {
/ er is geen volgende,	 

					if (!candidates.isEmpty()) {
						candidateConstructors = candidates.toArray(new Constructor<?>[candidates.size()]);

					this.candidateConstructorsCache.put(beanClass, candidateConstructors);
		return (candidateConstructors.length > 0 ? candidateConstructors : null);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).determineConstructorsFromBeanPostProcessors(Class<?>, String) line: 1043	
					Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
					if (ctors != null) {
						return ctors;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1015	
		if (ctors != null ||
/j
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {

			return autowireConstructor(beanName, mbd, ctors, args);		<-
		}
/ Dus nu NIET:
		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
/n
/n
/s
	/**
	 * "autowire constructor" (with constructor arguments by type) behavior.
	 * Also applied if explicit constructor argument values are specified,
	 * matching all remaining arguments with beans from the bean factory.
	 * <p>This corresponds to constructor injection: In this mode, a Spring
	 * bean factory is able to host components that expect constructor-based
	 * dependency resolution.
	 */
	protected BeanWrapper autowireConstructor( String beanName, RootBeanDefinition mbd, Constructor<?>[] ctors, Object[] explicitArgs) {
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
/s
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 100	

		BeanWrapperImpl bw = new BeanWrapperImpl();
		this.beanFactory.initBeanWrapper(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).initBeanWrapper(BeanWrapper) line: 1093	
		bw.setConversionService(getConversionService());
		registerCustomEditors(bw);
/s
DefaultListableBeanFactory(AbstractBeanFactory).registerCustomEditors(PropertyEditorRegistry) line: 1113	
					registrar.registerCustomEditors(registry);
registry	BeanWrapperImpl  (id=1508)		/ leeg	,
/s
ResourceEditorRegistrar.registerCustomEditors(PropertyEditorRegistry) line: 114	
		ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
		doRegisterEditor(registry, Resource.class, baseEditor);
		doRegisterEditor(registry, ContextResource.class, baseEditor);
		doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
		doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
		doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
		doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

		ClassLoader classLoader = this.resourceLoader.getClassLoader();
		doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
		doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
		doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

		if (this.resourceLoader instanceof ResourcePatternResolver) {
			doRegisterEditor(registry, Resource[].class,
					new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
		}
/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 103	
		this.beanFactory.initBeanWrapper(bw);
/d
		if (constructorToUse == null) {
			// Need to resolve the constructor.
			boolean autowiring = (chosenCtors != null ||
					mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
t
			else {
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues(); / komt uit de mbd	,
				resolvedValues = new ConstructorArgumentValues();
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
0
/ TODO
/ Intermezzo

  @Autowired
  public  RescueDamselQuest(PrintStream stream) {
    this.stream = stream;
  }
/ Einde Intermezzo

			// Take specified constructors, if any.
			Constructor<?>[] candidates = chosenCtors;
[public sia.knights.RescueDamselQuest(java.io.PrintStream)]

			if (candidates == null) {
/n
[public sia.knights.RescueDamselQuest(java.io.PrintStream)]

			for (int i = 0; i < candidates.length; i++) {
				Constructor<?> candidate = candidates[i];
				Class<?>[] paramTypes = candidate.getParameterTypes();
[class java.io.PrintStream]

				if (resolvedValues != null) {
/j	, maar []
					try {
						String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length); / @ConstructorProperties	,
null
						if (paramNames == null) {
/j
							ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
							if (pnd != null) {
								paramNames = pnd.getParameterNames(candidate);
paramNames	String[1]  (id=1594)	
	[0]	"stream" (id=1595)	
/ want	, 
/s
DefaultParameterNameDiscoverer(PrioritizedParameterNameDiscoverer).getParameterNames(Constructor<?>) line: 65	
		for (ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {
this	DefaultParameterNameDiscoverer  (id=1753)	
	parameterNameDiscoverers	LinkedList<E>  (id=1755)	
		[0]	StandardReflectionParameterNameDiscoverer  (id=1758)	
		[1]	LocalVariableTableParameterNameDiscoverer  (id=1759)	

			String[] result = pnd.getParameterNames(ctor);
/s
LocalVariableTableParameterNameDiscoverer.getParameterNames(Constructor<?>) line: 85	
		Class<?> declaringClass = ctor.getDeclaringClass();
declaringClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	

		Map<Member, String[]> map = this.parameterNamesCache.get(declaringClass);
this	LocalVariableTableParameterNameDiscoverer  (id=1759)	
	parameterNamesCache	ConcurrentHashMap<K,V>  (id=1762)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=1767)	
			key	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
			value	ConcurrentHashMap<K,V>  (id=1774)	
				[0]	ConcurrentHashMap$MapEntry<K,V>  (id=1777)	
					key	Method  (id=1780)	
					value	String[0]  (id=1781)	
				[1]	ConcurrentHashMap$MapEntry<K,V>  (id=1778)	
					key	Constructor<T>  (id=1779)	
					value	String[1]  (id=1594)	
						[0]	"stream" (id=1595)	

/ Intermezzo

/ bij sia.knights.DamselRescuingKnight	,

/ ASM

		if (map == null) {
			map = inspectClass(declaringClass);	/ bij class sia.knights.DamselRescuingKnight
/s
LocalVariableTableParameterNameDiscoverer.inspectClass(Class<?>) line: 112	
		InputStream is = clazz.getResourceAsStream(ClassUtils.getClassFileName(clazz));
		try {
			ClassReader classReader = new ClassReader(is);
			Map<Member, String[]> map = new ConcurrentHashMap<Member, String[]>(32);
			classReader.accept(new ParameterNameDiscoveringVisitor(clazz, map), 0);
/ TODO


/t
LocalVariableTableParameterNameDiscoverer.getParameterNames(Constructor<?>) line: 88	
		if (map == null) {
			map = inspectClass(declaringClass);
/d
map	ConcurrentHashMap<K,V>  (id=4888)	
	[0]	ConcurrentHashMap$MapEntry<K,V>  (id=4893)	
		key	Constructor<T>  (id=4898)	 / public sia.knights.DamselRescuingKnight(sia.knights.Quest)
		value	String[1]  (id=4899)	
			[0]	"quest" (id=4887)	
	[1]	ConcurrentHashMap$MapEntry<K,V>  (id=4894)	
		key	Method  (id=4895)	/ public void sia.knights.DamselRescuingKnight.embarkOnQuest()	
		value	String[0]  (id=4896)	

			this.parameterNamesCache.put(declaringClass, map);

/ Einde Intermezzo


		if (map != NO_DEBUG_INFO_MAP) {
			return map.get(ctor);
/t
DefaultParameterNameDiscoverer(PrioritizedParameterNameDiscoverer).getParameterNames(Constructor<?>) line: 66	
		for (ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {
			String[] result = pnd.getParameterNames(ctor);
/d
result	String[1]  (id=1594)	
	[0]	"stream" (id=1595)	

			if (result != null) {
				return result;
/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 185	
				if (resolvedValues != null) {
					try {
						String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
						if (paramNames == null) {
							ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
							if (pnd != null) {
								paramNames = pnd.getParameterNames(candidate);
/d
[stream]
						argsHolder = createArgumentArray(
								beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);
/s
ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 666	

		for (int paramIndex = 0; paramIndex < paramTypes.length; paramIndex++) {
paramTypes=[java.io.PrintStream]
			Class<?> paramType = paramTypes[paramIndex];
java.io.PrintStream
			String paramName = (paramNames != null ? paramNames[paramIndex] : null);
stream
			// Try to find matching constructor argument value, either indexed or generic.
			ConstructorArgumentValues.ValueHolder valueHolder =
					resolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);
null
resolvedValues	ConstructorArgumentValues  (id=1737)	
	genericArgumentValues	LinkedList<E>  (id=1857)	
[]
	indexedArgumentValues	LinkedHashMap<K,V>  (id=1858)	
{}
			// If we couldn't find a direct match and are not supposed to autowire,
			// let's try the next generic, untyped argument value as fallback:
			// it could match after type conversion (for example, String -> int).
			if (valueHolder == null && !autowiring) {
/n
autowiring=t
					MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
/s
MethodParameter.forMethodOrConstructor(Object, int) line: 474	
		else if (methodOrConstructor instanceof Constructor) {
			return new MethodParameter((Constructor<?>) methodOrConstructor, parameterIndex);
/t
ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 739	
					MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
/d
					Object autowiredArgument = resolveAutowiredArgument(param, beanName, autowiredBeanNames, converter);
/s
	/**
	 * Template method for resolving the specified argument which is supposed to be autowired.
	 */
ConstructorResolver.resolveAutowiredArgument(MethodParameter, String, Set<String>, TypeConverter) line: 811	
		return this.beanFactory.resolveDependency(
				new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);

/ Intermezzo

/ Bij RescueDamselQuest	,

param	MethodParameter  (id=1891)				/ ctor,
	constructor	Constructor<T>  (id=1430)	
		clazz	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
		declaredAnnotations	LinkedHashMap<K,V>  (id=1721)	
{interface org.springframework.beans.factory.annotation.Autowired=@org.springframework.beans.factory.annotation.Autowired(required=true)}
		parameterTypes	Class<T>[1]  (id=1718)	
[class java.io.PrintStream]


/ Bij DamselResqueingKnight	, 

/ Alle annotations	, ook die op de params van de ctor, worden door de jdk gegeven in de Constructor<T>	, 

param.getConstructor().getParameterAnnotations()
[0]	Annotation[1]  (id=6065)	
	[0]	$Proxy9  (id=6066) @org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)	

param	MethodParameter  (id=4988)	
	constructor	Constructor<T>  (id=4797)	
		annotations	(id=4813)		[0, 1, 0, 12, 0, 0]
		declaredAnnotations	LinkedHashMap<K,V>  (id=5348) {interface org.springframework.beans.factory.annotation.Autowired=@org.springframework.beans.factory.annotation.Autowired(required=true)}	
		parameterAnnotations	(id=5352) [1, 0, 1, 0, 14, 0, 1, 0, 15, 115, 0, 16]	
	parameterAnnotations	Annotation[1]  (id=5015)	
		[0]	$Proxy9  (id=5001)	@org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)
	parameterType	Class<T> (sia.knights.Quest) (id=2957)	

/ Wanneer wordt MethodParameter.parameterAnnotations set	?
/ TODO

/ Waarom lukt in eclipse WEL	, 
param.getConstructor().getParameterAnnotations()	, waar MethodParameter param	, 
/ en NIET
methodOrCtor.getParameterAnnotations()
/ terwijl	, 
param.getConstructor()==methodOrCtor



/ Einde Intermezzo

/s
DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 852	
		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
/s
DependencyDescriptor.initParameterNameDiscovery(ParameterNameDiscoverer) line: 246	
		if (this.methodParameter != null) {
			this.methodParameter.initParameterNameDiscovery(parameterNameDiscoverer);
/ sets
this	DependencyDescriptor  (id=1993)	
	methodParameter	MethodParameter  (id=1891)	
		parameterNameDiscoverer	DefaultParameterNameDiscoverer  (id=1753)	
/t
DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 853	
		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
/d
		else {
			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, beanName);
descriptor	DependencyDescriptor  (id=1993)	
	containingClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
/ or
	containingClass	Class<T> (sia.knights.DamselRescuingKnight) (id=4747)	
	methodParameter	MethodParameter  (id=1891)	
		constructor	Constructor<T>  (id=1430)	
		parameterAnnotations	Annotation[1]  (id=5015)	
			[0]	$Proxy9  (id=5001)	
				h	AnnotationInvocationHandler  (id=5043)	
					memberMethods	null	
					memberValues	LinkedHashMap<K,V>  (id=5054)	
						[0]	LinkedHashMap$Entry<K,V>  (id=5113)			/ bij DamselRescuingKnight
							key	"value" (id=4255)	
							value	"rescueDamselQuest" (id=5115)	
					type	Class<T> (org.springframework.beans.factory.annotation.Qualifier) (id=5003)		<-

/s
ContextAnnotationAutowireCandidateResolver.getLazyResolutionProxyIfNecessary(DependencyDescriptor, String) line: 44	
		return (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : null);
/s
ContextAnnotationAutowireCandidateResolver.isLazy(DependencyDescriptor) line: 54	

		for (Annotation ann : descriptor.getAnnotations()) {		
/n bij RescueDamselQuest, /j bij DamselRescuingKnight 
			Lazy lazy = AnnotationUtils.getAnnotation(ann, Lazy.class);
/n
		MethodParameter methodParam = descriptor.getMethodParameter();
		if (methodParam != null) {
			Method method = methodParam.getMethod();
null
			if (method == null || void.class.equals(method.getReturnType())) {
				Lazy lazy = AnnotationUtils.getAnnotation(methodParam.getAnnotatedElement(), Lazy.class);
null
				if (lazy != null && lazy.value()) {
/n
		return false;
/t
DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 861	
		else {
			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, beanName);
null
			if (result == null) {
				result = doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter);
/s
DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 871	

descriptor	DependencyDescriptor  (id=4998)				/ de dep is de Quest	
	containingClass	Class<T> (sia.knights.DamselRescuingKnight) (id=4747)	
	methodParameter	MethodParameter  (id=4988)	
		constructor	Constructor<T>  (id=4797)	
		parameterAnnotations	Annotation[1]  (id=5015)	
			[0]	$Proxy9  (id=5001)	
				h	AnnotationInvocationHandler  (id=5043)	
					memberMethods	null	
					type	Class<T> (org.springframework.beans.factory.annotation.Qualifier) (id=5003)	
					memberValues	LinkedHashMap<K,V>  (id=5054)	
						[0]	LinkedHashMap$Entry<K,V>  (id=5113)	
							key	"value" (id=4255)	
							value	"rescueDamselQuest" (id=5115)	

/ Intermezzo

@Component
public class DamselRescuingKnight implements Knight {

  private Quest quest;

  @Autowired
  public DamselRescuingKnight(@Qualifier("rescueDamselQuest")Quest quest) {
    this.quest = quest;
  }
  

  public void embarkOnQuest() {
    quest.embark();
  }

}

/ Einde Intermezzo

		Class<?> type = descriptor.getDependencyType();
this	MethodParameter  (id=1891)	
	parameterType	Class<T> (java.io.PrintStream) (id=1167)	
/t
DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 872	
		Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);	/ is er een @Value	?
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).getSuggestedValue(DependencyDescriptor) line: 298	
		Object value = findValue(descriptor.getAnnotations());
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).findValue(Annotation[]) line: 312	
		for (Annotation annotation : annotationsToSearch) {
annotation	$Proxy9  (id=5001)	
	h	AnnotationInvocationHandler  (id=5043)	
		type	Class<T> (org.springframework.beans.factory.annotation.Qualifier) (id=5003)	
		memberValues	LinkedHashMap<K,V>  (id=5054)	
			[0]	LinkedHashMap$Entry<K,V>  (id=5113)	
				key	"value" (id=4255)	
				value	"rescueDamselQuest" (id=5115)	

			if (this.valueAnnotationType.isInstance(annotation)) {
/n				/ GEEN @Value

		for (Annotation annotation : annotationsToSearch) {
			Annotation metaAnn = annotation.annotationType().getAnnotation(this.valueAnnotationType);
null
/ In def @Qualifier staat GEEN @Value
			if (metaAnn != null) {
/n
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).getSuggestedValue(DependencyDescriptor) line: 299	
		Object value = findValue(descriptor.getAnnotations());
/d
		if (value == null) {
/j
			MethodParameter methodParam = descriptor.getMethodParameter();
			if (methodParam != null) {
				value = findValue(methodParam.getMethodAnnotations());

methodParam	MethodParameter  (id=4988)	
	constructor	Constructor<T>  (id=4797)	
		declaredAnnotations	LinkedHashMap<K,V>  (id=5348)		/= methodParam.getMethodAnnotations()
			[0]	LinkedHashMap$Entry<K,V>  (id=5367)	
				key	Class<T> (org.springframework.beans.factory.annotation.Autowired) (id=182)	
				value	$Proxy8  (id=4816)	
						memberValues	LinkedHashMap<K,V>  (id=5377)	
							[0]	LinkedHashMap$Entry<K,V>  (id=5381)	
								key	"required" (id=1472)	
								value	Boolean  (id=1475)	
									value	true	
						type	Class<T> (org.springframework.beans.factory.annotation.Autowired) (id=182)	

/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).findValue(Annotation[]) line: 312	
/=
	protected Object findValue(Annotation[] annotationsToSearch) {

annotationsToSearch=[@org.springframework.beans.factory.annotation.Autowired(required=true)]
/ is een $Proxy8	, 

/ Lees	, 
http://stackoverflow.com/questions/21769445/what-does-the-value-annotation-in-method-do

		for (Annotation annotation : annotationsToSearch) {
			if (this.valueAnnotationType.isInstance(annotation)) {
/n @Value != @Autowired

		for (Annotation annotation : annotationsToSearch) {
			Annotation metaAnn = annotation.annotationType().getAnnotation(this.valueAnnotationType);
/n @Autowird heef @Value niet als meta-annotation	, 

		return null;
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).getSuggestedValue(DependencyDescriptor) line: 305	
				value = findValue(methodParam.getMethodAnnotations());
/d
null
		return value;
/t
DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 873	
		Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
/d
null
		else {
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
beanName=rescueDamselQuest
type=java.io.PrintStream
descriptor	DependencyDescriptor  (id=1993)	
	methodParameter	MethodParameter  (id=1891)	
		constructor	Constructor<T>  (id=1430)	
/s
DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1006	
/=
	protected Map<String, Object> findAutowireCandidates(
			String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {
beanName	"damselRescuingKnight" (id=2578)	
requiredType	Class<T> (sia.knights.Quest) (id=2957)	

		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this, requiredType, true, descriptor.isEager());
requiredType=PrintStream / als beanName=rescueDamselQuest 
requiredType=Quest / als beanName=damselRescuingKnight

		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
/s
DefaultListableBeanFactory.getBeanNamesForType(Class<?>, boolean, boolean) line: 353	
/=
	public String[] getBeanNamesForType(Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {
type=class java.io.PrintStream
/ or	,
type=class sia.knights.Quest 

		Map<Class<?>, String[]> cache =
				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);

this	DefaultListableBeanFactory  (id=1408)	
	allBeanNamesByType	ConcurrentHashMap<K,V>  (id=2158)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=5495)	
			key	Class<T> (sia.knights.Quest) (id=2957)	
			value	String[2]  (id=5497)	
				[0]	"rescueDamselQuest" (id=1544)	
				[1]	"slayDragonQuest" (id=2586)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=5496)	
			key	Class<T> (java.io.PrintStream) (id=1167)	
			value	String[1]  (id=2165)	
				[0]	"fakeMainPrintStream" (id=2168)	
	singletonBeanNamesByType	ConcurrentHashMap<K,V>  (id=2196)	
{}
/ TODO

		String[] resolvedBeanNames = cache.get(type);
[fakeMainPrintStream]

		if (resolvedBeanNames != null) {
			return resolvedBeanNames;
/t
BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class<?>, boolean, boolean) line: 188	
		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
/d
result	String[1]  (id=2165)	
	[0]	"fakeMainPrintStream" (id=2168)	
/ of	,
result	String[2]  (id=5497)	
	[0]	"rescueDamselQuest" (id=1544)	
	[1]	"slayDragonQuest" (id=2586)	


		return result;
/t
DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1008	
		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
				this, requiredType, true, descriptor.isEager());
/d
["fakeMainPrintStream"] 
/ of	, 
[rescueDamselQuest, slayDragonQuest]

this	DefaultListableBeanFactory  (id=1408)	
	resolvableDependencies	HashMap<K,V>  (id=2245)	
		[0]	HashMap$Node<K,V>  (id=2334)	
			key	Class<T> (org.springframework.beans.factory.BeanFactory) (id=563)	
			value	DefaultListableBeanFactory  (id=1408)	
		[1]	HashMap$Node<K,V>  (id=2335)	
			key	Class<T> (org.springframework.context.ApplicationContext) (id=556)	
			value	AnnotationConfigApplicationContext  (id=29)	
		[2]	HashMap$Node<K,V>  (id=2366)	
			key	Class<T> (org.springframework.core.io.ResourceLoader) (id=558)	
			value	AnnotationConfigApplicationContext  (id=29)	
		[3]	HashMap$Node<K,V>  (id=2367)	
			key	Class<T> (org.springframework.context.ApplicationEventPublisher) (id=559)	
			value	AnnotationConfigApplicationContext  (id=29)	
/ TODO

		for (Class<?> autowiringType : this.resolvableDependencies.keySet()) {
			if (autowiringType.isAssignableFrom(requiredType)) {	/ requiredType=PrintStream or Quest
/n

		for (String candidateName : candidateNames) {
			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
beanName	"rescueDamselQuest" (id=1544)	
candidateName	"fakeMainPrintStream" (id=2168)	
/ or	, 
beanName	"damselRescuingKnight" (id=2578)	
candidateName	"rescueDamselQuest" (id=1544)	
/ or	, 
candidateName	"slayDragonQuest" (id=2586)	

/ descriptor is @Qualifier("rescueDemselQuest")Quest quest	, dus de dep (arg van ctor)	:
descriptor	DependencyDescriptor  (id=4998)	
	methodParameter	MethodParameter  (id=4988)	
		genericParameterType	Class<T> (sia.knights.Quest) (id=2957)	<-	
		parameterAnnotations	Annotation[1]  (id=5015)	
					memberValues	LinkedHashMap<K,V>  (id=5054)	
						[0]	LinkedHashMap$Entry<K,V>  (id=5113)	
							key	"value" (id=4255)	
							value	"rescueDamselQuest" (id=5115)	
					type	Class<T> (org.springframework.beans.factory.annotation.Qualifier) (id=5003)	
/s
DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor) line: 573	
		return isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());
/s
DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor, AutowireCandidateResolver) line: 587	
		String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);		/=
		if (containsBeanDefinition(beanDefinitionName)) { 
/s 		
			return this.beanDefinitionMap.containsKey(beanName);
/t
			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);
/s
DefaultListableBeanFactory(AbstractBeanFactory).getMergedLocalBeanDefinition(String) line: 1154	
		// Quick check on the concurrent map first, with minimal locking.
		RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);		/ toch by name ? TODO
/j

this	DefaultListableBeanFactory  (id=1408)	
	mergedBeanDefinitions	ConcurrentHashMap<K,V>  (id=2236)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=2560)	
			key	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=2590)	
			value	RootBeanDefinition  (id=2591)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=2561)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=2588)	
			value	RootBeanDefinition  (id=2589)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=2562)	
			key	"rescueDamselQuest" (id=1544)	
			value	RootBeanDefinition  (id=1502)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=2563)	
			key	"slayDragonQuest" (id=2586)	
			value	RootBeanDefinition  (id=2587)	
		[4]	ConcurrentHashMap$MapEntry<K,V>  (id=2564)	
			key	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=2584)	
			value	RootBeanDefinition  (id=2585)	
		[5]	ConcurrentHashMap$MapEntry<K,V>  (id=2565)	
			key	"fakeMainPrintStream" (id=2168)	
			value	RootBeanDefinition  (id=2556)	
		[6]	ConcurrentHashMap$MapEntry<K,V>  (id=2566)	
			key	"braveKnight" (id=2582)	
			value	RootBeanDefinition  (id=2583)	
		[7]	ConcurrentHashMap$MapEntry<K,V>  (id=2567)	
			key	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=2580)	
			value	RootBeanDefinition  (id=2581)	
		[8]	ConcurrentHashMap$MapEntry<K,V>  (id=2568)	
			key	"damselRescuingKnight" (id=2578)	
			value	RootBeanDefinition  (id=2579)	
		[9]	ConcurrentHashMap$MapEntry<K,V>  (id=2569)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=2576)	
			value	RootBeanDefinition  (id=2577)	
		[10]	ConcurrentHashMap$MapEntry<K,V>  (id=2570)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=2574)	
			value	RootBeanDefinition  (id=2575)	
		[11]	ConcurrentHashMap$MapEntry<K,V>  (id=2571)	
			key	"knightMainConfig" (id=2572)	
			value	RootBeanDefinition  (id=2573)	

		if (mbd != null) {
			return mbd;
/t
DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor, AutowireCandidateResolver) line: 589	
			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);
/pd
/s
DefaultListableBeanFactory.isAutowireCandidate(String, RootBeanDefinition, DependencyDescriptor, AutowireCandidateResolver) line: 619	
		String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);
"fakeMainPrintStream"
		resolveBeanClass(mbd, beanDefinitionName);
/s
			if (mbd.hasBeanClass()) {		/ beanDefinitionName is not used	,
				return mbd.getBeanClass();
/t
DefaultListableBeanFactory.isAutowireCandidate(String, RootBeanDefinition, DependencyDescriptor, AutowireCandidateResolver) line: 620	
		resolveBeanClass(mbd, beanDefinitionName);
/d
		return resolver.isAutowireCandidate(
				new BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 141	
		boolean match = super.isAutowireCandidate(bdHolder, descriptor);
true
/ want	, 
/ Voortaan: sla deze deze call over	met debug	,
/s
ContextAnnotationAutowireCandidateResolver(GenericTypeAwareAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 60	
		return (descriptor == null || checkGenericTypeMatch(bdHolder, descriptor));
/s
	/**
	 * Match the given dependency type with its generic type information against the given
	 * candidate bean definition.
	 */
ContextAnnotationAutowireCandidateResolver(GenericTypeAwareAutowireCandidateResolver).checkGenericTypeMatch(BeanDefinitionHolder, DependencyDescriptor) line: 72	
		return (this.field != null ? ResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :
/n
				ResolvableType.forMethodParameter(this.methodParameter));
/s
ResolvableType.forMethodParameter(MethodParameter, Type) line: 1094	
/=
	public static ResolvableType forMethodParameter(MethodParameter methodParameter, Type targetType) {
targetType==null
		ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());
/s
ResolvableType.forType(Type) line: 1150	
		return forType(type, null, null);
/s
ResolvableType.forType(Type, SerializableTypeWrapper$TypeProvider, ResolvableType$VariableResolver) line: 1197	
		ResolvableType key = new ResolvableType(type, typeProvider, variableResolver);
type	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
typeProvider	null	
variableResolver	null	

		ResolvableType resolvableType = cache.get(key);
key	ResolvableType  (id=2982)	
	componentType	null	
	generics	null	
	interfaces	null	
	resolved	null	
	superType	null	
	type	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	typeProvider	null	
	variableResolver	null	
resolvableType	ResolvableType  (id=2983)	
	componentType	null	
	generics	ResolvableType[0]  (id=2985)	
	interfaces	null	
	resolved	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	superType	null	
	type	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	typeProvider	null	
	variableResolver	null	

		return resolvableType;
/t
ResolvableType.forMethodParameter(MethodParameter, Type) line: 1094	
		ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());
/pd
/s
ResolvableType.as(Class<?>) line: 359	
/=
	public ResolvableType as(Class<?> type) {
type	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	

		if (ObjectUtils.nullSafeEquals(resolve(), type)) {	/ ze zijn ==
			return this;
/t
ResolvableType.forMethodParameter(MethodParameter, Type) line: 1095	
		ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());
/d
owner	ResolvableType  (id=2983)	
	componentType	null	
	generics	ResolvableType[0]  (id=2985)	
	interfaces	null	
	resolved	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	superType	null	
	type	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	typeProvider	null	
	variableResolver	null	

		return forType(targetType, 
			new MethodParameterTypeProvider(methodParameter),
				owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(),
				methodParameter.typeIndexesPerLevel);

targetType	null	
/s
SerializableTypeWrapper$MethodParameterTypeProvider.<init>(MethodParameter) line: 332	
			if (methodParameter.getMethod() != null) {
/n 
/ het is een ctor	,
			else {
				this.methodName = null;
				this.parameterTypes = methodParameter.getConstructor().getParameterTypes();

			this.declaringClass = methodParameter.getDeclaringClass();
class sia.knights.RescueDamselQuest
			this.parameterIndex = methodParameter.getParameterIndex();
0
			this.methodParameter = methodParameter;
/t
/s
ResolvableType.asVariableResolver() line: 832	
		return new DefaultVariableResolver();
/t
/s
ResolvableType.forType(Type, SerializableTypeWrapper$TypeProvider, ResolvableType$VariableResolver) line: 1190	

/ Intermezzo

/we zijn in	,

/ stack
/s
	ResolvableType.forType(Type, SerializableTypeWrapper$TypeProvider, ResolvableType$VariableResolver) line: 1196	
/cb

	ResolvableType.forMethodParameter(MethodParameter, Type) line: 1095	
		ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());
sia.knights.DamselRescuingKnight
		return forType(targetType, new MethodParameterTypeProvider(methodParameter),
				owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(),
				methodParameter.typeIndexesPerLevel);
/ targetType==null, maar wordt set in called forType 
/cb

	ResolvableType.forMethodParameter(MethodParameter) line: 1063	
		return forMethodParameter(methodParameter, (Type) null);
/cb

	DependencyDescriptor.getResolvableType() line: 212	
		return (this.field != null ? 
/n
				ResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :
/n
				ResolvableType.forMethodParameter(this.methodParameter));	/ NB. Weer de eigenlijke methodParameter	, waar de @Autowired en de @Qualifier op de param in staan	, 
/cb

	ContextAnnotationAutowireCandidateResolver(GenericTypeAwareAutowireCandidateResolver).checkGenericTypeMatch(BeanDefinitionHolder, DependencyDescriptor) line: 72	
		ResolvableType dependencyType = descriptor.getResolvableType();
/cb

	ContextAnnotationAutowireCandidateResolver(GenericTypeAwareAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 64	
		return (descriptor == null || checkGenericTypeMatch(bdHolder, descriptor));
/cb

	ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 141	
		boolean match = super.isAutowireCandidate(bdHolder, descriptor);
/cb

	DefaultListableBeanFactory.isAutowireCandidate(String, RootBeanDefinition, DependencyDescriptor, AutowireCandidateResolver) line: 630	
		return resolver.isAutowireCandidate(
				new BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);
beanName	"rescueDamselQuest" (id=1544)		 /de misschien te autowire in bean	, de candidate bean	,
mbd	RootBeanDefinition  (id=1502)	
	beanClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
descriptor	DependencyDescriptor  (id=4998)	/ hier moet de candidate aan voldoen	, 	
	methodParameter	MethodParameter  (id=4988)	
		genericParameterType	Class<T> (sia.knights.Quest) (id=2957)	
		parameterAnnotations	Annotation[1]  (id=5015)	[@org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)]
/cb

	DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor, AutowireCandidateResolver) line: 589	
		if (containsBeanDefinition(beanDefinitionName)) {
			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);
/cb 

	DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor) line: 573	
		return isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());
beanName=rescueDamselQuest	, de misschien te autowire in in ctor van DamselRescuingKnight	,
/cb

	DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1020	
		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
				this, requiredType, true, descriptor.isEager());
/ Zoek in lbf beans van deze requiredType, dat is de type van de ctor arg	,

		for (String candidateName : candidateNames) {  
candidateName=rescueDamselQuest	/  	 als 1ste	candidaat voor het arg van de ctor van DamselRescuingKnight, die moet worden autowired	,
				if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
				result.put(candidateName, getBean(candidateName));
/cb

	DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 964	
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
type=interface sia.knights.Quest
/ Zoek in lbf beans van deze type, dat is de type van de ctor arg	,

/cb

	DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 862	
/cb

	ConstructorResolver.resolveAutowiredArgument(MethodParameter, String, Set<String>, TypeConverter) line: 811	
		return this.beanFactory.resolveDependency(
				new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);
param	MethodParameter  (id=4988)	
	constructor	Constructor<T>  (id=4797)	
		declaredAnnotations	LinkedHashMap<K,V>  (id=5348)	{interface org.springframework.beans.factory.annotation.Autowired=@org.springframework.beans.factory.annotation.Autowired(required=true)} 
	parameterAnnotations	Annotation[1]  (id=5015) [@org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)]	
/cb

	ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 739	
					MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
param	MethodParameter  (id=4988)	
	constructor	Constructor<T>  (id=4797)	
		declaredAnnotations	LinkedHashMap<K,V>  (id=5348)	{interface org.springframework.beans.factory.annotation.Autowired=@org.springframework.beans.factory.annotation.Autowired(required=true)} 
	genericParameterType	Class<T> (sia.knights.Quest) (id=2957)	
	parameterAnnotations	Annotation[1]  (id=5015)				/ [@org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)]	
	parameterNameDiscoverer	DefaultParameterNameDiscoverer  (id=1753)	
	parameterType	Class<T> (sia.knights.Quest) (id=2957)	
					Object autowiredArgument = resolveAutowiredArgument(param, beanName, autowiredBeanNames, converter);
/cb

	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 185	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1115	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1018	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
	AbstractBeanFactory$1.getObject() line: 302	
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
	DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
	AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 482	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	



/ Einde Intermezzo

		if (type == null && typeProvider != null) {
/j
			type = SerializableTypeWrapper.forTypeProvider(typeProvider);
typeProvider	SerializableTypeWrapper$MethodParameterTypeProvider  (id=3011)	
	declaringClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	methodParameter	MethodParameter  (id=1891)	
	parameterTypes	Class<T>[1]  (id=3014)	[0]	Class<T> (java.io.PrintStream) (id=1167)	
type	Class<T> (java.io.PrintStream) (id=1167)	
/ of	,
typeProvider	SerializableTypeWrapper$MethodParameterTypeProvider  (id=5774)	
	declaringClass	Class<T> (sia.knights.DamselRescuingKnight) (id=4747)	
	methodParameter	MethodParameter  (id=4988)	
	parameterTypes	Class<T>[1]  (id=5775) [interface sia.knights.Quest]	
type	Class<T> (sia.knights.Quest) (id=2957)	

/ herinner	, 
  @Autowired
  public  RescueDamselQuest(PrintStream stream) {
    this.stream = stream;
  }
/ of	,
 @Autowired
  public DamselRescuingKnight(@Qualifier("rescueDamselQuest")Quest quest) {
    this.quest = quest;
  }
/ want	,
/s
SerializableTypeWrapper.forTypeProvider(SerializableTypeWrapper$TypeProvider) line: 154	
		if (provider.getType() instanceof Serializable || provider.getType() == null) {
provider.getType()=sia.knights.Quest	, inderdaad het type van het arg	,
/ want,	
/s
SerializableTypeWrapper$MethodParameterTypeProvider.getType() line: 340	
			return this.methodParameter.getGenericParameterType();
/s
MethodParameter.getGenericParameterType() line: 247	
		if (this.genericParameterType == null) {
/n
		return this.genericParameterType;
/t
SerializableTypeWrapper.forTypeProvider(SerializableTypeWrapper$TypeProvider) line: 154	
		if (provider.getType() instanceof Serializable || provider.getType() == null) {
			return provider.getType();
/t
ResolvableType.forType(Type, SerializableTypeWrapper$TypeProvider, ResolvableType$VariableResolver) line: 1192	
		if (type == null && typeProvider != null) {
			type = SerializableTypeWrapper.forTypeProvider(typeProvider);
/d
type	Class<T> (java.io.PrintStream) (id=1167)	

		ResolvableType key = new ResolvableType(type, typeProvider, variableResolver);

type	Class<T> (java.io.PrintStream) (id=1167)	
typeProvider	SerializableTypeWrapper$MethodParameterTypeProvider  (id=3011)	
	declaringClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	methodParameter	MethodParameter  (id=1891)	
		constructor	Constructor<T>  (id=1430)	
		parameterAnnotations	Annotation[0]  (id=2078)		/ geen @Qualifier in dit geval	,
	parameterTypes	Class<T>[1]  (id=3014)	
		[0]	Class<T> (java.io.PrintStream) (id=1167)	
variableResolver	ResolvableType$DefaultVariableResolver  (id=3024)	

		ResolvableType resolvableType = cache.get(key);
		if (resolvableType == null) {
			resolvableType = new ResolvableType(type, typeProvider, variableResolver, null);
			cache.put(resolvableType, resolvableType);
		}

resolvableType	ResolvableType  (id=3187)	
	resolved	Class<T> (java.io.PrintStream) (id=1167)	
	type	Class<T> (java.io.PrintStream) (id=1167)	
	typeProvider	SerializableTypeWrapper$MethodParameterTypeProvider  (id=3193)	
	variableResolver	ResolvableType$DefaultVariableResolver  (id=3194)	

		return resolvableType;

/ Intermezzo

/ we zijn in 	,

/stack
/s
	ResolvableType.forType(Type, SerializableTypeWrapper$TypeProvider, ResolvableType$VariableResolver) line: 1203	
		return resolvableType;	
/cb
	ResolvableType.forMethodParameter(MethodParameter, Type) line: 1095	
		return forType(targetType, new MethodParameterTypeProvider(methodParameter),
				owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(),
				methodParameter.typeIndexesPerLevel);
/cb
	ResolvableType.forMethodParameter(MethodParameter) line: 1063	
		return forMethodParameter(methodParameter, (Type) null);
/cb
	DependencyDescriptor.getResolvableType() line: 212	
		return (this.field != null ? ResolvableType.forField(this.field, this.nestingLevel, this.containingClass) :
this.field==null
				ResolvableType.forMethodParameter(this.methodParameter));			<-
/cb
	ContextAnnotationAutowireCandidateResolver(GenericTypeAwareAutowireCandidateResolver).checkGenericTypeMatch(BeanDefinitionHolder, DependencyDescriptor) line: 72	
		ResolvableType dependencyType = descriptor.getResolvableType();
/cb
	ContextAnnotationAutowireCandidateResolver(GenericTypeAwareAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 64	
		return (descriptor == null || checkGenericTypeMatch(bdHolder, descriptor));
bdHolder	BeanDefinitionHolder  (id=2931)	
	beanName	"fakeMainPrintStream" (id=2168)	
descriptor	DependencyDescriptor  (id=1993)	
	containingClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	methodParameter	MethodParameter  (id=1891)	
/cb
	ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 141	
		boolean match = super.isAutowireCandidate(bdHolder, descriptor);
/cb
	DefaultListableBeanFactory.isAutowireCandidate(String, RootBeanDefinition, DependencyDescriptor, AutowireCandidateResolver) line: 630	
		return resolver.isAutowireCandidate(
				new BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);
/cb
	DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor, AutowireCandidateResolver) line: 589	
		if (containsBeanDefinition(beanDefinitionName)) {
			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);
/cb
	DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor) line: 573	
		return isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());
/cb
	DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1020	
			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
candidateName	"fakeMainPrintStream" (id=2168)		/ TODO
descriptor	DependencyDescriptor  (id=1993)	
	declaringClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	methodParameter	MethodParameter  (id=1891)	
		constructor	Constructor<T>  (id=1430)	
/cb
	DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 964	
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
/cb
	DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 862	
				result = doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter);
/cb
	ConstructorResolver.resolveAutowiredArgument(MethodParameter, String, Set<String>, TypeConverter) line: 811	
		return this.beanFactory.resolveDependency(
				new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);
/cb
	ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 739	
					MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
					Object autowiredArgument = resolveAutowiredArgument(param, beanName, autowiredBeanNames, converter);
beanName=rescueDamselQuest	, de autowired argument is die PrintStream, en dat gaat de FakeMainPrintStream worden	, 
/cb
	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 185	
						argsHolder = createArgumentArray(
								beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1115	
		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1018	
			return autowireConstructor(beanName, mbd, ctors, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
		BeanWrapper instanceWrapper = null;
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
		Object beanInstance = doCreateBean(beanName, mbd, args);
/cb
	AbstractBeanFactory$1.getObject() line: 302	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);		<-
/cb
	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
					singletonObject = singletonFactory.getObject();
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {		<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/cb
	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
		return doGetBean(name, null, null, false);
/cb
	DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
					getBean(beanName);		/ beanName="rescueDamselQuest"
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/cb
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 482	
				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);
/cb
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
		refresh();
/cb
	KnightMain.main(String[]) line: 10	
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);

/ Einde Intermezzo

/t
ResolvableType.forMethodParameter(MethodParameter, Type) line: 1095	
		return forType(targetType, 
				new MethodParameterTypeProvider(methodParameter),
				owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(),
				methodParameter.typeIndexesPerLevel);
/s
ResolvableType.getNested(int, Map<Integer,Integer>) line: 532	
/=
	public ResolvableType getNested(int nestingLevel, Map<Integer, Integer> typeIndexesPerLevel) {
nestingLevel	1	
typeIndexesPerLevel	null	

		return result;
result	ResolvableType  (id=3187)	 	PrintStream
...
/t
ContextAnnotationAutowireCandidateResolver(GenericTypeAwareAutowireCandidateResolver).checkGenericTypeMatch(BeanDefinitionHolder, DependencyDescriptor) line: 73	
		ResolvableType dependencyType = descriptor.getResolvableType();
/d
dependencyType ResolvableType  (id=3187)	
	type	Class<T> (java.io.PrintStream) (id=1167)	
/ of	,
dependencyType	ResolvableType  (id=5758)	
	type	Class<T> (sia.knights.Quest) (id=2957)	
	typeProvider	SerializableTypeWrapper$MethodParameterTypeProvider  (id=5770)	
	variableResolver	ResolvableType$DefaultVariableResolver  (id=5771)	


		if (dependencyType.getType() instanceof Class) {
			// No generic type -> we know it's a Class type-match, so no need to check again.
			return true;
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 142	
		boolean match = super.isAutowireCandidate(bdHolder, descriptor);
/d
true
/ Voortaan: sla deze call over met debug	,

		if (match && descriptor != null) {
			match = checkQualifiers(bdHolder, descriptor.getAnnotations());
/ @QUALIFIER
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifiers(BeanDefinitionHolder, Annotation[]) line: 164	
		if (ObjectUtils.isEmpty(annotationsToSearch)) {	 / er is geen @Qualifier op de par		,
/j
			return true;
/ of	,
		if (ObjectUtils.isEmpty(annotationsToSearch)) { / [@org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)]
/n
		for (Annotation annotation : annotationsToSearch) {
			Class<? extends Annotation> type = annotation.annotationType();
interface org.springframework.beans.factory.annotation.Qualifier
			if (isQualifier(type)) {
				if (!checkQualifier(bdHolder, annotation, typeConverter)) {
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifier(BeanDefinitionHolder, Annotation, TypeConverter) line: 217	
/=
	protected boolean checkQualifier(
			BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter) {
/ bdHolder=Bean definition with name 'rescueDamselQuest'	, de candidate voor de te autowire dep in de ctor van de DamselRescuingKnight, die je wilt check tegen de annotation=@org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)

		Class<? extends Annotation> type = annotation.annotationType();
interface org.springframework.beans.factory.annotation.Qualifier
		RootBeanDefinition bd = (RootBeanDefinition) bdHolder.getBeanDefinition();

		AutowireCandidateQualifier qualifier = bd.getQualifier(type.getName());
null
/ want bd.qualifiers={}	
/ TODO
		if (qualifier == null) {
/j
			qualifier = bd.getQualifier(ClassUtils.getShortName(type));
null
/ want bd.qualifiers={}	
		if (qualifier == null) {
			// First, check annotation on factory method, if applicable
			Annotation targetAnnotation = getFactoryMethodAnnotation(bd, type);
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).getFactoryMethodAnnotation(RootBeanDefinition, Class<Annotation>) line: 287	
		Method resolvedFactoryMethod = bd.getResolvedFactoryMethod(); 	/ bd= bean def. van de candidate class sia.knights.RescueDamselQuest
null
/ want	, 
bd	RootBeanDefinition  (id=1502)	
	resolvedConstructorOrFactoryMethod	Constructor<T>  (id=1430)		 / is een ctor, GEEN method	,
		declaredAnnotations	LinkedHashMap<K,V>  (id=1721)		@Autowired
		parameterAnnotations	null	

		return (resolvedFactoryMethod != null ? AnnotationUtils.getAnnotation(resolvedFactoryMethod, type) : null);
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifier(BeanDefinitionHolder, Annotation, TypeConverter) line: 227	
			// First, check annotation on factory method, if applicable
			Annotation targetAnnotation = getFactoryMethodAnnotation(bd, type);
/d
			if (targetAnnotation == null) {
				RootBeanDefinition dbd = getResolvedDecoratedDefinition(bd);	/ bd is van de te autowire candidate bean	, RescueDamselQuest	,
null
/ want	,
bd	RootBeanDefinition  (id=1502)	
	decoratedDefinition	null	

			if (targetAnnotation == null) {
				// Look for matching annotation on the target class
				if (getBeanFactory() != null) {
					Class<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());	/ bdHolder van de te autowire candidate bean , Res
cueDamselQuest ,
/s
DefaultListableBeanFactory(AbstractBeanFactory).getType(String) line: 563	
		// Check manually registered singletons.
		Object beanInstance = getSingleton(beanName, false);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, boolean) line: 185	
		Object singletonObject = this.singletonObjects.get(beanName);
sia.knights.RescueDamselQuest@671a5887

		return (singletonObject != NULL_OBJECT ? singletonObject : null);
/t
DefaultListableBeanFactory(AbstractBeanFactory).getType(String) line: 567	
		// Check manually registered singletons.
		Object beanInstance = getSingleton(beanName, false);
/d
		if (beanInstance != null) {
			if (beanInstance instanceof FactoryBean && !BeanFactoryUtils.isFactoryDereference(name)) {
			else {
				return beanInstance.getClass();
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifier(BeanDefinitionHolder, Annotation, TypeConverter) line: 237	
					Class<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());
/d
class sia.knights.RescueDamselQuest	 /type van de te autowire in candidate bean in de ctor van DamselRescuingKnight	,

					if (beanType != null) {
						targetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);
beanType	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
type	Class<T> (org.springframework.beans.factory.annotation.Qualifier) (id=5003)	
/ Heeft RescueDamselQuest zelf een @Qualifier annot	?
/ nee
/ want er staat alleen @Component op , en die heeft zelf geen @Qualifier annot (meta annot)	,
/s
	/**
	 * Return the user-defined class for the given class: usually simply the given
	 * class, but the original class in case of a CGLIB-generated subclass.
	 * @param clazz the class to check
	 * @return the user-defined class
	 */
ClassUtils.getUserClass(Class<?>) line: 350	
/=
	public static Class<?> getUserClass(Class<?> clazz) {
		if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {	/ $$
/n
		return clazz;
/t
/s
AnnotationUtils.getAnnotation(AnnotatedElement, Class<T>) line: 111	
			T ann = annotatedElement.getAnnotation(annotationType);	/ Class method	,
annotatedElement	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
annotationType	Class<T> (org.springframework.beans.factory.annotation.Qualifier) (id=5003)	
null
			if (ann == null) {
				for (Annotation metaAnn : annotatedElement.getAnnotations()) {
@org.springframework.stereotype.Component(value=)		/ Klopt, RescueDamselQuest heeft de @Component annot	,
					ann = metaAnn.annotationType().getAnnotation(annotationType);
null
/ er is geen volgende for loop	,
			return ann;
null
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifier(BeanDefinitionHolder, Annotation, TypeConverter) line: 241	
						targetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);
beanType	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
type	Class<T> (org.springframework.beans.factory.annotation.Qualifier) (id=5003)	
/d
null
				if (targetAnnotation == null && bd.hasBeanClass()) {
					targetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(bd.getBeanClass()), type);
null
/ hetzelfde	,

		Map<String, Object> attributes = AnnotationUtils.getAnnotationAttributes(annotation);
{value=rescueDamselQuest}

		for (Map.Entry<String, Object> entry : attributes.entrySet()) {
			String attributeName = entry.getKey();
value
			Object expectedValue = entry.getValue();
value=rescueDamselQuest
			Object actualValue = null;

			// Check qualifier first
			if (qualifier != null) {
/n										/ op de candidate bean RescueDamselQuest zelf is geen @Qualifier	,
			if (actualValue == null) {
				// Fall back on bean definition attribute
				actualValue = bd.getAttribute(attributeName);	/ attributeName="value"
null
/ want	,	
bd	RootBeanDefinition  (id=1502)	
	attributes	LinkedHashMap<K,V>  (id=3770)	
		[0]	LinkedHashMap$Entry<K,V>  (id=6609)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass" (id=6610)	
			value	BeanMetadataAttribute  (id=6611) / 	metadata attribute 'org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass'

			if (actualValue == null && attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &&
					expectedValue instanceof String && bdHolder.matchesName((String) expectedValue)) {
				// Fall back on bean name (or alias) match
				continue;
			}
/ want	,
bdHolder	BeanDefinitionHolder  (id=5750)	
	aliases	String[0]  (id=5752)	
	beanDefinition	RootBeanDefinition  (id=1502)	
	beanName	"rescueDamselQuest" (id=1544)	

/ volgende	, 
		for (Map.Entry<String, Object> entry : attributes.entrySet()) {
/ is er niet	,

		return true;
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifiers(BeanDefinitionHolder, Annotation[]) line: 174	
				if (!checkQualifier(bdHolder, annotation, typeConverter)) {
/n
					fallbackToMeta = true;
				}
				else {
/j
					checkMeta = false;

			if (checkMeta) {
/n
/ volgende	,
		for (Annotation annotation : annotationsToSearch) {
/ geen 
		return true;
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 144	
			match = checkQualifiers(bdHolder, descriptor.getAnnotations());
true
/ bdHolder is de candidate bean , descriptor.getAnnotations=[@org.springframework.beans.factory.annotation.Qualifier(value=rescueDamselQuest)] is de eis waaraan de candidate moet volden	, 
/ het is het arg van de DamselRescuingKniight's ctor	, 

			if (match) {
				MethodParameter methodParam = descriptor.getMethodParameter();
				if (methodParam != null) {
					Method method = methodParam.getMethod();
					if (method == null || void.class.equals(method.getReturnType())) {
/j 
/ het is de ctor, dus methodParam.method==null
						match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());
methodParam.getMethodAnnotations()=@Autowired(required=true)
/ Hij kijkt of er op de ctor ook een @Qualifier staat	, 
/ is niet zo	,
/ gaat nu check	,
/s
MethodParameter.getMethodAnnotations() line: 288	
		return getAnnotatedElement().getAnnotations();
getAnnotatedElement()=Construtor<T> public sia.knights.DamselRescuingKnight(sia.knights.Quest)
/s
Constructor<T>(AccessibleObject).getAnnotations() line: 207	
        return getDeclaredAnnotations(); / @Autowired(required=true)
/t
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifiers(BeanDefinitionHolder, Annotation[]) line: 161	
/=
	protected boolean checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch) {
/ lbf kwam met een bean aanzetten, die def zit in bdHolder	, en de vraag is of dze matches met een van  de annots in annotationsToSearch

		for (Annotation annotation : annotationsToSearch) {	 @Autowired
			Class<? extends Annotation> type = annotation.annotationType();
			boolean checkMeta = true;
			boolean fallbackToMeta = false;
			if (isQualifier(type)) {
/n
			if (checkMeta) {
				boolean foundMeta = false;
				for (Annotation metaAnn : type.getAnnotations()) {
[@java.lang.annotation.Target(value=[CONSTRUCTOR, FIELD, METHOD, ANNOTATION_TYPE]), @java.lang.annotation.Retention(value=RUNTIME), @java.lang.annotation.Documented()]
					if (isQualifier(metaType)) {
/n
/ volgende	, 
		for (Annotation annotation : annotationsToSearch) {	 @Autowired
/ geen meer	,
		return true;
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 154	
						match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());
true
		return match;
/t
DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1021	
		for (String candidateName : candidateNames) {
			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
/d
				result.put(candidateName, getBean(candidateName));
/ volgende	,
		for (String candidateName : candidateNames) {	
/ candidateName	"slayDragonQuest" (id=2586)	
			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
/n

/ Intermezzo

/ 7	. 

/ we zijn in 	, 
/s
	ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 141	
	DefaultListableBeanFactory.isAutowireCandidate(String, RootBeanDefinition, DependencyDescriptor, AutowireCandidateResolver) line: 630	
	DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor, AutowireCandidateResolver) line: 589	
	DefaultListableBeanFactory.isAutowireCandidate(String, DependencyDescriptor) line: 573	

	DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1020	
		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
				this, requiredType, true, descriptor.isEager());		/ requiredType=Quest
		for (String candidateName : candidateNames) {	/ [rescueDamselQuest, slayDragonQuest]
			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
				result.put(candidateName, getBean(candidateName));
			}
		}
/cb

	DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 964	
		else {
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
/cb

	DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 862	
			if (result == null) {
				result = doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter);
/cb

	ConstructorResolver.resolveAutowiredArgument(MethodParameter, String, Set<String>, TypeConverter) line: 811	
		return this.beanFactory.resolveDependency(
				new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);
/cb

	ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 739	
					MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
					Object autowiredArgument = resolveAutowiredArgument(param, beanName, autowiredBeanNames, converter);
/cb

	ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 185	
						argsHolder = createArgumentArray(
								beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);
/cb

	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 1115	

	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBeanInstance(String, RootBeanDefinition, Object[]) line: 1018	
			return autowireConstructor(beanName, mbd, ctors, args);
/cb

	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 504	
		if (instanceWrapper == null) {
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/cb

	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 475	
	AbstractBeanFactory$1.getObject() line: 302	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);					<-
/cb

	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {			<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/cb

	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 193	
	DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
			beanNames = new ArrayList<String>(this.beanDefinitionNames);
		for (String beanName : beanNames) {
				else {
					getBean(beanName);
/cb

	AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 762	
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/cb

	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 482	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	

/ 7	. 

ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifier(BeanDefinitionHolder, Annotation, TypeConverter) line: 217	
/ main method om na te gaan of @Qualifier past	, 
/ TODO @Qualifier op bdHolder=bean candidate=RescueDamselQuest	 of SlayDragonQuest	, 
	/ of bij arg van DamselRescuingKnight's ctor	, dat van type Quest is : @Qualifier(value=rescueDamselQuest) Quest

/ Einde Intermezzo

/ we zijn nog in	, 
DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1032	
		for (String candidateName : candidateNames) {
			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
				result.put(candidateName, getBean(candidateName));
			}
		}
/d
		return result;
{rescueDamselQuest=sia.knights.RescueDamselQuest@37f1104d}
/t
DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 965	
		else {
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
/d
			// We have exactly one match.
			Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
			if (autowiredBeanNames != null) {
				autowiredBeanNames.add(entry.getKey());
			}
			return entry.getValue();
/t
DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 864	
				result = doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter);
/d
			}
			return result;
/t
ConstructorResolver.resolveAutowiredArgument(MethodParameter, String, Set<String>, TypeConverter) line: 811	
		return this.beanFactory.resolveDependency(
				new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);
/d
/t
ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 740	
					MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
					Object autowiredArgument = resolveAutowiredArgument(param, beanName, autowiredBeanNames, converter);
/d
sia.knights.RescueDamselQuest@37f1104d

		ArgumentsHolder args = new ArgumentsHolder(paramTypes.length);
/ eerder	, 
					args.rawArguments[paramIndex] = autowiredArgument;
					args.arguments[paramIndex] = autowiredArgument;
					args.preparedArguments[paramIndex] = new AutowiredArgumentMarker();
					args.resolveNecessary = true;

		for (String autowiredBeanName : autowiredBeanNames) {
			this.beanFactory.registerDependentBean(autowiredBeanName, beanName);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).registerDependentBean(String, String) line: 410	

				this.dependentBeanMap.put(canonicalName, dependentBeans);
			dependentBeans.add(dependentBeanName);
this.dependentBeanMap={rescueDamselQuest=[damselRescuingKnight], fakeMainPrintStream=[rescueDamselQuest]}

				this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);
			dependenciesForBean.add(canonicalName);
this.dependenciesForBeanMap={rescueDamselQuest=[fakeMainPrintStream], damselRescuingKnight=[rescueDamselQuest]}
/t
ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 754	
			this.beanFactory.registerDependentBean(autowiredBeanName, beanName);
/d
		return args;
/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 209	
						argsHolder = createArgumentArray(
								beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);
/d

/ Ga verder bij VERDER


descriptor	DependencyDescriptor  (id=1993)	
	containingClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
	methodParameter	MethodParameter  (id=1891)	
		constructor	Constructor<T>  (id=1430)	
			declaredAnnotations	LinkedHashMap<K,V>  (id=1721)	
				[0]	LinkedHashMap$Entry<K,V>  (id=3384)	
					key	Class<T> (org.springframework.beans.factory.annotation.Autowired) (id=182)	 	/ @Autowired op ctor
					value	$Proxy8  (id=1436)	
		parameterAnnotations	Annotation[0]  (id=2078)			/ zou @Qualifier zijn	op arg, 

/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifiers(BeanDefinitionHolder, Annotation[]) line: 164	
			match = checkQualifiers(bdHolder, descriptor.getAnnotations());
/d
true
			if (match) {
				MethodParameter methodParam = descriptor.getMethodParameter();
				if (methodParam != null) {
					Method method = methodParam.getMethod();
null
/ want is ctor	, 
					if (method == null || void.class.equals(method.getReturnType())) {
/j
						match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());
/ bdHolder heeft RootBeanDefinition van Root bean: class [sia.knights.FakeMainPrintStream]; ... 
/s
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).checkQualifiers(BeanDefinitionHolder, Annotation[]) line: 164	
		if (ObjectUtils.isEmpty(annotationsToSearch)) {
/n																										/ zonet wel	,
		for (Annotation annotation : annotationsToSearch) {
			Class<? extends Annotation> type = annotation.annotationType();
Autowired
			if (isQualifier(type)) {
/n
			if (checkMeta) {
				boolean foundMeta = false;
				for (Annotation metaAnn : type.getAnnotations()) {
[@java.lang.annotation.Target(value=[CONSTRUCTOR, FIELD, METHOD, ANNOTATION_TYPE]), 
	@java.lang.annotation.Retention(value=RUNTIME), 
	@java.lang.annotation.Documented()]
/ eig $Proxy1, ...
					Class<? extends Annotation> metaType = metaAnn.annotationType();
					if (isQualifier(metaType)) {
/n
/ geen van 3	, 
/ volgende	, 
		for (Annotation annotation : annotationsToSearch) {
/ is er niet	,
		return true;
/t
ContextAnnotationAutowireCandidateResolver(QualifierAnnotationAutowireCandidateResolver).isAutowireCandidate(BeanDefinitionHolder, DependencyDescriptor) line: 154	
						match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());
/d
		return match;
true
...
/t
DefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 1021	
			if (!isSelfReference(beanName, candidateName) && isAutowireCandidate(candidateName, descriptor)) {
/j
				result.put(candidateName, getBean(candidateName));	/ hij is er al in lbf's singletonObjects	,
/ INJECTION IN CTOR IS RESOLVED MATCHING BEANS 
result	LinkedHashMap<K,V>  (id=2513)	
	[0]	LinkedHashMap$Entry<K,V>  (id=3471)	
		key	"fakeMainPrintStream" (id=2168)	
		value	FakeMainPrintStream  (id=1624)	

/ volgende	, 
		for (String candidateName : candidateNames) {
/ is er niet	,  alleen fakeMainPrintStream is er	, 

		return result;
/t
DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 965	
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
/d
{fakeMainPrintStream=sia.knights.FakeMainPrintStream@672872e1}

			if (matchingBeans.isEmpty()) {
/n
			if (matchingBeans.size() > 1) {
/n
			// We have exactly one match.
			Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
			if (autowiredBeanNames != null) {
				autowiredBeanNames.add(entry.getKey());
[fakeMainPrintStream]
			return entry.getValue();	/ de bean inst	,
/t
DefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 864	
				result = doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter);
/d
result	FakeMainPrintStream  (id=1624)	
			return result;
/t
ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 740	
					MethodParameter param = MethodParameter.forMethodOrConstructor(methodOrCtor, paramIndex);
					Object autowiredArgument = resolveAutowiredArgument(param, beanName, autowiredBeanNames, converter);
/d
sia.knights.FakeMainPrintStream@672872e1
					args.rawArguments[paramIndex] = autowiredArgument;	/ paramIndex=0
					args.arguments[paramIndex] = autowiredArgument;
					args.preparedArguments[paramIndex] = new AutowiredArgumentMarker();
					args.resolveNecessary = true;

/ volgende param	,
		for (int paramIndex = 0; paramIndex < paramTypes.length; paramIndex++) {
/ Geen	, er was er maar 1 autowired inj in de ctor	,

		for (String autowiredBeanName : autowiredBeanNames) {
			this.beanFactory.registerDependentBean(autowiredBeanName, beanName);
/s
	/**
	 * Register a dependent bean for the given bean,
	 * to be destroyed before the given bean is destroyed.
	 */
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).registerDependentBean(String, String) line: 394	
/=
	public void registerDependentBean(String beanName, String dependentBeanName) {
beanName	"fakeMainPrintStream" (id=2168)	
dependentBeanName	"rescueDamselQuest" (id=1544)	

		String canonicalName = canonicalName(beanName);
			Set<String> dependentBeans = this.dependentBeanMap.get(canonicalName);
			if (dependentBeans == null) {
				dependentBeans = new LinkedHashSet<String>(8);
				this.dependentBeanMap.put(canonicalName, dependentBeans);
			}
			dependentBeans.add(dependentBeanName);

this	DefaultListableBeanFactory  (id=1408)	
	dependentBeanMap	ConcurrentHashMap<K,V>  (id=2213)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=3557)	
			key	"fakeMainPrintStream" (id=2168)	
			value	LinkedHashSet<E>  (id=3529)	
				[0]	"rescueDamselQuest" (id=1544)	

			Set<String> dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);
			if (dependenciesForBean == null) {
				dependenciesForBean = new LinkedHashSet<String>(8);
				this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);
			}
			dependenciesForBean.add(canonicalName);

this	DefaultListableBeanFactory  (id=1408)	
	dependenciesForBeanMap	ConcurrentHashMap<K,V>  (id=2211)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=3613)	
			key	"rescueDamselQuest" (id=1544)	
			value	LinkedHashSet<E>  (id=3553)	
				[0]	"fakeMainPrintStream" (id=2168)	

/t
ConstructorResolver.createArgumentArray(String, RootBeanDefinition, ConstructorArgumentValues, BeanWrapper, Class<?>[], String[], Object, boolean) line: 754	
			this.beanFactory.registerDependentBean(autowiredBeanName, beanName);
/d
			if (this.beanFactory.logger.isDebugEnabled()) {
/ TODO

/ volgende	, 
		for (String autowiredBeanName : autowiredBeanNames) {
/ is er niet	, 

		return args;
/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 209	
						argsHolder = createArgumentArray(
								beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);
/ VERDER
/d
argsHolder	ConstructorResolver$ArgumentsHolder  (id=3221)	
	arguments	Object[1]  (id=3634)	
		[0]	FakeMainPrintStream  (id=1624)	
	preparedArguments	Object[1]  (id=3635)	
		[0]	ConstructorResolver$AutowiredArgumentMarker  (id=3639)	
	rawArguments	Object[1]  (id=3636)	
		[0]	FakeMainPrintStream  (id=1624)	
	resolveNecessary	true	

				int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
/j
						argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
paramTypes=[java.io.PrintStream.class]
/s
ConstructorResolver$ArgumentsHolder.getTypeDifferenceWeight(Class<?>[]) line: 846	
			int typeDiffWeight = MethodInvoker.getTypeDifferenceWeight(paramTypes, this.arguments);

paramTypes=[java.io.PrintStream.class]
this	ConstructorResolver$ArgumentsHolder  (id=3221)	
	arguments	Object[1]  (id=3634)	
		[0]	FakeMainPrintStream  (id=1624)	
/s
	/**
	 * Algorithm that judges the match between the declared parameter types of a candidate method
	 * and a specific list of arguments that this method is supposed to be invoked with.
	 * <p>Determines a weight that represents the class hierarchy difference between types and
	 * arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase
	 * the result - all direct matches means weight 0. A match between type Object and arg of
	 * class Integer would increase the weight by 2, due to the superclass 2 steps up in the
	 * hierarchy (i.e. Object) being the last one that still matches the required type Object.
	 * Type Number and class Integer would increase the weight by 1 accordingly, due to the
	 * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number.
	 * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a
	 * constructor (Number) which would in turn be preferred to a constructor (Object).
	 * All argument weights get accumulated.
	 * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm
	 * used for constructor and factory method selection in Spring's bean container (in case
	 * of lenient constructor resolution which is the default for regular bean definitions).
	 */
MethodInvoker.getTypeDifferenceWeight(Class<?>[], Object[]) line: 294	
/=
	public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {
paramTypes	Class<T>[1]  (id=1738)	
	[0]	Class<T> (java.io.PrintStream) (id=1167)	
args	Object[1]  (id=3634)	
	[0]	FakeMainPrintStream  (id=1624)	

/ herinner	,
public class FakeMainPrintStream extends PrintStream {

		for (int i = 0; i < paramTypes.length; i++) {
			if (args[i] != null) {
				Class<?> paramType = paramTypes[i];
				Class<?> superClass = args[i].getClass().getSuperclass();	/ class java.io.PrintStream
				while (superClass != null) {
					if (paramType.equals(superClass)) {
						result = result + 2;
/ TODO waarom niet 1	?
						superClass = null;
					}
		return result;
2
/t
ConstructorResolver$ArgumentsHolder.getTypeDifferenceWeight(Class<?>[]) line: 847	
			int typeDiffWeight = MethodInvoker.getTypeDifferenceWeight(paramTypes, this.arguments);
/d
2
			int rawTypeDiffWeight = MethodInvoker.getTypeDifferenceWeight(paramTypes, this.rawArguments) - 1024;
-1022
			return (rawTypeDiffWeight < typeDiffWeight ? rawTypeDiffWeight : typeDiffWeight);
/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 222	
				int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
						argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
/d
-1022

			int minTypeDiffWeight = Integer.MAX_VALUE;
/ eerder	,
				if (typeDiffWeight < minTypeDiffWeight) {	 
/j
					constructorToUse = candidate;	/ public sia.knights.RescueDamselQuest(java.io.PrintStream)
					argsHolderToUse = argsHolder;
					argsToUse = argsHolder.arguments;	/ [sia.knights.FakeMainPrintStream@672872e1]
					minTypeDiffWeight = typeDiffWeight;	/ -1022
					ambiguousConstructors = null;
				}

/ volgende	,
			for (int i = 0; i < candidates.length; i++) {
/ geen meer	, 
			if (explicitArgs == null) {
				argsHolderToUse.storeCache(mbd, constructorToUse);
/s
ConstructorResolver$ArgumentsHolder.storeCache(RootBeanDefinition, Object) line: 870	
				mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;
				mbd.constructorArgumentsResolved = true;
				if (this.resolveNecessary) {
					mbd.preparedConstructorArguments = this.preparedArguments;

mbd	RootBeanDefinition  (id=1502)	
	preparedConstructorArguments	Object[1]  (id=3635)	
		[0]	ConstructorResolver$AutowiredArgumentMarker  (id=3639)	
	resolvedConstructorOrFactoryMethod	Constructor<T>  (id=1430)	

/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 270	
				argsHolderToUse.storeCache(mbd, constructorToUse);
/d
/ TODO

			else {
				beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(
						mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
beanName	"rescueDamselQuest" (id=1544)	
/ of	, 
beanName damselRescuingKnight
argsToUse	Object[1]  (id=1616)	
	[0]	RescueDamselQuest  (id=1609)	
/ CREATE BEAN WITH AUTOWIRED ARG
/ hier wordt inderdaad de bean create,  met het autowired arg	, met return ctor.newInstance(args);									

/s
CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory, Constructor<?>, Object[]) line: 114	
			return BeanUtils.instantiateClass(ctor, args);
ctor	Constructor<T>  (id=1430)	
args	Object[1]  (id=3634)	
	[0]	FakeMainPrintStream  (id=1624)	
/s
BeanUtils.instantiateClass(Constructor<T>, Object...) line: 145	
			ReflectionUtils.makeAccessible(ctor);
			return ctor.newInstance(args);															<-
/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 274	
			else {
				beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(
						mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
/d
beanInstance	RescueDamselQuest  (id=3904)	
	stream	FakeMainPrintStream  (id=1624)	
/ of	,
beanInstance	DamselRescuingKnight  (id=1721)	
	quest	RescueDamselQuest  (id=1609)	

			bw.setWrappedInstance(beanInstance);
/s
BeanWrapperImpl.setWrappedInstance(Object, String, Object) line: 217	
		this.object = object;
		this.nestedPath = (nestedPath != null ? nestedPath : "");
		this.rootObject = (!"".equals(this.nestedPath) ? rootObject : object);
		this.nestedBeanWrappers = null;
		this.typeConverterDelegate = new TypeConverterDelegate(this, object);
		setIntrospectionClass(object.getClass());
/t
ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor<?>[], Object[]) line: 275	
			bw.setWrappedInstance(beanInstance);
/d
			return bw;
...
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 506	
			instanceWrapper = createBeanInstance(beanName, mbd, args);
/d
		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);

/ we zien postbeanprocessors	,

/  1ste beanpostprocessor	.

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 909	

"getBeanPostProcessors()"	 (pending)	
	elementData	Object[10]  (id=3918)	
		[0]	ApplicationContextAwareProcessor  (id=3919)	
		[1]	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=1428)	
		[2]	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=3920)	
		[3]	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=1427)	
		[4]	CommonAnnotationBeanPostProcessor  (id=3921)		/ filecycle: op methods: @PostConstruct	, @PreDestroy	, injectiont: op fields & methods: @Webservice, @EjbRef	, @Resource
		[5]	AutowiredAnnotationBeanPostProcessor  (id=1410)	/ injections: op fields & methods, dus NIET op ctors: @Autowired
		[6]	RequiredAnnotationBeanPostProcessor  (id=3922)	
		[7]	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=1424)	
	size	8	

		try {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
bp	CommonAnnotationBeanPostProcessor  (id=3921)	

					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 282	
		super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
/s
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 124	
			LifecycleMetadata metadata = findLifecycleMetadata(beanType);
/s
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).findLifecycleMetadata(Class<?>) line: 181	
		// Quick check on the concurrent map first, with minimal locking.
		LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz);
		if (metadata == null) {
			synchronized (this.lifecycleMetadataCache) {
				metadata = this.lifecycleMetadataCache.get(clazz);
				if (metadata == null) {
					metadata = buildLifecycleMetadata(clazz);
/s
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).buildLifecycleMetadata(Class<?>) line: 191	
/=
	private LifecycleMetadata buildLifecycleMetadata(Class<?> clazz) { / clazz=class sia.knights.RescueDamselQuest
		final boolean debug = logger.isDebugEnabled();
/ TODO
			for (Method method : targetClass.getDeclaredMethods()) {
method=public void sia.knights.RescueDamselQuest.embark()		/ er is er maar 1	,

				if (this.initAnnotationType != null) {	 @PostConstruct
/j
					if (method.getAnnotation(this.initAnnotationType) != null) {
/n
				if (this.destroyAnnotationType != null) {		/ @PreDestroy
/j
					if (method.getAnnotation(this.destroyAnnotationType) != null) {
/n

			initMethods.addAll(0, currInitMethods);	/ []
			destroyMethods.addAll(currDestroyMethods);	/ []

			targetClass = targetClass.getSuperclass();	 / Object.class

		while (targetClass != null && targetClass != Object.class);
/n
		return new LifecycleMetadata(clazz, initMethods, destroyMethods);
/t
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).findLifecycleMetadata(Class<?>) line: 182	
					metadata = buildLifecycleMetadata(clazz);
/d
					this.lifecycleMetadataCache.put(clazz, metadata);
metadata	InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata  (id=3953)	
	checkedDestroyMethods	null	
	checkedInitMethods	null	
	destroyMethods	LinkedList<E>  (id=3951)		[]					/ geen @PreDestroy
	initMethods	LinkedList<E>  (id=3950)			[]				/ geen @PostConstruct
	targetClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	

				return metadata;
/t
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 125	
			LifecycleMetadata metadata = findLifecycleMetadata(beanType);
			metadata.checkConfigMembers(beanDefinition);
/t
CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 284	
		super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
/d
		if (beanType != null) {
			InjectionMetadata metadata = findResourceMetadata(beanName, beanType);
/s
CommonAnnotationBeanPostProcessor.findResourceMetadata(String, Class<?>) line: 329	
/=
	private InjectionMetadata findResourceMetadata(String beanName, final Class<?> clazz) {
beanName	"rescueDamselQuest" (id=1544)	
clazz	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	

		InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
null
					do {
						LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<InjectionMetadata.InjectedElement>();
						for (Field field : targetClass.getDeclaredFields()) {		
/ private java.io.PrintStream sia.knights.RescueDamselQuest.stream	, enigste	,

							if (webServiceRefClass != null && field.isAnnotationPresent(webServiceRefClass)) {
/n
							else if (ejbRefClass != null && field.isAnnotationPresent(ejbRefClass)) {
/n
							else if (field.isAnnotationPresent(Resource.class)) {
/n

						for (Method method : targetClass.getDeclaredMethods()) {
public void sia.knights.RescueDamselQuest.embark()

								if (webServiceRefClass != null && method.isAnnotationPresent(webServiceRefClass)) {
/n
								else if (ejbRefClass != null && method.isAnnotationPresent(ejbRefClass)) {
/n
								else if (method.isAnnotationPresent(Resource.class)) {
/n
						elements.addAll(0, currElements);

						targetClass = targetClass.getSuperclass();	/ Object
					}
					while (targetClass != null && targetClass != Object.class);
/n
					metadata = new InjectionMetadata(clazz, elements);
					this.injectionMetadataCache.put(cacheKey, metadata);
		return metadata;

/ In het totaal	, 
this	CommonAnnotationBeanPostProcessor  (id=3921)	
	injectionMetadataCache	ConcurrentHashMap<K,V>  (id=3971)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=4016)	
			key	"rescueDamselQuest" (id=1544)	
			value	InjectionMetadata  (id=4009)	
				checkedElements	null	
				injectedElements	LinkedList<E>  (id=3982)	 / hierin hadden @Webservice, @EjbRef, @Resource fields & methods gestaan	, 
				logger	Log4JLogger  (id=4021)	
				targetClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=4017)	
			key	"fakeMainPrintStream" (id=2168)	
			value	InjectionMetadata  (id=4023)	
				checkedElements	LinkedHashSet<E>  (id=4046)	
				injectedElements	LinkedList<E>  (id=4047)	/ hierin hadden @Webservice, @EjbRef, @Resource fields & methods gestaan	, 
				logger	Log4JLogger  (id=4021)	
				targetClass	Class<T> (sia.knights.FakeMainPrintStream) (id=1625)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=4018)	
			key	"knightMainConfig" (id=2572)	
			value	InjectionMetadata  (id=4027)	
				checkedElements	LinkedHashSet<E>  (id=4030)	
				injectedElements	LinkedList<E>  (id=4031)	/ hierin hadden @Webservice, @EjbRef, @Resource fields & methods gestaan	, 
				logger	Log4JLogger  (id=4021)	
				targetClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=56)	

	lifecycleMetadataCache	ConcurrentHashMap<K,V>  (id=3932)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=4156)	
			key	Class<T> (sia.knights.FakeMainPrintStream) (id=1625)	
			value	InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata  (id=4160)	
				checkedDestroyMethods	LinkedHashSet<E>  (id=4165)	
				checkedInitMethods	LinkedHashSet<E>  (id=4166)	
				destroyMethods	LinkedList<E>  (id=4167) / hierin hadden @PreDestroy methods gestaan	,	
				initMethods	LinkedList<E>  (id=4169)	/ hierin hadden @PostConstruct methods gestaan	,	
				targetClass	Class<T> (sia.knights.FakeMainPrintStream) (id=1625)	
				this$0	CommonAnnotationBeanPostProcessor  (id=3921)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=4157)	
			key	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=56)	
			value	InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata  (id=4162)	
				checkedDestroyMethods	LinkedHashSet<E>  (id=4175)	
				checkedInitMethods	LinkedHashSet<E>  (id=4176)	
				destroyMethods	LinkedList<E>  (id=4177)	/ hierin hadden @PreDestroy methods gestaan	,	
				initMethods	LinkedList<E>  (id=4178)	/ hierin hadden @PostConstruct methods gestaan	,	
				targetClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=56)	
				this$0	CommonAnnotationBeanPostProcessor  (id=3921)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=4158)	
			key	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
			value	InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata  (id=3953)	
				checkedDestroyMethods	LinkedHashSet<E>  (id=4182)	
				checkedInitMethods	LinkedHashSet<E>  (id=3969)	
				destroyMethods	LinkedList<E>  (id=3951)	/ hierin hadden @PreDestroy methods gestaan	,	
				initMethods	LinkedList<E>  (id=3950)	/ hierin hadden @PostConstruct methods gestaan	,	
				targetClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
				this$0	CommonAnnotationBeanPostProcessor  (id=3921)	

/t
CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 285	
			InjectionMetadata metadata = findResourceMetadata(beanName, beanType);
/d
			metadata.checkConfigMembers(beanDefinition);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 906	

/ volgende	, 
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
bp	AutowiredAnnotationBeanPostProcessor  (id=1410)	

					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
beanName	"rescueDamselQuest" (id=1544)	
/s
AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 221	
		if (beanType != null) {
			InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType);
/s
AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata(String, Class<?>) line: 319	
		String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
		InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
null
					metadata = buildAutowiringMetadata(clazz);
/s
AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(Class<?>) line: 338	

			for (Field field : targetClass.getDeclaredFields()) { 
private java.io.PrintStream sia.knights.RescueDamselQuest.stream	, enigste	,

				AnnotationAttributes annotation = findAutowiredAnnotation(field);
/s
AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AccessibleObject) line: 383	
		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
interface org.springframework.beans.factory.annotation.Autowired, 

			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
null

/ volgende	,
		for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
interface org.springframework.beans.factory.annotation.Value

			AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(ao, type.getName());
null

		return null;
/t
AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(Class<?>) line: 341	
			for (Field field : targetClass.getDeclaredFields()) {
				AnnotationAttributes annotation = findAutowiredAnnotation(field);
/d
null

			for (Method method : targetClass.getDeclaredMethods()) {
public void sia.knights.RescueDamselQuest.embark()
				AnnotationAttributes annotation = BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod) ?
						findAutowiredAnnotation(bridgedMethod) : findAutowiredAnnotation(method);
null
			elements.addAll(0, currElements);
			targetClass = targetClass.getSuperclass();
		}
		while (targetClass != null && targetClass != Object.class);
/n

		return new InjectionMetadata(clazz, elements);
/t
AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata(String, Class<?>) line: 326	
					metadata = buildAutowiringMetadata(clazz);
					this.injectionMetadataCache.put(cacheKey, metadata);
		return metadata;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyMergedBeanDefinitionPostProcessors(RootBeanDefinition, Class<?>, String) line: 906	
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor@568ff82
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/ leeg	, 
/ TODO

/ volgende	, 
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
org.springframework.context.support.PostProcessorRegistrationDelegate$ApplicationListenerDetector@50caa560
				if (bp instanceof MergedBeanDefinitionPostProcessor) {
					MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
					bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
/s
PostProcessorRegistrationDelegate$ApplicationListenerDetector.postProcessMergedBeanDefinition(RootBeanDefinition, Class<?>, String) line: 338	
			if (beanDefinition.isSingleton()) {
/j
				this.singletonNames.put(beanName, Boolean.TRUE);
{rescueDamselQuest=true, fakeMainPrintStream=true, damselRescuingKnight=true, knightMainConfig=true}
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 513	
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
/d
				mbd.postProcessed = true;

/ Intermezzo

/ je kunt @Autowired op de ctor resp method set	,
/ in xml doe je dan <constructor-arg ...> resp <property ...>
/ dus met annotaties makkelijker

/ Einde Intermezzo


		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
beanName	"rescueDamselQuest" (id=1544)	
instanceWrapper	BeanWrapperImpl  (id=1708)	
	object	RescueDamselQuest  (id=3904)	
		stream	FakeMainPrintStream  (id=1624)	
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1128	
		PropertyValues pvs = mbd.getPropertyValues();
pvs	MutablePropertyValues  (id=3773)	PropertyValues: length=0
/ TODO

/ 2de beanpostprocessor	. 

		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=1427)	
bp	CommonAnnotationBeanPostProcessor  (id=3921)	
bp	AutowiredAnnotationBeanPostProcessor  (id=1410)	
bp	RequiredAnnotationBeanPostProcessor  (id=3922)	
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
/s
						return true;

		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
true
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);
false
		if (hasInstAwareBpps || needsDepCheck) {
/j

this	DefaultListableBeanFactory  (id=1408)	
	filteredPropertyDescriptorsCache	ConcurrentHashMap<K,V>  (id=2224)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=4325)	
			key	Class<T> (sia.knights.FakeMainPrintStream) (id=1625)	
			value	PropertyDescriptor[2]  (id=4328)	
				[0]	GenericTypeAwarePropertyDescriptor  (id=4330)	
					beanClass	Class<T> (sia.knights.FakeMainPrintStream) (id=1625)	
					name	"class" (id=4332)	
				[1]	GenericTypeAwarePropertyDescriptor  (id=4331)	
					beanClass	Class<T> (sia.knights.FakeMainPrintStream) (id=1625)	
					name	"printedString" (id=4344)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=4327)	
			key	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=56)	
			value	PropertyDescriptor[1]  (id=4329)	
				[0]	GenericTypeAwarePropertyDescriptor  (id=4361)	
					beanClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28) (id=56)	
					name	"class" (id=4332)	

			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
null
bw	BeanWrapperImpl  (id=1708)	
	object	RescueDamselQuest  (id=3904)	

						filtered = filterPropertyDescriptorsForDependencyCheck(bw);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).filterPropertyDescriptorsForDependencyCheck(BeanWrapper) line: 1343	
		List<PropertyDescriptor> pds =
				new LinkedList<PropertyDescriptor>(Arrays.asList(bw.getPropertyDescriptors()));
"bw.getPropertyDescriptors()"	 (pending)	
	[0]	GenericTypeAwarePropertyDescriptor  (id=4472)	
		beanClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
		name	"class" (id=4332)	
/ TODO
		return pds.toArray(new PropertyDescriptor[pds.size()]);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).filterPropertyDescriptorsForDependencyCheck(BeanWrapper, boolean) line: 1324	
						filtered = filterPropertyDescriptorsForDependencyCheck(bw);
/d
						this.filteredPropertyDescriptorsCache.put(bw.getWrappedClass(), filtered);

this	DefaultListableBeanFactory  (id=1408)	
	filteredPropertyDescriptorsCache	ConcurrentHashMap<K,V>  (id=2224)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=4576)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=4577)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=4578)	
			key	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
			value	PropertyDescriptor[1]  (id=4553)	
				[0]	GenericTypeAwarePropertyDescriptor  (id=4472)	
					beanClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	
					name	"class" (id=4332)	


		return filtered;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1182	
			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
/d

/ 3de beanpostprocoessor	, 

				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=1427)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/ niets	,

/ volgende
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	CommonAnnotationBeanPostProcessor  (id=3921)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/s
CommonAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 303	
		InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass());	/ al eerder set	, 
metadata	InjectionMetadata  (id=4009)	
	checkedElements	LinkedHashSet<E>  (id=4667)	[]
	injectedElements	LinkedList<E>  (id=3982)	[] / hierin hadden @Webservice, @EjbRef, @Resource fields & methods gestaan	, 
	logger	Log4JLogger  (id=4021)	
	targetClass	Class<T> (sia.knights.RescueDamselQuest) (id=1433)	

			metadata.inject(bean, beanName, pvs);
/ niets, want checkedElements=[]
/ TODO
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1198	
/ volgende
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	AutowiredAnnotationBeanPostProcessor  (id=1410)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/ dezelfde method als bij CommonAnnotationBeanPostProcessor  hier vlak boven	, 
/ TODO

/ volgende
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
bp	RequiredAnnotationBeanPostProcessor  (id=3922)	
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
/s
RequiredAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 161	
			this.validatedBeanNames.add(beanName);
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1198	
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
/ geen	, 
		applyPropertyValues(beanName, mbd, bw, pvs);
/ er is er nu geen 1, 
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 538	
			populateBean(beanName, mbd, instanceWrapper);
/d
			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1541	
		else {
			invokeAwareMethods(beanName, bean);
/ niets

/ 4de beanpostprocessor	,

		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/s

		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	ApplicationContextAwareProcessor  (id=3919)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
ApplicationContextAwareProcessor.postProcessBeforeInitialization(Object, String) line: 94	
		else {
			invokeAwareInterfaces(bean);
/s
ApplicationContextAwareProcessor.invokeAwareInterfaces(Object) line: 122	
		if (bean instanceof Aware) {
/n
/t
ApplicationContextAwareProcessor.postProcessBeforeInitialization(Object, String) line: 94	
		else {
			invokeAwareInterfaces(bean);
		return bean;
/d
	
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 408	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	PostProcessorRegistrationDelegate$BeanPostProcessorChecker  (id=1428)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
				return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=3920)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor.postProcessBeforeInitialization(Object, String) line: 413	
			if (bean instanceof ImportAware) {
/n
			return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor  (id=1427)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).postProcessBeforeInitialization(Object, String) line: 77	
		return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	CommonAnnotationBeanPostProcessor  (id=3921)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessBeforeInitialization(Object, String) line: 131	
		LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());	 / is er	,
		try {
			metadata.invokeInitMethods(bean, beanName);
/s
		LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
		try {
			metadata.invokeInitMethods(bean, beanName);
/s
InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(Object, String) line: 303	
			Collection<LifecycleElement> initMethodsToIterate =
					(this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods);
/j
[]
			if (!initMethodsToIterate.isEmpty()) {
/n
/t
CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessBeforeInitialization(Object, String) line: 141	
			metadata.invokeInitMethods(bean, beanName);
/d
		return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	AutowiredAnnotationBeanPostProcessor  (id=1410)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
AutowiredAnnotationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).postProcessBeforeInitialization(Object, String) line: 77	
		return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	RequiredAnnotationBeanPostProcessor  (id=3922)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
RequiredAnnotationBeanPostProcessor(InstantiationAwareBeanPostProcessorAdapter).postProcessBeforeInitialization(Object, String) line: 77	
		return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ volgende	,
		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
beanProcessor	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=1424)	

			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/s
PostProcessorRegistrationDelegate$ApplicationListenerDetector.postProcessBeforeInitialization(Object, String) line: 344	
			return bean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 407	
			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
/d
/ geen volgende	,
		return result;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1550	
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
/d
		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
/s
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).invokeInitMethods(String, Object, RootBeanDefinition) line: 1618	
		boolean isInitializingBean = (bean instanceof InitializingBean);
f
		if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
/n
		if (mbd != null) {
			String initMethodName = mbd.getInitMethodName();
null
			if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
/n
					!mbd.isExternallyManagedInitMethod(initMethodName)) {
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1559	
		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
/d

/ 5de beanpostprocessor	,

		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
/ alle beanpostprocoessors doen niets

		return wrappedBean;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 549	
				exposedObject = initializeBean(beanName, exposedObject, mbd);
/d

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
null
			if (earlySingletonReference != null) {
/n

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
/s
DefaultListableBeanFactory(AbstractBeanFactory).registerDisposableBeanIfNecessary(String, Object, RootBeanDefinition) line: 1555	
		if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
			if (mbd.isSingleton()) {
				// Register a DisposableBean implementation that performs all destruction
				// work for the given bean: DestructionAwareBeanPostProcessors,
				// DisposableBean interface, custom destroy method.
				registerDisposableBean(beanName,
						new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
/s
DisposableBeanAdapter.<init>(Object, String, RootBeanDefinition, List<BeanPostProcessor>, AccessControlContext) line: 139	
		this.bean = bean;
		this.beanName = beanName;
		this.invokeDisposableBean =
				(this.bean instanceof DisposableBean && !beanDefinition.isExternallyManagedDestroyMethod("destroy"));
f
		this.nonPublicAccessAllowed = beanDefinition.isNonPublicAccessAllowed();
t
		this.acc = acc;
		String destroyMethodName = inferDestroyMethodIfNecessary(bean, beanDefinition);
null
		if (destroyMethodName != null && ...
/n
		this.beanPostProcessors = filterPostProcessors(postProcessors);
/s
class DisposableBeanAdapter implements DisposableBean, Runnable, Serializable {
	private List<DestructionAwareBeanPostProcessor> filterPostProcessors(List<BeanPostProcessor> postProcessors) {
		List<DestructionAwareBeanPostProcessor> filteredPostProcessors = null;
		if (postProcessors != null && !postProcessors.isEmpty()) {
			filteredPostProcessors = new ArrayList<DestructionAwareBeanPostProcessor>(postProcessors.size());
			for (BeanPostProcessor postProcessor : postProcessors) {
				if (postProcessor instanceof DestructionAwareBeanPostProcessor) {
					filteredPostProcessors.add((DestructionAwareBeanPostProcessor) postProcessor);
				}
			}
		}
		return filteredPostProcessors;
/t
DisposableBeanAdapter.<init>(Object, String, RootBeanDefinition, List<BeanPostProcessor>, AccessControlContext) line: 139	
		this.beanPostProcessors = filterPostProcessors(postProcessors);
/d
this	DisposableBeanAdapter  (id=4715)	
	beanPostProcessors	ArrayList<E>  (id=4721)	
		[0]	CommonAnnotationBeanPostProcessor  (id=3921)	
		[1]	PostProcessorRegistrationDelegate$ApplicationListenerDetector  (id=1424)	
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 584	
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
/d
		return exposedObject;
/t
DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 479	
		Object beanInstance = doCreateBean(beanName, mbd, args);
/d
		return beanInstance;
/t
AbstractBeanFactory$1.getObject() line: 302	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);		<-
/d
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
					singletonObject = singletonFactory.getObject();
/d
				addSingleton(beanName, singletonObject);
/s
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).addSingleton(String, Object) line: 143	
			this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
/t
DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 228	
				addSingleton(beanName, singletonObject);
/d
			return (singletonObject != NULL_OBJECT ? singletonObject : null);
/t
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 298	
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {		<-
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
/d
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
		return (T) bean;
/t
DefaultListableBeanFactory.preInstantiateSingletons() line: 706	
					getBean(beanName);
/d
/ volgende	, 
		// Trigger initialization of all non-lazy singleton beans...
		for (String beanName : beanNames) {																/ damselRescuingKnight
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
/n
				else {
					getBean(beanName);
/s
/ We geloven het	, 
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 763	
		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
/d
this	AnnotationConfigApplicationContext  (id=22)	
beanFactory	DefaultListableBeanFactory  (id=21)	
	singletonObjects	ConcurrentHashMap<K,V>  (id=1086)	
		[0]	ConcurrentHashMap$MapEntry<K,V>  (id=1651)	
		[1]	ConcurrentHashMap$MapEntry<K,V>  (id=1652)	
		[2]	ConcurrentHashMap$MapEntry<K,V>  (id=1653)	
		[3]	ConcurrentHashMap$MapEntry<K,V>  (id=1654)	
		[4]	ConcurrentHashMap$MapEntry<K,V>  (id=1655)	
		[5]	ConcurrentHashMap$MapEntry<K,V>  (id=1656)	
		[6]	ConcurrentHashMap$MapEntry<K,V>  (id=1658)	
		[7]	ConcurrentHashMap$MapEntry<K,V>  (id=1659)	
		[8]	ConcurrentHashMap$MapEntry<K,V>  (id=1660)	
		[9]	ConcurrentHashMap$MapEntry<K,V>  (id=1661)	
		[10]	ConcurrentHashMap$MapEntry<K,V>  (id=1662)	
			key	"damselRescuingKnight" (id=1466)	
			value	DamselRescuingKnight  (id=1520)	
				quest	RescueDamselQuest  (id=1522)											<-
		[11]	ConcurrentHashMap$MapEntry<K,V>  (id=1663)	
			key	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=1528)	
			value	AutowiredAnnotationBeanPostProcessor  (id=1437)	
		[12]	ConcurrentHashMap$MapEntry<K,V>  (id=1664)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importRegistry" (id=1677)	
			value	ConfigurationClassParser$ImportStack  (id=1678)	
		[13]	ConcurrentHashMap$MapEntry<K,V>  (id=1665)	
			key	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=1534)	
			value	ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor  (id=1676)	
		[14]	ConcurrentHashMap$MapEntry<K,V>  (id=1666)	
			key	"knightMainConfig" (id=1433)	
			value	KnightMainConfig$$EnhancerBySpringCGLIB$$eb55fb28  (id=1440)	
		[15]	ConcurrentHashMap$MapEntry<K,V>  (id=1667)	
			key	"applicationEventMulticaster" (id=1674)	
			value	SimpleApplicationEventMulticaster  (id=1675)	
		[16]	ConcurrentHashMap$MapEntry<K,V>  (id=1668)	
			key	"messageSource" (id=1672)	
			value	DelegatingMessageSource  (id=1673)	
		[17]	ConcurrentHashMap$MapEntry<K,V>  (id=1669)	
			key	"environment" (id=1670)	
			value	StandardEnvironment  (id=1671)	

/ we zien de autowired ctor arg RescueDamselQuest als quest prop in DamselRescuingKnight 

/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 485	
				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);
/d
				// Last step: publish corresponding event.
				finishRefresh();
/s
	/**
	 * Finish the refresh of this context, invoking the LifecycleProcessor's
	 * onRefresh() method and publishing the
	 * {@link org.springframework.context.event.ContextRefreshedEvent}.
	 */
AnnotationConfigApplicationContext(AbstractApplicationContext).finishRefresh() line: 772	
		// Initialize lifecycle processor for this context.
		initLifecycleProcessor();
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).initLifecycleProcessor() line: 697	
		if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {	/ "lifecycleProcessor"
/n
		else {
			DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();
			defaultProcessor.setBeanFactory(beanFactory);
			this.lifecycleProcessor = defaultProcessor;
			beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).finishRefresh() line: 775	
		// Initialize lifecycle processor for this context.
		initLifecycleProcessor();
/d
		// Propagate refresh to lifecycle processor first.
		getLifecycleProcessor().onRefresh();
/s
DefaultLifecycleProcessor.onRefresh() line: 112	
		startBeans(true);
/s
DefaultLifecycleProcessor.startBeans(boolean) line: 131	
		Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();
/s
DefaultLifecycleProcessor.getLifecycleBeans() line: 272	
		String[] beanNames = this.beanFactory.getBeanNamesForType(Lifecycle.class, false, false);
[lifecycleProcessor]
		for (String beanName : beanNames) {
			String beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);
			boolean isFactoryBean = this.beanFactory.isFactoryBean(beanNameToRegister);
f
			String beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);
			if ((this.beanFactory.containsSingleton(beanNameToRegister) &&
					(!isFactoryBean || Lifecycle.class.isAssignableFrom(this.beanFactory.getType(beanNameToCheck)))) ||
					SmartLifecycle.class.isAssignableFrom(this.beanFactory.getType(beanNameToCheck))) {
				Lifecycle bean = this.beanFactory.getBean(beanNameToCheck, Lifecycle.class);
/ is er al	,
bean	DefaultLifecycleProcessor  (id=1746)	
				if (bean != this) {
/n
					beans.put(beanNameToRegister, bean);
/n
		return beans;
{}
/t
DefaultLifecycleProcessor.startBeans(boolean) line: 152	
		Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();
/ doet verder niets	,
		return beans;
{}
/t
DefaultLifecycleProcessor.onRefresh() line: 113	
		startBeans(true);
/d
		this.running = true;
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).finishRefresh() line: 778	
		// Propagate refresh to lifecycle processor first.
		getLifecycleProcessor().onRefresh();
/d
		// Publish the final event.
		publishEvent(new ContextRefreshedEvent(this));
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).publishEvent(ApplicationEvent) line: 333	
		getApplicationEventMulticaster().multicastEvent(event);
/s
		for (final ApplicationListener listener : getApplicationListeners(event)) {
[]
/s
SimpleApplicationEventMulticaster(AbstractApplicationEventMulticaster).getApplicationListeners(ApplicationEvent) line: 158	
		Class<? extends ApplicationEvent> eventType = event.getClass();
		Object source = event.getSource();
		Class<?> sourceType = (source != null ? source.getClass() : null);
		ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);
org.springframework.context.event.AbstractApplicationEventMulticaster$ListenerCacheKey@cd16862c
		ListenerRetriever retriever = this.retrieverCache.get(cacheKey);
org.springframework.context.event.AbstractApplicationEventMulticaster$ListenerRetriever@2b91004a
		if (retriever != null) {
			return retriever.getApplicationListeners();
/s
AbstractApplicationEventMulticaster$ListenerRetriever.getApplicationListeners() line: 296	
			for (ApplicationListener<?> listener : this.applicationListeners) {
[]
			if (!this.applicationListenerBeans.isEmpty()) {
/n
			return allListeners;
[]
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).finishRefresh() line: 781	
		// Participate in LiveBeansView MBean, if active.
		LiveBeansView.registerApplicationContext(this);
/s
LiveBeansView.registerApplicationContext(ConfigurableApplicationContext) line: 61	
		String mbeanDomain = applicationContext.getEnvironment().getProperty(MBEAN_DOMAIN_PROPERTY_NAME);	/ "spring.liveBeansView.mbeanDomain"
/ niets verder	, 
/t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 499	
				// Last step: publish corresponding event.
				finishRefresh();
/t
KnightMain.main(String[]) line: 12	
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);
/d
    Knight knight=(Knight)context.getBean("braveKnight");
/s
AnnotationConfigApplicationContext(AbstractApplicationContext).getBean(String) line: 974	
		return getBeanFactory().getBean(name);
...
/s
DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 240	
		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
sharedInstance	BraveKnight  (id=1800)	
	quest	SlayDragonQuest  (id=1802)	
		return (T) bean;
/t
KnightMain.main(String[]) line: 13	
    Knight knight=(Knight)context.getBean("braveKnight");
/d
    knight.embarkOnQuest();
/s
BraveKnight.embarkOnQuest() line: 18	
    quest.embark();
/s
SlayDragonQuest.embark() line: 21	
/=
    stream.println("Embarking on quest to slay the dragon!");

this	SlayDragonQuest  (id=1802)	
	stream	PrintStream  (id=1818)	

/ Intermezzo

/ 13	.

public class KnightMain {
  public static void main(String[] args) throws Exception {
   
    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(KnightMainConfig.class);
//    Knight knight = context.getBean(Knight.class);
    Knight knight=(Knight)context.getBean("braveKnight");
/ TODO Kies de andere	,  

/ 13	. 

@Component
public class SlayDragonQuest implements Quest {

	@Value("#{T(java.lang.System).out}")						<-	 TODO
 	 private PrintStream stream;

  @Autowired
  public SlayDragonQuest(PrintStream stream) {
    this.stream = stream;
  }

  public void embark() {
    stream.println("Embarking on quest to slay the dragon!");
  }

/ Einde Intermezzo



















/ Einde DEBUG SPRING

/ SPRING API DOCS

/ 13	. 

/ MergedBeanDefinitions bestaat niet	, 

public interface MergedBeanDefinitionPostProcessor extends BeanPostProcessor

Post-processor callback interface for merged bean definitions at runtime. BeanPostProcessor implementations may implement this sub-interface in order to post-process the merged bean definition (a processed copy of the original bean definition) that the Spring BeanFactory uses to create a bean instance.

/ 13	. 

**
 * {@link BeanFactoryPostProcessor} used for bootstrapping processing of
 * {@link Configuration @Configuration} classes.
 *
 * <p>Registered by default when using {@code <context:annotation-config/>} or
 * {@code <context:component-scan/>}. Otherwise, may be declared manually as
 * with any other BeanFactoryPostProcessor.
 *
 * <p>This post processor is {@link Ordered#HIGHEST_PRECEDENCE} as it is important
 * that any {@link Bean} methods declared in Configuration classes have their
 * respective bean definitions registered before any other BeanFactoryPostProcessor
 * executes.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @author Phillip Webb
 * @since 3.0
 */
public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,
		PriorityOrdered, 																																						<-
	 	ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware {

/ 13	 .

/ Verschil BeanFactoryPostProcessor en BeanPostProcessor	, 
/ een BeanFactoryPostProcessor past bean def aan	, een BeanPostProcessor een bean inst	,


public interface BeanFactoryPostProcessor
Allows for custom modification of an application context's bean definitions, adapting the bean property values of the context's underlying bean factory.
Application contexts can auto-detect BeanFactoryPostProcessor beans in their bean definitions and apply them before any other beans get created.

Useful for custom config files targeted at system administrators that override bean properties configured in the application context.

See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs.

A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead.

/ en	, 

public interface BeanPostProcessor
Factory hook that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies.
ApplicationContexts can autodetect BeanPostProcessor beans in their bean definitions and apply them to any beans subsequently created. Plain bean factories allow for programmatic registration of post-processors, applying to all beans created through this factory.

Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization(java.lang.Object, java.lang.String), while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization(java.lang.Object, java.lang.String).

/ 13	. 


/ Einde SPRING API DOCS

/ SPRING PROPERTY VALUES

/ Lees	, 
https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-beans

company.setPropertyValue("name", "Some Company Inc.");

/ is dit hetzelfde als in xml <property ...>

/ Lees	, 
https://www.petrikainulainen.net/programming/spring-framework/spring-from-the-trenches-injecting-property-values-into-configuration-beans/



/ Einde SPRING PROPERTY VALUES

/ SPRING LOGGING

/ Lees	, 
https://www.tutorialspoint.com/spring/logging_with_log4j.htm

/ Einde SPRING LOGGING

/ SPRING THEORY

http://stackoverflow.com/questions/29743320/how-exactly-works-the-spring-bean-post-processor
->
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-extension-bpp




/ Einde SPRING THEORY

/ DEBUG @CONFIGURATION

/ stack	
/s
	PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94		 / See IMPORTANT METHODS
	AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
	AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
	AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
	KnightMain.main(String[]) line: 10	

/ debug	, 
/s
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
/s
PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessBeanDefinitionRegistry(registry);
/s
ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 226	
/ Gaat bean defs van andere beans register	, 

		registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);
Root bean: class [org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor]; ...
		registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);
Root bean: class [org.springframework.context.annotation.ConfigurationClassPostProcessor$EnhancedConfigurationBeanPostProcessor]; ... 
		processConfigBeanDefinitions(registry);
/s
ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 272	
		for (String beanName : registry.getBeanDefinitionNames()) {
"registry.getBea...finitionNames()"	 (pending)	
	[0]	"org.springframework.context.annotation.internalConfigurationAnnotationProcessor" (id=131)	
	[1]	"org.springframework.context.annotation.internalAutowiredAnnotationProcessor" (id=132)	
	[2]	"org.springframework.context.annotation.internalRequiredAnnotationProcessor" (id=134)	
	[3]	"org.springframework.context.annotation.internalCommonAnnotationProcessor" (id=136)	
	[4]	"knightMainConfig" (id=138)	
	[5]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor" (id=1368)	
	[6]	"org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor" (id=1398)	
			else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
configCandidates=
[Bean definition with name 'knightMainConfig': Generic bean: class [sia.knights.KnightMainConfig]; ... 

		// Parse each @Configuration class
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
		parser.parse(configCandidates);
/s
ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 151	
					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
/s
ConfigurationClassParser.parse(Class<?>, String) line: 185	
		processConfigurationClass(new ConfigurationClass(clazz, beanName));
/s
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 190	
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 235	

/ WHERE @COMPONENTSCAN OF @BEAN
/ Dit is 'm 	, de method die @ComponentScan of @Bean process	,
/ Dus @Configuration class post processor ( post processes a @Configuration annotated class) calls for process de @ComponentScan  annot	TODO , 

		// Process any @ComponentScan annotations
		AnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);
			// The config class is annotated with @ComponentScan -> perform the scan immediately
			Set<BeanDefinitionHolder> scannedBeanDefinitions =
				this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/s
ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 73	
		return scanner.doScan(StringUtils.toStringArray(basePackages));
[sia.knights]
/s
ClassPathBeanDefinitionScanner.doScan(String...) line: 239	




/ Einde DEBUG @CONFIGURATION

/ DEBUG @CONFIGURATION

/ 7	. 

/ Nogmaals	,

sia.knights.KnightMain at localhost:45494	
	Thread [main] (Suspended)	
		owns: Object  (id=83)	
		AnnotationTypeFilter.matchSelf(MetadataReader) line: 83	
		AnnotationTypeFilter(AbstractTypeHierarchyTraversingFilter).match(MetadataReader, MetadataReaderFactory) line: 61	
		ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).isCandidateComponent(MetadataReader) line: 344	
		ClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 278	
		ClassPathBeanDefinitionScanner.doScan(String...) line: 242	
		ComponentScanAnnotationParser.parse(AnnotationAttributes, String) line: 134	
		ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 248	
		ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 218	
		ConfigurationClassParser.parse(Class<?>, String) line: 185	
		ConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 155	
		ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 305	
		ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 243	
		PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry) line: 254	
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 94	
		AnnotationConfigApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 611	
		AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 464	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
/cb
		AnnotationConfigApplicationContext.<init>(Class<?>...) line: 84	
		KnightMain.main(String[]) line: 10	

/ we zien dat we eerst @Configuration parse met ConfigurationClassParser	, en dan @ComponentScan met ComponentScanAnnotationParser	,
/ dat is logisch	, 

@Configuration
@ComponentScan
class KnightMainConfig

/ ComponentScanAnnotationParser calls ClassPathBeanDefinitionScanner.doScan met basePackage sia.knights	, die  for (Resource resource : resources) { doet (dat zijn er 12	, waaronder RescueDamselQuest	, ... ) en een MetaDataReader om elke Resource maakt	, 
/ ClassPathDefinitionScanner.isCandidateComponent uses filters , die kijken of de resource de @Component heeft	,
/ de metaData van de resource heeft annotationSet	, en daar zit @Component in	,

/ 7	. 

/ Even later	,

ClassPathBeanDefinitionScanner.doScan(String...) line: 257	
		for (String basePackage : basePackages) {											/ sia.knights
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage); / rescueDamselQuest	, ... 	, met @Component	, 
			for (BeanDefinition candidate : candidates) {
					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
					registerBeanDefinition(definitionHolder, this.registry);
/ komt in 
this	DefaultListableBeanFactory  (id=25)	
	beanDefinitionMap	ConcurrentHashMap<K,V>  (id=122)	
	beanDefinitionNames	ArrayList<E>  (id=123)	
////////////////////////////////////////////////////
/ een @Component annot type wordt dus een bean		!
/ er zijn nu alleen nog class types registered	, er zijn nog geen insts	,

/t
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 250	
/ METHOD WHERE @COMPONENETSCAN AND @BEAN
		// Process any @ComponentScan annotations
			Set<BeanDefinitionHolder> scannedBeanDefinitions =


		// Process individual @Bean methods
		Set<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}


/ 13	. 
/ we waren in	, 
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 250	
					this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
/d
/ rescueDamselQuest	, ...
			for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
				if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
					parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
...
/s
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 195	
		ConfigurationClass existingClass = this.configurationClasses.get(configClass);
configClass = ConfigurationClass:beanName=rescueDamselQuest,resource=class path resource [sia/knights/RescueDamselQuest.class]	
/////////////////////////////////////////////////////////////////////////////////
/ Dus nu is RescueDamselQuest de config class	, niet KnightMainConfig	, 
/ we gaan deze parse	, maar daarin zijn geen @ComponentScan of @Bean	, dus doet niets hiermee	, 

			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
/s
ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClass, ConfigurationClassParser$SourceClass) line: 235	
/////////////////////////////////////////////////////////////////////
/ we komen weer in de method die @ComponentScan en @Bean handles	, 
		return null;
/t
ConfigurationClassParser.processConfigurationClass(ConfigurationClass) line: 222	
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
null
		this.configurationClasses.put(configClass, configClass);


/ 13	. 

/ Later	, 
/t
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 126	
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
/d
			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
/s
ConfigurationClassPostProcessor.enhanceConfigurationClasses(ConfigurableListableBeanFactory) line: 385	
/ enhances KnightMainConfig 	, die full is	, 
beanDef	AnnotatedGenericBeanDefinition  (id=1473)	
	beanClass	Class<T> (sia.knights.KnightMainConfig$$EnhancerBySpringCGLIB$$5b92458a) (id=2208)	

/ 13	. 

/ t
AnnotationConfigApplicationContext(AbstractApplicationContext).refresh() line: 467	
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

/ MORGENOCHTEND	
/ Knight2	, 
/ wanneer Spring beans def create	, 
/ / wanneer bean insts create	,
/ wanneer bean, zoals RescueDamselQuest worden parsed	, zodat @Autowired wordt gevonden	, 

 


/ Einde DEBUG @CONFIGURATION
