/ See CAMEL TEST FRAMEWORK

/ 7	. 

[eric@almond Eclipse]$ pwd
/home/eric/Devel/Eclipse
[eric@almond Eclipse]$ eclipse-java-2019-06-R-linux-gtk-x86_64/eclipse/eclipse
~/Devel/workspacesworkspace_camel



/ 7	. 

/ google,
camel narayana

/ lees	,
https://github.com/christian-posta/spring-boot-camel-narayana/blob/master/README.md
/ lees	,
https://access.redhat.com/documentation/en-us/red_hat_fuse/7.1/html/transaction_guide/configuring-narayana

/ google	,
camel activemq jta
/ lees	,
https://camel.apache.org/how-do-i-make-my-jms-endpoint-transactional.html
/ kijk
https://www.youtube.com/watch?v=22OW5t_Mbnk&t=341s

/ google	,
activemq routing
/ lees,	
https://examples.javacodegeeks.com/enterprise-java/apache-camel/apache-camel-routing-tutorial/

/ lees	,
http://activemq.apache.org/components/artemis/documentation/
https://camel.apache.org/index.html

/ 7	. 

[eric@almond demo]$ mkdir ~/Devel/workspaces/workspace_camel

[eric@almond misc_codebase]$ pwd
/home/eric/misc_codebase
[eric@almond misc_codebase]$ unzip  ~/Downloads/camelinaction-master.zip 

[eric@almond Eclipse]$ eclipse-java-2019-06-R-linux-gtk-x86_64/eclipse/eclipse 
/ op workspace_camel
/ disable validation	,

/ toggle off Build automatically	,
File, Import, Maven project,
/home/eric/misc_codebase/camelinaction-master
/ hij gaat wel alle deps import	, ook sources en javadoc	, dus dat gaat gewoon door,	
/ we use eclipse's mvn	, 
/ we check Build automatically	, 
/ we zien 7 Errors	,
/ Maven, Maven update	,
/ TODO was dit nodig?
/ we zien projects zoals chapter1 en chapter1-file-copy. Alleen de laatste is een Java (Maven) project, dat zie je aan de J in het icon	,

/ 7	. 

/ google,
log4j pattern layout	,
/ lees 	,
https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html
https://www.tutorialspoint.com/log4j/log4j_patternlayout

/ 7	. 

FileCopierWithCamel, right click,	 
/ In console zien we de logging	,

/ 7	. 

$ vi parent/pom.xml
...
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>2.5</version>
          <configuration>
            <source>1.8</source>
            <target>1.8</target>

/ was 1.7, 
/ select all projects, Maven update	, 
/ we zien in build path JavaSE-1.8

/ 7	. 

/ google,
camel routesbuilder functional interface
/ lees	,
https://stackoverflow.com/questions/31482093/why-cant-functionalinterface-be-applied-to-a-sam-abstract-base-class

/ RoutesBuilder of RouteBuilder (TODO) is geen functional interface	, dus lambdas gaat niet 	,

/ er staat hoe wel toch wel kan	,

public static RouteBuilder fromConfigurator(Consumer<RouteBuilder> configurator) {
    return new RouteBuilder() {
        public void configure() {
            configurator.accept(this);
        }
    }
}
And use it like this:

context.addRoutes(fromConfigurator(
    rb->rb.from("file:data/inbox?noop=true").to("file:data/outbox")));

/ TODO

/ 7	. 

/ slf4j	, 

/ we zien	,
$ vi chapter1-file-copy/pom.xml
...
     <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-log4j12</artifactId>
     </dependency>
  </dependencies>

$  less ~/.m2/repository/org/apache/camel/camel-core/2.15.2/camel-core-2.15.2.pom
/ als we de slf4j-log4j12 dep niet opnemen, hebben we geen slf4j deps, want dan zien we alleen entries in <dependencyManagement/>

  <properties>
    <slf4j-version>1.7.5</slf4j-version>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>1.7.5</version>
      </dependency>
      <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>1.7.5</version>
      </dependency>

/ als we het wel doen, zien we in <dependencies/>	,
  <dependencies>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.5</version>
      <scope>compile</scope>
    </dependency>
  </dependencies>

/ In chapter2-ftp-jms/pom.xml wordt er in <dependencies/>: 
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.17</version>
      <scope>compile</scope>
    </dependency>

/ en dat is ook goed	,
/ TODO

/ we zien in Deps Hierarchy dat we niet slf4j of log4j hoeven te dep	, want die zijn er al	,
slf4j-log4j12:1.7.5
	slf4j:1.7.5
	log4j:1.12.7

/ we zien in dep hierarchy,
camel-core:2.15.2
	slf4j-api:1.7.5	 (managed from 1.6.6)
/ in de pom van camel-core zien we inderdaad slf4j version 1.6.6	, 
/ waarom komt 1.7.5 vandaan?
/ TODO

/ 7	. 

/ we zien	,

package org.apache.camel.component.file;
public class FileConsumer extends GenericFileConsumer<File> {
    @Override
    protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileList, int depth) {
        log.trace("pollDirectory from fileName: {}", fileName);
/e
package org.apache.camel.component.file;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public abstract class GenericFileConsumer<T> extends ScheduledBatchPollingConsumer {
    protected final Logger log = LoggerFactory.getLogger(getClass());
    protected int poll() throws Exception {
        if (!prePollCheck()) {
            log.debug("Skipping poll as pre poll check returned false");
...


/ 7	 .

/ we start	,

$ PATH=/home/eric/Devel/Java/activemq/apache-activemq-5.15.8/bin/:$PATH
$ activemq console
...
INFO | Listening for connections at: tcp://almond.nuts.org:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600
INFO | ActiveMQ WebConsole available at http://0.0.0.0:8161/

/ we maken in eclipse, in chapter2-ftp-jms	,

public class FileToJmsExample {
	public static void main(String[] args) throws Exception {
		CamelContext ctx = new DefaultCamelContext();
//		ConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost");
		ConnectionFactory fact = new ActiveMQConnectionFactory("tcp://localhost:61616");		
		ctx.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(fact));
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:data/inbox?noop=true").to("jms:foobar");
			}
		});
		ctx.start();
		Thread.sleep(10000);
		ctx.stop();

/ we hebben	,
$ cat data/inbox/message1.xml
<?xml version="1.0" encoding="UTF-8"?>
<order name="motor" amount="1" customer="honda"/>

/ run dit prg,
/ open localhost:8161	,
/ klik queues, we zien : foobar klik 	,
/ we zien	in de 1ste column	, 

Message ID  	Correlation ID  	Persistence  	Priority  	Redelivered  	Reply To  	Timestamp  	Type  	Operations  
ID:almond.nuts.org-43539-1563625746707-1:1:1:1:1	
/ klik hierop	,
/ dan zien we 
Headers

Headers
-------
Message ID	ID:almond.nuts.org-43539-1563625746707-1:1:1:1:1
Destination	queue://foobar																		<-
Correlation ID	
Group	
Sequence	0
Expiration	0
Persistence	Persistent
Priority	4
Redelivered	false
Reply To	
Timestamp	2019-07-20 14:29:06:895 CEST
Type		

Properties
----------
CamelFileContentType	application/xml
CamelFileLastModified	1436201236000
CamelFileParent	data/inbox
CamelFilePath	data/inbox/message1.xml												<-
CamelFileNameConsumed	message1.xml
breadcrumbId	ID-almond-nuts-org-43569-1563625744508-0-1
CamelFileLength	89
CamelFileRelativePath	message1.xml
CamelFileAbsolute	false
CamelFileAbsolutePath	/home/eric/misc_codebase/camelinaction-master/chapter2/ftp-jms/data/inbox/message1.xml
CamelFileName	message1.xml
CamelFileNameOnly	message1.xml

Message Details
--------------
<?xml version="1.0" encoding="UTF-8"?>
<order name="motor" amount="1" customer="honda"/>

/ we zien geen polling	, net als in chapter1-file-copy	,
/ TODO

/ 7	 .

/ google	,
camel jms queue
/ lees,
https://people.apache.org/~dkulp/camel/jms.html

jms:[queue:|topic:]destinationName[?options]
Where destinationName is a JMS queue or topic name. By default, the destinationName is interpreted as a queue name. For example, to connect to the queue, FOO.BAR use:

jms:FOO.BAR
You can include the optional queue: prefix, if you prefer:

jms:queue:FOO.BAR
To connect to a topic, you must include the topic: prefix. For example, to
connect to the topic, Stocks.Prices, use:

jms:topic:Stocks.Prices
You append query options to the URI using the following format, ?option=value&option=value&...

/ 7. 

/ google
camel from jms to file example
/ lees, 
https://camel.apache.org/walk-through-an-example.html
->
https://svn.apache.org/repos/asf/camel/trunk/examples/camel-example-jms-file/src/main/java/org/apache/camel/example/jmstofile/CamelJmsToFileExample.java

/ 7	. 

/ we willen van file -> jms -> file	,

/ we start	,
$ PATH=/home/eric/Devel/Java/activemq/apache-activemq-5.15.8/bin/:$PATH
$ activemq console
...
INFO | Listening for connections at: tcp://almond.nuts.org:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600
INFO | ActiveMQ WebConsole available at http://0.0.0.0:8161/

/ 13	. 

$ vi FileToJmsToFileExample {

public class FileToJmsToFileExample {
	public static void main(String[] args) throws Exception {
		CamelContext ctx = new DefaultCamelContext();
//		ConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost");
		ConnectionFactory fact = new ActiveMQConnectionFactory("tcp://localhost:61616");
		ctx.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(fact));
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:data/inbox?noop=true").to("jms:queue:foobar");
			}
		});
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("jms:foobar").to("file:data/outbox");

			}
		});

		ctx.start();
		Thread.sleep(1000);
		ctx.stop();
		

/ 13	. 

/ we hadden eerst een andere moment van de 2de ctx.addRoute	, maar zoals hierboven is beste; we hadden eerst: 

$ vi FileToJmsToFileExample1.java 

package camelinaction;

import javax.jms.ConnectionFactory;

public class FileToJmsToFileExample1 {
	public static void main(String[] args) throws Exception {
		CamelContext ctx = new DefaultCamelContext();
//		ConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost");
		ConnectionFactory fact = new ActiveMQConnectionFactory("tcp://localhost:61616");
		ctx.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(fact));
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:data/inbox?noop=true").to("jms:queue:foobar");
			}
		});

		ctx.start();
		Thread.sleep(1000);
		
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("jms:foobar").to("file:data/outbox");

			}
		});
		Thread.sleep(1000);
		ctx.stop();


/ 13	. 
		
$ vi FileToJmsToFileExample2.java 

public class FileToJmsToFileExample2 {
	public static void main(String[] args) throws Exception {
		CamelContext ctx = new DefaultCamelContext();
//		ConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost");
		ConnectionFactory fact = new ActiveMQConnectionFactory("tcp://localhost:61616");
		ctx.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(fact));
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:data/inbox?noop=true").to("jms:queue:foobar");
			}
		});

		ctx.start();
		Thread.sleep(1000);
		ctx.stop();
		
		CamelContext ctx2 = new DefaultCamelContext();
		ConnectionFactory fact2 = new ActiveMQConnectionFactory("tcp://localhost:61616");
		ctx2.addComponent("jms2", JmsComponent.jmsComponentAutoAcknowledge(fact2));
		ctx2.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("jms2:foobar").to("file:data/outbox");

			}
		});
		ctx2.start();
		Thread.sleep(1000);
		ctx2.stop();
		
/ 13	. 

/ onthoud: na ctx.stop() moet je ctx niet meer gebruiken	,


$ vi FileToJmsToFileExample3.java 

public class FileToJmsToFileExample3 {
	public static void main(String[] args) throws Exception {
		CamelContext ctx = new DefaultCamelContext();
//		ConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost");
		ConnectionFactory fact = new ActiveMQConnectionFactory("tcp://localhost:61616");
		ctx.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(fact));
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:data/inbox?noop=true").to("jms:queue:foobar");
			}
		});

		ctx.start();
		Thread.sleep(1000);
		ctx.stop();
		
		ctx = new DefaultCamelContext();
		fact = new ActiveMQConnectionFactory("tcp://localhost:61616");			
		ctx.addComponent("jms2", JmsComponent.jmsComponentAutoAcknowledge(fact));
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("jms2:foobar").to("file:data/outbox");

			}
		});
		ctx.start();
		Thread.sleep(1000);
		ctx.stop();	

/ deze is OK	,	
/ maar als we NIET ctx=new DefaultCamelContext() doen	, maar dus met de ctx.stop() verder gaan	,
/ dan of je nou een nieuwe fact maakt of niet	, we zien	ERR,
// java.lang.IllegalArgumentException: connectionFactory must be specified
/ TODO

/ 7	. 

/ we voegen een paar log regels toe	,

public class FileToJmsToFileExampleWithProcessor {
	static final Logger logger=LoggerFactory.getLogger(FileToJmsToFileExample.class);
	
	public static void main(String[] args) throws Exception {
		CamelContext ctx = new DefaultCamelContext();
		ConnectionFactory fact = new ActiveMQConnectionFactory("vm://localhost");
//		ConnectionFactory fact = new ActiveMQConnectionFactory("tcp://localhost:61616");
		ctx.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(fact));
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:data/inbox?noop=true")
				.process(new Processor() {
					@Override
					public void process(Exchange exchange) throws Exception {
						logger.info("From file to jms: "+exchange.getIn().getHeader("CamelFileName"));
					}
				})
				.to("jms:queue:foobar");
			}
		});
		ctx.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("jms:foobar")
				.process(new Processor() {	
					@Override
					public void process(Exchange exchange) throws Exception {
						logger.info("From jms to file: "+exchange.getIn().getHeader("JMSDestination"));
					}
				})
				.to("file:data/outbox");

			}
		});

		ctx.start();
		Thread.sleep(1000);
		ctx.stop(); 

/ we zien in de logging	,
[ thread #0 - file://data/inbox] FileToJmsToFileExample         INFO  From file to jms: message1.xml
[hread #1 - JmsConsumer[foobar]] FileToJmsToFileExample         INFO  From jms to file: queue://foobar

/ we set een b in beide .process	,

/ from file to jms	,
/s,
exchange
	in
		headers
{breadcrumbId=ID-almond-nuts-org-45067-1563647779947-0-1, 
 CamelFileAbsolute=false
 CamelFileAbsolutePath=/home/eric/misc_codebase/camelinaction-master/chapter2/ftp-jms/data/inbox/message1.xml
 CamelFileContentType=application/xml
 CamelFileLastModified=1436201236000
 CamelFileLength=89
 CamelFileName=message1.xml
 CamelFileNameConsumed=message1.xml
 CamelFileNameOnly=message1.xml
 CamelFileParent=data/inbox
 CamelFilePath=data/inbox/message1.xml
 CamelFileRelativePath=message1.xml}

exchange
	pattern
 InOnly
	properties
{CamelBatchSize=1
 CamelFileLockFileAcquired=true
 CamelMessageHistory=[DefaultMessageHistory[routeId=route1, node=process1]]
 CamelBatchComplete=true
 CamelFileLockFileName=/home/eric/misc_codebase/camelinaction-master/chapter2/ftp-jms/data/inbox/message1.xml.camelLock
 CamelBatchIndex=0
 CamelFileExchangeFile=GenericFile[message1.xml]
 CamelCreatedTimestamp=Sat Jul 20 20:41:51 CEST 2019}

/ from jms to file	

exchange
	in
		headers
{breadcrumbId=ID-almond-nuts-org-38907-1563647944378-0-1
 CamelFileAbsolute=false
 CamelFileAbsolutePath=/home/eric/misc_codebase/camelinaction-master/chapter2/ftp-jms/data/inbox/message1.xml
 CamelFileContentType=application/xml
 CamelFileLastModified=1436201236000
 CamelFileLength=89
 CamelFileName=message1.xml
 CamelFileNameConsumed=message1.xml
 CamelFileNameOnly=message1.xml
 CamelFileParent=data/inbox
 CamelFilePath=data/inbox/message1.xml
 CamelFileRelativePath=message1.xml
 JMSCorrelationID=null
 JMSDeliveryMode=2
 JMSDestination=queue://foobar
 JMSExpiration=0
 JMSMessageID=ID:almond.nuts.org-42481-1563647947000-3:2:1:1:1
 JMSPriority=4
 JMSRedelivered=false
 JMSReplyTo=null
 JMSTimestamp=1563647949132
 JMSType=null
 JMSXGroupID=null
 JMSXUserID=null}

exchange
	pattern
		InOnly
	properties
{CamelBinding=org.apache.camel.component.jms.JmsBinding@6cb5591e
 CamelMessageHistory=[DefaultMessageHistory[routeId=route2, node=process2]]
 CamelExternalRedelivered=false
 CamelCreatedTimestamp=Sat Jul 20 20:40:00 CEST 2019}

/ 7	. 

/ start eclipse
[eric@almond Eclipse]$ eclipse-java-2019-06-R-linux-gtk-x86_64/eclipse/eclipse 
/ kies ws /home/eric/Devel/workspaces/workspace_camel

$ vi chapter2-cbr/.../MyOrderRouter.java

package camelinaction;
...
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyOrderRouter {
	
	private static final Logger logger=LoggerFactory.getLogger(MyOrderRouter.class);

	public static void main(String[] args) throws Exception {
		CamelContext context = new DefaultCamelContext();
		ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
		context.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(factory));
		context.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:src/data?noop=true").to("jms:queue:incomingOrders");
				from("jms:queue:incomingOrders").choice()
					.when(header("CamelFileName").endsWith("xml"))
						.to("jms:queue:xmlOrders")
					.when(header("CamelFileName").endsWith("csv"))
						.to("jms:queue:csvOrders");
				from("jms:queue:xmlOrders").process(new Processor() {			
					@Override
					public void process(Exchange exchange) throws Exception {
						logger.info("Received xml order "+exchange.getIn().getHeader("CamelFileName"));
					}
				});
				from("jms:queue:csvOrders").process(new Processor() {	
					@Override
					public void process(Exchange exchange) throws Exception {
						logger.info("Received csv order "+exchange.getIn().getHeader("CamelFileName"));
						
					}
				});
						
					
			}
		});
		context.start();
		Thread.sleep(1000);
		context.stop();

	}

}
/ In src/data zijn 4 files	, 
message1.xml
message2.csv
message3.csl
message4.bad

/ we zien in amq 3 queues:
incomingOrders 	4 4
xmlOrders	1 1
csvOrders 1 1
/ klopt	,

/ 7	 . 

/ boek (79)
/ ws. workspace_camel
/ proj. chapter3-order	,

/ CAMEL TEST FRAMEWORK

/ 13	. 

/ bijv	, 

/ proj. chapter3-order

/ we zien dat onderstaande method via een @Before method altijd dus wordt called	, en dat daarvan een @Test method gebruik kan maken	, 

public class PurchaseOrderCsvTest extends CamelTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                context.setTracing(true);

                from("file://src/test/resources?noop=true&fileName=order.csv")
                    .unmarshal().csv()
                    .split(body())
                        .to("mock:queue.csv");
            }
        };
    }

/ start	,
package org.apache.camel.test.junit4;
public abstract class CamelTestSupport extends TestSupport {
    @Before
    public void setUp() throws Exception {
...
                doSetUp();
/s,
    private void doSetUp() throws Exception {
            RouteBuilder[] builders = createRouteBuilders();
            for (RouteBuilder builder : builders) {
                log.debug("Using created route builder: " + builder);
                context.addRoutes(builder);
            }
////////////////////////////////
/ context.addRoutes(new RouteBuilder(){@Override public void configure()throws Exception{from("file:...").to("jms:...")
/ doen we altijd zelf, maar nu doet het test fw het voor ons	, tenminste alleen context.addRoutes doet hij voor ons	, de rest moeten we nog zelf doen	,
/s,
    /**
     * Factory method which derived classes can use to create an array of
     * {@link org.apache.camel.builder.RouteBuilder}s to define the routes for testing
     *
     * @see #createRouteBuilder()
     */
    protected RouteBuilder[] createRouteBuilders() throws Exception {
        return new RouteBuilder[] {createRouteBuilder()};
    }
/s,
public class PurchaseOrderCsvTest extends CamelTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                context.setTracing(true);

                from("file://src/test/resources?noop=true&fileName=order.csv")
                    .unmarshal().csv()
                    .split(body())
                        .to("mock:queue.csv");
            }
        };
    }

/ 13	. 

/ proj. chapter3-order

public class PurchaseOrderCsvTest extends CamelTestSupport {
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
			...
/ er is een route added aan context	,

/ nu kan de @Test method deze use	,

	@Test
    public void testCsv() throws Exception {
        MockEndpoint mock = getMockEndpoint("mock:queue.csv");
        mock.expectedMessageCount(2);

        assertMockEndpointsSatisfied();

        List line1 = mock.getReceivedExchanges().get(0).getIn().getBody(List.class);
        assertEquals("Camel in Action", line1.get(0));
        assertEquals("4995", line1.get(1));
        assertEquals("1", line1.get(2));

        List line2 = mock.getReceivedExchanges().get(1).getIn().getBody(List.class);
        assertEquals("Activemq in Action", line2.get(0));
        assertEquals("4495", line2.get(1));
        assertEquals("2", line2.get(2));
    }

/ 13	. 

/ we gaan deze method echt doen	,

/ 13	. 

/ we deden per ongeluk,
		ConnectionFactory factory = new ActiveMQConnectionFactory("http://localhost:61616");
/ we zien ERR	,
Caused by: java.lang.NoClassDefFoundError: org/apache/http/HttpRequestInterceptor
/ TODO

/ 13	. 

/ een class in src/test/java kent de classes in src/main/java	, maar niet andersom	,

/ 13	. 

/ voor een class in src/main/java	,
public class PurchaseOrderCSVFromFileToJms {
 				from("file:src/main/resources?noop=true&fileName=order.csv")
/ ERR	,
 				from("file:data/inbox?noop=true&fileName=order.csv")
/ OK	,

/ WH kan wel voor een class in src/test/java	, 
 				from("file:src/test/resources?noop=true&fileName=order.csv")
/ TODO


/ 13	. 

/ als in de pom de deps er zijn	, dan moet je nog wel in src/main/java en src/test/java afzonderlijk log4j.xml hebben in src/main/resources resp. src/test/resources	, 
/ dus een class in src/main/java wilt log, moet er in src/main/resources log4j.xml zijn,	

/ 13	. 

/ als FileToJmsExample from("file:data/inbox?noop=true").to("jms:queue:foobar") doet, dan zien we in amq	,
/ als JmsToFileExample from("jms:queue:foobar").to("file:data/outbox"); doet, dan zien we in amq	,
number of pending messages,  messages enqueued,	messages.dequeued 
1														1										0									# na file -> jms
0														1										1									# na jms -> file

/ dus als we FileToJmsToFile doen, die beide ... na elkaar doet	, dan zien we
number of pending messages,  messages enqueued,	messages.dequeued 
0														1										1									# na file -> jms

/ 13	. 

/ lees	,
https://logging.apache.org/log4j/1.2/manual.html
https://activemq.apache.org/how-do-i-change-the-logging

[eric@almond camelinaction-master]$ vi  ~/Devel/Java/activemq/apache-activemq-5.15.8/conf/log4j.properties 

log4j.rootLogger=INFO, console, logfile
# When debugging or reporting problems to the ActiveMQ team,
# comment out the above lines and uncomment the next.
#log4j.rootLogger=DEBUG, logfile, console
log4j.appender.console.threshold=INFO

->

#log4j.rootLogger=INFO, console, logfile
# When debugging or reporting problems to the ActiveMQ team,
# comment out the above lines and uncomment the next.
log4j.rootLogger=DEBUG, logfile, console
log4j.appender.console.threshold=INFO

/ in de log file
[eric@almond camelinaction-master]$ less ~/Devel/Java/activemq/apache-activemq-5.15.8/data/activemq.log 
/ zien we DEBUG, maar op de console niet, alleen INFO	, dit komt door die threshold	,

/ 13	. 

////////////////////////////////////////////////////
/ use Thread.sleep(3000)	, 
/ Thread.sleep(1000) is te weinig	,

/ inlog in amq is admin, admin

/ 13	. 

/ proj. chapter3-order	,

/ in src/main/java	,
$ vi PurchaseOrderCSVFromFileToJms.java

public class PurchaseOrderCSVFromFileToJms {
	public static void main(String[] args) throws Exception{
		CamelContext context = new DefaultCamelContext();
		ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
		context.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(factory));
		context.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("file:data/inbox?noop=true&fileName=order.csv")
				.unmarshal().csv().split(body())
				.to("jms:queue:csvOrders");

			}
		});
		context.start();
		Thread.sleep(3000);
		context.stop();
	}
}

/ we zien in amq	,
name, 		number of pending messages, messages unqueued	, messages queued
csvOrders 2														2										0

/ klik csvOrders	, we zien er twee	, 
/ als je op beide klikt, zie je	,
[Camel in Action, 4995, 1]
[Activemq in Action, 4495, 2]

/ je start met csv, vandaar dat je unmarshal doet, dus je krijgt een List van List<String>	; een row is een List<String> en we hebben meerdere rows, dus dat is ook een List	,

/ 13	. 

/ proj. chapter3-order

/ voor 
public class PurchaseOrderCSVFromFileToJms {
				from("file:data/inbox?noop=true&fileName=order.csv")
				.unmarshal().csv().split(body())
				.to("jms:queue:csvOrders");

/ hebben we geen PurchaseOrder class nodig: werkt met een csv file	,

/ maar voor PurchaseOrderJaxbTest hebben we wel een PurchaseOrder class nodig (annotated met jaxb annotaties), want nu werken we met java objecten ipv een csv file!

/ 13	. 

/ jaxb

/ lees,
https://camel.apache.org/producertemplate.html

/ proj chapter3-order

/ de PurchageOrder type is verplaatst naar src/main/java	,

$ vi PurchaseOrderJaxbToJms.java

public class PurchaseOrderJaxbToJms {
	public static void main(String[] args) throws Exception{
		CamelContext context = new DefaultCamelContext();
		ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
		context.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(factory));
		context.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("direct:order")
				.marshal().jaxb()
				.to("jms:queue:jaxbOrders");
			}
		});    
		
		PurchaseOrder order=new PurchaseOrder();
    order.setAmount(5);
    order.setName("foo");
    order.setPrice(3.14159);

    ProducerTemplate template=context.createProducerTemplate();

		context.start();
		// na context.start() anders zijn er geen consumers:
    template.sendBody("direct:order", order);
		Thread.sleep(3000);
		context.stop();
	}
}

/ let op:
		context.start();
		// na context.start() anders zijn er geen consumers:
    template.sendBody("direct:order", order);

/ we zien in amq	,
name, 		number of pending messages, messages unqueued	, messages queued
jaxbOrders 1														1										0
/ klik op jaxbOrders	,

Message ID  	Correlation ID  	Persistence  	Priority  	Redelivered  	Reply To  	Timestamp  	Type  	Operations  
ID:almond.nuts.org-43643-1563959136019-1:1:1:1:1	 ...
/ klik op deze,	

Message Details
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<purchaseOrder name="foo" price="3.14159" amount="5.0"/>

/ 13	. 

/ bindy	,

/ we maken in src/main/java ook een package camelinaction.bindy	, en verplaatsten PurchaseOrder daarheen	,
/ als je het project chapter3-order clean, dan ziet eclipse pas dat er in src/main/java/camelinaction.bindy en in src/test/java/camelinaction.bindy PurchaseOrder staat	,

package camelinaction.bindy;
@CsvRecord(separator = ",", crlf = "UNIX")
public class PurchaseOrder {
...

$ vi PurchaseOrderBindyToJms.java

package camelinaction.bindy
public class PurchaseOrderBindyToJms {
	public static void main(String[] args) throws Exception{
		CamelContext context = new DefaultCamelContext();
		ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
		context.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(factory));
		context.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("direct:order")
				.marshal().bindy(BindyType.Csv, "camelinaction.bindy")
				.to("jms:queue:bindyOrders");
			}
		});    
		
		PurchaseOrder order=new PurchaseOrder();
	  order.setAmount(5);
	  order.setName("foo");
	  order.setPrice(new BigDecimal("3.14"));

	  ProducerTemplate template=context.createProducerTemplate();
		
		context.start();
		// na context.start() anders zijn er geen consumers:
	  template.sendBody("direct:order", order); 
		Thread.sleep(3000);
		context.stop();
	}
}

/ we zien in amq	,

Name 	Number Of Pending Messages  	Number Of Consumers  	Messages Enqueued  	Messages Dequeued
bindyOrders	1	0	1	0
/ klik bindyOrders	,

/ we zien	,
Message ID  	Correlation ID  	Persistence  	Priority  	Redelivered  	Reply To  	Timestamp  	Type  	Operations  
ID:almond.nuts.org-34483-1563962607987-1:1:1:1:1		Persistent	4	false		2019-07-24 12:03:28:175 CEST		Delete
View Consumers
/ klik ID:almond.nuts.org-34483-1563962607987-1:1:1:1:1 

/ we zien	,
Message Details
foo,3.14,5

/ 13	. 

/ proj. chapter3-order

public class PurchaseOrderJSONTest extends CamelTestSupport {

    @Test
    public void testJSON() throws Exception {
        String out = template.requestBody("http://localhost:8080/order/service?id=123", null, String.class);

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("jetty://http://0.0.0.0:8080/order/service")
                    .beanRef("orderService", "lookup")
                    .marshal().json(JsonLibrary.Jackson);
            }


/ Waarom wordt deze jetty (simulatie door camel) used? Tot nu toe we marshal/unmarshal en je stuurde het antwoord naar jms	, 

/ nu willen we het antwoord zelf hebben: String out=template.requestBody(...)	, 
/ we sturen een leeg req mee: template.requestBody(...,null,...)	,

/ we deden altijd template.sendBody	,
/ template.requestBody is ook een .send	, zou .sendRequest heten als deze zou bestaan	, je send het request (als is die null bij ons)	,
/ daarom komt hij toch aan bij from("jetty://http://0.0.0.0:8080/order/service")	, deze zoekt de bean "orderService op in de registry	, en invokes lookup()	, dan marshal als json	, en sends als response	, en dat String out=...

/ 13	. 

/ lees	,
https://camel.apache.org/data-format.html

/ we doen altijd unmarshal().csv() of marshal().jaxb()
/////////////////////////////////////////////////////////////////////
/ .csv() en .jaxb() zijn dataformats	,

/ we zien ze in XML configs ook in het boek (83)	,

<camelContext ...>
	<dataFormats>
		<json ...>

/ we maken	,
		DataFormat format=new JaxbDataFormat("camelinaction");
/ we moeten in src/main/resources
	camelinaction
		jaxb.index

$ vi jaxb.index
PurchaseOrder

/ we doen dus ipv .marshal().jaxb(): marshal(format) in	,

$ vi PurchaseOrderJaxbToJms2.java

public class PurchaseOrderJaxbToJms2 {
	public static void main(String[] args) throws Exception{
		CamelContext context = new DefaultCamelContext();
		ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
		context.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(factory));
		DataFormat format=new JaxbDataFormat("camelinaction");			<-
		context.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("direct:order")
				.marshal(format)																				<-
				.to("jms:queue:jaxbOrders");
			}
		});    

/  we zien in amq,
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<purchaseOrder name="bar" price="3.14159" amount="5.0"/>

/ 1313	. 

/ we krijgen ERR als we new JaxbDataFormat() doen	,
Caused by: java.io.IOException: org.apache.camel.InvalidPayloadException: No body available of type: javax.xml.bind.JAXBElement but has value: camelinaction.PurchaseOrder@18d87d80 of type: camelinaction.PurchaseOrder on: Message: <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<purchaseOrder name="bar" price="3.14159" amount="5.0"/>
. Exchange[Message: <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<purchaseOrder name="bar" price="3.14159" amount="5.0"/>
]
/ TODO

/ 13	. 

/ eigen dataformat	,

/ we move ReverseDataFormat van src/test/java naar src/main/java	,

/ we maken eigen ReverseDataFormatToSelf.java	,

/ we gebruiken template.requestBody weer, dat een .sendBody doet , nl een req	, en dus in een from terecht komt	, maar nu komt er een resp terug	,

/ Intermezzo

class DefaultProducerTemplate{
    public Object requestBody(String endpoint, Object body) throws CamelExecutionException {
        return sendBody(endpoint, ExchangePattern.InOut, body);
    }
/ we zien InOut	,

/ Einde Intermezzo


/ 1313	. 

/ we kunnen een template.requestBody("direct:marshal") niet aanlaten sluiten op:
				from("direct:marshal")
				.marshal(format)
				.to("jms:queue:log");
/ want dan zien we:
org.apache.camel.ExchangeTimedOutException: The OUT message was not received within: 20000 millis due reply message with correlationID: Camel-ID-almond-nuts-org-45053-1563982038815-0-3 not received on destination: temp-queue://ID:almond.nuts.org-40495-1563982039945-1:1:1. Exchange[Message: !skcor lemaC]
	at org.apache.camel.component.jms.reply.ReplyManagerSupport.processReply(ReplyManagerSupport.java:152)
	at org.apache.camel.component.jms.reply.TemporaryQueueReplyHandler.onTimeout(TemporaryQueueReplyHandler.java:61)
	at org.apache.camel.component.jms.reply.CorrelationTimeoutMap.onEviction(CorrelationTimeoutMap.java:54)
	at org.apache.camel.component.jms.reply.CorrelationTimeoutMap.onEviction(CorrelationTimeoutMap.java:30)
	at org.apache.camel.support.DefaultTimeoutMap.purge(DefaultTimeoutMap.java:230)
	at org.apache.camel.support.DefaultTimeoutMap.run(DefaultTimeoutMap.java:180)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

/ template.requestBody verwacht een antwoord en dat geeft jms niet	,

/ 1313. 

/ daarom	,

public class ReverseDataFormatToLog {
	private static final Logger logger=LoggerFactory.getLogger(ReverseDataFormat.class);
	
	public static void main(String[] args) throws Exception{
		CamelContext context = new DefaultCamelContext();
		DataFormat format=new ReverseDataFormat();
		context.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("direct:marshal")
				.marshal(format)
				.to("log:marshal");
			}
		});    
		context.addRoutes(new RouteBuilder() {	
			@Override
			public void configure() throws Exception {
				from("direct:unmarshal")
				.marshal(format)
				.to("log:unmarshal");
			}
		});

	    ProducerTemplate template=context.createProducerTemplate();
		
		context.start();
		// na context.start() anders zijn er geen consumers:
	    String res=template.requestBody("direct:marshal","Camel rocks!",String.class); 
	    logger.info("res: "+res);
	    String finalRes=template.requestBody("direct:unmarshal",res,String.class); 
	    logger.info("finalRes: "+finalRes);
	    logger.info("equals: "+"Camel rocks!".equals(finalRes));
		Thread.sleep(3000);
		context.stop();
	}

/ we zien in de console log van eclipse	,

DEBUG DirectProducer       - Starting producer: Producer[direct://marshal]
DEBUG ProducerCache        - Adding to producer cache with key: Endpoint[direct://marshal] for producer: Producer[direct://marshal]
DEBUG ProducerCache        - >>>> Endpoint[direct://marshal] Exchange[Message: Camel rocks!]
DEBUG SendProcessor        - >>>> Endpoint[log://marshal] Exchange[Message: !skcor lemaC]
INFO  marshal            * - Exchange[ExchangePattern: InOut, BodyType: byte[], Body: !skcor lemaC]
INFO  ReverseDataFormat  ! - res: !skcor lemaC
DEBUG DirectProducer       - Starting producer: Producer[direct://unmarshal]
DEBUG ProducerCache        - Adding to producer cache with key: Endpoint[direct://unmarshal] for producer: Producer[direct://unmarshal]
DEBUG ProducerCache        - >>>> Endpoint[direct://unmarshal] Exchange[Message: !skcor lemaC]
DEBUG SendProcessor        - >>>> Endpoint[log://unmarshal] Exchange[Message: Camel rocks!]
INFO  unmarshal          * - Exchange[ExchangePattern: InOut, BodyType: byte[], Body: Camel rocks!]
INFO  ReverseDataFormat  ! - finalRes: Camel rocks!
INFO  ReverseDataFormat    - equals: true

/ de regels met * zijn wh .to(log:marshal) en .to(log:unmarshal)
/ de regels met ! zijn onze eigen log regels	,

/ Waarom?
INFO  marshal              - Exchange[ExchangePattern: InOut, BodyType: byte[], Body: !skcor lemaC]
/ WH is .marshal InOut	, en doet .log log de Out van .marshal	, maar de Out van .marshal gaat ook gewoon naar de client	,
/ bij .to achter .marshal gaat de Out van .marshal naar de In van .to	, en gaat de Out van .marshal niet naar de client	(maar naar .to)	, 

/ 131313	. 

/ we doen	,
		context.addRoutes(new RouteBuilder() {
			@Override
			public void configure() throws Exception {
				from("direct:marshal")
				.marshal(format);
//				.to("log:marshal");
			}
		});    
		context.addRoutes(new RouteBuilder() {	
			@Override
			public void configure() throws Exception {
				from("direct:unmarshal")
				.marshal(format);
//				.to("log:unmarshal");

/ Alles gaat nog OK	, we missen WH alleen de 2 log regels	,

DEBUG ProducerCache        - >>>> Endpoint[direct://marshal] Exchange[Message: Camel rocks!]
INFO  ReverseDataFormat  ! - res: !skcor lemaC
DEBUG DirectProducer       - Starting producer: Producer[direct://unmarshal]
DEBUG ProducerCache        - Adding to producer cache with key: Endpoint[direct://unmarshal] for producer: Producer[direct://unmarshal]
DEBUG ProducerCache        - >>>> Endpoint[direct://unmarshal] Exchange[Message: !skcor lemaC]
INFO  ReverseDataFormat  ! - finalRes: Camel rocks!
INFO  ReverseDataFormat    - equals: true

/ de regels met ! zijn onze eigen log regels	,

/ 131313	. 

/ wat docs	,

/ 13131313	. 

/ google
camel log inout
/ lees	,
https://stackoverflow.com/questions/22099945/camel-inout-log-both-in-and-out

yeah the log only logs the IN, as there is not OUT as the log does not change/set an OUT message. â€“ Claus Ibsen Feb 28 '14 at 16:45

If you add the log at the end of the route, then what the log output in IN is what is returned to the client.

Its the pipes and filters principle http://camel.apache.org/pipes-and-filters.html
/ TODO

/ 13131313	 

/ google,
camel marshal inout
/ lees,
https://stackoverflow.com/questions/5456807/apache-camel-inout-routes-out-exchange-marshaling-unmarshaling-with-jaxb
from("jms:doCommand").unmarshal(jaxbDataFormat).beanRef("bean").marshal(jaxbDataFormat);
/ lees,	
https://access.redhat.com/documentation/en-us/red_hat_jboss_fuse/6.2/html/apache_camel_development_guide/restservices-binding


/ 13131313	. 

/ google,	
camel log exchange pattern
/ lees	,
https://camel.apache.org/exchange-pattern.html
->
https://camel.apache.org/request-reply.html

/ 7	. 

/ type converters	,

/ proj. chapter3-converter

/ we zien 
$ less /home/eric/misc_codebase/camelinaction-master/chapter3/converter/src/main/resources/META-INF/services/org/apache/camel/TypeConverter

camelinaction

$ less /home/eric/misc_codebase/camelinaction-master/chapter3/converter/src/main/java/camelinaction/PurchaseOrderConverter.java

@Converter
public final class PurchaseOrderConverter {
    @Converter
    public static PurchaseOrder toPurchaseOrder(byte[] data, Exchange exchange) {
			... 

/ 13	. 

/ ook in Camel zelf zijn er TypeConverter files en converters	,

[eric@almond Camel]$ cd ~/git_codebase/
[eric@almond git_codebase]$ git clone https://github.com/apache/camel.git

[eric@almond camel]$ find -name TypeConverter
./core/camel-core/src/test/resources/META-INF/services/org/apache/camel/TypeConverter
./components/camel-test-blueprint/src/test/resources/META-INF/services/org/apache/camel/TypeConverter
./tests/camel-typeconverterscan-test/src/test/resources/META-INF/services/org/apache/camel/TypeConverter
./tests/camel-partial-classpath-test/src/test/resources/META-INF/services/org/apache/camel/TypeConverter

[eric@almond camel]$ cat  ./core/camel-core/src/test/resources/META-INF/services/org/apache/camel/TypeConverter
org.apache.camel.converter.myconverter
/ TODO

/ Er zijn veel @Converter classes	,

[eric@almond camel]$ find -name "*.java" | xargs grep @Converter
./core/camel-jaxp/src/main/java/org/apache/camel/converter/jaxp/XmlConverter.java:    @Converter
./core/camel-base/src/main/java/org/apache/camel/converter/ObjectConverter.java:    @Converter
./components/camel-cxf/src/main/java/org/apache/camel/component/cxf/converter/CxfConverter.java:    @Converter
./components/camel-hl7/src/main/java/org/apache/camel/component/hl7/HL724Converter.java:    @Converter
./components/camel-mail/src/main/java/org/apache/camel/component/mail/MailConverters.java:    @Converter
./components/camel-activemq/src/main/java/org/apache/camel/component/activemq/converter/ActiveMQMessageConverter.java:    @Conver

/ 7	. 

/ boek (117)

/ proj. chapter4-bean

/ we hebben de files,
src/main/java
camelinaction.XmlOrderService.java
src/test/java
camelinaction.XmlOrderTest.java
xmlOrder.xml

$ vi camelinaction.XmlOrderTest.java

public class XmlOrderTest extends CamelSpringTestSupport {
...
/ de xml,
        // prepare a XML document from a String which is converted to a DOM
        String body = "<order customerId=\"4444\"><item>Camel in action</item></order>";
        Document xml = context.getTypeConverter().convertTo(Document.class, body);

/ startpunt	,	
        // store the order as a file which is picked up by the route
        template.sendBodyAndHeader("file://target/order", xml, Exchange.FILE_NAME, "order.xml");

$ vi xmlOrder.xml
    <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
        <route>
            <from uri="file://target/order"/>		/ dan komt hierin	,
            <to uri="log:before"/>
            <bean ref="xmlOrderService"/>	/ dan komt hierin	,
            <to uri="log:after"/>
            <to uri="mock:queue:order"/>
        </route>
    </camelContext>

$ vi camelinaction.XmlOrderService.java
public class XmlOrderService { 																/ dus komen we hier	,
    public Document handleIncomingOrder(@Body Document xml,
                                        @XPath("/order/@customerId") int customerId,
                                        @Bean(ref = "guid", method = "generate") int orderId) {








 

/ Einde CAMEL TEST FRAMEWORK
