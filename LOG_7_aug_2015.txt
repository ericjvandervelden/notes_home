/ ASM

/ 7	. 

[eric@almond Asm]$ pwd
/home/eric/Devel/Asm
[eric@almond Asm]$ cat fun2.c

#include<string.h>
int main(){
	int i=7;
	int j;
	j=fun(i);
	return(0);
}
int fun(int i){
 	int r=fct(i,"eric j.");
	return r;	
}
int fct(int i,char*s){
	return strlen(s);
}

[eric@almond Asm]$ gcc -S fun2.c;gcc -g fun2.s
$ gdb a.out
(gdb) b*main
Breakpoint 1 at 0x4004f6: file fun2.s, line 8.

/ wat steeds gepushed wordt zijn de ri (gepushed door de caller, = return inst in de caller, popped door callee), en de $rbp van de caller	 (gepushed door de callee, en popped door callee)	,
/ de $rbp is base van het frame,	 tov params worden push	 (TODO),
/ op de $rbp zelf staat de vorige $rbp ,

	pushq %rbp
/ verlaag $rsp en set content $rbp op $rsp
	popq %rbp
/ set content $rsp in $rbp en verhoog $rsp 

/ main's $rbp bevat een $rip	, __libc_csu_init	, 
/ TODO( Vreemde branch pointer)	, 
/ de $rbp van de andere fcts, van fun en fct	, bevatten de adres van de caller's $rbp	, omdat er wordt gedaan	,
	movq	%rsp, %rbp
/ dus zo komt je in de caller's frame terug		,
/ ret zorgt ervoor deat de $rip de return instr van de caller wordt=de instr achter de call instr in de caller	,
/ er gebeuren dus 2 dingen: de bp	, en de ip	, worden set en teruggezet	,

/ call fun:
/=
	pushq 0x400554 <main+30>	/ ri in main achter deze call fun	,
	$rip=fun
36		pushq	%rbp 			/ push $rbp van de caller, want straks daarna terug	,
39		movq	%rsp, %rbp		/ set $rbp=bp van fun	

/ we hebben nu ri caller en bp caller pushed	,
...
47		call	fct
	pushq    0x40057d <fun+31>	/ ri in fun achter deze call fct   
	$rip=  fct
36		pushq	%rbp 			/ push $rbp van de caller, want straks daarna terug	,
39		movq	%rsp, %rbp		/ set $rbp=bp van fun	

72		leave
/=
        movq %rbp, %rsp
        popq %rbp				/ $rbp wordt fun's $rbp	, dat is een stack adres	, $rsp wordt 1 verhoogt	,
	
		ret						/ $rip=fun's ri , $rsp wordt 1 verhoogt	,

72		leave
/=
        movq %rbp, %rsp
        popq %rbp				/ $rbp wordt main's $rbp	, dat is een stack adres	, $rsp wordt 1 verhoogt	,
	
		ret						/ $rip=main's ri , $rsp wordt 1 verhoogt	,

21		leave
(gdb) p $rbp
$7 = (void *) 0x7fffffffde50
(gdb) x/i *(int*)$rbp
   0x4005b0 <__libc_csu_init>:	push   %r15
/ TODO ($rbp is een instr	, NIET op de stack)	,

(gdb) x/i *(long*)$rsp
   0x7ffff7a3dfe0 <__libc_start_main+240>:	mov    %eax,%edi
(gdb) p $rip
$10 = (void (*)()) 0x40055d <main+39>

23		ret

(gdb) p $rip
$11 = (void (*)()) 0x7ffff7a3dfe0 <__libc_start_main+240>









/ 7	.

/ 13	. 

/ long	,
18446744073709551615 = 0xffffffffffffffff
 9223372036854775807 = 0x7fffffffffffffff

/ int
4294967295=0xffffffff
2147483647=0x7fffffff

/ short	,
65535=0xffff
32767=0x7fff

/ char
255=0xff
127=0x7f

/ 13	. 

/ add.c

int main(){
    unsigned int i=-1;
    unsigned int i2=4294967295;
    unsigned int i3=0xffffffff;
    unsigned long l=-1;
    unsigned long l2=18446744073709551615u;
    unsigned long l3=0xffffffffffffffff;
/ OK
    movl    $-1, -4(%rbp)
    movl    $-1, -8(%rbp)
    movl    $-1, -12(%rbp)
    movq    $-1, -24(%rbp)
    movq    $-1, -32(%rbp)
    movq    $-1, -40(%rbp)

/ we moeten	u achter,
11:    unsigned long l2=18446744073709551615u;
/anders	,
add3.c:11:2: warning: this decimal constant is unsigned only in ISO C90
/ we zijn WH iso c90	, dus hij ziet hem als unsigned	,  
/ De asm is	,
    movq    $-1, -8(%rbp)


/ 13	. 

11:    unsigned int i4=4294967296;
    unsigned long l4=4294967296;
add3.c:11:18: warning: large integer implicitly truncated to unsigned type [-Woverflow]
/=
    movl    $0, -4(%rbp)
    movabsq $4294967296, %rax
    movq    %rax, -16(%rbp)

/ Dus 4294967296=0x100000000 wordt truncated to 0x00000000=0	,

/ 13	. 

(gdb) p 0x7fffffff
$1 = 2147483647

/ 13	. 

/ Lees intel docs bij add	,

The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer oper-
ands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The
SF flag indicates the sign of the signed result.

/ 13	. 

    int i=2147483647;
    i+=1;
    long l=2147483647;
    l+=1;
    unsigned int j=-1;
    j+=1;
    unsigned long m=-1;
    m+=1;


13		movl	$2147483647, -4(%rbp)
(gdb) p $eflags
$1 = [ PF ZF IF ]
(gdb) x/4x $rbp-4
0x7fffffffde4c:	0x7fffffff

14		addl	$1, -4(%rbp)
(gdb) p $eflags
$2 = [ PF AF SF IF OF ]
/ sf=sign flag	, of=overflow flag	,
(gdb) x/4x $rbp-4
0x7fffffffde4c:	0x80000000

15		movq	$2147483647, -16(%rbp)
(gdb) p $eflags
$2 = [ PF AF SF IF OF ] 				/ ze staan nog zo	,
16		addq	$1, -16(%rbp)
(gdb) p $eflags
$3 = [ PF AF IF ]

17		movl	$-1, -20(%rbp)
(gdb) p $eflags
$2 = [ PF AF IF ]
18		addl	$1, -20(%rbp)
(gdb) p $eflags
$3 = [ CF PF AF ZF IF ]
/ cf=carry flag	, zf=zero flag	,

19		movq	$-1, -32(%rbp)
(gdb) p $eflags
$3 = [ CF PF AF ZF IF ]					/ staan nog zo	,
20		addq	$1, -32(%rbp)
(gdb) 
21		movl	$0, %eax
(gdb) p $eflags
$4 = [ CF PF AF ZF IF ]

/ 13	. 

$ vi add4.c
/ TODO (short & unsigned short)	,
/ TODO (char & unsigned char)	,

B-2 Vol. 1
EFLAGS CONDITION CODES
The terms “above” and “below” are associated with the CF
flag and refer to the relation between two unsigned
integer values. The terms “greater” and “less” are associat
ed with the SF and OF flags and refer to the relation
between two signed integer values

/ 13	 

    int i=0x7fffffff;
    i+=1;
    i+=1;
    i-=1;
    i-=1;
    i-=1;
    i=0xffffffff;
    i+=1;
    i+=1;
    i-=1;
    i-=1;
    i-=1;

/ hieronder zien we de asm	,
/ voor unsigned int precies dezelfde asm, eflags	,

    movl    $2147483647, -4(%rbp)
0x7fffffff
    addl    $1, -4(%rbp)
0x80000000
$1 = [ PF AF SF IF OF ]

    addl    $1, -4(%rbp)
0x80000001
$2 = [ SF IF ]

    subl    $1, -4(%rbp)
0x80000000
$3 = [ PF SF IF ]

    subl    $1, -4(%rbp)
0x7fffffff
$4 = [ PF AF IF OF ]

    subl    $1, -4(%rbp)
0x7ffffffe
$5 = [ IF ]

    movl    $-1, -4(%rbp)
0xffffffff

    addl    $1, -4(%rbp)
0x00000000
$7 = [ CF PF AF ZF IF ]

    addl    $1, -4(%rbp)
0x00000001
$8 = [ IF ]

    subl    $1, -4(%rbp)
0x00000000
$9 = [ PF ZF IF ]

    subl    $1, -4(%rbp)
0xffffffff
$10 = [ CF PF AF SF IF ]

    subl    $1, -4(%rbp)
0xfffffffe
$11 = [ SF IF ]

/ dus 
7f+1=80 en 80-1=7f is overflow	,
ff+1=00 en 00-1=ff is carry	,

/ 7	.

    long l=7;
    unsigned char b=l>0;
    unsigned char b2=l<0;
    unsigned char b3=l>=0;
    unsigned char b4=l<=0;
/=
    movq    $7, -8(%rbp)

    cmpq    $0, -8(%rbp)
    setg    %al

    shrq    $63, %rax

    notq    %rax
    shrq    $63, %rax

    cmpq    $0, -8(%rbp)
    setle   %al

    int i=0;
    if(l<0)i=-1;else i=1;
    if(l>0)i=1;else i=-1;
    if(l>=0)i=1;else i=-1;
    if(l<=0)i=-1;else i=1;

    cmpq    $0, -8(%rbp)
    jns .L2						/ else

    cmpq    $0, -8(%rbp)
    jle .L4

   	cmpq    $0, -8(%rbp)
    js  .L6

    cmpq    $0, -8(%rbp)
    jg  .L8

/ 13	. 

/ 1313

    unsigned int i=0x40000000;
    unsigned char bi=i>0;
    unsigned char bi2=i>0xc0000000;

    movl    $1073741824, -4(%rbp)
    cmpl    $0, -4(%rbp)
    setne   %al 
    movb    %al, -5(%rbp)

    cmpl    $-1073741824, -4(%rbp)
$2 = [ CF PF SF IF OF ]

    seta    %al
    movb    %al, -6(%rbp)
    movl    $0, %eax

(gdb) p 0xc0000000
$4 = 3221225472
(gdb) p (int)0xc0000000
$5 = -1073741824

/ 1313	,

    int i=0x40000000;
    unsigned char bi=i>0;
    unsigned char bi2=i>0xc0000000;

    movl    $1073741824, -4(%rbp)
    cmpl    $0, -4(%rbp) 
    setg    %al 
    movb    %al, -5(%rbp)

    movl    -4(%rbp), %eax
    cmpl    $-1073741824, %eax
    seta    %al
    movb    %al, -6(%rbp)
    movl    $0, %eax

/ Doet dit NIET: 0xc0000000 is een unsigned	(default)	,

/ 1313	.

    int i=0x40000000;
    unsigned char bi=i>0;
    unsigned char bi2=i>(int)0xc0000000;

   	char c=0x40;
    unsigned char bc=i>0;
    unsigned char bc2=i>(char)0xc0;

    unsigned char uc=0x40;
    unsigned char ubc=uc>0;
    unsigned char ubc2=uc>(unsigned char)0xc0;


    movl    $1073741824, -4(%rbp)
    cmpl    $0, -4(%rbp)
    setg    %al
    movb    %al, -5(%rbp)

    cmpl    $-1073741823, -4(%rbp)
$2 = [ CF PF AF IF ]
    setge   %al
1
    movb    %al, -6(%rbp)
    movl    $0, %eax

   	movb    $64, -7(%rbp)
    cmpl    $0, -4(%rbp)
    setg    %al
    movb    %al, -8(%rbp)

    cmpl    $-63, -4(%rbp)
$6 = [ CF PF AF IF ]
    setge   %al
1
    movb    %al, -9(%rbp)
    movl    $0, %eax


    movb    $64, -10(%rbp)
    cmpb    $0, -10(%rbp)
    setne   %al
    movb    %al, -11(%rbp)
    cmpb    $-64, -10(%rbp)
$1 = [ CF SF IF OF ]
    seta    %al
    movb    %al, -12(%rbp)
    movl    $0, %eax

/ overflow is alleen interessant voor sign bit	, we kunnen dus de bit rij altijd in 2-compl denken	,

/ bij signed 	, > -64 doet: >= -63	,

/ bij cmpl -63 doet sub -63	, cmpb -64 doet sub -64	,
/ sub -63 is bijna add 63	, bij sub -63  is carry set	, maar het antwoord is hetzelfde	,

0100.0000	 64
1100.0001		-63
--------- -
/=
0100.0000	64
0011.1111	63
--------- +
0111.1111
/ alleen de 1ste heeft carry bit zet	, de 2de niet	,
/ TODO


0100.0000 			64
1100.0001			-63
---------- -
011111111	, en C
/ denk - -63 = + 63 en we hebben 0100.0000+0011.1111=0111.1111=127, dus 2 pos, en result is ook pos, dus geen overflow	,

0100.0000			64
1100.0000			-64
--------- -
1000.0000	, en C en S en O	,			
/ denk: - -64 en dan 0100.0000+0100.0000=1000.0000=-128, dus 2 pos	, en result neg	, dus overflow	,


/ 13	. 

/ overflow is als de add/sub niet klopt als we de bitstrings als signed opvatten	, 
/ carry is als de add/sub niet klopt als we de bitstrings als unsigned opvatten	, 

/ add

/ stel 2- bit strings, dus bit 1 is sign bit	,

01+01=10: 
/ overflow	, want 1+1=-1 signed ERR	, 
/ GEEN carry, want 1+1=2 unsigned OK	,

11+11=(1)10:
/ GEEN overflow	, want -1+-1=-2 signed 	,  we zien dat de extra signed bit overbodig is: (1)10==10	, 
/ carry, 	3+3=2 unsigned ERR	, bij unsigned maakt extra bit wel uit	,

10+10=(1)00:
/ overflow	, want -2+-2=0  signed  ERR	,  we zien dat de extra signed bit NIET overbodig is: (1)00!=00	, 
/ carry, 	3+3=2 unsigned ERR	, bij unsigned maakt extra bit wel uit	,

11+10=(1)01: carry+overflow	,

/ sub	,

(1)10-11=11
/ signed: -2- -1=-1 OK	, geen overflow	,
/ unsigned : 2-3=3, ERR	, wel carry	,

(1)00-01=11
/ signed 0- 1= -1 , OK	,
/ unsigned 0-1 3 , ERR	, carry	,

(1)01-11=10
/ signed : 1- -1=-2 ERR	, overflow	,
/ unsigned : 1-3=2 ERR, carry	,

/ 13	. 

/ 1313	. 

/ met char	,

    char c1=(char)0x40;
    char c2=(char)0xc0;
    char d=c1-c2;
/ (*)
    unsigned char b=c1<c2;
/ (**)

    unsigned char uc1=0x40;
    unsigned char uc2=0xc0;
    unsigned char ud=uc1-uc2;
/ (***)
    unsigned char b2=c1<c2;
/ (****)

/ Als we (*) met de hand doen	, zien we cf en of	,
/ maar zij doen iets anders, waardoor er geen of is	,
/ bij (**) zien we wel of	, 
/ bij (***) doen ze wat we verwacht hadden bij (*)	, we zien cf en of	,

/(*)
    movb    $64, -1(%rbp)
    movb    $-64, -2(%rbp)
    movzbl  -1(%rbp), %edx
    movzbl  -2(%rbp), %eax
    subl    %eax, %edx
$1 = [ CF SF IF ]
(gdb) p/x $eax
$3 = 0xc0
(gdb) p/x $edx
$4 = 0xffffff80

    movl    %edx, %eax
    movb    %al, -3(%rbp)

/ (**)
    movzbl  -1(%rbp), %eax
    cmpb    -2(%rbp), %al
$6 = [ CF SF IF OF ]
    setl    %al
    movb    %al, -4(%rbp)

/ (***)
    movb    $64, -5(%rbp)
    movb    $-64, -6(%rbp)
    movzbl  -5(%rbp), %eax
    subb    -6(%rbp), %al
$7 = [ CF SF IF OF ]
    movb    %al, -7(%rbp)
 
/ (****)
    movzbl  -1(%rbp), %eax
    cmpb    -2(%rbp), %al
$8 = [ CF SF IF OF ]
    setl    %al
    movb    %al, -8(%rbp)

/ 1313	.

/ met int	,

/ Deze heeft bij (*) wel meteen de goede eflags	, met of	,

$ vi add8a.c

    int i1=(int)0x40000000;
    int i2=(int)0xc0000000;
    int d=i1-i2;
/(*)

    unsigned int ui1=0x40000000;
    unsigned int ui2=0xc0000000;
    unsigned int ud=ui1-ui2;
/(**)

/ (*)
    movl    $1073741824, -4(%rbp)
    movl    $-1073741824, -8(%rbp)
    movl    -4(%rbp), %eax
    subl    -8(%rbp), %eax
$1 = [ CF PF SF IF OF ]
    movl    %eax, -12(%rbp)

/ (**)
    movl    $1073741824, -16(%rbp)
    movl    $-1073741824, -20(%rbp)
    movl    -16(%rbp), %eax
    subl    -20(%rbp), %eax
$2 = [ CF PF SF IF OF ]
    movl    %eax, -24(%rbp)



/ Einde ASM

/ ASM

/ 7	. 

/ fun.c/.s

/ 13	. 

/ overzicht	, we zijn in fun	,

gdb) x/6x $rsp-16
0x7fffffffdc80:	0x00007fffffffdca0	0x000000000040050f
0x7fffffffdc90:	0x00007fffffffdd80	0x0000000700000000
0x7fffffffdca0:	0x0000000000400530	0x00007ffff7a3b580
(gdb) x/i 0x000000000040050f
=> 0x40050f <main+25>:	mov    %eax,-0x8(%rbp)
(gdb) x/i 0x00007ffff7a3b580
   0x7ffff7a3b580 <__libc_start_main+240>:	mov    %eax,%edi
/ 0x00007fffffffdca0 is bp van main	, 
(gdb) x/i 0x000000000040050f
   0x40050f <main+25>:	mov    %eax,-0x8(%rbp)

dc80=bp f
dc88=ret i in main na call f 	, pushed door call f
...=stack main voor call f	,
dca0=bp main
dcf8=ret i in __libc_start_main na call main, pushed door call main	,

/ 13		. 

/ in main	,

/ als we zojuist in main	,
8		pushq	%rbp
11		movq	%rsp, %rbp
/ dan kunnen we het ret instr	zo terugzien	,
(gdb) x/i *((long*)$rsp+1)
   0x7ffff7a3b580 <__libc_start_main+240>:	mov    %eax,%edi
(gdb) x/8gx $rsp
0x7fffffffdca0:	0x0000000000400530	0x00007ffff7a3b580
(gdb) x/i 0x00007ffff7a3b580
   0x7ffff7a3b580 <__libc_start_main+240>:	mov    %eax,%edi
/ Wat is 0x0000000000400530 voor een bp	?


/  13	. 	.

/ call fun	,

/ als we zojuist ,	

17		call	fun
(gdb) s
fun () at fun.s:31
31		pushq	%rbp
34		movq	%rsp, %rbp
/ dan ri	,
(gdb) x/i *((long*)$rsp+1)
   0x40050f <main+25>:	mov    %eax,-0x8(%rbp)
(gdb) x/8gx $rsp
0x7fffffffdc80:	0x00007fffffffdca0	0x000000000040050f / ri naar main
0x7fffffffdc90:	0x00007fffffffdd80	0x0000000700000000
0x7fffffffdca0:	0x0000000000400530	0x00007ffff7a3b580 / ri naar ...


/ 13	. 

/ return uit fun	,

(gdb) x/8xg $rsp
0x7fffffffdc80:	0x00007fffffffdca0	0x000000000040050f
0x7fffffffdc90:	0x00007fffffffdd80	0x0000000700000000
0x7fffffffdca0:	0x0000000000400530	0x00007ffff7a3b580
39		popq	%rbp
/ pops $rsp in $rbp	, we komen weer in de (branch van ) main	,

gdb) x/8xg $rsp
0x7fffffffdc88:	0x000000000040050f	0x00007fffffffdd80
0x7fffffffdc98:	0x0000000700000000	0x0000000000400530
41		ret
/ pops ret i eraf	, dus $rsp gaat 8 naar boven	, logisch
(gdb) x/i $rip
=> 0x40050f <main+25>:	mov    %eax,-0x8(%rbp)
(gdb) x/8xg $rsp
0x7fffffffdc90:	0x00007fffffffdd80	0x0000000700000000
0x7fffffffdca0:	0x0000000000400530	0x00007ffff7a3b580

/ 7	. 

/ arrays	,

/ int array	,

[eric@almond Asm]$ cat arr.c
#include<stdlib.h>
#define N 10
int main(){
	int*a=(int*)malloc(N*sizeof(int));
	int i;
	for(i=0;i<N;i++){
		a[i]=i*i;
	}	
	return(0);
}

/ long array	,

$ vi arr_l.c

#include<stdlib.h>
#define N 10
int main(){
        long*a=(long*)malloc(N*sizeof(long));
        long i;
        for(i=0;i<N;i++){
                a[i]=i*i;
        }
        return(0);
}


$ arr.s
	.file	"arr.c"
	.text
	.globl	main
	.type	main, @function
main:
.LFB2:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$40, %edi 		movl	$80, %edi
	call	malloc
	movq	%rax, -16(%rbp)
	movl	$0, -4(%rbp) 		movl	$0, -8(%rbp)
	jmp	.L2
.L3:
	movl	-4(%rbp), %eax 		movl	-8(%rbp), %rax
	cltq				NIET
	leaq	0(,%rax,4), %rdx 	leaq	0(,%rax,8), %rdx
0,4,8,... 				0,8,16,...
	movq	-16(%rbp), %rax
	addq	%rax, %rdx
	movl	-4(%rbp), %eax 		movl	-4(%rbp), %rax
	imull	-4(%rbp), %eax 		imull	-4(%rbp), %rax
	movl	%eax, (%rdx) 		movl	%rax, (%rdx)
	addl	$1, -4(%rbp) 		addl	$1, -8(%rbp)
.L2:
	cmpl	$9, -4(%rbp) 		cmpl	$9, -8(%rbp)
	jle	.L3
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE2:
	.size	main, .-main
	.ident	"GCC: (GNU) 5.3.1 20151207 (Red Hat 5.3.1-2)"
	.section	.note.GNU-stack,"",@progbits

/ Als we debug	,

/ int array	,
gdb) x/3w 0x602010
0x602010:	0x00000000	0x00000001	0x00000004

/ long array	,
(gdb) x/3g 0x602010
0x602010:	0x0000000000000000	0x0000000000000001
0x602020:	0x0000000000000004

/ bij int array	, kunnen we ook	, maar makes no sense	,
(gdb) x/3g 0x602010
0x602010:	0x0000000100000000	0x0000000000000004
0x602020:	0x0000000000000000

/ geef 
(gdb) help x
/ size w (word), g (giant)	, h (half word), b (byte)
/ x betekent hex	,


/ Einde ASM

/ MIXAL

/ Ga naar	,
http://www.gnu.org/software/mdk/#mix


/ 13	. 
/ click MDK Documentation	,
http://www.gnu.org/software/mdk/manual/html_node/index.html

/ Kies 3. Getting started

/ Kies 3.1 Writing a source file	,
http://www.gnu.org/software/mdk/manual/html_node/Writing-a-source-file.html#Writing-a-source-file


/ 13	. 
/ click  tutorial	,
http://www.gnu.org/software/mdk/manual/html_node/MIX-and-MIXAL-tutorial.html
/ click de MIX computer
/ click MIX instruction set	,

[eric@almond mdk-1.2.8]$ sudo yum install mdk
Dependencies Resolved

============================================================================================================
 Package               Arch                   Version                          Repository              Size
============================================================================================================
Installing:
 mdk                   x86_64                 1.2.8-1.fc21                     fedora                 273 k
Installing for dependencies:
 gc                    x86_64                 7.4.2-2.fc21                     fedora                 104 k
 guile                 x86_64                 5:2.0.11-3.fc21                  fedora                 3.9 M

Transaction Summary
============================================================================================================
Install  1 Package (+2 Dependent packages)

Total download size: 4.3 M
Installed size: 15 M
Is this ok [y/d/N]: 

[eric@almond Manual]$ repoquery -l mdk
/usr/bin/gmixvm
/usr/bin/mixasm
/usr/bin/mixguile
/usr/bin/mixvm
/usr/share/applications/mdk.desktop
/usr/share/doc/mdk
/usr/share/doc/mdk/AUTHORS
/usr/share/doc/mdk/COPYING
/usr/share/doc/mdk/README
/usr/share/doc/mdk/THANKS
/usr/share/info/mdk.info.gz
/usr/share/locale/de/LC_MESSAGES/mdk.mo
/usr/share/mdk
/usr/share/mdk/mixal-mode.el
/usr/share/mdk/mixgtk.glade
/usr/share/mdk/mixguile-commands.scm
/usr/share/mdk/mixguile-vm-stat.scm
/usr/share/mdk/mixguile.scm
/usr/share/mdk/mixvm.el

/ 7	. 

/ Lees	,
http://www.jklp.org/profession/books/mix/c06.html


/ Kies op  
https://www.gnu.org/software/mdk/#downloading
/ MDK Documentation
https://www.gnu.org/software/mdk/manual/html_node/index.html

/ Kies Getting started
https://www.gnu.org/software/mdk/manual/html_node/index.html#toc-Getting-started-1

$ mixasm hello
$ mixvm -r hello

/ 13	. 

$ vi for3.mixal

N   EQU 10
TERM EQU 19
START OUT MSG(TERM)
    HLT
MSG ALF "Hello"
    END START

[eric@almond Manual]$ mixasm for3
[eric@almond Manual]$ mixvm -r for3
Program loaded. Start address: 0
Running ...
HELLO                                                                 
... done

/ HLT kunnen we RM	,
/ TODO

/ 13	 .

/ maar deze is ook OK	,

$ vi for2.xml

N   EQU 10
TERM EQU 19
START OUT MSG(TERM)
    END START

[eric@almond Manual]$ mixasm for2
for2.mixal:0: warning: undefined symbol: MSG
(1 warning(s))
[eric@almond Manual]$ mixvm -r for2
Program loaded. Start address: 0
Running ...
                                                                      
... done

/ 7	. 

[eric@almond Manual]$ cat hello.mixal
TERM    EQU    19       
        ORIG   1000    
START   OUT    MSG(TERM)
        HLT            
MSG     ALF    "MIXAL"
        ALF    " HELL"
        ALF    "O WOR"
        ALF    "LD   "
        END    START 

$ mixvm -r runs 	, maar zonder -r kunnen we debug	,

[eric@almond Manual]$ mixvm hello
MIX> pc
Current address: 1000
MIX> help
...
MIX> pall
rA: + 00 00 00 00 00 (0000000000)
rX: + 00 00 00 00 00 (0000000000)
rJ: + 00 00 (0000)
rI1: + 00 00 (0000)	rI2: + 00 00 (0000)	
rI3: + 00 00 (0000)	rI4: + 00 00 (0000)	
rI5: + 00 00 (0000)	rI6: + 00 00 (0000)	
Overflow: F
Cmp: E
MIX> help pmem
pmem           Print memory contents in address range.
               Usage: pmem FROM[-TO]
MIX> pmem 0
0000: + 00 00 00 00 00 (0000000000)
MIX> pmem 1000
1000: + 15 42 00 18 37 (0262669477)
MIX> pmem 1001
1001: + 00 00 00 02 05 (0000000133)
MIX> pmem 1002
1002: + 14 09 27 01 13 (0237350989)
MIX> psym
START               :  1000
MSG                 :  1002
TERM                :  18
MIX> pline
Line 3: START       OUT    MSG(TERM)

/ Kijk Knuth vol1 (148)
14=M
9=I
...
/ dus op 1002=MSG zien we MIXAL 	, klopt	,



/ 7	. 

$ vi for5.mixal

ARR     ORIG    *+10
TERM    EQU     19
N       CON     7
        ORIG    1000
START   LDA     N
        STA     ARR
        OUT     ARR(TERM)
	HLT
        END     START

eric@almond Manual]$ mixvm -r for5
Program loaded. Start address: 1000
Running ...
    G                                                 G               
... done

/ Klopt, 7 is G	,
/ we zien 2 keer G	, want is op N	, maar ook op ARR	,

[eric@almond Manual]$ mixvm for5
Program loaded. Start address: 1000
MIX> psym
START               :  1000
N                   :  10
ARR                 :  0
TERM                :  19
MIX> pmem 10
0010: + 00 00 00 00 07 (0000000007)
...
MIX> pmem 0
0000: + 00 00 00 00 07 (0000000007)
MIX> pmem 10
0010: + 00 00 00 00 07 (0000000007)
/ G staat al op 10 (N)	, maar nu ook op 0 (ARR)


/ Dit is hetzelfde	,
N CON 7
START   LDA N
/ en	,
START   LDA =7=

/ Lees Knuth Vol1 (150) Dat is ook wat =7= doet: er wordt een line	,
n CON 7
/ created	, 
en LDA =7= wordt vervangen door	, 
	LDA n

/ 7	.




/ 7. 	

/ see ACP1(149) met CHAR	,

$ vi arr.mixal

ARR ORIG *+10
TERM EQU 19
N CON 7
    ORIG 1000
START   LDA N
    CHAR
    STX ARR

    OUT ARR(TERM)

    END START

/ we zien	, 
00007

/ 7	. 

ARR ORIG *+10
TERM EQU 19
N CON 7
M EQU 7
    ORIG 1000
START   LDA N
    INCA M
    CHAR
    STX ARR

    OUT ARR(TERM)

    END START

/ we zien 
00017
/ want N=10, N is een &	, 
/ we moeten dus	,

ARR ORIG *+10
TERM EQU 19
N CON 7
M EQU 7
    ORIG 1000
START   LDA N
    INCA M
    CHAR
    STX ARR

    OUT ARR(TERM)

    END START

/ of directer	,

ARR ORIG *+10
TERM EQU 19
N CON 7
    ORIG 1000
START   LDA N
    INCA 7
    CHAR
    STX ARR

    OUT ARR(TERM)

    END START
 
/ we zien als we print naast 00014 ook G	, 
/ hij print ook wat er op & N staat: 7	, als we N CON 8 doen	, zien we H	,

/ we moeten dan ook	,

$ vi for5.mixal

ARR ORIG *+10
    ORIG 1000
TERM EQU 19
N CON 7
M EQU 7
START   LDA N
    INCA M
    CHAR
    STX ARR

    OUT ARR(TERM)

    END START

/ we zien 
00014

/ we hernoemen for5.mixal met arr.mixal,
/ we hebben ook for5.mixal created	, achteraf weer	,

/ 7	. 

 /we kunnnen ook directer	,

$ vi arr2.mixal	,

ARR     EQU     0
TERM    EQU     19
M       EQU     7
        ORIG    10
N       CON     8
        ORIG    1000
START   LDA     N
        INCA    M
        CHAR
        STX     ARR

        OUT     ARR(TERM)
        HLT
        END     START

[eric@almond Manual]$ mixvm -r arr2
Program loaded. Start address: 1000
Running ...
00015                                                 H               
... done

/Dus CHAR zorgt ervoor dat we het getal zelf zien	, en niet N (want 15 is N)	,

/ we kunnen achter HLT	,

$ vi arr2.mixal

ARR     EQU     0
TERM    EQU     19
M       EQU     7
        ORIG    1000
START   LDA     N
        INCA    M
        CHAR
        STX     ARR

        OUT     ARR(TERM)
        HLT
        ORIG    10
N       CON     8
        END     START

/ maar de EQU's moeten bovenaan blijven	,

/ ARR EQU 0 moet ook	, niet default of zo, want anders kent hij ARR niet	,


/ 7	. 

/ LDA STA werken met &'s dus met CON	,  maar =7= kan ook	,	want deze maakt stiekem ook een CON regel	,
/ INCA werkt met getallen , dus met EQU	, of met 7	,

/ ADD, SUB, MUL, DIV werken met &'s dus MUL N	, dan CON N	,
/ MUL, CHAR pakken rA, 	en result in rArX	, dus als klein, dan alleen in rX	, 
/ DIV pakt rArX, wordt gedeeld door wat op & M staat	, dus DIV M, met CON M	,

/ 7

$ vi for6.mixal

ARR ORIG *+10
H ORIG *+1
TERM EQU 19
N CON 8
M EQU 7
 ORIG 1000
START   LDA N
 INCA M
 MUL N
 STX H
 LDA H
 CHAR
 STX ARR
 OUT ARR(TERM)
 END START

/ 7	. 

$ vi for6a.mixal

ARR     ORIG 10			ARR= loc 0	,
N CON 8				N = loc 10
H ORIG 1			H = loc 11	, ORIG 1 is useless here	
TERM EQU 19
M EQU 7
 ORIG 1000
START   LDA N
 INCA M
 MUL N
 STX H				0011: + 00 00 00 01 56 (0000000120)
 LDA H
 CHAR
 STX ARR			0000: + 30 30 31 32 30 (0511309854)
 OUT H(TERM)
 END START


/ MUL sets result in rArX	. Nu staat 120 in rX.	 Deze moet naar rA copy	, voor CHAR	. Dit doen we via H	. 
/ TODO (Kan dit anders?) 

/ MUL N : rA*N	, en sets result in rArX	, dus bij kleine res zit alles in rX	,
/ CHAR pakt rA en sets res in rArX	,

/ we hebben omdat we kleine res , rX -> H -> rA en toen CHAR , en toen STX omdat alle char's, 120, in rX , weer	,
/ TODO (Hoe bij grote getallen?)

/ we zien  
rX: + 00 00 00 01 56 (0000000120)
/ 120=64+56	,  dus is dit een mix van octal en decimal	, ?
/ TODO

MIX> pline 
Line 9:             MUL   N
MIX> next 
Elapsed time: 10 /Total program time: 13 (Total uptime: 13)
MIX> preg
rA: + 00 00 00 00 00 (0000000000)
rX: + 00 00 00 01 56 (0000000120)
MIX> preg 
rA: + 00 00 00 01 56 (0000000120)
rX: + 00 00 00 01 56 (0000000120)
MIX> pline
Line 12:             CHAR  
MIX> next 
Elapsed time: 10 /Total program time: 27 (Total uptime: 27)
MIX> preg 
rA: + 30 30 30 30 30 (0511305630)
rX: + 30 30 31 32 30 (0511309854)

MIX>  pline
Line 13:             STX   ARR 	
MIX> next 
Elapsed time: 2 /Total program time: 29 (Total uptime: 29)
MIX> pmem 0
0000: + 30 30 31 32 30 (0511309854)
MIX> pmem 10
0010: + 00 00 00 00 08 (0000000008)
MIX> pmem 11
0011: + 00 00 00 01 56 (0000000120)

 OUT H(TERM)
MIX> next 
   A'         

/ we zien in Knuth Vol1 (140/141) dat A=1 en '=55	, blijkbaar 56 -> '	,



/ we moeten als er geen label (=&) staat een spatie inspringen	,

/ we zien 	,
[eric@almond Manual]$ mixasm for6.mixal ; mixvm -r for6
Program loaded. Start address: 1000
Running ...
00120                                                A'    H          
... done


/ 7	. 

$ vi for7.mixal

TERM EQU 19
N CON 8
M EQU 7
 ORIG 1000
START   LDA N
 INCA M
 MUL N
 STX H
 LDA H
 CHAR
 STX ARR
 OUT ARR(TERM)
 HLT
ARR ORIG 0
H ORIG 1
 END START

 /of	,

ARR ORIG 0
H ORIG 1
 ORIG 14
TERM EQU 19
N CON 8
M EQU 7
 ORIG 1000
START   LDA N
 INCA M
 MUL N
 STX H
 LDA H
 CHAR
 STX ARR
 OUT ARR(TERM)
 HLT
 END START

/ Lees ACP(136) 19 is 14 words	, Geef ORIG 14 zodat N op de volgende regel	,  we doen OUT ARR(TERM) , 1 regel dus	, en we zien dus NIET	,
00144                                                                I
 

/ we zien	,

[eric@almond Manual]$ mixasm for7.mixal ; mixvm -r for7
Program loaded. Start address: 1000
Running ...
00120                                                                 
... done


/ 7	.

$ vi for7a.mixal

ARR ORIG 0
 ORIG 1 
TERM EQU 19
N CON 9
M EQU 7
 ORIG 1000
START   LDA N
 CHAR
 STX ARR
 OUT ARR(TERM)
 END START

[eric@almond Manual]$ mixasm for7a.mixal ; mixvm -r for7a
Program loaded. Start address: 1000
Running ...
00009    I                                                            
... done

$ vi for7a.mixal

ARR ORIG 0
 ORIG 1 
TERM EQU 19
N CON 9
M EQU 7
 ORIG 1000
START   LDA N
 CHAR
 STX ARR
 STX N
 OUT ARR(TERM)
 END START

/ we overwrite N=1 	, eerst 9	,  later 39	,

[eric@almond Manual]$ mixasm for7a.mixal ; mixvm -r for7a
Program loaded. Start address: 1000
Running ...
0000900009                                                            
... done

/ we laten ORIG 1 weg	, dan hebben we minder ruimte res	,

$ vi for7a.mixal

ARR ORIG 0
TERM EQU 19
N CON 9
M EQU 7
 ORIG 1000
START   LDA N
 CHAR
 STX ARR
 STX N
 OUT ARR(TERM)
 END START

[eric@almond Manual]$ mixasm for7a.mixal ; mixvm -r for7a
Program loaded. Start address: 1000
Running ...
00009
... done

/ Dus zien we N niet	,
/ Klopt	, ARR=0 en N=0	, en in X staat 39	, 


$ vi for7a.mixal

ARR ORIG 0
 ORIG 1
TERM EQU 19
N CON 9
M EQU 7
 ORIG 1000
START   LDA N
 CHAR
 STX ARR
 OUT ARR(TERM)
 END START

[eric@almond Manual]$ mixasm for7a.mixal ; mixvm -r for7a
Program loaded. Start address: 1000
Running ...
00009    I                                                            
... done

$ vi for7b.mixal

ARR EQU 0
H EQU 1
TERM EQU 19
M EQU 7
 ORIG 1000
START   LDA  H	 
 CHAR
 STX ARR
 STX N
 OUT ARR(TERM)
 HLT
 ORIG ARR
 ORIG H
N CON 9
 END START

/ Of	,
START   LDA  N	 

/ want N is waar H begint	,  

[eric@almond Manual]$ mixasm for7b.mixal ; mixvm -r for7b
Program loaded. Start address: 1000
Running ...
0000900009                                                            
... done

/ als we	,
 ORIG ARR
N CON 9
 ORIG H

/ dan doet load 0	,  
START LDA H 

/ 7	 .

$ vi for7c.mixal

ARR EQU 0
H EQU 1
TERM EQU 19
M EQU 7
 ORIG 1000
STRT LDA  H 
 CHAR
 STX ARR
 STX N
 OUT ARR(TERM)
 HLT
 ORIG 1
N CON 9
 END STRT

/we zien	,
[eric@almond Manual]$ mixasm for7c.mixal ; mixvm -r for7c
Program loaded. Start address: 1000
Running ...
0000900009                                                            
... done

/ we moeten ORIG 1 bijvoorbeeld voor N CON 9	, anders is N ergens achter 1000	,

/ 7	.

$ vi for7c.mixal

TERM EQU 19
 ORIG 1000
STRT LDA ARR
 CHAR
 STX ARR
 LDA M
 CHAR
 STX M
 OUT ARR(TERM)
 HLT
ARR ORIG 0
N CON 7
M CON 13
 END STRT

/ Dit is niets bijzonders	, 
ARR ORIG 0
/ ARR is ergens in de 1000	, een label (&)	,
/ Dus als we 
 LDA ARR
/ krijgen we 0	,

/ Maar N=0	, en M=1	, dus we kunnen	, 

$ vi for7c.mixal

H EQU 1
TERM EQU 19
 ORIG 1000
STRT LDA 0
 CHAR
 STX ARR
 LDA M
 CHAR
 STX M
 OUT ARR(TERM)
 HLT
ARR ORIG 0
N CON 7
M CON 13
 END STRT

/we zien	,
[eric@almond Manual]$ mixasm for7c.mixal ; mixvm -r for7c
Program loaded. Start address: 1000
Running ...
00007                                                                 
... done

/ WH staat 7 ergens op plaats acher 1000	,

/ we kunnen ook	,
STRT LDA 1
Running ...
00013                                                                 
... done

/ 7	. 

$ vi for6a.mixal

ARR ORIG *+10
N CON 8
H ORIG *+1
TERM EQU 19
M EQU 7
 ORIG 1000
START   LDA N
 INCA M
 MUL N
 STX H
 LDA H
 CHAR
 STX ARR
 OUT ARR(TERM)
 END START

[eric@almond Manual]$ mixasm for6a.mixal ; mixvm  for6a
MIX> psym N
+ 00 00 00 00 10 (0000000010)
MIX> psym H
+ 00 00 00 00 11 (0000000011)

/ Inderdaad	, N=10, een adres	,

/ als we hier zijn	,
MIX> pline
Line 11:             LDA   H
/ dan	,
MIX> pmem 10
0010: + 00 00 00 00 08 (0000000008)
MIX> pmem 11
0011: + 00 00 00 01 56 (0000000120)
/ Klopt	,

MIX> next
00120                                                 H   A'          
Elapsed time: 1 /Total program time: 30 (Total uptime: 30)

/ we zien hier WH ARR (10 bytes) en N en H	, 
/ Dus 
 OUT ARR(TERM)
/ prints ARR, N en H	, 
/ Wanneer stopt hij	?

/ we kunnen ook gewoon	, ORIG 10 ipv, ORIG *+10	,

$ vi foo6a.mixal

ARR ORIG 10
N CON 8
H ORIG 1
TERM EQU 19
M EQU 7
 ORIG 1000
START   LDA N
 INCA M
 MUL N
 STX H
 LDA H
 CHAR
 STX ARR
 OUT H(TERM)
 END START

/ 7	. 

/ we fill een array met 10 getallen	, 

$ vi for9.mixal
ARR     EQU     0
        ORIG    1000
START   ENT3    9 
LOOP    ST3     ARR,3
        DEC3    1
        J3P     LOOP
        HLT
        END     START

/ we zien
ARR=0 	0
1	1
...
9	9

/ 7	. 

/ Maak een array van kwadraten	,

$ vi for9.mixal

ARR     EQU     0
H       EQU     10
        ORIG    1000
START   ENT1    9
LOOP    ST1     H
        LDA     H
        MUL     H
        STX     ARR,1
        DEC1    1
        J1P     LOOP
        HLT
        END     START

/ we zien	,

MIX> pmem 9
0009: + 00 00 00 01 17 (0000000081)
MIX> pmem 8
0008: + 00 00 00 01 00 (0000000064)
MIX> pmem 7
0007: + 00 00 00 00 49 (0000000049)
MIX> pmem 1
0001: + 00 00 00 00 01 (0000000001)
MIX> pmem 2
0002: + 00 00 00 00 04 (0000000004)

/ 13	. 

/ we print ook  de kwadraten	,

$ vi for9a.mixal

ARR     EQU     0
STR     EQU     10
H       EQU     20
PRINTER EQU     19
        ORIG    1000
START   IOC     0(PRINTER)
        ENT1    9
LOOP    ST1     H
        LDA     H
        MUL     H
        STX     ARR,1
        LDA     ARR,1
        CHAR
        STX     STR,1
        OUT     STR,1(PRINTER)
        DEC1    1
        J1P     LOOP
        HLT
        END     START

MIX> run
Running ...
00081    I                                                            
0006400081    H                                                       
000490006400081    G                                                  
00036000490006400081    F                                             
0002500036000490006400081    E                                        
000160002500036000490006400081    D                                   
00009000160002500036000490006400081    C                              
0000400009000160002500036000490006400081    B                         
000010000400009000160002500036000490006400081    A                    

/ Hij print dus de hele line	, en ook nog eens H	,
/ TODO


/ of	,
/ met oplopende teller in loops	,

$ vi for9a_2.mixal

ARR     EQU     0
STR     EQU     10
H       EQU     20
PRINTER EQU     19
        ORIG    30
M       CON     10
        ORIG    1000
START   IOC     0(PRINTER)
        ENT1    0
6H      ST1     H
        LDA     H
        MUL     H
        STX     ARR,1
        LDA     ARR,1
        CHAR
        STX     STR,1
        OUT     STR,1(PRINTER)
        INC1    1
        CMP1    M
        JL      6B
        HLT
        END     START


/ we hebben hierboven toegepast	,

/ 7	 

/ Hierboven laten we de loops aflopen	, 9,8,...,2,1,0
/ Kunnen we ook oplopende loops maken	?

/ CMP1 werkt met een mem location	,

 $ vi jump_2.mixal

H       CON     10
        ORIG    1000
START   ENT1    9
6H      CMP1    H
        JL      6B
6H      HLT
        END START

/ of	,

$ vi jump.mixal

H       CON 	10 
        ORIG    1000
START  	ENT1	9 
6H      CMP1    H
        JL      6B
6H      HLT
        END START



$ vi loop2_mixal

H       CON     10      upperbound      ,
        ORIG    1000
START   ENT1    0
6H      CMP1    H       compare         ,
        INC1    1
        JL      6B
        HLT
        END START

/ of	,

$ vi loop.mixal

H       EQU     0
        ORIG    1000
START   ENTA    10
        STA     H       upperbound	,
        ENT1    0
6H      CMP1    H       compare	,
        INC1    1
        JL      6B
        HLT
        END START



/ 7. 

/ we maken C program	,

$ less arr.c

#include<stdlib.h>
#define N 10
int main(){
        int*a=(int*)malloc(N*sizeof(int));
        int i;
        for(i=0;i<N;i++){
                a[i]=i*i;
        }
        return(0);
}

$ gcc -S arr.c

/ 	7	.

/ Lees	,
http://www.jklp.org/profession/books/mix/c06.html

$ vi pr_with_sub_2.mixal

LIST    EQU     0
VARS    EQU     10
        ORIG    VARS
M       CON     10
        ORIG    3000
PROG    ENT1    0
2H      CMP1    M
        INC1    1
        ST1     LIST,1
        JL      2B
        JMP     MAX
        JMP     PRINT
        HLT
MAX     STJ     RI
RI      JMP     *
PRINT   STJ     RI2
RI2     JMP     *
        END     PROG

/ we zien dat de ri na 'jmp max' is 'jmp print'. Dus in RI wordt 'jmp print' stored	,
/ we zien dat de ri na 'jmp print' is 'hlt'. Dus in RI2 wordt 'hlt' stored	,

[eric@almond Manual]$ mixvm pr_with_sub_2
Program loaded. Start address: 3000
MIX> psym
LIST            :  0
M               :  10
VARS            :  10
PROG            :  3000
MAX             :  3008
RI		:  3009
PRINT           :  3010
RI2		:  3011

/ 7	. 

/ We kunnen WH alleen een mem optellen in add	, 

$ vi reg_to_reg.mixal

M       CON     7
N       CON     8
        ORIG    1000
PROG    ENT1    1
        ENT2    0,1
        LD3     M
        LD4     M,1
        HLT
        END     PROG

/ OK	, 

/ ent pakt constants	, ld mem 	, we kunnen beide index	, 

$ vi in.mixal
LIST    EQU     0
        ORIG    1000
PGR     IN      LIST(19)

/ we zien dat als we bijv	, 
MIX> next 
1234 7  	134	/ geef 2 tabs na 7	, 
MIX> pmem 0
0000: + 31 32 33 34 00 (0528619648)
MIX> pmem 1
0001: + 37 63 63 31 33 (0637532129)
MIX> pmem 2
0002: + 34 00 00 00 00 (0570425344)

/ Dus een space geeft 0	, een tab 63	,
/ TODO

/ we moeten WH na iedere enter de value inlezen, met NUM -> getal, en store in LIST	, 
/ Dus niet een hele list inlezen	, maar getal voor getal	,
/ TODO

/ 7	. 

/ we hardcode de input	,

LIST    EQU     0
L       EQU     10

        ORIG    3000
PROG    ENTA    13
        ENT1    0
        STA     LIST,1
        ENTA    7
        INC1    1
        STA     LIST,1
        ENTA    15
        INC1    1
        STA     LIST,1
        ENTA    8
        INC1    1
        STA     LIST,1
        INC1	1
        ST1     L
        HLT
        END     PROG

MIX> pmem 0
0000: + 00 00 00 00 13 (0000000013)
MIX> pmem 1
0001: + 00 00 00 00 07 (0000000007)
MIX> pmem 2
0002: + 00 00 00 00 15 (0000000015)
MIX> pmem 3
0003: + 00 00 00 00 08 (0000000008)
MIX> pmem 10
0010: + 00 00 00 00 04 (0000000004)


/ see book (145)	, 
$ vi pr_with_sub_2.mixal


LIST	EQU 	0
L	EQU	10	
I	EQU 	11
M	EQU	12

	ORIG 	3000
PROG 	ENTA	13
	ENT1	0
	STA	LIST,1
	ENTA	7
	INC1	1
	STA	LIST,1
	ENTA	15	
	INC1	1
	STA	LIST,1
	ENTA	8	
	INC1	1
	STA	LIST,1
	INC1	1
	ST1	L

	JMP 	MAX	
	JMP	PRINT
	HLT	

MAX	STJ 	RI	
	LD1 	L		I1=j
	DEC1	1	
	LD2	LIST,1		I2=Xj
	ENT3 	0,1		I3=k

2H	DEC3	1
	J3N 	SAVE	
	CMP2	LIST,3
	JGE	2B
	ENT1	0,3
	LD2 	LIST,3	
	JMP 	*-6	
SAVE	ENTA	0,1
	CHAR
	STX	I
	ENTA	0,2
	CHAR
	STX	M		
RI	JMP	*	

PRINT	STJ	RI2	
	IOC	0(19)
	OUT	I(19)
	OUT	M(19)
RI2	JMP	*
	END 	PROG

/ Alleen print gaat niet OK	, 
/ Kunnen we alleen een hele line print	?
/ TODO

/ 7	. 

[eric@almond Manual]$ mv pr_with_sub_2.mixal max_of_list.mixal

[eric@almond Manual]$ mv loop_2.mixal model_loop.mixal

/ Het is bijna C	,
[eric@almond Manual]$ cat model_loop.mixal 
H	CON	10 	upperbound	,
	ORIG 	1000
START 	ENT1	0
6H 	CMP1 	H	compare		,
	INC1	1
	JL 	6B
	HLT	
	END START
/ of	,

[eric@almond Manual]$ cat model_loop_2.mixal 
        ORIG    1000
START   ENT1    0
6H      CMP1    =10=    compare         ,
        INC1    1
        JL      6B
        HLT
        END START

/ 7	. 

/ we kunnen geen registers print,	 alleen mem locations	,
        ST1     0
        OUT     H(19)
/ prints mem location 0	,

/ we willen model_loop_2 hierboven test	, we print	,

$ vi model_loop_and_print.mixal
	ORIG 	1000
START 	ENT1	0
	IOC	0(19)
0H 	CMP1 	=10=	compare		,

	ENTA	0,1
	CHAR
	STX	0
	OUT 	0(19)

	INC1	1
	JL 	0B
	HLT	
	END START

[eric@almond Manual]$ mixvm -r model_loop_and_print
Program loaded. Start address: 1000
Running ...
00000                                                                 
00001                                                                 
00002                                                                 
00003                                                                 
00004                                                                 
00005                                                                 
00006                                                                 
00007                                                                 
00008                                                                 
00009                                                                 
00010                                                                 
... done




/ 7	. 

/ PRIME NUMBERS

/ We hebben primes 2,3,5,7	, 
/ Nu 11	 , 
/ 2 is geen deler	, 
11/3=3, rest 2	,   dus niet rest 0 
11/5=2, rest 1	, dus niet rest 0, maar ook	,
/ de rest<5 altijd	, maar nu is ook quotient 2<5	, en daardoor kunnen we sqrt 11 relateren aan 5	, 
11=2*5+1<5^2+5<6^2 => sqrt 11<=5 , 
/ als 11 een deler zou hebben , is er altijd een die <=sqrt 11	, maar die is er niet , want dat hebben we al gecontroleerd: 2,3,5 geven geen rest 0	,

/ 11/3=3, rest 2, dan kom je in stap P8	,

/ 13	. 

LDX	N	loads rX met cont(mem loc N)
ENTX	N	loads rX met mem loc N, bijv 200	,

/ 13	. 

A       CON     7
PROG    LDA     A
        LDX     =13=
        ENTA    8
/ Allemaal OK	,

/ 13	. 
       	ENTA    0
        ENTX    100
        DIV     =14=

MIX> preg
rA: + 00 00 00 00 07 (0000000007)
rX: + 00 00 00 00 02 (0000000002)

/ OK

 /13	. 

       ENT1    6
        ENTA    0,1

/ OK
 A heeft nu ook 6	, 
/ Als we	,
	LDA	0,1
/ dan loads a van mem 6 de value in	,

/ 13	. 

       ENT1    A
        ENT2    A+7

/ in I1 is mem loc A en in I2 mem loc A+7

        LD1     A
        LD2     A+7

/ In I1 is cont mem loc A	, in I2 is cont mem loc A+7	,

/ 13	. 

/ cmp uses altijd cont mem loc	,

        ENT1    A+14
        CMP1    =A+7=
        JGE     0F

/ OK

/ 13	. 

/ 	7. 

/ Voorlopig primes prg	,


$ vi primes_2.mixal

PRIME 	EQU	0
STR	EQU	1000
N	EQU  	2000
	ORIG 	3000

PROG	ENT1	1		I1=j
	IOC	0(19)
	ENTA	2		N=n	(n is the number)
	STA	PRIME,1
	ENTA	3
	STA	N
0H	CMP1 	=1000=	
	JGE	3F
	INC1	1
	LDA	N
	STA	PRIME,1
1H	LDA	N	
	INCA	2		next number
	STA	N
	ENT2	1		I2=k	(k is index of the divisor PRIME[k])	
2H	INC2	1
	ENTA	0
	LDX	N
	DIV 	PRIME,2
	CMPX	=0=
	JE	1B	
	CMPA	PRIME,2
	JLE	0B		
	JMP	2B
3H	ENT1	0
4H	CMP1 	=1000=	
	INC1	1
	LDA	PRIME,1
	CHAR
	STX	STR,1(2:5)	
	JL	4B

	ENT1 	STR	
5H	CMP1	=STR+1000=
	OUT	0,1(19)
	INC1	14
	JL	5B
6H	HLT
	END	PROG	

[eric@almond Manual]$ mixvm -r primes_2
Program loaded. Start address: 3000
Running ...
  A'/ 0002 0003 0005 0007 0011 0013 0017 0019 0023 0029 0031 0037 0041
 0043 0047 0053 0059 0061 0067 0071 0073 0079 0083 0089 0097 0101 0103
 0107 0109 0113 0127 0131 0137 0139 0149 0151 0157 0163 0167 0173 0179
 0181 0191 0193 0197 0199 0211 0223 0227 0229 0233 0239 0241 0251 0257
 0263 0269 0271 0277 0281 0283 0293 0307 0311 0313 0317 0331 0337 0347
 0349 0353 0359 0367 0373 0379 0383 0389 0397 0401 0409 0419 0421 0431
 0433 0439 0443 0449 0457 0461 0463 0467 0479 0487 0491 0499 0503 0509
 0521 0523 0541 0547 0557 0563 0569 0571 0577 0587 0593 0599 0601 0607
 0613 0617 0619 0631 0641 0643 0647 0653 0659 0661 0673 0677 0683 0691
 0701 0709 0719 0727 0733 0739 0743 0751 0757 0761 0769 0773 0787 0797
 0809 0811 0821 0823 0827 0829 0839 0853 0857 0859 0863 0877 0881 0883
 0887 0907 0911 0919 0929 0937 0941 0947 0953 0967 0971 0977 0983 0991
 0997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087
 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187
 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289
 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409
 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489
 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597
 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697
 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801
 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913
 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027
 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131
 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251
 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351
 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447
 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591
 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689
 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789
 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897
 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019
 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163
 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259
 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371
 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499
 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593
 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701
 3709 3719 3727 3733 3739 3761 3767 3769 3779 3793 3797 3803 3821 3823
 3833 3847 3851 3853 3863 3877 3881 3889 3907 3911 3917 3919 3923 3929
 3931 3943 3947 3967 3989 4001 4003 4007 4013 4019 4021 4027 4049 4051
 4057 4073 4079 4091 4093 4099 4111 4127 4129 4133 4139 4153 4157 4159
 4177 4201 4211 4217 4219 4229 4231 4241 4243 4253 4259 4261 4271 4273
 4283 4289 4297 4327 4337 4339 4349 4357 4363 4373 4391 4397 4409 4421
 4423 4441 4447 4451 4457 4463 4481 4483 4493 4507 4513 4517 4519 4523
 4547 4549 4561 4567 4583 4591 4597 4603 4621 4637 4639 4643 4649 4651
 4657 4663 4673 4679 4691 4703 4721 4723 4729 4733 4751 4759 4783 4787
 4789 4793 4799 4801 4813 4817 4831 4861 4871 4877 4889 4903 4909 4919
 4931 4933 4937 4943 4951 4957 4967 4969 4973 4987 4993 4999 5003 5009
 5011 5021 5023 5039 5051 5059 5077 5081 5087 5099 5101 5107 5113 5119
 5147 5153 5167 5171 5179 5189 5197 5209 5227 5231 5233 5237 5261 5273
 5279 5281 5297 5303 5309 5323 5333 5347 5351 5381 5387 5393 5399 5407
 5413 5417 5419 5431 5437 5441 5443 5449 5471 5477 5479 5483 5501 5503
 5507 5519 5521 5527 5531 5557 5563 5569 5573 5581 5591 5623 5639 5641
 5647 5651 5653 5657 5659 5669 5683 5689 5693 5701 5711 5717 5737 5741
 5743 5749 5779 5783 5791 5801 5807 5813 5821 5827 5839 5843 5849 5851
 5857 5861 5867 5869 5879 5881 5897 5903 5923 5927 5939 5953 5981 5987
 6007 6011 6029 6037 6043 6047 6053 6067 6073 6079 6089 6091 6101 6113
 6121 6131 6133 6143 6151 6163 6173 6197 6199 6203 6211 6217 6221 6229
 6247 6257 6263 6269 6271 6277 6287 6299 6301 6311 6317 6323 6329 6337
 6343 6353 6359 6361 6367 6373 6379 6389 6397 6421 6427 6449 6451 6469
 6473 6481 6491 6521 6529 6547 6551 6553 6563 6569 6571 6577 6581 6599
 6607 6619 6637 6653 6659 6661 6673 6679 6689 6691 6701 6703 6709 6719
 6733 6737 6761 6763 6779 6781 6791 6793 6803 6823 6827 6829 6833 6841
 6857 6863 6869 6871 6883 6899 6907 6911 6917 6947 6949 6959 6961 6967
 6971 6977 6983 6991 6997 7001 7013 7019 7027 7039 7043 7057 7069 7079
 7103 7109 7121 7127 7129 7151 7159 7177 7187 7193 7207 7211 7213 7219
 7229 7237 7243 7247 7253 7283 7297 7307 7309 7321 7331 7333 7349 7351
 7369 7393 7411 7417 7433 7451 7457 7459 7477 7481 7487 7489 7499 7507
 7517 7523 7529 7537 7541 7547 7549 7559 7561 7573 7577 7583 7589 7591
 7603 7607 7621 7639 7643 7649 7669 7673 7681 7687 7691 7699 7703 7717
 7723 7727 7741 7753 7757 7759 7789 7793 7817 7823 7829 7841 7853 7867
 7873 7877 7879 7883 7901 7907 7919 9152                              
                                                                      
... done

/ De 1ste en de laatste klopt niet	,

/ 7	. 

/ MORGEN
primes_3
/ in Asm arr.s	, en daar kijk hoe for loop	, we zien $9	, 

/ 7	. 

$ vi arr.c

#include<stdlib.h>
#define N 10
int main(){
        int*a=(int*)malloc(N*sizeof(int));
        int i;
        for(i=1;i<=N;i++){
                a[i]=i*i;
        }
        return(0);
}

$ vi arr.s

/ Geef in google, array addressing gas
/ Lees	,
https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax

When referencing a register, the register needs to be prefixed with a "%". Constant numbers need to be prefixed with a "$".

-4(%ebp, %edx, 4): -4+(%ebp+%edx*4)
-4(, %edx, 4): -4+(%edx*4)
...

/ See ASM

/ Lees	,
http://stackoverflow.com/questions/6555094/what-does-cltq-do-in-assembly

/ 7	. 

/ we maken de loops anders	,

$ vi loop_2.mixal
$ vi model_loop_and_print_2.mixal

        ORIG    1000
START   IOC     0(19)
        ENT1    0
        JMP     1F
0H      ENTA    0,1
        CHAR
        STX     0
        OUT     0(19)  
        INC1    1
1H      CMP1    =10=
        JL      0B
        HLT
        END START

[eric@almond Manual]$ mixvm -r loop_2
Program loaded. Start address: 1000
Running ...
00000                                                                 
00001                                                                 
00002                                                                 
00003                                                                 
00004                                                                 
00005                                                                 
00006                                                                 
00007                                                                 
00008                                                                 
00009                                                                 
... done

$ vi model_loop_2.mixal

        ORIG    1000
START   IOC     0(19)
        ENT1    0
        JMP     1F
0H      INC1    1
1H      CMP1    =10=
        JL      0B
        HLT
        END START

/ 7	. 

/ we hebben 
model_loop_2.mixal & model_loop_and_print_2.mixal: vlg for(j=1;j<=100;j++)

/ we hebben primes.c en primes.s: zelf gemaakt in C met for loops 

/ we hebben primes_2.mixal	, die bijna OK is	,

/ we gaan primes_3 maken, vlg Knuth	,

/ 7	. 

/ we maken test tbv primes_3	,

/ 13	. 

/ In C is dit do-while loop	,

$ vi loop_variant.mixal

        ORIG    1000
PROG    ENT1    1       j
        ENT2    3       n
0H      INC1    1
        ST2     0,1
        INC2    2
        CMP1    =13=
        JL      0B
        HLT
        END     PROG

MIX> pmem 1
0001: + 00 00 00 00 00 (0000000000)
MIX> pmem 2
0002: + 00 00 00 00 03 (0000000003)
MIX> pmem 3
0003: + 00 00 00 00 05 (0000000005)
MIX> pmem 4
0004: + 00 00 00 00 07 (0000000007)
MIX> pmem 13
0013: + 00 00 00 00 25 (0000000025)
MIX> pmem 14
0014: + 00 00 00 00 00 (0000000000)

$ vi loop_variant.c

#define N 13
#include<stdlib.h>
int main(){
        int*P=(int*)malloc(N*sizeof(int));

        int j=1;
        int n=3;
        do{
                j=j+1;
                P[j]=n;
                n+=2;
        }while(j<=N);

        return(0);
}

$ vi loop_variant.s

        movl    $52, %edi
        call    malloc
        movq    %rax, -16(%rbp)
       	movl    $1, -4(%rbp)
        movl    $3, -8(%rbp)
.L2:
        addl    $1, -4(%rbp)
        movl    -4(%rbp), %eax
        cltq
        leaq    0(,%rax,4), %rdx
        movq    -16(%rbp), %rax
        addq    %rax, %rdx
        movl    -8(%rbp), %eax
        movl    %eax, (%rdx)
        addl    $2, -8(%rbp)
        cmpl    $13, -4(%rbp)
        jle     .L2
        movl    $2, -4(%rbp)
        jmp     .L3

[eric@almond Manual]$ ./a.out
3
5
7
9
11
13
15
17
19
21
23
25



/ 13	. 

/ we start met j=2, en maken while loop	,

/ we zien nagenoeg dezelfde asm	, 
/ de actie	, de body is ook aan het begin	, de test is toch ook achteraan	, maar vanwege de iets andere begin	, springt hij bij while in asm meteen naar achteren , naar de test	, en keert meteen naar de actie terug, vanaf dan is alles hetzelfde	, 

$ vi loop_variant_2.c

#define N 13
#include<stdlib.h>
#include<stdio.h>
int main(){
        int*P=(int*)malloc(N*sizeof(int));

        int j=2;
        int n=3;
        while(j<=N){
                P[j]=n;
                j=j+1;
                n+=2;
        }

        for(j=2;j<=N;j++){
                printf("%d\n",P[j]);
        }
        
        return(0);
}

[eric@almond Manual]$ ./a.out
3
5
7
9
11
13
15
17
19
21
23
25

        movl    $52, %edi
        call    malloc
        movq    %rax, -16(%rbp)
        movl    $2, -4(%rbp)
        movl    $3, -8(%rbp)
        jmp     .L2
.L3:
        movl    -4(%rbp), %eax
        cltq
        leaq    0(,%rax,4), %rdx
        movq    -16(%rbp), %rax
        addq    %rax, %rdx
        movl    -8(%rbp), %eax
        movl    %eax, (%rdx)
        addl    $1, -4(%rbp)
        addl    $2, -8(%rbp)
.L2:
        cmpl    $13, -4(%rbp)
       	jle     .L3


/ Ook kunnen we  een for loop		,
/ we zien dezelfde asm als bij while loop	,

$ vi loop_variant_3.c

       int j=2;
        int n=3;
        for(;j<=N;j++){
                P[j]=n;
                n+=2;
        }

        for(j=2;j<=N;j++){
                printf("%d\n",P[j]);
        }

/ 7	. 

/ we hadden al primes.c	, 
/ nu maken we primes_3.c , in C zoals in boek	, 
/ TODO (welke loops	, over j, en k, maar ook over n?)
/ en daarna primes_3.mixal	, zoals in boek	, 
/ we hebben al primes_2.mixal	, maar 1ste, laatste ERR	, 

/ we hebben in primes_3.mixal geen N mem loc , maar I2	, 

$ vi primes_3.mixal

PRIME 	EQU	0
STR	EQU	1000
	ORIG 	3000

PROG	IOC	0(19)
	ENT2	2		I2=n	(n is number, candidate for in PRIME)
	ENT1	1		I1=j
	ST2	PRIME,1
	ENT2	3
0H	INC1	1
	CMP1	=501=
	JE	3F
	ST2	PRIME,1
1H	INC2	2
	ENT3	1		I3=k
2H	INC3	1
	ENTA	0
	ENTX	0,2
	DIV	PRIME,3
	CMPX	=0=
	JE	1B
	CMPA	PRIME,3
	JG	2B
	JMP	0B
3H	HLT
	END 	PROG		
		
/ set b op HLT	,
MIX> pmem 50
0050: + 00 00 00 03 37 (0000000229)
MIX> pmem 100
0100: + 00 00 00 08 29 (0000000541)
MIX> pmem 500
0500: + 00 00 00 55 51 (0000003571)
/ Klopt	,

/ 13	. 

/ Het printen gaat wat ingewikkeld	, 
/ let op: hij rekent met indices tov PRIMES	, dus de 1ste prime 2, heeft index 1	, ook al is dat mem loc 0	, 
/ de primes hebben index
|1...50|51...100|101...150|...|401...450|451...500|

/ Hij print op 2 buffers	,
buf0, buf0+1	, ... , buf0+10
buf1, buf1+1	, ... , buf1+10

/ er zijn ook buf0+24, die buf1+10 heeft als content	,
/ buf1+24, die buf0+10 heeft als content	,


/ Hij maakt eerst de bovenste rij, met indices van achter uit	,
-49 1 51 101 ... 401 451
/ hij maakt ze van achter uit	, hij stopt als er een neg bij komt	,
/ hij print 1, 51, ... 401, 451
/ en telt 501 op bij -49: 452	, en maakt dan de indices rij, van achter uit,
-48 2 52 102 ... 402 452	,
/ hij maakt ze van achter uit	, hij stopt als er een neg bij komt	,
/ hij print 2, 52, ... 402, 452
/ hij gaat verder, pakt -48 en telt er 501 bij op	, 453	, en maakt vanachter uit	,
-47 3 53 103, ... 403, 453	, 
...
-1 49 ...	499	, en prints
0 50 ... 	 500 	, en prints
/ en nu gaat niet verder, want op l (37) J5N 2B doet hij niet meer	, 

/ 7	. 

/ SUBROUTINE

        ORIG    1000
PRG     ENT1    0		1000: + 00 00 00 02 49
2H      CMP1    =32=		
        JGE     4F
        ST1     LIST,1
        INC1    1
        JMP     2B
4H      JMP     MAX		1006: + 15 49 00 00 39	, 15*64+49=1009
        JMP     PR	 	1007: + 15 59 00 00 39	
        HLT

MAX     STJ     EXIT		1009: + 15 58 00 02 32 , 15*64+58=1018
        LD1     0
6H      CMP1    N
        JGE     EXIT
        LDA     LIST,1
        CHAR
        STX     PLIST,1
        INC1    1
        JMP     6B
EXIT    JMP     *		1018: + 15 58 00 00 39	, Gaat veranderen	

/ 13	. 

/ als 
	JMP	MAX
/ dan wordt het ri write in rJ
rJ: + 15 47 (1007)

/ 13	. 

/ Na
	STJ	EXIT
MIX> pmem 1018
1018: + 15 47 00 00 39 (0263979047)

/ dus op 1018 staat	
	JMP 	*
/ maar we hadden ook 
	JMP 	*-3
/ dan had er eerst gestaan	,
1018: + 15 55 00 00 39
/ maar na
	STJ	EXIT
/ wordt het toch weer	,
MIX> pmem 1018
1018: + 15 47 00 00 39 (0263979047)

/ 7	. 

/ Knuth Vol1(186/189)

/ we maken maximum, zoals (186)	,  

$ vi pr_with_sub_2.mixal

LIST	EQU 	0
STR	EQU 	1000

	ORIG 	3000
PROG 	IOC	0(19)	
	ENTA	13
	ENT1	0
	STA	LIST,1
	ENTA	7
	INC1	1
	STA	LIST,1
	ENTA	15	
	INC1	1
	STA	LIST,1
	ENTA	8	
	INC1	1
	STA	LIST,1
	JMP 	MAX	
	JMP 	PRINT
	HLT	

MAX	STJ  	EXIT	
	ENT3	4
	JMP 	2F
1H	CMPA	LIST,3
	JGE	*+3
2H	ENT2	0,3	j=index max
	LDA	LIST,3	m=max
	DEC3	1
	J3P	1B
EXIT 	JMP 	*

PRINT	STJ	EXIT1
	CHAR
	STX	STR
	OUT	STR(19)
EXIT1	JMP 	*

	END 	PROG

[eric@almond Manual]$ mixvm -r pr_with_sub_2
Program loaded. Start address: 3000
Running ...
00015                                                                 
... done

/ 7	. 

/ Nu zoals op (189)	, met arg achter de call	,

$ vi pr_with_sub_3.mixal


LIST	EQU 	0
STR	EQU 	1000

	ORIG 	3000
PROG 	IOC	0(19)	
	ENTA	13
	ENT1	0
	STA	LIST,1
	ENTA	7
	INC1	1
	STA	LIST,1
	ENTA	15	
	INC1	1
	STA	LIST,1
	ENTA	8	
	INC1	1
	STA	LIST,1
	JMP 	MAX	
	CON	4		3014: + 00 00 00 00 04
	JMP 	PRINT
	HLT	

MAX	STJ   	*+1		3017: + 47 10 00 02 32	, 47*64+10=3018
	ENT1	*		3018: + 47 10 00 02 49	, gaat veranderen	
	LD3	0,1		
	JMP 	2F
1H	CMPA	LIST,3
	JGE	*+3
2H	ENT2	0,3	j=index max
	LDA	LIST,3	m=max
	DEC3	1
	J3P	1B
EXIT 	JMP 	1,1	

PRINT	STJ	EXIT1
	CHAR
	STX	STR
	OUT	STR(19)
EXIT1	JMP 	*

	END 	PROG

/ Na
	JMP 	MAX	
/ zien we	, zoals altijd	,
rJ: + 47 06 (3014)

/ Na
MAX	STJ   	*+1	
/ zien we	, dat de instr eronder: ENT1 * , verandert is	,
3018: + 47 06 00 02 49 (0790102193)
/ 47*64+06=3014=return inst achter de call op MAX	, en daar staat het arg	,

/ Na
	ENT1	*
/ zien we	,
rI1: + 47 06 (3014)

/ Na
	LD3	0,1
/ zien we	,
rI3: + 00 04 (0004)

/ dan	,
Line 33: EXIT        JMP   1,1	
rI1: + 47 06 (3014)
/ we komen in 3015:
Line 20:             JMP   PRINT

/ 7	. 

/ Knuth Vol1 (189, bovenaan, multiple ...)

/ WH bedoelen ze	, (2 keer hardcoded args, ipv meegeven)	,

$ vi pr_with_sub_4.mixal


LIST	EQU 	0
STR	EQU 	1000

	ORIG 	3000
PROG 	IOC	0(19)	
	ENTA	13
	ENT1	1
	STA	LIST,1
	ENTA	7
	INC1	1
	STA	LIST,1
	ENTA	15	
	INC1	1
	STA	LIST,1
	ENTA	8	
	INC1	1
	STA	LIST,1
	ENTA	34	
	INC1	1
	STA	LIST,1
	JMP 	MAX5
	JMP 	PRINT
	ENT3	4
	JMP	MAXN
	JMP 	PRINT
	JMP 	MAX2
	JMP 	PRINT
	HLT	

MAX2	ENT3	2
	JSJ	MAXN
MAX5	ENT3	5
MAXN	STJ	EXIT
	JMP 	2F
1H	CMPA	LIST,3
	JGE	*+3
2H	ENT2	0,3	j=index max
	LDA	LIST,3	m=max
	DEC3	1
	J3P	1B
EXIT 	JMP  	*	

PRINT	STJ	EXIT1
	CHAR
	STX	STR
	OUT	STR(19)
EXIT1	JMP 	*

	END 	PROG

[eric@almond Manual]$ mixvm  -r pr_with_sub_4
Program loaded. Start address: 3000
Running ...
00034                                                                 
00015                                                                 
00013                                                                 
... done

/ 7	. 

https://savannah.gnu.org/bugs/?47208
ericjvelden
vlWalnoot27

/ 7	. 

/ In MIX is iedere byte  6 bits	, 
            01		= 1
         01 00 		= 64
      01 00 00		= 64^2=4096
   01 00 00 00 		= 64^3=262144
01 00 00 00 00		= 64^4=16777216 

/ we oef met loop en print	,

$ vi add_3.mixal

        ORIG    1000
PROG    IOC     0(19)
        ENT1    1
        JMP     1F
0H      ENTA    0,1
        CHAR
        STX     0
        OUT     0(19)
        INC1    1
1H      CMP1    =10=
        JL      0B
        HLT
        END     PROG

[eric@almond Manual]$ mixvm -r add_3
Program loaded. Start address: 1000
Running ...
00001                                                                 
00002                                                                 
00003                                                                 
00004                                                                 
00005                                                                 
00006                                                                 
00007                                                                 
00008                                                                 
00009                                                                 
... done

/ 13	. 

/ we maken, 	en print	, 
0101010101 

$ vi add_3.mixal

        ORIG    1000
PROG    IOC     0(19)
        ENT1    0
        JMP     1F
0H      SLA     1
        ADD     =1=
        INC1    1
1H      CMP1    =5=
        JL      0B
        CHAR
        STA     0
        STX     1
        OUT     0(19)
        HLT
        END     PROG

[eric@almond Manual]$ mixvm -r add_3
Program loaded. Start address: 1000
Running ...
0017043521                                                            
... done

/ 13	. 

/ we maken	, en print	,
6363636363

/ vrijwel hetzelfde	,  we moeten add =63= doen ipv. add =1=	,
$ vi add_3.mixal

        ORIG    1000
PROG    IOC     0(19)
        ENT1    0
        JMP     1F
0H      SLA     1
        ADD     =63=
        INC1    1
1H      CMP1    =5=
        JL      0B
        CHAR
        STA     0
        STX     1
        OUT     0(19)
        HLT
        END     PROG

[eric@almond Manual]$ mixvm -r add_3
Program loaded. Start address: 1000
Running ...
1073741823                                                            
... done

/ 13	. 

/ Als we in A 6363636363 en we add =1=	, dan zien we overflow	, en in A staat 0	, 
/ Als we in A 6363636363 en we add =2=	, dan zien we overflow	, en in A staat 1	, 

$ vi add_3.mixal

        ORIG    1000
PROG    IOC     0(19)

        ENT1    0
        JMP     1F
0H      SLA     1
        ADD     =63=
        INC1    1
1H      CMP1    =5=
        JL      0B

        ADD     =2=

        CHAR
        STA     0
        STX     1
        OUT     0(19)
        HLT
        END     PROG

/ Als we debug,	 en we zijn na ADD =2=	, 
MIX> preg
rA: + 00 00 00 00 01 (0000000001)
...
MIX> pflags 
Overflow: T
Cmp: E

/ 13	. 

/ we zien dat fout gaat	,
	LDA	=16777215=
/ Maar expliciet via CON gaat OK	,
A	CON	6777215
	LDA	A

/ 13	. 

/ mod 64^5=1073741824	, komt in rA	,

$ vi vol2p12.mixal
A       CON     7
X       CON     13
C       CON     5
        ORIG    1000
PROG    LDA     A
        MUL     X
        SLAX    5
        ADD     C
        HLT
        END     PROG

/ na MUL X	,
MIX> preg
rA: + 00 00 00 00 00 (0000000000)
rX: + 00 00 00 01 27 (0000000091)

/ na SLAX 5	,
MIX> preg
rA: + 00 00 00 01 27 (0000000091)
rX: + 00 00 00 00 00 (0000000000)

/ 13	. 

$ vi vol2p12.mixal

A       CON     64*64*64-1
X       CON     13
C       CON     5
        ORIG    1000
PROG    LDA     A
        MUL     A
        SLAX    5
        ADD     C
        HLT
        END     PROG

/ na LDA A	,
MIX> preg
rA: + 00 00 63 63 63 (0000262143)
rX: + 00 00 00 00 00 (0000000000)
/ na MUL A	
MIX> preg 
rA: + 00 00 00 00 63 (0000000063)
rX: + 63 62 00 00 01 (1073217537)
/ na SLAX 5	,
MIX> preg 
rA: + 63 62 00 00 01 (1073217537)
rX: + 00 00 00 00 00 (0000000000)

/ 13	. 

/ als we	, 
A       CON     64*64*64*64*64-1
/ dan 	,
MIX> pmem 0
0000: - 00 00 00 00 01 (0000000001)

/ 13	. 

/ Hoe maken we het negatiefste getal	?

$ vi sub_2.mixal

        ORIG    1000
PROG    ENT1    0
        JMP     1F
0H      SLA     1
        SUB     =63=
        INC1    1
1H      CMP1    =5=
        JL      0B
        HLT
        END     PROG

/ Op HLT	,
MIX> preg
rA: - 63 63 63 63 63 (1073741823)
rX: + 00 00 00 00 00 (0000000000)

/ 13	. 

/ Als we van - 63 63 63 63 63 -1	, krijgen we overflow	, 
/ Wat als we er 2 vanaf halen	? Wat zien we dan in rA	?

$ vi sub_2.mixal

       ORIG    1000
PROG    ENT1    0
        JMP     1F
0H      SLA     1
        SUB     =63=
        INC1    1
1H      CMP1    =5=
        JL      0B
        SUB     =2=
        JOV     *+1
        HLT
        END     PROG

/ Na SUB =2=	,
MIX> preg
rA: - 00 00 00 00 01 (0000000001)
rX: + 00 00 00 00 00 (0000000000)
MIX> pflags 
Overflow: T
Cmp: E

/ Hetzelfde als bij + 63 63 63 63 63 en dan add =2=	, dan zien we  + 1

/ Na JOV *+1
MIX> pflags 
Overflow: F
Cmp: E
/ en we komen gewoon op de HLT line,	

/ 13	. 

/ ldan	,

$ vi vol2p12_2.mixal

X       CON     63
        ORIG    1000
PROG    LDAN    X
        HLT
        END     PROG

/ we zien na LDAN X	,
MIX> preg
rA: - 00 00 00 00 63 (0000000063)
rX: + 00 00 00 00 00 (0000000000)

/ 13	. 

/ MUL M verm rA met M	, en result is in rAX	, 

$ vi vol2p12_2.mixal

X       CON     63
A       CON     64
        ORIG    1000
PROG    LDAN    X
        MUL     A
        HLT
        END     PROG

/ Na LDAN X	,
MIX> preg
rA: - 00 00 00 00 63 (0000000063)
rX: + 00 00 00 00 00 (0000000000)
/ Na MUL A	,
MIX> preg
rA: - 00 00 00 00 00 (0000000000)
rX: - 00 00 00 63 00 (0000004032)

/ 13	. 

$ vi vol2p12_2.mixal

X       CON     64*64*64
A       CON     64*64*64-1
        ORIG    1000
PROG    LDAN    X
        MUL     A
        HLT
        END     PROG

/ Na LDAN X 
MIX> preg
rA: - 00 01 00 00 00 (0000262144)
rX: + 00 00 00 00 00 (0000000000)
/ NA MUL A	,
MIX> preg
rA: - 00 00 00 00 63 (0000000063)
rX: - 63 63 00 00 00 (1073479680)

/ 13	. 

$ vi vol2p12_2.mixal

/ ADD, SUB hebben res in rA, blijven in rA	, 
/ MUL res in rAX	,

X       CON     64*64*64
A       CON     64*64*64-1
TMP     EQU     2
        ORIG    1000
PROG    LDAN    X
        MUL     A
        STX     TMP
        SUB     TMP
        HLT
        END     PROG

/ Na LDAN X
MIX> preg
rA: - 00 01 00 00 00 (0000262144)
rX: + 00 00 00 00 00 (0000000000)
/ Na MUL A
MIX> preg
rA: - 00 00 00 00 63 (0000000063)
rX: - 63 63 00 00 00 (1073479680)
/ Na STX TMP
MIX> pmem 2
0002: - 63 63 00 00 00 (1073479680)
/ Na SUB TMP
MIX> preg
rA: + 63 62 63 63 01 (1073479617)
rX: - 63 63 00 00 00 (1073479680)


/ 13	. 

	ENTA	=63=
/ NIET	,
	ENTA	63
/ OK	, In rA staat nu 63	,

	ADD	=63=
/ OK	, bij rA komt 63	,

/ 13	. 

/ we hebben in Manual/	, wordlen.mixal	,

/ we zien in Vol2 (12) onderaan	,
	ADD =w-1=

$ vi wordlen.mixal

W       EQU     1073741824
        ORIG    1000
PROG    LDA     =W-1=
        HLT
        END     PROG

/ Maar in W komt 0	, en in rA -1	,

/ 13	. 

$ vi vol2p12_2.mixal

A       CON     64*64*64
X       CON     64*64+1
WM1     CON     1073741823
TMP     CON     0

        ORIG    1000
PROG    LDAN    X
        MUL     A
        STX     TMP
        SUB     TMP
        JANN    *+3
        INCA    2
        ADD     WM1

        HLT
        END     PROG

/ 13	. 

/ voor table1	, we hebben 5 bytes van 6 bits	, dus 64^5=2^30	, dus e=30 bij ons	, de word size is 30 bits,	dus e=30	,

/ dus w=64^5=1073741824.

/ 13	. 

/ See vol2(13)	. 
/ de reden dat we mod w+/-1 rekenen, is dat 2, 2^2, 2^3, ... nooit w+/-1 delen	, dus zijn de laatste bit , of laatste 2 bits, of laatste 3, ... random	, 
/ als e=30	, en we rekenen mod w+1	, dan is mod 5^2, 	mod 13	, mod 41	, mod 61	, mod 1321 NIET random	, maar mod 2^k wel	,

/ 13	. 

/ vol2(28)

/ we oef voor progA	, 

/ we maken list 
01234	, en we doen xn=x(n-2)+x(n-4)	, 
dus we maken 012342465889...
/ en met cyclus	,
01234
21334
24234
24634
24654
24658
84658
89658
89(14)58
...


/ 13	. 

/ maak array 0123	, en print	,

$ vi vol2p28_study.mixal

X       EQU     0
S       EQU     100

        ORIG    1000
PROG    IOC     0(19)

        ENT1    0
        JMP     0F
1H      ST1     X,1
        INC1    1
0H      CMP1    =5=
        JL      1B

        ENT1    0
        JMP     2F
3H      LDA     X,1
        INC1    1
        CHAR
        STX     S,1
        OUT     S,1(19)
2H      CMP1    =5=
        JL      3B

        HLT
        END     PROG

/ of	,
/ als we met N werken, en variable maken	,

$ vi vol2p28_study.mixal

X       EQU     0
S       EQU     100
        ORIG    200
N       CON     4
        ORIG    1000
PROG    IOC     0(19)

        ENT1    0
        JMP     0F
1H      ST1     X,1
        INC1    1
0H      CMP1    N
        JLE     1B

        ENT1    0
        JMP     2F
3H      LDA     X,1
        INC1    1
        CHAR
        STX     S,1
        OUT     S,1(19)
2H      CMP1    N
        JLE     3B

        HLT
        END     PROG

Program loaded. Start address: 1000
Running ...
00000                                                                 
00001                                                                 
00002                                                                 
00003                                                                 
00004                                                                 
... done

/ of	,
/ en als we subroutines invoeren	, let op dan END PROG helemaal aan het eind, anders kent hij INIT en PRINT niet	,
/ voor print moeten we eerst S clear	, anders als we S,1 print en I1=0	, krijgen we ook S+1, ... te zien	, we moeten mem op S, S+1, ... 0 maken	, 
/ Zie ook hoe makkelijk we een empty line print	,	 we eindigen print met een empty line	,

$ vi vol2p28_study.mixal

X	EQU	0
S	EQU 	100
	ORIG	200
N	CON	4
EMPTY	ALF	

	ORIG 	1000
PROG	IOC 	0(19)
	JMP 	INIT
	JMP	PRINT
	JMP	PRINT
	HLT


INIT	STJ	EXIT
	ENT1	0
	JMP 	0F
1H	ST1	X,1	
	INC1 	1
0H	CMP1 	N	
	JLE	1B	
EXIT	JMP	*

PRINT	STJ	EXIT2
	JMP 	CLEAR
	ENT1	0
	JMP 	2F
3H	LDA	X,1	
	CHAR
	STX	S,1
	OUT	S,1(19)
	INC1 	1
2H	CMP1	N	
	JLE	3B	
	OUT	EMPTY(19)
EXIT2	JMP	*

CLEAR	STJ	EXIT3
	ENT1	1
	LDA	0
	JMP 	4F
5H	STA	S,1
	INC1	1
4H	CMP1	N
	JLE	5B
EXIT3	JMP 	*

	END 	PROG

/ 13	. 

/ Let op	,

X       EQU     0
S       EQU     100
        ORIG    200
N       CON     4
ITER    CON     8
J       CON     N-2
K       CON     N-4

/ Op J=302 staat nu 198	, want N=200	, en niet 4	,
/ we kunnen	,

X       EQU     0
S       EQU     100
        ORIG    200
N       CON     4
ITER    CON     8
J       CON     0
K       CON     0

INIT    STJ     EXIT

        LDA     N
        DECA    2
        STA     J
        LDA     N
        DECA    4
        STA     K

/ Maar we gaan de j,k in I3, I4 doen	,

/ 13	. 
	ADD	1
/ adds wat er in mem 1 staat aan rA	, 
	INCA	1
/ adds 1 to rA	,

/ Ook	,
	LDA	0
/ loads A met mem 0	, 
	ENTA	0

/ Dus	,
	ENT1	5
	ENT2	0,1
/ In I2 komt wat er in I1 staat	, 5	, want 0 betekent hier 0	, NIET mem 0	,

N 	EQU	1	
	ORIG	6
	CON 	12
	ORIG 	1000
	ENT1	5
	LD3	N,1
/ In I3 komt 12	, want N=1, en I1=5, dus LD3 loads mem 6 in A	,

/ Dus LDA 0,1 loads mem I1	, ENTA 0,1 loads I1, dus wat er in I1 staat	,

/ we kunnen niet rI1 load met wat er in rA staat	,

/ 13	. 

/ DECi INCi gaan net als ENTi	, dus 

        LD4     L
        LD1     A
        DEC4    0,1

/ loads I4 en I1 met want er in mem L en A staat	, 
/ en doet rI4 -=rI1	, dus wat er in rI1 staat gaat van rI4 af	,

	

 

/ 13	. 

/ Deze doet het	,

/ we doen	,
xn=xn-3 + xn-5	, 
/ we start met
01234
/ dus k=0	, j=2 init	,
/ iha	, 
xn=xn-a + xn-b	,	 a=3 bij ons	, en b=l altijd	, (l=len)	, 

$ vi vol2p28_study.mixal

X	EQU	0
S	EQU 	100
	ORIG	200
L	CON	5
A	CON	3		xn=xn-a + xn-b
B	CON	5
K	CON	0	
J	CON	0	
ITER	CON	8
EMPTY	ALF	

	ORIG 	1000
PROG	IOC 	0(19)
	JMP 	INIT
	JMP 	MAIN
	HLT


INIT	STJ	EXIT

	LDA	L
	SUB 	A
	STA	J
	LDA	L
	SUB 	B
	STA	K

	ENT1	0
	JMP 	0F
1H	ST1	X,1	
	INC1 	1
0H	CMP1 	L	
	JL	1B	
EXIT	JMP	*


PRINT	STJ	EXIT2
	JMP 	CLEAR
	ENT1	0
	JMP 	2F
3H	LDA	X,1	
	CHAR
	STX	S,1
	OUT	S,1(19)
	INC1 	1
2H	CMP1	L	
	JL	3B	
	OUT	EMPTY(19)
EXIT2	JMP	*

CLEAR	STJ	EXIT3
	ENT1	0
	ENTA	0	
	JMP 	4F
5H	STA	S,1
	INC1	1
4H	CMP1	L
	JL	5B
EXIT3	JMP 	*

MAIN	STJ	EXIT4
	ENT2	0
	JMP	6F
7H	LD3	K
	LD4	J	
	LDA	X,3	
	ADD	X,4
	STA	X,3

	JMP 	PRINT

	LDA	K
	INCA	1	
	STA	K

	LDA	J
	INCA	1	
	STA	J

	LD3	K
	CMP3	L
	JL	*+3
	ENT3	0
	ST3	K

	LD3	J
	CMP3	L
	JL	*+3
	ENT3	0
	ST3	J

	INC2	1
6H	CMP2	ITER
	JL	7B 	
EXIT4	JMP	*

	END 	PROG

[eric@almond Vol2]$ mixvm -r vol2p28_study
Program loaded. Start address: 1000
Running ...
00002                                                                 
00001                                                                 
00002                                                                 
00003                                                                 
00004                                                                 
                                                                      
00002                                                                 
00004                                                                 
00002                                                                 
00003                                                                 
00004                                                                 
                                                                      
00002                                                                 
00004                                                                 
00006                                                                 
00003                                                                 
00004                                                                 
                                                                      
00002                                                                 
00004                                                                 
00006                                                                 
00005                                                                 
00004                                                                 
                                                                      
00002                                                                 
00004                                                                 
00006                                                                 
00005                                                                 
00008                                                                 
                                                                      
00008                                                                 
00004                                                                 
00006                                                                 
00005                                                                 
00008                                                                 
                                                                      
00008                                                                 
00009                                                                 
00006                                                                 
00005                                                                 
00008                                                                 
                                                                      
00008                                                                 
00009                                                                 
00014                                                                 
00005                                                                 
00008                                                                 
                                                                      
... done

/ 7	. 

/ we maken j en k in registers	,

an=an-3+an-5

/ we set a5 op 0	, a6 op 1	, ..., a9 op 4, a10 op 0	, ...

/ start met uitrekenen van n=5	, dus k=0, j=2
ak=ak+aj

01234
k j
21234
 k j
24234
  k j
24634
j  k
24654
 j  k
24658
k j  
...


$ vi vol2p28_study_k_j_in_reg.mixal


X	EQU	0
S	EQU 	100
	ORIG	200
L	CON	5
A	CON	3		xn=xn-a + xn-b
B	CON	5
ITER	CON	8
EMPTY	ALF	

	ORIG 	1000
PROG	IOC 	0(19)
	JMP 	INIT
	JMP 	MAIN
	HLT


INIT	STJ	EXIT

	LD4	L
	LD1	B
	DEC4	0,1	K

	LD5	L
	LD1	A
	DEC5	0,1 	j


	ENT1	0
	JMP 	0F
1H	ST1	X,1	
	INC1 	1
0H	CMP1 	L	
	JL	1B	
EXIT	JMP	*


PRINT	STJ	EXIT2
	JMP 	CLEAR
	ENT1	0
	JMP 	2F
3H	LDA	X,1	
	CHAR
	STX	S,1
	OUT	S,1(19)
	INC1 	1
2H	CMP1	L	
	JL	3B	
	OUT	EMPTY(19)
EXIT2	JMP	*

CLEAR	STJ	EXIT3
	ENT1	0
	ENTA	0	
	JMP 	4F
5H	STA	S,1
	INC1	1
4H	CMP1	L
	JL	5B
EXIT3	JMP 	*

MAIN	STJ	EXIT4
	ENT2	0
	JMP	6F
7H	LDA	X,4	
	ADD	X,5
	STA	X,4

	JMP 	PRINT

	INC5	1
	INC4	1


	ENT3	0,4	
	CMP3	L
	JL	*+2
	ENT4	0

	ENT3	0,5	
	CMP3	L
	JL	*+2
	ENT5	0

	INC2	1
6H	CMP2	ITER
	JL	7B 	
EXIT4	JMP	*

	END 	PROG

/ 	7.

/ Overflow	, 

/ Lees	,
http://www.gnu.org/software/mdk/manual/html_node/Debug-commands.html

/ 13	. 

/ show instruction encoding	,

MIX > strace on
MIX > next
3000: [OUT	3002,0(2:3)]	START	OUT	MSG(TERM)

/ 13	. 

debug command: sbp line_number
debug command: cbp line_no
/ Wat we altijd doen,	

debug command: spba address
debug command: cbpa address
MIX> sbpa 1003 
MIX> run
/ springt naar cmd op mem 1003	, 
/ dit kan ook ipv regelnummer	, 

debug command: sbpr A | X | J | Ii
debug command: cbpr A | X | J | Ii
/ stops als reg change	,

debug command: sbpm address
debug command: cbpm address
/ stops als mem change	,

debug command: sbpo
debug command: cbpo
/ stops als overflow flag changes	,

debug command: sbpc
debug command: cbpc
/ TODO

/ 13	. 

$ vi ov.mixal

X	CON	1
L	CON 	30	
S	EQU	100	
	ORIG	1000
PROG	IOC	0(19)	

	JMP PRINT 
	ENT1	0
	JMP	0F
1H	LDA	X
	ADD	X
	STA	X
	JMP PRINT
	INC1	1
0H	CMP1 	L	
	JL	1B
	HLT

PRINT	STJ 	RI	In rJ zit ri, dat is & van i na de call op print
	LDA	X
	CHAR
	STA	S
	STX	S+1
	OUT	S(19)
RI	JMP	*

	END 	PROG	

[eric@almond test]$ mixvm  ov
MIX> sbpo
Conditional breakpoint on overflow toggled set
MIX> run
Running ...
0000000001                                                            
0000000002                                                            
0000000004                                                            
0000000008                                                            
0000000016                                                            
0000000032                                                            
0000000064                                                            
0000000128                                                            
0000000256                                                            
0000000512                                                            
0000001024                                                            
0000002048                                                            
0000004096                                                            
0000008192                                                            
0000016384                                                            
0000032768                                                            
0000065536                                                            
0000131072                                                            
0000262144                                                            
0000524288                                                            
0001048576                                                            
0002097152                                                            
0004194304                                                            
0008388608                                                            
0016777216                                                            
0033554432                                                            
0067108864                                                            
0134217728                                                            
0268435456                                                            
0536870912                                                            
... stopped: Overflow toggled ON (line 12, address 1006)
MIX> pflags
Overflow: T
Cmp: L
MIX> pline
Line 12:             STA   X

/ dus de overflow gebeurt bij ->	,  
/ klopt precies	,

1H      LDA     X
        ADD     X	<-
        STA     X

MIX> preg
rA: + 00 00 00 00 00 (0000000000)
/ De bit is verdwenen naar links	, is eraf	, en vandaar de overflow	,

/ 13	. 

/ we kunnnen daarom een jov doen	,
$ vi ov.mixal
...
        JMP PRINT
        ENT1    0
        JMP     0F
1H      LDA     X
        ADD     X
        JOV     *+6
        STA     X
        JMP PRINT
        INC1    1
0H      CMP1    L
        JL      1B
        HLT

/ dan	,
[eric@almond test]$ mixvm -r ov
Program loaded. Start address: 1000
Running ...
0000000001                                                            
0000000002                                                            
0000000004                                                            
0000000008                                                            
0000000016                                                            
0000000032                                                            
0000000064                                                            
0000000128                                                            
0000000256                                                            
0000000512                                                            
0000001024                                                            
0000002048                                                            
0000004096                                                            
0000008192                                                            
0000016384                                                            
0000032768                                                            
0000065536                                                            
0000131072                                                            
0000262144                                                            
0000524288                                                            
0001048576                                                            
0002097152                                                            
0004194304                                                            
0008388608                                                            
0016777216                                                            
0033554432                                                            
0067108864                                                            
0134217728                                                            
0268435456                                                            
0536870912                                                            
... done

/ Zonder deze jov zien we	,

[eric@almond test]$ mixvm -r ov
Program loaded. Start address: 1000
Running ...
0000000001                                                            
0000000002                                                            
0000000004                                                            
0000000008                                                            
0000000016                                                            
0000000032                                                            
0000000064                                                            
0000000128                                                            
0000000256                                                            
0000000512                                                            
0000001024                                                            
0000002048                                                            
0000004096                                                            
0000008192                                                            
0000016384                                                            
0000032768                                                            
0000065536                                                            
0000131072                                                            
0000262144                                                            
0000524288                                                            
0001048576                                                            
0002097152                                                            
0004194304                                                            
0008388608                                                            
0016777216                                                            
0033554432                                                            
0067108864                                                            
0134217728                                                            
0268435456                                                            
0536870912                                                            
0000000000
... done

/ 7	. 

$ vi sl.mixal

	ORIG 	1000
PROG	ENTA 	1	
	SLA	1
	HLT
	END	PROG

/ In rA komt 64	,

/ 7	. 

$ vi mod.mixal

X	CON	64+63
	ORIG 	1000
PROG	LDA	X(5:5)
	HLT
	END	PROG		

/ In rA komt 63	, 

/ 7	. 

/ we rekenen mod 64, resp. 4096	, door te doen	,

        STA     X,4(5:5)
/ resp	,
        STA     X,4(4:5)

 /we rekenen mod 4096	, we zien de 2 least significant bytes	,
/ we doen 1024 iteraties	,

$ vi vol2p28_study_k_j_in_reg_print_random_numbers_mod.mixal
/=
$ vi vol2p28_3

X	EQU	0
S	EQU 	100
	ORIG	200
L	CON	55
A	CON	24		xn=xn-a + xn-b
B	CON	55
ITER	CON	1024	

	ORIG 	1000
PROG	IOC 	0(19)
	JMP 	INIT
	JMP 	MAIN
	HLT


INIT	STJ	EXIT

	LD4	L
	LD1	B
	DEC4	0,1	K

	LD5	L
	LD1	A
	DEC5	0,1 	j

	ENT1	0
	JMP 	0F
1H	ST1	X,1(4:5)

       	LDA     X,1
        CHAR
        STA     S
        STX     S+1
        OUT     S(19)

	INC1 	1
0H	CMP1 	L	
	JL	1B	
EXIT	JMP	*

PRINT   STJ     RI      
        LDA     X,4
        CHAR
        STA     S
        STX     S+1
        OUT     S(19)
RI      JMP     *


MAIN	STJ	EXIT4
	ENT2	0
	JMP	6F
7H	LDA	X,4	
	ADD	X,5
	STA	X,4(4:5)

	JMP 	PRINT

	INC5	1
	INC4	1


	ENT3	0,4	
	CMP3	L
	JL	*+2
	ENT4	0

	ENT3	0,5	
	CMP3	L
	JL	*+2
	ENT5	0

	INC2	1
6H	CMP2	ITER
	JL	7B 	
EXIT4	JMP	*

	END 	PROG

[eric@almond Vol2]$ mixvm -r vol2p28_study_k_j_in_reg_print_random_numbers_mod
/=
[eric@almond Vol2]$ mixvm -r vol2p28_3
Program loaded. Start address: 1000
Running ...
0000000000                                                            
0000000001                                                            
0000000002                                                            
0000000003                                                            
0000000004                                                            
0000000005                                                            
0000000006                                                            
0000000007              
...
0000001044                                                            
0000001449                                                            
0000003582                                                            
0000000231                                                            
0000002736                                                            
0000002461                                                            
... done

/ 7	. 

/ Hoe in MIX modulo een getal, priemgetal	?

/ 13	. 

/ we hebben al gezien dat mod 64, mod 4096 makkelijk gaat met 

$ vi mod.mixal

X       CON     4096+4095
V       CON     4096
W       CON     64
A	CON	16777216
        ORIG    1000
PROG    LDA     X(4:5)
        LDA     X(5:5)

        LDA     A
        MUL     =64=
        DIV     =64=


        ENTA    0
        LDX     X
        DIV     V

        ENTA    0
        LDX     X
        DIV     W

        ENTA    0
        ENTX    17
        DIV     =13=

        HLT
        END     PROG


MIX> pmem 0
0000: + 00 00 01 63 63 (0000008191)

/ Na LDA     X(4:5)
MIX> preg
rA: + 00 00 00 63 63 (0000004095)

/ Na LDA     X(5:5)
MIX> preg
rA: + 00 00 00 00 63 (0000000063)

/ Na DIV     V
MIX> preg
rA: + 00 00 00 00 63 (0000000063)
rX: + 00 00 01 63 63 (0000008191)

/ Na DIV     W
MIX> preg
MIX> preg
rA: + 00 00 00 00 01 (0000000001)
rX: + 00 00 00 63 63 (0000004095)

/ Na DIV =13=	, 
MIX> preg
rA: + 00 00 00 00 01 (0000000001)
rX: + 00 00 00 00 04 (0000000004)

/ 13	. 
	
        LDA     A
        MUL     =64=
MIX> preg
rA: + 00 00 00 00 01 (0000000001)
rX: + 00 00 00 00 00 (0000000000)

        DIV     =64=
MIX> preg
rA: + 01 00 00 00 00 (0016777216)
rX: + 00 00 00 00 00 (0000000000)

/ 13	. 

/ we doen nu mod V	,

$ vi vol2p28_4.mixal

X	EQU	0
S	EQU 	100
	ORIG	200
L	CON	5
A	CON	3		xn=xn-a + xn-b
B	CON	5
M	CON 	10
ITER	CON 	16	
EMPTY	ALF

	ORIG 	1000
PROG	IOC 	0(19)
	JMP 	INIT
	OUT	EMPTY(19)
	JMP 	MAIN
	HLT

INIT	STJ	EXIT

	LD4	L
	LD1	B
	DEC4	0,1	K

	LD5	L
	LD1	A
	DEC5	0,1 	j

	ENT1	0
	JMP 	0F
1H	ENTA	0	
	ENTX	0,1	
	DIV	M
	STX	X,1

       	LDA     X,1
        CHAR
        STA     S
        STX     S+1
        OUT     S(19)

	INC1 	1
0H	CMP1 	L	
	JL	1B	
EXIT	JMP	*

PRINT   STJ     RI      
        LDA     X,4
        CHAR
        STA     S
        STX     S+1
        OUT     S(19)
RI      JMP     *


MAIN	STJ	EXIT4
	ENT2	0
	JMP	6F
7H	LDA	X,4	
	ADD	X,5
	STA	X,4
	ENTA	0
	LDX	X,4
	DIV	M
	STX	X,4

	JMP 	PRINT

	INC5	1
	INC4	1


	ENT3	0,4	
	CMP3	L
	JL	*+2
	ENT4	0

	ENT3	0,5	
	CMP3	L
	JL	*+2
	ENT5	0

	INC2	1
6H	CMP2	ITER
	JL	7B 	
EXIT4	JMP	*

	END 	PROG

Program loaded. Start address: 1000
Running ...
0000000000                                                            
0000000001                                                            
0000000002                                                            
0000000003                                                            
0000000004                                                            
                                                                      
0000000002                                                            
0000000004                                                            
0000000006                                                            
0000000005                                                            
0000000008                                                            
0000000008                                                            
0000000009                                                            
0000000004                                                            
0000000003                                                            
0000000007                                                            
0000000002                                                            
0000000002                                                            
0000000001                                                            
0000000005                                                            
0000000009                                                            
0000000003                                                            
... done

/ TODO
/ de print fct moet param hebben	, haal print code uit init	,
	
/ Hoe de index print voor X[i]	, dus i: X[i]	, 
/ TODO

/ 7	. 

/ SUBROUTINES

/ sub routines	,

/ Lees	,
http://www.jklp.org/profession/books/mix/c06.html 

/ ook	,	 over W-expressions	, 
http://www.gnu.org/software/mdk/manual/html_node/MIXAL-directives.html

$ vi subroutine.mixal

X	CON	1
	CON	13
	CON	7
	CON	6
	CON	34
	CON	17
	CON 	56
	CON	18
	CON	98
	CON	71	
L	CON 	10	
S	EQU	100	

	ORIG	1000
PROG	IOC	0(19)	
	JMP	SUM
	JMP	PRT

	HLT

* output in rA
SUM	STJ	RI
	ENTA	0
	ENT1	L-1	
0H	ADD	X,1
	DEC1	1
	J1NN	0B
RI	JMP	*

* input in rA
PRT	STJ 	RI2
	CHAR
	STA	S
	STX	S+1
	OUT	S(19)
RI2	JMP	*

	END 	PROG	

/ OK

/ 13	. 

/ we kunnen 
MIX> strace on

/ maar als we willen zien hoe de JMP * is modified	, moeten we ,	

eric@almond test]$ mixvm subroutine
Program loaded. Start address: 1000
MIX> psym
X                   :  0
SUM                 :  1004
RI2                 :  1016
L                   :  10
PROG                :  1000
S                   :  100
RI                  :  1010
PRT                 :  1011

MIX> pmem 1010
1010: + 15 50 00 00 39 (0264765479)
/ OP=39=JMP	, en 15*64+50=1010	, klopt	, we hadden * 	, 
	RI	JMP	*

/ dan gaan we de fct SUM in	,
MIX> pline 
Line 16:             JMP   SUM
MIX> next 
1001: [JMP	1004,0     ]	            JMP   SUM
MIX> pline 
Line 22: SUM         STJ   RI
MIX> preg
rJ: + 15 42 (1002)
/ Klopt	, dat is de instr achter JMP SUM	,
MIX> next 
1004: [STJ	1010,0     ]	SUM         STJ   RI
MIX> pmem 1010
1010: + 15 42 00 00 39 (0262668327)

/ Hij doet precies wat er staat: store rJ=15*64+42=1002 in RI=1010	,

/ 13	. 

/ herstel used register I1	,

$ vi subroutine_2.mixal

* output in rA
SUM     STJ     RI
        ST1     TMP
        ENTA    0
        ENT1    L-1
0H      ADD     X,1
        DEC1    1
        J1NN    0B
        LD1     TMP
RI      JMP     *
TMP    	ORIG	*+1 

* input in rA
PRT     STJ     RI2
...


MIX> psym
SUM                 :  1005
TMP                 :  1014
RI                  :  1013

/ Voordat 1005 wordt exec	, is 
MIX> pmem 1013
1013: + 15 53 00 00 39 (0000000039)
/ Als we STJ doen	, worden alleen de 1ste 2 bytes overwrite	,
1013: + 15 43 00 00 39 (0262930471)
/ Maar als we ST1 doen	, wordt heel 1014 overwrite	, terwijl rI1 ook maar 2 bytes zijn	, zoals rJ	, 
/ STJ doet zoals ST1(0:2)	, 

/ we doen 	, zoals op page	,
	TMP	ORIG *+1  
/ Tijdens compile wordt ORIG *+1 exec,	 maar dit is een NOP	, want dit gebeurt zoiezo	, PRT=1015	, of ORIG *+1 er staat of niet (je kunt bijv TMP NOP doen)	, 
/ Als we TMP ORIG *+2 	, dan is PRT 1016	,
  
/ we zien dat , voordat we ST1 TMP doen,  er 00 00 00 00 00 staat op TMP	, klopt	, 

/ Intermezzo

/ 13	. 

$ vi orig.mixal

X       CON     1
        CON     13
        CON     7
        CON     6
        CON     34
        CON     17
        CON     56
        CON     18
        CON     98
        CON     71
L       CON     10
S       EQU     100

TMP     ORIG    *+10
PROG    IOC     0(19)
        ENT1    13
        HLT

        END     PROG

MIX> psym
X                   :  0
L                   :  10
S                   :  100
TMP		    :  11
PROG                :  21

MIX> pmem 11
0011: + 00 00 00 00 00 (0000000000)


/ EQU, ORIG zijn pseudo instructions	, dus geven geen mem line	,
/ dus L=10	, S staat niet in mem		, ORIG ook niet	, maar * is 11	, 
/ TODO 

/ 13	. 

/ we draaien om	,
TMP     ORIG    *+2
RI      JMP     *

$ vi subroutine2.mixal

* output in rA
SUM     STJ     RI
       	ST1     TMP
        ENTA    0
        ENT1    L-1
0H      ADD     X,1
        DEC1    1
        J1NN    0B
        LD1     TMP
TMP     ORIG    *+2
RI      JMP     *

MIX> psym
SUM                 :  1005
TMP                 :  1013
RI                  :  1015

/ we zien dat RI 2 verder is dan TMP	, dat komt door ORIG *+2	,
/ Deze ORIG *+2 wordt dus exec bij compile	, 
/ tijdens exec wordt TMP overwrite met 13	, 

MIX> sbpa 1013
Breakpoint set at address 1013
MIX> run
...
MIX> pline 
Line 0: No such line (debug info not available)
MIX>  pmem 1013
1013: + 00 00 00 00 13 (0000000013)
MIX> next 
1013: [NOP	0,0        ]	
MIX> next 
1014: [NOP	0,0        ]	
MIX> next 
1015: [JMP	1003,0     ]	RI          JMP   *	



/ Einde Intermezzo

/13	. 

/ Maar nu rm we de aparte mem loc TMP	, 	, en doen het beter	,

$ vi subroutine_2a.mixal

* output in rA
SUM     STJ     RI
        ST1     TMP(0:2)
        ENTA    0
        ENT1    L-1
0H      ADD     X,1
        DEC1    1
        J1NN    0B
TMP     ENT1    *
RI      JMP     *


MIX> psym
TMP                 :  1012
SUM                 :  1005
RI                  :  1013

MIX> pmem 1012
1012: + 15 52 00 02 49 (0265289905)
/ Hier staat ENT1 *	, omdat 15*64+52=1012
MIX> pline 
Line 24:             ST1   TMP(0:2)
MIX> next 
1006: [ST1	1012,0(0:2)]	            ST1   TMP(0:2)

Elapsed time: 2 /Total program time: 7 (Total uptime: 7)
MIX> pmem 1012
1012: + 00 13 00 02 49 (0003408049)


/ 13	. 

/ Nu met arg	, 
/ I1: array	, I2: length array	,

$ vi subroutine_3.mixal

X	CON	1
	CON	13
	CON	7
	CON	6
	CON	34
	CON	17
	CON 	56
	CON	18
	CON	98
	CON	71	
L	CON 	10	
S	EQU	100	

	ORIG	1000
PROG	IOC	0(19)	
	ENT1	X		pointer
	LD2	L		niet pointer, value
	JMP	SUM
	JMP	PRT

	HLT

* input I1=array, I2=length
* output in rA
SUM	STJ	RI
	ST2	TMP(0:2)
	ENTA	0
	DEC2	1
0H	ADD	0,1
	INC1	1
	DEC2	1
	J2NN	0B
TMP	ENT2	*	
RI	JMP 	*	

* input in rA 
PRT	STJ 	RI2
	CHAR
	STA	S
	STX	S+1
	OUT	S(19)
RI2	JMP	*

	END 	PROG	

/ OK	,

 /13	. 

$ vi subroutine_3a.mixal

X       CON     1
        CON     13
        CON     7
        CON     6
        CON     34
        CON     17
        CON     56
        CON     18
        CON     98
        CON     71
L       CON     10
S       EQU     100


SUM     STJ     RI
        ST2     TMP(0:2)
        ENTA    0
0H      ADD     -1,1:2
        DEC2    1
        J2P     0B
TMP     ENT2    *
RI      JMP     *

/ ADD	-1,1:2 werkt WH NIET	, 
/ Het is ADD -1,2
/ Dus we zien X over het hoofd	,
/ Als we X=1 maken	, geeft hij een ander antwoord	,
/ TODO

/ 13	. 

/ TODO 

/ Afmaken 	,
http://www.jklp.org/profession/books/mix/c06.html


/ Einde SUBROUTINES

/ 7	. 

/ we hadden open	,

[eric@almond Manual]$ pwd
/home/eric/Devel/MIX/Manual
[eric@almond Manual]$ vi loop_variant.mixal 
[eric@almond Manual]$ vi pr_with_sub_4.mixal 

/ In ACP/Vol2/vol2p28_3.mixal  doen we mod 4096=2^12 door 
        STA     X,4(4:5)                mod 2^12=4096
/ In ACP/Vol2/vol2p28_4.mixal  doen we mod door DIV 	, en dan rX te store in X	, 


/ LEEDS

http://www1.maths.leeds.ac.uk/~voss/projects/2012-RNG/Burgoine.pdf
http://sites.stat.psu.edu/~mga/401/tables/Chi-square-table.pdf

https://cran.r-project.org/bin/linux/redhat/README

/ 7	. 

/ RND creates M=1024 rnd numbers	, CNT telt ze in K bags	, 
/ we delen de rnd numbers door M/K=64	, door SRA 1 te doen	, en dat geeft de index van een van de K bags die +1 wordt	, 
/ In de volgende versie vervangen we SRA 1 door gewoon DIV =64=	,

/ Hier chi1	, chi1a hieronder is uiteindelijke versie	,

[eric@almond Leeds]$ pwd
/home/eric/Devel/MIX/Leeds
$ vi chi1.mixal

X	EQU	0
S	EQU	400
T	EQU	800
	ORIG	1600
L	CON	400
A	CON	13		
C	EQU	3
M	CON 	1024
K	CON	16
MEM	CON	0	

	ORIG 	2000
PROG	IOC 	0(19)
	JMP 	RND	
	JMP 	CNT
	JMP  	PRINT	
	HLT

RND	STJ 	RIRND	

	ENT1	0
	ENTX	0
	STX	X,1

	ENT1	0
	JMP	0F
1H	LDA	X,1	
	MUL	A	
	INCX	C	
	DIV 	M
	INC1	1
	STX	X,1

0H	CMP1 	L	
	JL	1B 	

RIRND	JMP	*

CNT	STJ	RICNT

	ENT1	0
	JMP	0F
1H	LDA	X,1
	SRA	1	M/K=64	, SRA 1 is DIV =64= 	
	STA	MEM
	LD2	MEM
	LDA	T,2
	INCA	1
	STA	T,2

	INC1	1
0H	CMP1	L
	JL	1B

RICNT	JMP	*

CHI	STJ	RICHI

	ENT1	0
	JMP	0F
0H	CMP1	K	

RICHI	JMP	*

PRINT   STJ     RI      

	ENT1	0
	JMP	2F	

3H      LDA     T,1
        CHAR
        STA     S
        STX     S+1
        OUT     S(19)

	INC1	1
2H	CMP1	K
	JL	3B

RI      JMP     *

	END 	PROG

[eric@almond Leeds]$ mixvm -r chi1
Program loaded. Start address: 2000
Running ...
0000000026                                                            
0000000028                                                            
0000000025                                                            
0000000027                                                            
0000000027                                                            
0000000027                                                            
0000000031                                                            
0000000022                                                            
0000000028                                                            
0000000025                                                            
0000000021                                                            
0000000021                                                            
0000000024                                                            
0000000029                                                            
0000000018                                                            
0000000021                                                            
... done


/ 7	. 

/ Skeleton for loop	,

CHI     STJ     RICHI

        ENT1    0
        JMP     0F
1H      NOP
	INC1	1
0H      CMP1    K
        JL      1B

RICHI   JMP     *

/ 	7.

/ we kunnen van rI

[eric@almond test]$ cat r_to_r.mixal
J	CON 	7
N 	EQU 	1	
	ORIG 	6
K	CON	12
	ORIG 	1000
PROG	ENT1	5
	ENT2	0,1	
	LD3	N,1	I3=12, want N=1 en I1=5, en mem6=12	,
	HLT
	END	PROG

[eric@almond test]$ cat rA_to_rI1.mixal 
X	EQU 	0
M	EQU 	400
	ORIG	1000
P	IOC	0(19)

	ENTA	7
	STA	M	Mem truc, kan het zonder? TODO
	LD1	M

	LDA	X,1
	INCA	1
	STA	X,1	
	HLT
	END	P

/ 7	. 

/ we gen rnd numbers 0<= <1024	, 
/ we maken 16 baskets
[0 - 64>
[64 - 128 >
...
/ want 1024/16=64

/ we gen 400 rnd numbers	,
/ we tellen hoeveel in iedere basket	, 
/ we verwachten 400/16=25 in iedere basket	, 
/ we berekenen V=som (aantal in basket  - 25)^2/25
/ maar omdat we steeds door 25 delen	, berekenen we de som	, omdat deze MIXAL impl geen FDIV heeft	, 
/ we vinden 190	, 190/25=7.6	 
/ Aantal vrijheidsgraden=15	, we zien 6.262 en 27.488	, 7.6 zit daar tussen 	, dus de rij is random	,


[eric@almond Leeds]$ pwd
/home/eric/Devel/MIX/Leeds
$ vi chi1a.mixal

X	EQU	0
S	EQU	400
T	EQU	800
	ORIG	1600
L	CON	400
A	CON	13		
C	EQU	3
M	CON 	1024
K	CON	16
SZ	CON 	64	M/K	
E	CON	25	L/K
V	CON 	0
MEM	CON	0	

	ORIG 	2000
PROG	IOC 	0(19)
	JMP 	RND	
	JMP 	CNT
*	JMP  	PRINT	
	JMP 	CHI

        CHAR
        STA     S
        STX     S+1
        OUT     S(19)


	HLT

RND	STJ 	RIRND	

	ENT1	0
	ENTX	0
	STX	X,1

	ENT1	0
	JMP	0F
1H	LDA	X,1	
	MUL	A	
	INCX	C	
	DIV 	M
	INC1	1
	STX	X,1

0H	CMP1 	L	
	JL	1B 	

RIRND	JMP	*

CNT	STJ	RICNT

	ENT1	0
	JMP	0F
1H	LDA	X,1
	SRA	1	index
	STA	MEM	
	LD2	MEM
	LDA	T,2
	INCA	1
	STA	T,2

	INC1	1
0H	CMP1	L
	JL	1B

RICNT	JMP	*

CHI	STJ	RICHI

	ENT1	0
	JMP	0F

1H	LDA	T,1
	SUB 	E
	STA	T,1	
	MUL	T,1
	SLAX	5
	ADD	V
	STA	V


	INC1	1
0H	CMP1	K	
	JL	1B

RICHI	JMP	*

PRINT   STJ     RI      

	ENT1	0
	JMP	0F	

1H      LDA     T,1
        CHAR
        STA     S
        STX     S+1
        OUT     S(19)

	INC1	1
0H	CMP1	K
	JL	1B

RI      JMP     *

	END 	PROG

[eric@almond Leeds]$ mixvm -r chi1a
Program loaded. Start address: 2000
Running ...
0000000190                                                            
... done

/ 7	. 

	
	


/ Einde MIXAL

/ LEEDS IN C

/ 7	. 

/ versie chi1.c	, met & (1<<m)-1 ipv % (1<<m)

[eric@almond Leeds]$ pwd
/home/eric/Devel/MIX/Leeds

#define A 13
#define C 3
#define m 10

#define L 400
#define k 4 

int x[L];
int t[1<<k];

void rnd();
void cnt();
 
int main(){
	rnd();		
	cnt();
	return (0);
}
void rnd(){
	x[0]=0;
	for(int i=1;i<L;i++){
		x[i]=A*x[i-1]+C & (1<<m)-1; 
	 }
}
void cnt(){
	int K=1<<k;
	for(int i=0;i<K;i++){
		t[i]=0;
	}
	int d=m-k;	
	for(int i=0;i<L;i++){
		int J=x[i]>>d;	
		t[J]++;
	}
}

gdb) p t
$1 = {26, 28, 25, 27, 27, 27, 31, 22, 28, 25, 21, 21, 24, 29, 18, 21}

/  Nu helemaal afmaken	,
	



/ Einde LEEDS IN C

/ LINKS R

http://www.cyclismo.org/tutorial/R/

/ Einde LINKS R

/ LEEDS IN R


/ 13	 

> exists('x')
[1] FALSE
> x=c()
> exists('x')
[1] TRUE
> x
NULL
> rm('x')
> x
Error: object 'x' not found

> if(exists('x'))rm(x)
/ OK

> ls()
/ Geeft def objs	,


/ 13	. 

/ Onthoud: In R vectors beginnen met index 1	,

> rm(x)
> ls()
character(0)
> x=c()
> ls()
[1] "x"
> x[1]=7
> x[1]
[1] 7

/ Doe NIET	,
> x[0]=7
/ want dan gebeurt er gewoon NIETS	,

/ we simuleren hieronder x[0]	,

/ 13	. 

[eric@almond Leeds]$ pwd
/home/eric/Devel/MIX/Leeds
eric@almond Leeds]$ cat lcg.R
lcg=function(a,c,m,n,h){
  x=c()
  for(i in 1:n)
    x[i]=h=(a*h+c)%%m
  x/m
}
> source('lcg.R')
> x=lcg(13,3,16,10,0)
> x
 [1] 0.1875 0.6250 0.3125 0.2500 0.4375 0.8750 0.5625 0.5000 0.6875 0.1250

/ we nemen net als in Leeds X0 niet mee in x	,

/ 13	. 

> x=lcg(13,3,1024,400,0)
> x
  [1] 0.002929688 0.041015625 0.536132812 0.972656250 0.647460938 0.419921875
  [7] 0.461914062 0.007812500 0.104492188 0.361328125 0.700195312 0.105468750
 [13] 0.374023438 0.865234375 0.250976562 0.265625000 0.456054688 0.931640625
 [19] 0.114257812 0.488281250 0.350585938 0.560546875 0.290039062 0.773437500
 [25] 0.057617188 0.751953125 0.778320312 0.121093750 0.577148438 0.505859375
 [31] 0.579101562 0.531250000 0.909179688 0.822265625 0.692382812 0.003906250
 [37] 0.053710938 0.701171875 0.118164062 0.539062500 0.010742188 0.142578125
 [43] 0.856445312 0.136718750 0.780273438 0.146484375 0.907226562 0.796875000
 [49] 0.362304688 0.712890625 0.270507812 0.519531250 0.756835938 0.841796875
 [55] 0.946289062 0.304687500 0.963867188 0.533203125 0.934570312 0.152343750
 [61] 0.983398438 0.787109375 0.235351562 0.062500000 0.815429688 0.603515625
 [67] 0.848632812 0.035156250 0.459960938 0.982421875 0.774414062 0.070312500
 [73] 0.916992188 0.923828125 0.012695312 0.167968750 0.186523438 0.427734375
 [79] 0.563476562 0.328125000 0.268554688 0.494140625 0.426757812 0.550781250
 [85] 0.163085938 0.123046875 0.602539062 0.835937500 0.870117188 0.314453125
 [91] 0.090820312 0.183593750 0.389648438 0.068359375 0.891601562 0.593750000
 [97] 0.721679688 0.384765625 0.004882812 0.066406250 0.866210938 0.263671875
[103] 0.430664062 0.601562500 0.823242188 0.705078125 0.168945312 0.199218750
[109] 0.592773438 0.708984375 0.219726562 0.859375000 0.174804688 0.275390625
[115] 0.583007812 0.582031250 0.569335938 0.404296875 0.258789062 0.367187500
[121] 0.776367188 0.095703125 0.247070312 0.214843750 0.795898438 0.349609375
[127] 0.547851562 0.125000000 0.627929688 0.166015625 0.161132812 0.097656250
[133] 0.272460938 0.544921875 0.086914062 0.132812500 0.729492188 0.486328125
[139] 0.325195312 0.230468750 0.999023438 0.990234375 0.875976562 0.390625000
[145] 0.081054688 0.056640625 0.739257812 0.613281250 0.975585938 0.685546875
[151] 0.915039062 0.898437500 0.682617188 0.876953125 0.403320312 0.246093750
[157] 0.202148438 0.630859375 0.204101562 0.656250000 0.534179688 0.947265625
[163] 0.317382812 0.128906250 0.678710938 0.826171875 0.743164062 0.664062500
[169] 0.635742188 0.267578125 0.481445312 0.261718750 0.405273438 0.271484375
[175] 0.532226562 0.921875000 0.987304688 0.837890625 0.895507812 0.644531250
[181] 0.381835938 0.966796875 0.571289062 0.429687500 0.588867188 0.658203125
[187] 0.559570312 0.277343750 0.608398438 0.912109375 0.860351562 0.187500000
[193] 0.440429688 0.728515625 0.473632812 0.160156250 0.084960938 0.107421875
[199] 0.399414062 0.195312500 0.541992188 0.048828125 0.637695312 0.292968750
[205] 0.811523438 0.552734375 0.188476562 0.453125000 0.893554688 0.619140625
[211] 0.051757812 0.675781250 0.788085938 0.248046875 0.227539062 0.960937500
[217] 0.495117188 0.439453125 0.715820312 0.308593750 0.014648438 0.193359375
[223] 0.516601562 0.718750000 0.346679688 0.509765625 0.629882812 0.191406250
[229] 0.491210938 0.388671875 0.055664062 0.726562500 0.448242188 0.830078125
[235] 0.793945312 0.324218750 0.217773438 0.833984375 0.844726562 0.984375000
[241] 0.799804688 0.400390625 0.208007812 0.707031250 0.194335938 0.529296875
[247] 0.883789062 0.492187500 0.401367188 0.220703125 0.872070312 0.339843750
[253] 0.420898438 0.474609375 0.172851562 0.250000000 0.252929688 0.291015625
[259] 0.786132812 0.222656250 0.897460938 0.669921875 0.711914062 0.257812500
[265] 0.354492188 0.611328125 0.950195312 0.355468750 0.624023438 0.115234375
[271] 0.500976562 0.515625000 0.706054688 0.181640625 0.364257812 0.738281250
[277] 0.600585938 0.810546875 0.540039062 0.023437500 0.307617188 0.001953125
[283] 0.028320312 0.371093750 0.827148438 0.755859375 0.829101562 0.781250000
[289] 0.159179688 0.072265625 0.942382812 0.253906250 0.303710938 0.951171875
[295] 0.368164062 0.789062500 0.260742188 0.392578125 0.106445312 0.386718750
[301] 0.030273438 0.396484375 0.157226562 0.046875000 0.612304688 0.962890625
[307] 0.520507812 0.769531250 0.006835938 0.091796875 0.196289062 0.554687500
[313] 0.213867188 0.783203125 0.184570312 0.402343750 0.233398438 0.037109375
[319] 0.485351562 0.312500000 0.065429688 0.853515625 0.098632812 0.285156250
[325] 0.709960938 0.232421875 0.024414062 0.320312500 0.166992188 0.173828125
[331] 0.262695312 0.417968750 0.436523438 0.677734375 0.813476562 0.578125000
[337] 0.518554688 0.744140625 0.676757812 0.800781250 0.413085938 0.373046875
[343] 0.852539062 0.085937500 0.120117188 0.564453125 0.340820312 0.433593750
[349] 0.639648438 0.318359375 0.141601562 0.843750000 0.971679688 0.634765625
[355] 0.254882812 0.316406250 0.116210938 0.513671875 0.680664062 0.851562500
[361] 0.073242188 0.955078125 0.418945312 0.449218750 0.842773438 0.958984375
[367] 0.469726562 0.109375000 0.424804688 0.525390625 0.833007812 0.832031250
[373] 0.819335938 0.654296875 0.508789062 0.617187500 0.026367188 0.345703125
[379] 0.497070312 0.464843750 0.045898438 0.599609375 0.797851562 0.375000000
[385] 0.877929688 0.416015625 0.411132812 0.347656250 0.522460938 0.794921875
[391] 0.336914062 0.382812500 0.979492188 0.736328125 0.575195312 0.480468750
[397] 0.249023438 0.240234375 0.125976562 0.640625000

> x=lcg(13,3,1025,400,0)
> x
  [1] 0.002926829 0.040975610 0.535609756 0.965853659 0.559024390 0.270243902
  [7] 0.516097561 0.712195122 0.261463415 0.401951220 0.228292683 0.970731707
 [13] 0.622439024 0.094634146 0.233170732 0.034146341 0.446829268 0.811707317
 [19] 0.555121951 0.219512195 0.856585366 0.138536585 0.803902439 0.453658537
 [25] 0.900487805 0.709268293 0.223414634 0.907317073 0.798048780 0.377560976
 [31] 0.911219512 0.848780488 0.037073171 0.484878049 0.306341463 0.985365854
 [37] 0.812682927 0.567804878 0.384390244 0.000000000 0.002926829 ...
/ Kleine period	,

> x=lcg(13,3,1024,1024,0)
> x
...
[1021] 0.1708984375 0.2246093750 0.9228515625 0.0000000000
/ dus x[0]=0, x[1024]=0	

> x=lcg(1664525,1013904223,2^32,2000,0)
/ OK

> x=lcg(65539,0,2^31,2000,1)
> x
   [1] 3.051898e-05 1.831097e-04 8.239872e-04 3.295936e-03 1.235973e-02
/ TODO




/ Einde Intermezzo

/ HISTOGRAM BARPLOT

/ 13	. 

/ Intermezzo

> x=c('k','k','l','m','m','m')
> table(x)
/=
> tapply(rep(1,length(x)),x,sum)
k l m 
2 1 3 
> barplot(s)
/ OK

 hist(1:10)
/ OK
/ Bij hist mag de vector niet te klein	,
/ TODO
/ Je ziet aut. factor	,
/ TODO

/ 13	. 

////////////////////////////////

/ of	,

> y=lcg(13,3,1024,400,0)
> hist(y)
/ OK

/ of	,

> c=cut(y,.1*(0:10))
/ en	,
> t=table(c)
/ of	,
> t=tapply(rep(1,length(c)),c,sum)
c
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
       41        45        42        42        42        42        34        41 
(0.8,0.9]   (0.9,1] 
       41        30 
> barplot(table(c))
/ OK

/ Einde HISTOGRAM BARPLOT

/ 13	. 

> x=lcg(13,3,1024,400,0)
> hist(x)
/ Deze zien we in de pdf	,

> cut(x,0:10/10,labels=F)
  [1]  1  1  6 10  7  5  5  1  2  4  8  2  4  9  3  3  5 10  2  5  4  6  3  8  1
...
/ Geeft de indexes	, ipv	,
> cut(x,0:10/10)
  [1] (0,0.1]   (0,0.1]   (0.5,0.6] (0.9,1]   (0.6,0.7] (0.4,0.5] (0.4,0.5]

> tapply( rep(1,length(z)),z,sum)
 1  2  3  4  5  6  7  8  9 10 
41 45 42 42 42 42 34 41 41 30 

/ 13	. 

$ cat chisq.R

a=13
c=3
m=1024
n=400
h=0
x=lcg(a,c,m,n,h)

k=10
cs=cut(x,0:k/k)

t=tapply(rep(1,n),cs,sum) 		/ bij Leeds O (observed)
t[is.na(t)]=0
e=rep(n/k,k)

r=sum((t-e)^2/e)
r

> source('chisq.R')
r
[1] 4.5

/ Ook	,
> x
  [1] 0.002929688 0.041015625 0.536132812 0.972656250 0.647460938 0.419921875
  [7] 0.461914062 0.007812500 0.104492188 0.361328125 0.700195312 0.105468750
...
/ De random numbers,	

> cs
  [1] (0,0.1]   (0,0.1]   (0.5,0.6] (0.9,1]   (0.6,0.7] (0.4,0.5] (0.4,0.5]
  [8] (0,0.1]   (0.1,0.2] (0.3,0.4] (0.7,0.8] (0.1,0.2] (0.3,0.4] (0.8,0.9]
...
/ categories	,

> t
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
       41        45        42        42        42        42        34        41 
(0.8,0.9]   (0.9,1] 
       41        30 
> e
 [1] 40 40 40 40 40 40 40 40 40 40

/ Intermezzo

/ Wat Leeds doet is , wij t hierboven	,
for(i in 1:k) O[i] <- sum(z==i)

> z==2
  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE
 [13] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
 [25] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [37] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE
 [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
 [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [73] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [85]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
 [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
[109] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE
[133] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
[193] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE
[205] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[217] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE
[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[241] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[253] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[265] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE
[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[289]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
[301] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
[313] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[325] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
[349] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[397] FALSE FALSE  TRUE FALSE
> sum(z==2)
[1] 45
/ Klopt	, hadden wij ook voor t	,


/ Einde Intermezzo

/ Intermezzo

/ & doet elk elem in de list	, 
/ && doet alleen de 1ste in de list	,

> c(T,T,T) && c(T,F,T)
[1] TRUE
> c(F,T,T) && c(T,F,T)
[1] FALSE

> c(F,T,T) & c(T,F,T)
[1] FALSE FALSE  TRUE


/ Einde Intermezzo

x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10
n=20

k=10
cs=cut(x,0:k/k)

t=tapply(rep(1,n),cs,sum)
e=rep(n/k,k)

r=sum((t-e)^2/e)
r

u=1/20
if(r<qchisq(u/2,k-1) || r>qchisq(u/2,k-1,lower.tail=F))rs=list("REJECT",r) else rs=list("ACCEPT",r)
rs

/ 7	. 

/ we hadden zelf niet een lcg 	, maar met de hand 
x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10

$ vi chisq2.R

x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10
n=20

k=10
cs=cut(x,0:k/k)

t=tapply(rep(1,n),cs,sum)
t[is.na(t)]=0

e=rep(n/k,k)

r=sum((t-e)^2/e)
r

u=1/20
if(r<qchisq(u/2,k-1) || r>qchisq(u/2,k-1,lower.tail=F))rs=list("REJECT",r) else rs=list("ACCEPT",r)
rs

> source("chisq2.R")
> rs
[[1]]
[1] "REJECT"

[[2]]
[1] 33

/ 13	. 

/ Waarom 
t[is.na(t)]=0
/ Omdat zonder deze er NA staan in t	, en dan gaat r fout	,

 [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.5 0.5 0.5 0.5 0.7 0.7 0.7 0.7 0.7 0.9 0.9 0.9
[20] 0.9
> t
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
        7        NA        NA        NA         4        NA         5        NA 
(0.8,0.9]   (0.9,1] 
        4        NA 
> is.na(t)
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
    FALSE      TRUE      TRUE      TRUE     FALSE      TRUE     FALSE      TRUE 
(0.8,0.9]   (0.9,1] 
    FALSE      TRUE 
> t[is.na(t)]=0
> t
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
        7         0         0         0         4         0         5         0 
(0.8,0.9]   (0.9,1] 
        4         0 

/ SAMENVATTING CHISQ

/ 13	. 

[eric@almond Leeds]$ cat lcg.R 

lcg=function(a,c,m,n,h){
	x=c()
	for(i in 1:n)
		x[i]=h=(a*h+c)%%m
	x/m
}

[eric@almond Leeds]$ cat chisq.R 

a=13
c=3
m=1024
n=400
h=0
x=lcg(a,c,m,n,h)

k=10
cs=cut(x,0:k/k)

t=tapply(rep(1,n),cs,sum)
e=rep(n/k,k)

r=sum((t-e)^2/e)
r

u=1/20
if(r<qchisq(u/2,k-1) || r>qchisq(u/2,k-1,lower.tail=F))rs=list("REJECT",r) else rs=list("ACCEPT",r)
rs

/ ACCEPT

/ 13	. 

[eric@almond Leeds]$ cat chisq2.R 

x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10
n=20

k=10
cs=cut(x,0:k/k)

t=tapply(rep(1,n),cs,sum)
t[is.na(t)]=0

e=rep(n/k,k)

r=sum((t-e)^2/e)
r

u=1/20
if(r<qchisq(u/2,k-1) || r>qchisq(u/2,k-1,lower.tail=F))rs=list("REJECT",r) else rs=list("ACCEPT",r)
rs

/ REJECT

/ Einde SAMENVATTING CHISQ

/ 7	.


>  x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10
> x
 [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.5 0.5 0.5 0.5 0.7 0.7 0.7 0.7 0.7 0.9 0.9 0.9
[20] 0.9
> n=20
> e=1:n/n
> e
 [1] 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75
[16] 0.80 0.85 0.90 0.95 1.00
> e-x
 [1] -0.05  0.00  0.05  0.10  0.15  0.20  0.25 -0.10 -0.05  0.00  0.05 -0.10
[13] -0.05  0.00  0.05  0.10 -0.05  0.00  0.05  0.10
> max(e-x)
[1] 0.25

> f=0:(n-1)/n
> f
 [1] 0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70
[16] 0.75 0.80 0.85 0.90 0.95
> x-f 
 [1]  0.10  0.05  0.00 -0.05 -0.10 -0.15 -0.20  0.15  0.10  0.05  0.00  0.15
[13]  0.10  0.05  0.00 -0.05  0.10  0.05  0.00 -0.05
> max(x-f)
[1] 0.15

[1] 0.15
> ks.test(x,e)
	Two-sample Kolmogorov-Smirnov test
D = 0.25, p-value = 0.5596
...
/ TODO

> sqrt(n)*max(1:n/n-x)
[1] 1.118034
> sqrt(n)*max(x-0:(n-1)/n)
[1] 0.6708204







/ Einde LEEDS IN R

/ R ECDF KS.TEST MISC

/ 7	. 

/ compute on vectors	, 

> x=-10:10
> y=x^2
> plot(x,y)
/ OK

/ 7	. 

/ plot vector	,

> x=rnorm(12)
> plot(x)
/ we zien x op verticale as	, tegen index	,

/ als we de x op de horizontale as willen	,
> plot(x,rep(0,12))

/ Kan het anders	, met kruisjes op de horizontale as	?
/ TODO

/ 7	. 

/ ecdf

> x=c(1,1,2,2,2,3,3,3,3,4)/10
> x
 [1] 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0.3 0.4
> f=ecdf(x)
> f(x)
 [1] 0.2 0.2 0.5 0.5 0.5 0.9 0.9 0.9 0.9 1.0
> knots(f)
[1] 0.1 0.2 0.3 0.4
> summary(f)
Empirical CDF:	  4 unique values with summary
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.100   0.175   0.250   0.250   0.325   0.400 

> plot(f)
> plot(f,verticals=T)

> plot.ecdf(rnorm(24))

/ 7	 

/ Lees	,
http://stats.stackexchange.com/questions/10030/difference-between-k-s-manual-test-and-k-s-test-with-r

/ 13	 .

ks.test( c(2,3,4,4,4,4,4,4,4,4,4,5,5,5,5), 
         c(1,1,1,2,2,2,3,3,3,4,4,4,5,5,5) ) 
/ D = 0.4667=K-	, en is bij 3: 3/5-2/15=7/15	,
/ Maar dit is zonder die sqrt	. 
/ TODO

/ de vragensteller doet het goed, hij geeft de freq op van 1,2,3,4,5: 0,1,1,9,4	, dus de cumulative freq zijn 0, 1/15, 2/15, 11/15, 1	, en de verwachte cumulative freq zijn 1/5,2/5,3/5,4/5,1	, 

/ 13	. 

/ we hebben 

>  x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10
> x
 [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.5 0.5 0.5 0.5 0.7 0.7 0.7 0.7 0.7 0.9 0.9 0.9
[20] 0.9
> e=1:n/n
> e
 [1] 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75
[16] 0.80 0.85 0.90 0.95 1.00

/ x zijn de waarnemingen, sorted, normed	, en e zijn de verwachtingen	, ook sorted, normed	,

/ In ons schrift hebben we precies	,
> fr=ecdf(x)
> plot(fr)
/ Dus bij 1/10 totale freq 7/20	, bij  5/10 totale freq 11/20	, bij 7/10 totale freq 16/20 en bij 9/10 totale freq 1	,

/ 7	. 

/ we hebben dezelfde rij	,	 
>  x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10

/ maar we maken een freq rij	,
k=10
cs=cut(x,0:k/k)
n=20
t=tapply(rep(1,n),cs,sum)
> t[is.na(t)]=0

e=rep(n/k,k)

> t
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
        7         0         0         0         4         0         5         0 
(0.8,0.9]   (0.9,1] 
        4         0 
> t=as.vector(t)
> t
 [1] 7 0 0 0 4 0 5 0 4 0
> e
 [1] 2 2 2 2 2 2 2 2 2 2
> p=e/20
> p
 [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1

> chisq.test(t,p=p)

	Chi-squared test for given probabilities

data:  t
X-squared = 33, df = 9, p-value = 0.0001336

/////////////////////////////////////////////////////////////////////////////
/ chisq.test werkt met freq	, ks.test met de waarnemingen	,

/ 7	. 

/ 13	. 

> p
 [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
> chisq.test(rep(1,10),p=p)
X-squared = 0, df = 9, p-value = 1
/ p-value=p chisq>0

/ 13	. 

> plot(pchisq(1:20,df=9))

/ 13	. 

> z=c(rep(1,5),rep(3,5))
> chisq.test(z,p=p)
X-squared = 5, df = 9, p-value = 0.8343
/ p-value=p chisq >5



/ 7	. 

/ Herhaal	,
> x
 [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.5 0.5 0.5 0.5 0.7 0.7 0.7 0.7 0.7 0.9 0.9 0.9
[20] 0.9
> fr=ecdf(x)
> plot(fr)


/ 7. 

> ?chisq.test

> res=chisq.test(t,p=p)
> class(res)
[1] "htest"
> res$statistic
X-squared 
       33 
> res$parameter
df 
 9 
> res$p.value
[1] 0.0001335521
> res$method
[1] "Chi-squared test for given probabilities"
> res$data.name
[1] "t"
> res$observed
 [1] 7 0 0 0 4 0 5 0 4 0
> res$expected
 [1] 2 2 2 2 2 2 2 2 2 2
> res$residuals
 [1]  3.535534 -1.414214 -1.414214 -1.414214  1.414214 -1.414214  2.121320
 [8] -1.414214  1.414214 -1.414214
> res$residuals^2
 [1] 12.5  2.0  2.0  2.0  2.0  2.0  4.5  2.0  2.0  2.0
/ Deze is wat we altijd uitrekenen	,


/ 7. 	

/ SAMENVATTING CHISQ LCG

[eric@almond Leeds]$ pwd
/home/eric/Devel/MIX/Leeds

$ vi chisqa.R

lcg=function(a,c,m,n,h){
	x=c()
	for(i in 1:n)
		x[i]=h=(a*h+c)%%m
	x/m
}


test_chisq=function(x,uncert){

n=length(x)
k=10
categories=cut(x,0:k/k)
t=tapply(rep(1,n),categories,sum) 	# verzamelen, moet voor chisq	, niet voor ks
t[is.na(t)]=0
t=as.vector(t)

p=rep(n/k,k)/n

chi=chisq.test(t,p=p)
stat=chi$statistic
val=chi$p.value
if(val<uncert/2 || (1-val)<uncert/2)str='reject' else str='accept'
res=list(str=str,stat=stat,val=val) 

}

uncert=1/20
lcg1=lcg(13,3,1024,400,0)
res1=test_chisq(lcg1,uncert)
lcg2=lcg(13,3,1025,400,0)
res2=test_chisq(lcg2,uncert)
lcg3=lcg(13,3,1024,2000,0)
res3=test_chisq(lcg3,uncert)
lcgnr=lcg(1664525,1013904223,2^32,2000,0)
resnr=test_chisq(lcgnr,uncert)
randu=lcg(65539,0,2^31,2000,1)
resrandu=test_chisq(randu,uncert)

/ OK


/ 7	. 

/ ks.test

     A list with class ‘"htest"’ containing the following components:

statistic: the value of the test statistic.

 p.value: the p-value of the test.

alternative: a character string describing the alternative hypothesis.

  method: a character string indicating what type of test was
          performed.

data.name: a character string giving the name(s) of the data.


$ vi ks2.R

x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10

test_ks=function(x,uncert){

n=length(x)

e=1:n/n

ks=ks.test(x,e);
stat=ks$statistic
val=ks$p.value
if(val<uncert/2 || (1-val)<uncert/2)str='reject' else str='accept'
res=list(str=str,stat=stat,val=val)

}

res=test_ks(x,1/20)


/ OK


/ 7	. 

/ SAMENVATTING

/ chisq & ks

[eric@almond Leeds]$ pwd
/home/eric/Devel/MIX/Leeds

$ vi chisq_ks.R



lcg=function(a,c,m,n,h){
	x=c()
	for(i in 1:n)
		x[i]=h=(a*h+c)%%m
	x/m
}


test_chisq=function(x,uncert){

n=length(x)
k=10
categories=cut(x,0:k/k)
t=tapply(rep(1,n),categories,sum) 	# verzamelen, moet voor chisq	, niet voor ks
t[is.na(t)]=0
t=as.vector(t)

p=rep(n/k,k)/n

chi=chisq.test(t,p=p)
stat=chi$statistic
val=chi$p.value
if(val<uncert/2 || (1-val)<uncert/2)str='reject' else str='accept'
res=list(str=str,stat=stat,val=val) 

}

test_ks=function(x,uncert){

n=length(x)

e=1:n/n

ks=ks.test(x,e);
stat=ks$statistic
val=ks$p.value
if(val<uncert/2 || (1-val)<uncert/2)str='reject' else str='accept'
res=list(str=str,stat=stat,val=val)

}


uncert=1/20

lcg1=lcg(13,3,1024,400,0)
res_chisq_lcg1=test_chisq(lcg1,uncert)
res_ks_lcg1=test_ks(lcg1,uncert)

lcg2=lcg(13,3,1025,400,0)
res_chisq_lcg2=test_chisq(lcg2,uncert)
res_ks_lcg2=test_ks(lcg2,uncert)

lcg3=lcg(13,3,1024,2000,0)
res_chisq_lcg3=test_chisq(lcg3,uncert)
res_ks_lcg3=test_ks(lcg3,uncert)

lcgnr=lcg(1664525,1013904223,2^32,2000,0)
res_chisq_lcgnr=test_chisq(lcgnr,uncert)
res_ks_lcgnr=test_ks(lcgnr,uncert)

randu=lcg(65539,0,2^31,2000,1)
res_chisq_randu=test_chisq(randu,uncert)
res_ks_randu=test_ks(randu,uncert)


/ Einde SAMENVATTING

/ 7	. 

/ Lees	,
http://www.real-statistics.com/tests-normality-and-symmetry/statistical-tests-normality-symmetry/kolmogorov-smirnov-test/
http://www.real-statistics.com/statistics-tables/kolmogorov-smirnov-table/

P(Dn ≤ Dn,α) = 1 – α
/ De getallen in zijn KS table , en ook in R, zijn / sqrt(n)	, 

> x=c(rep(1,2),rep(5,8),rep(7,1),rep(9,1))/10
> ks.test(x,'punif')
D = 0.33333, p-value = 0.1389

/ Dus in Knuth's table: P(Dn <= sqrt(12)/3=1.15)=1-.1389=86%	, 
 en dat klopt wel met Knuth(51)	,

/ 13	. 

/ Maar	,
> x=c(rep(1,2),rep(3,3),rep(5,2),rep(7,3),rep(9,2))/10
> ks.test(x,'punif')
D = 0.13333, p-value = 0.9833

/ en P(D<= .13333*sqrt(12)=.46)=1-.9833=1.66%	, maar dat klopt niet	,m 
/ TODO


/ 7. 	

/ chisq	,

/ 13	 .

> x=c(rep(1,7),rep(5,4),rep(7,5),rep(9,4))/10
> x
 [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.5 0.5 0.5 0.5 0.7 0.7 0.7 0.7 0.7 0.9 0.9 0.9
[20] 0.9

>  table(x)
x
0.1 0.5 0.7 0.9 
  7   4   5   4 

/ we hebben niet de tussenliggende values met freq 0	,
/ daarom	,

> u=0:10/10
>  u
 [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

> r=summary(cut(x,u))
> r
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
        7         0         0         0         4         0         5         0 
(0.8,0.9]   (0.9,1] 
        4         0 

/ Het maakt dus niet uit wat length(x) is	, 20 of ...	, we cat in 10 intervals	,

> f=as.vector(r)
> f
 [1] 7 0 0 0 4 0 5 0 4 0

> e=rep(2,10)
> e
 [1] 2 2 2 2 2 2 2 2 2 2

> sum((f-e)^2/e)
[1] 33

> chisq.test(f,p=e/20)
X-squared = 33, df = 9, p-value = 0.0001336

/ 13	. 

> x=c(1,1,3:10)/10
> r=summary(cut(x,u));f=as.vector(r)
> f
 [1] 2 0 1 1 1 1 1 1 1 1
> e=rep(1,10)
> chisq.test(f,p=e/10)
X-squared = 2, df = 9, p-value = 0.9915

/ of met de hand	,
> e=rep(1,10)
> sum((f-e)^2/e)
[1] 2

/ Nu maakt het uit of je e=rep(2,10) of rep(1,10) neemt	, met chisq.test doen we toch /20, resp /10 	

/ 13	. 

> x=c(1,1,1,4:10)/10
> x
 [1] 0.1 0.1 0.1 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> r=summary(cut(x,u));f=as.vector(r)
> r
  (0,0.1] (0.1,0.2] (0.2,0.3] (0.3,0.4] (0.4,0.5] (0.5,0.6] (0.6,0.7] (0.7,0.8] 
        3         0         0         1         1         1         1         1 
(0.8,0.9]   (0.9,1] 
        1         1 
> e=rep(1,10)
> chisq.test(f,p=e/10)
X-squared = 6, df = 9, p-value = 0.7399

/ of met de hand	,
> e=rep(1,10)
> sum((f-e)^2/e)
[1] 6



/ 7	. 


/ stepfun 

> y=c(2,8,-1,4,3,2)
> sf=stepfun(1:(length(y)-1),y)
> plot(sf)
/ OK


/ Einde R ECDF KS.TEST MISC

/ R SPECTRAL TEST

/ Knuth, Vol2 (105)

/ Lees	, 
http://www.cse.wustl.edu/~jain/cse567-08/ftp/k_27trg.pdf

[eric@almond Leeds]$ pwd
/home/eric/Devel/MIX/Leeds
[eric@almond Leeds]$ vi spectral.R 

lcg=function(a,c,m,n,h){
  x=c()
  for(i in 1:n)x[i]=h=(a*h+c)%%m
  x/m
}

f=function(){
  y=c()
  for(i in 1:n-1)y[i]=x[i+1]
  y
}

...

# self
# 2 lines ,
#x0=0
#n=8
#x=lcg(1,3,8,n,x0)

# jain
# 3 lines
x0=1
n=31
x=lcg(3,0,31,n,x0)

y=f()

k=n-1
plot(x[1:k],y[1:k],type="n")
text(x[1:k],y[1:k],l[1:k])

/ bij self	,
> x*8
[1] 4 7 2 5 0 3 6 1
> y*8
[1] 7 2 5 0 3 6 1
/ we zien 2 lijen	,
y=x+3
y=x-5

/ bij jain	,
> x*31
 [1]  3  9 27 19 26 16 17 20 29 25 13  8 24 10 30 28 22  4 12  5 15 14 11  2  6
[26] 18 23  7 21  1  3  9 27 19 26 16 17 20 29 25 13  8 24 10 30 28 22  4 12  5
[51] 15 14 11  2  6 18 23  7 21  1  3  9 27 19
> y*31
 [1]  9 27 19 26 16 17 20 29 25 13  8 24 10 30 28 22  4 12  5 15 14 11  2  6 18
[26] 23  7 21  1  3  9 27 19 26 16 17 20 29 25 13  8 24 10 30 28 22  4 12  5 15
[51] 14 11  2  6 18 23  7 21  1  3  9 27 19
/we zien 3 lijnen	,
y=3x
y=3x-31
y=3x-62


/ HIER HIER HIER









/ Einde R SPECTRAL TEST

/ C

/ 7	. 

/ % 2^n = & 2^n-1

/ - is sterker dan &	, 

(gdb) p x
$13 = 6
(gdb) p m
$17 = 4
(gdb) p x & m -1
$11 = 2
(gdb) p x & m 
$12 = 4

 /7	. 

/ % is sterk,	 daarom () om 13*549+3
/ << is zwakker dan -	, daarom () om 1<<10	, anders 1<<9
/ & is zwakker dan +	,

(gdb) p (13*549+3) % 1024
$15 = 996
/ of	,
(gdb) p 13*549+3 & (1<<10)-1
$19 = 996

/ als we % 1023	,

(gdb) p (13*549+3) % ((1<<10)-1)
/ want % is zo sterk als *	, vandaar (...) % (...)
/ (1<<10)-1 	, want << is zwakker dan -


/ 7	. 

/ Lees	,
http://www.tutorialspoint.com/cprogramming/c_operators_precedence.htm

/ operator prededence in C	,

Category	Operator	Associativity
Postfix	() [] -> . ++ - -	Left to right
Unary	+ - ! ~ ++ - - (type)* & sizeof	Right to left
Multiplicative	* / %	Left to right
Additive	+ -	Left to right
Shift	<< >>		Left to right
Relational < <= > >=	Left to right
Equality	== !=	Left to right
Bitwise AND	&	Left to right
Bitwise XOR	^	Left to right
Bitwise OR	|	Left to right
Logical AND	&&	Left to right
Logical OR	||	Left to right
Conditional	?:	Right to left
Assignment	= += -= *= /= %=>>= <<= &= ^= |=	Right to left
Comma	,	Left to right

/ 7	. 

(gdb) sho pr elem
Limit on string chars or array elements to print is 200.
(gdb) set pr elem 400

/ toont hele array	,
(gdb) p x
$2 = {0, 3, 42, 549, 996, 663, 430, 473, 8, 107, 370, 717, 108, 383, 886, 257, 272, 467, 
  954, 117, 500, 359, 574, 297, 792, 59, 770, 797, 124, 591, 518, 593, 544, 931, 842, 709, 
  4, 55, 718, 121, 552, 11, 146, 877, 140, 799, 150, 929, 816, 371, 730, 277, 532, 775, 
  862, 969, 312, 987, 546, 957, 156, 1007, 806, 241, 64, 835, 618, 869, 36, 471, 1006, 
  793, 72, 939, 946, 13, 172, 191, 438, 577, 336, 275, 506, 437, 564, 167, 126, 617, 856, 
  891, 322, 93, 188, 399, 70, 913, 608, 739, 394, 5, 68, 887, 270, 441, 616, 843, 722, 
  173, 204, 607, 726, 225, 880, 179, 282, 597, 596, 583, 414, 265, 376, 795, 98, 253, 220, 
  815, 358, 561, 128, 643, 170, 165, 100, 279, 558, 89, 136, 747, 498, 333, 236, 1023, 
  1014, 897, 400, 83, 58, 757, 628, 999, 702, 937, 920, 699, 898, 413, 252, 207, 646, 209, 
  672, 547, 970, 325, 132, 695, 846, 761, 680, 651, 274, 493, 268, 415, 278, 545, 944, 
  1011, 858, 917, 660, 391, 990, 585, 440, 603, 674, 573, 284, 623, 934, 881, 192, 451, 
  746, 485, 164, 87, 110, 409, 200, 555, 50, 653, 300, 831, 566, 193, 464, 915, 634, 53, 
  692, 807, 254, 233, 984, 507, 450, 733, 316, 15, 198, 529, 736, 355, 522, 645, 196, 503, 
  398, 57, 744, 459, 850, 813, 332, 223, 854, 865, 1008, 819, 410, 213, 724, 199, 542, 
  905, 504, 411, 226, 893, 348, 431, 486, 177, 256, 259, 298, 805, 228, 919, 686, 729, 
  264, 363, 626, 973, 364, 639, 118, 513, 528, 723, 186, 373, 756, 615, 830, 553, 24, 315, 
  2, 29, 380, 847, 774, 849, 800, 163, 74, 965, 260, 311, 974, 377, 808, 267, 402, 109, 
  396, 31, 406, 161, 48, 627, 986, 533, 788, 7, 94, 201, 568, 219, 802, 189, 412, 239, 38, 
  497, 320, 67, 874, 101, 292, 727, 238, 25, 328, 171, 178, 269, 428, 447, 694, 833, 592, 
  531, 762, 693, 820, 423, 382, 873, 88, 123, 578, 349, 444, 655, 326, 145, 864, 995, 650, 
  261, 324, 119, 526, 697, 872, 75, 978, 429, 460, 863, 982, 481, 112, 435, 538, 853, 852, 
  839, 670, 521, 632, 27, 354, 509, 476, 47, 614, 817, 384, 899, 426, 421, 356, 535, 814, 
  345, 392, 1003, 754, 589, 492, 255, 246, 129}



/ Einde C

/ R MANUAL

/ 7	. 

/ install	,

/ Geef in google	,
fedora r-project
/ Lees	,
https://cran.r-project.org/bin/linux/redhat/README
/ hoe kom je hier vanuit de home page	?
/ TODO

[eric@almond Leeds]$ sudo dnf install R

/ 7	. 

/ manual 

https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Introduction-and-preliminaries

[eric@almond 1]$ pwd
/home/eric/Devel/R/Manual/1
[eric@almond 1]$ R

R version 3.2.3 (2015-12-10) -- "Wooden Christmas-Tree"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

/ in 2*x+y+1 is y de langste vector, 
/ 1 wordt steeds herhaald	, dus wordt opgeteld bij ieder elem van y	,
/ 2*x is korter, dus wordt ook steeds herhaald	, dus als x 4 lang en y 10	, dan past x er 2 keer in, en ook x0 en x1 als laatste	,


> x
[1] 10.4  5.6  3.1  6.4 21.7
> rep(x,times=2)
 [1] 10.4  5.6  3.1  6.4 21.7 10.4  5.6  3.1  6.4 21.7
> rep(x,each=2)
 [1] 10.4 10.4  5.6  5.6  3.1  3.1  6.4  6.4 21.7 21.7
> seq(along=x)
[1] 1 2 3 4 5
> x>10
[1]  TRUE FALSE FALSE FALSE  TRUE
> x+x>10
[1]  TRUE  TRUE FALSE  TRUE  TRUE
> x+(x>10)
[1] 11.4  5.6  3.1  6.4 22.7

> is.na(na)
Error: object 'na' not found
> is.na(NA)
[1] TRUE

> 1 == TRUE
[1] TRUE
/ er is geen is.true function

> NA==NA
[1] NA
> is.na(NA)
[1] TRUE
> x==NA
[1] NA NA NA NA NA
s.na(x)
[1] FALSE FALSE FALSE FALSE FALSE

> 1/0
[1] Inf
> 0/0
[1] NaN
> Inf - Inf
[1] NaN

> paste(c("X","Y"),1:10,sep="")
 [1] "X1"  "Y2"  "X3"  "Y4"  "X5"  "Y6"  "X7"  "Y8"  "X9"  "Y10"
> paste(c("X","Y"),1:10)
 [1] "X 1"  "Y 2"  "X 3"  "Y 4"  "X 5"  "Y 6"  "X 7"  "Y 8"  "X 9"  "Y 10"
/ Net als bij 2*x+y+1 hierboven wordt de korste rij ("X","Y") hier herhaalt	,

/ 7	. 

>  x[2]
[1] 5.6
> x[3]=NA
> x
[1] 10.4  5.6   NA  6.4 21.7
> !is.na(x)
[1]  TRUE  TRUE FALSE  TRUE  TRUE
> x[!is.na(x)]
[1] 10.4  5.6  6.4 21.7
> y
 [1] 10.4  5.6  3.1  6.4 21.7  0.0 10.4  5.6  3.1  6.4 21.7
> y[!is.na(x)]
[1] 10.4  5.6  6.4 21.7  0.0 10.4  3.1  6.4 21.7
/ Hier zien we ook weer dat !is.na(x) wordt herhaald	, want het is een kleinere vector	,
> x+1
[1] 11.4  6.6   NA  7.4 22.7
> (x+1)[x>10]
[1] 11.4   NA 22.7
> x>10
[1]  TRUE FALSE    NA FALSE  TRUE
> x[x>10]
[1] 10.4   NA 21.7
> y[x>10]
[1] 10.4   NA 21.7  0.0   NA  6.4 21.7
/ ook hier weer x>10 is kleiner dan y	, wordt herhaald	,

/ na = non missing	, 

/ een vector start met index 1,	

> x
[1] 10.4  5.6  3.1  6.4 21.7
> x[1:10]
 [1] 10.4  5.6  3.1  6.4 21.7   NA   NA   NA   NA   NA
> x[3]=NaN
> x[1:10]
 [1] 10.4  5.6  NaN  6.4 21.7   NA   NA   NA   NA   NA

> x
[1] 10.4  5.6  NaN  6.4 21.7
> x>10
[1]  TRUE FALSE    NA FALSE  TRUE

> rep(c(1,2,2,1),times=4)
 [1] 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1
> c("x","y")[rep(c(1,2,2,1),times=4)]
 [1] "x" "y" "y" "x" "x" "y" "y" "x" "x" "y" "y" "x" "x" "y" "y" "x"

> -(1:5)
[1] -1 -2 -3 -4 -5
> x[-(1:5)]
numeric(0)
/ alle behalve de 1ste 5	,
/ leeg	, want x heeft maar 5 elems	,
> x[6]=11.3
> x[-(1:5)]
[1] 11.3

/ trucate x	,
> length(x)<-5
> x
[1] 10.4  5.6  NaN  6.4 21.7

> f<-c(5,10,1,20)
> names(f)<-c("orange","banana","apple","peach")
> f
orange banana  apple  peach 
     5     10      1     20 
> f[c("apple","orange")]
 apple orange 
     1      5 
/ names is een R-fct	,

> z<-x
> z
[1] 10.4  5.6  NaN  6.4 21.7
/ cp a vector	,
> z[is.na(z)]
[1] NaN
> z[is.na(z)]<-0
> z
[1] 10.4  5.6  0.0  6.4 21.7

> z<-x
> z<--z
> z
[1] -10.4  -5.6   NaN  -6.4 -21.7

> z<-y
> z[1]<--z[1]
> z[4]<--z[4]
> z
 [1] -10.4   5.6   3.1  -6.4  21.7   0.0  10.4   5.6   3.1   6.4  21.7
> z[z<0]
[1] -10.4  -6.4
> z[z<0]<--z[z<0]
> z[z<0]
numeric(0)
/ leeg	,

/ ch 3	,

> z<-1:9
> z
[1] 1 2 3 4 5 6 7 8 9
> as.character(z)
[1] "1" "2" "3" "4" "5" "6" "7" "8" "9"
> as.integer(as.character(z))
[1] 1 2 3 4 5 6 7 8 9
> z== as.integer(as.character(z))
[1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE

> e<- character()
> e[3]<-7
> e
[1] NA  NA  "7"

> a<-10:1
> a
 [1] 10  9  8  7  6  5  4  3  2  1
> a[2*1:5]
[1] 9 7 5 3 1
/ met even indices	,


 [1] 10  9  8  7  6  5  4  3  2  1
> length(a)<-3
> a
[1] 10  9  8
/ truncate	,

> z<-9:1
> attr(z,'dim')<c(3,3)
logical(0)
/ TODO

> z<-9:1
> z
[1] 9 8 7 6 5 4 3 2 1
> class(z)
[1] "integer"
> class(z)<-data.frame
Error in class(z) <- data.frame : 
 cannot coerce type 'closure' to vector of type 'character'
/ TODO

/ ch 4	,

> t<- c(3,3,1,1,1,1,7,7,5,5,5)
> t
 [1] 3 3 1 1 1 1 7 7 5 5 5
> factor(t)
 [1] 3 3 1 1 1 1 7 7 5 5 5
Levels: 1 3 5 7

> state
 [1] "tas" "sa"  "qld" "nsw" "nsw" "nt"  "wa"  "wa"  "qld" "vic" "nsw" "vic"
[13] "qld" "qld" "sa"  "tas" "sa"  "nt"  "wa"  "vic" "qld" "nsw" "nsw" "wa" 
[25] "sa"  "act" "nsw" "vic" "vic" "act"
> statef
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa  tas sa  nt  wa 
[20] vic qld nsw nsw wa  sa  act nsw vic vic act
Levels: act nsw nt qld sa tas vic wa

 incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
+                61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
+                59, 46, 58, 43)
> tapply(incomes,statef,mean)
     act      nsw       nt      qld       sa      tas      vic       wa 
44.50000 57.33333 55.50000 53.60000 55.00000 60.50000 56.00000 52.25000 

The function tapply() is used to apply a function, here mean(), to each group of components of the first argument, here incomes, defined by the levels of the second component, here statef15, as if they were separate vector structures.
///////////////////////////////////////////////////////
/ Dus factor is als group by in sql	,
 
> stderr_<-function(x)sqrt(var(x)/length(x))
> tapply(incomes,state
state           state.area      state.division  state.region    statef
state.abb       state.center    state.name      state.x77       
> tapply(incomes,statef,stderr
stderr   stderr_  
> tapply(incomes,statef,stderr_)
     act      nsw       nt      qld       sa      tas      vic       wa 
1.500000 4.310195 4.500000 4.106093 2.738613 0.500000 5.244044 2.657536 

/ stderr is er al, 
/ TODO
/ _stderr is ERR	, stderr_ is OK	, 
/ TODO

As an exercise you may care to find the usual 95% confidence limits for the state mean incomes. To do this you could use tapply() once more with the length() function to find the sample sizes, and the qt() function to find the percentage points of the appropriate t-distributions. (You could also investigate R’s facilities for t-tests.)
/ TODO

/ ch 5


> x<-array(1:20)
> x
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
> x==c(1:20)
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE
/ is vector == array?
/ TODO

>  x<-array(1:20,dim=c(4,5))
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

> x<-c(1,2,3,4)
> dim(x)<-c(2,2)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4


> x<-array(c(1:3,3:1),dim=c(3,2))
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    2
[3,]    3    1

/ Dus pak x[1,3], x[2,2], x[3,1]

> x[i]
[1] 9 6 3

> x[i]<-0
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    0   13   17
[2,]    2    0   10   14   18
[3,]    0    7   11   15   19
[4,]    4    8   12   16   20

/ 13	. 

> h<-c(1:24)
> h
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
> x<-array(h,dim=c(3,4,2))
> x
, , 1

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , 2

     [,1] [,2] [,3] [,4]
[1,]   13   16   19   22
[2,]   14   17   20   23
[3,]   15   18   21   24

> x
/=
> x[]

/ we zien hierboven	,
> x[,,1]
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

/ maar	,
> x[1,,]
     [,1] [,2]
[1,]    1   13
[2,]    4   16
[3,]    7   19
[4,]   10   22


/ 13	. 

/ %o% is tensor product, zij noemen outer product	,

> outer(1:2,1:2)
/ of	,
> outer(c(1,2),c(1,2))
/ of	,
> c(1,2) %o% c(1,2)
/ of	,
> 1:2 %o% 1:2
     [,1] [,2]
[1,]    1    2
[2,]    2    4

/ 13	. 

/ vervang * door f	, 

/ we nemen eerst f=*	, 

> f<-function(x,y) x*y
> outer(c(1,2),c(1,2),f)
     [,1] [,2]
[1,]    1    2
[2,]    2    4

/ Dan veranderen we f	,
> f<-function(x,y) x*y*2

> outer(c(1,2),c(1,2),f)
     [,1] [,2]
[1,]    2    4
[2,]    4    8


/ 13	. 

> x<-1:2 %o% 1:2
> x %o% x
, , 1, 1

     [,1] [,2]
[1,]    1    2
[2,]    2    4

, , 2, 1

     [,1] [,2]
[1,]    2    4
[2,]    4    8

, , 1, 2

     [,1] [,2]
[1,]    2    4
[2,]    4    8

, , 2, 2

     [,1] [,2]
[1,]    4    8
[2,]    8   16

> table(x %o% x)

 1  2  4  8 16 
 1  4  6  4  1 

/ 13	. 

> outer(1:2,1:2,"*")
     [,1] [,2]
[1,]    1    2
[2,]    2    4
> outer(1:2,1:2,"-")
     [,1] [,2]
[1,]    0   -1
[2,]    1    0

/ met *: 
1 tensor 1 
2	 2
= 
in richting 
1
0
 is het
1
2
en in richting
0
2
is het 
2
4	, 
/ met -	, doe - ipv *	, je haalt de richting ervan af	,
in richting 
0
2 
 is het
1-2
2-2
=
-1
0

/ 13	. 

/ table is frequency table,	

> d
     [,1] [,2]
[1,]    1    2
[2,]    2    4
> table(d)
d
1 2 4 
1 2 1 

> d %o% d
, , 1, 1

     [,1] [,2]
[1,]    1    2
[2,]    2    4

, , 2, 1

     [,1] [,2]
[1,]    2    4
[2,]    4    8

, , 1, 2

     [,1] [,2]
[1,]    2    4
[2,]    4    8

, , 2, 2

     [,1] [,2]
[1,]    4    8
[2,]    8   16

> table(d %o% d)

 1  2  4  8 16 
 1  4  6  4  1 


/ 13	. 

> d<-outer(1:2,1:2)
> outer(d,d,"-")
, , 1, 1

     [,1] [,2]
[1,]    0    1
[2,]    1    3

, , 2, 1

     [,1] [,2]
[1,]   -1    0
[2,]    0    2

, , 1, 2

     [,1] [,2]
[1,]   -1    0
[2,]    0    2

, , 2, 2

     [,1] [,2]
[1,]   -3   -2
[2,]   -2    0

/ Klopt	,

> freq<-table(outer(d,d,"-"))
> freq

-3 -2 -1  0  1  2  3 
 1  2  2  6  2  2  1 

/ klopt	,

> plot(as.numeric(names(fr)),fr,type="h",xlab="Determinant",ylab="Frequency")

/ TODO (getallen op de assen)	,

/ 13	. 

 x<-array(1:12,dim=3:4)
> x
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> aperm(x,2:1)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
[4,]   10   11   12

 /of	,

> x<-array(1:12,dim=c(3,2,2))
> x
, , 1

     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6

, , 2

     [,1] [,2]
[1,]    7   10
[2,]    8   11
[3,]    9   12

> aperm(x,3:1)
, , 1

     [,1] [,2]
[1,]    1    4
[2,]    7   10

, , 2

     [,1] [,2]
[1,]    2    5
[2,]    8   11

, , 3

     [,1] [,2]
[1,]    3    6
[2,]    9   12

/ 13	. 

/ * is elem by elem product, %*% is matrix product	, %o% is tensor product	, 

> a<-array(c(1,2,2,1),dim=c(2,2))
> b<-array(c(1,-1,-1,1),dim=c(2,2))

> a * b
     [,1] [,2]
[1,]    1   -2
[2,]   -2    1

> a %*% b
     [,1] [,2]
[1,]   -1    1
[2,]    1   -1

> p<-a %o% b
> p
, , 1, 1

     [,1] [,2]
[1,]    1    2
[2,]    2    1

, , 2, 1

     [,1] [,2]
[1,]   -1   -2
[2,]   -2   -1

, , 1, 2

     [,1] [,2]
[1,]   -1   -2
[2,]   -2   -1

, , 2, 2

     [,1] [,2]
[1,]    1    2
[2,]    2    1

> p[1,1,,]
     [,1] [,2]
[1,]    1   -1
[2,]   -1    1
> p[1,2,,]
     [,1] [,2]
[1,]    2   -2
[2,]   -2    2
> p[2,1,,]
     [,1] [,2]
[1,]    2   -2
[2,]   -2    2
> p[2,2,,]
     [,1] [,2]
[1,]    1   -1
[2,]   -1    1

/ Kan dat ook in 1 keer	, dat je p[1,1,,], ... ziet	? 
/ TODO
/ R neemt tensor product van achter	, 
/ TODO

/ 13	. 

> x<-array(1:3,dim=c(3,1))
> y<-array(1:3,dim=c(1,3))
> x
     [,1]
[1,]    1
[2,]    2
[3,]    3
> y
     [,1] [,2] [,3]
[1,]    1    2    3
> crossprod(x,y)
Error in crossprod(x, y) : non-conformable arguments
> crossprod(x,x)
     [,1]
[1,]   14
> crossprod(y,y)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    2    4    6
[3,]    3    6    9

/ crossprod= inwendig product	,

/ 13	. 

> x<-array(1:3,dim=c(3,1))
> y<-array(1:3,dim=c(1,3))

> x*x
     [,1]
[1,]    1
[2,]    4
[3,]    9
> y*y
     [,1] [,2] [,3]
[1,]    1    4    9
> x %*% x
Error in x %*% x : non-conformable arguments
> y %*% y
Error in y %*% y : non-conformable arguments
> x %*% y
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    2    4    6
[3,]    3    6    9
> y %*% x
     [,1]
[1,]   14


> x %o% x
, , 1, 1

     [,1]
[1,]    1
[2,]    2
[3,]    3

, , 2, 1

     [,1]
[1,]    2
[2,]    4
[3,]    6

, , 3, 1

     [,1]
[1,]    3
[2,]    6
[3,]    9

> x %o% y
, , 1, 1

     [,1]
[1,]    1
[2,]    2
[3,]    3

, , 1, 2

     [,1]
[1,]    2
[2,]    4
[3,]    6

, , 1, 3

     [,1]
[1,]    3
[2,]    6
[3,]    9

> y %o% x
, , 1, 1

     [,1] [,2] [,3]
[1,]    1    2    3

, , 2, 1

     [,1] [,2] [,3]
[1,]    2    4    6

, , 3, 1

     [,1] [,2] [,3]
[1,]    3    6    9

> y %o% y
, , 1, 1

     [,1] [,2] [,3]
[1,]    1    2    3

, , 1, 2

     [,1] [,2] [,3]
[1,]    2    4    6

, , 1, 3

     [,1] [,2] [,3]
[1,]    3    6    9

/ 13	. 

> diag(c(1,2,3))
     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    2    0
[3,]    0    0    3
> diag(diag(c(1,2,3)))
[1] 1 2 3
> diag(2)
     [,1] [,2]
[1,]    1    0
[2,]    0    1

/ 13	. 

> A<-array(c(1,2,3,4),dim=c(2,2))
> A
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> x<-array(c(1,2),dim=c(2,1))
> x
     [,1]
[1,]    1
[2,]    2

> b<-A %*% x
> b
     [,1]
[1,]    7
[2,]   10

/ Nu oplossen	,

> solve(A,b)
     [,1]
[1,]    1
[2,]    2

/ of zo	,

> solve(A)
     [,1] [,2]
[1,]   -2  1.5
[2,]    1 -0.5
> solve(A) %*% b
     [,1]
[1,]    1
[2,]    2

/ Wat is dit	?
> A^{-1}
     [,1]      [,2]
[1,]  1.0 0.3333333
[2,]  0.5 0.2500000

/ 13	. 

 A<-array(c(1,2,2,4),dim=c(2,2))
> eigen(A)
$values
[1] 5 0

$vectors
          [,1]       [,2]
[1,] 0.4472136 -0.8944272
[2,] 0.8944272  0.4472136

/ R geeft de nomalized vectors	, dus niet bij eigenwaarde 5	,
1
2
/ maar 
1/sqrt(5)
2/sqrt(5)

/ de eigenvector bij 0 is
-2
1

/ we kunnen apart	,
> eigen(A)$values
/ of	,
> eigen(A)$val
/ of	,
> eigen(A)$va
[1] 5 0

/ en	
> eigen(A)$vectors
/ of	,
> eigen(A)$ve
          [,1]       [,2]
[1,] 0.4472136 -0.8944272
[2,] 0.8944272  0.4472136

/ als we $values erachter set	, berekent hij toch $vectors	,
/ als we dat niet willen moeten we	,

> eigen(A,only.values=TRUE)$values
[1] 5 0

/ check	,
> eigen(A,only.values=TRUE)$ve
/ of	,
> eigen(A,only.values=T)$ve
NULL

> eigen(A,only.values=T)$va
[1] 5 0

/ of nog korter	,
> eigen(A,only.val=T)$va
[1] 5 0
> eigen(A,only.val=T)$ve
NULL

/ 13	. 

/ we hadden zelf 	,

f * -1 0 * e = A= 1 2
 e   0 3    f	  2 1

|-1 1| * |-1 0 |* 1/2|-1 1| = |1 2| 
| 1 1|   | 0 3 |     | 1 1|   |2 1|	

/ Als we 3 en -1 omdraaien	, moeten we de kolommen links ook omdraaien , en rechts uitrekenen	,

|1 -1| * |3  0 |* 1/2| 1 1| = |1 2| 
|1  1|   |0 -1 |     |-1 1|   |2 1|	

/ en we maken van de -1 een 1	, we bepalen de kolommen links, en rekenen laten staan,	 

|1  1| * |3  0 |* 1/2| 1 1| = |1 2| 
|1 -1|   |0  1 |     |-1 1|   |2 1|	

/ en dat is ook wat R geeft	, afgezien van dat de u en v met -1 zijn *	,

> a<-array(c(1,2,2,1),dim=c(2,2))
> a
     [,1] [,2]
[1,]    1    2
[2,]    2    1
> svd(a)
$d
[1] 3 1

$u
           [,1]       [,2]
[1,] -0.7071068 -0.7071068
[2,] -0.7071068  0.7071068

$v
           [,1]       [,2]
[1,] -0.7071068  0.7071068
[2,] -0.7071068 -0.7071068


/ 13	. 

>   cbind(c(1,2),c(3,4))
     [,1] [,2]
[1,]    1    3
[2,]    2    4
>   rbind(c(1,2),c(3,4))
     [,1] [,2]
[1,]    1    2
[2,]    3    4

>   cbind(1,c(1,2),c(3,4))
     [,1] [,2] [,3]
[1,]    1    1    3
[2,]    1    2    4

/ 13	. 

> cbind(1,c(1,2),c(3,4))
     [,1] [,2] [,3]
[1,]    1    1    3
[2,]    1    2    4

> factor(  cbind(1,c(1,2),c(3,4)))
[1] 1 1 1 2 3 4
Levels: 1 2 3 4

/ factor loopt colums af en print rows	, dus eerst 1ste column : 1, 1	, dan 2de column : 1,2, ...
/ levels sorts ze en uniques ze	, 

/ ander voorbeeld,	
>  cbind(4,c(1,2),c(3,4))
     [,1] [,2] [,3]
[1,]    4    1    3
[2,]    4    2    4
> factor(  cbind(4,c(1,2),c(3,4)))
[1] 4 4 1 2 3 4
Levels: 1 2 3 4

> table(  cbind(1,c(1,2),c(3,4)))

1 2 3 4 
3 1 1 1 

/ geeft freq	, bovenste rij is level bij factor	,

/ 13	. 

> 35+10*(0:7)
[1]  35  45  55  65  75  85  95 105

> incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
+                61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
+                59, 46, 58, 43)
> c<-cut(incomes, breaks = 35+10*(0:7))
> c
 [1] (55,65] (45,55] (35,45] (55,65] (55,65] (55,65] (55,65] (45,55] (55,65]
[10] (65,75] (65,75] (35,45] (55,65] (55,65] (55,65] (55,65] (55,65] (45,55]
[19] (45,55] (55,65] (45,55] (45,55] (35,45] (45,55] (45,55] (45,55] (55,65]
[28] (45,55] (55,65] (35,45]
Levels: (35,45] (45,55] (55,65] (65,75] (75,85] (85,95] (95,105]

> factor(c)
 [1] (55,65] (45,55] (35,45] (55,65] (55,65] (55,65] (55,65] (45,55] (55,65]
[10] (65,75] (65,75] (35,45] (55,65] (55,65] (55,65] (55,65] (55,65] (45,55]
[19] (45,55] (55,65] (45,55] (45,55] (35,45] (45,55] (45,55] (45,55] (55,65]
[28] (45,55] (55,65] (35,45]
Levels: (35,45] (45,55] (55,65] (65,75]
/ we zien toch een verschil tussen c en factor(c): minder levels	, 
/ de levels (75,85] (85,95] (95,105] komen niet voor	, factor ziet dat	,

> state <- c("tas", "sa",  "qld", "nsw", "nsw", "nt",  "wa",  "wa",
+              "qld", "vic", "nsw", "vic", "qld", "qld", "sa",  "tas",
+              "sa",  "nt",  "wa",  "vic", "qld", "nsw", "nsw", "wa",
+              "sa",  "act", "nsw", "vic", "vic", "act")
> f<-factor(state)
> f
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa  tas sa  nt  wa 
[20] vic qld nsw nsw wa  sa  act nsw vic vic act
Levels: act nsw nt qld sa tas vic wa

> table(c,f)
          f
c          act nsw nt qld sa tas vic wa
  (35,45]    1   1  0   1  0   0   1  0
  (45,55]    1   1  1   1  2   0   1  3
  (55,65]    0   3  1   3  2   2   2  1
  (65,75]    0   1  0   0  0   0   1  0
  (75,85]    0   0  0   0  0   0   0  0	
  (85,95]    0   0  0   0  0   0   0  0
  (95,105]   0   0  0   0  0   0   0  0
> table(factor(c),f)
         f
          act nsw nt qld sa tas vic wa
  (35,45]   1   1  0   1  0   0   1  0
  (45,55]   1   1  1   1  2   0   1  3
  (55,65]   0   3  1   3  2   2   2  1
  (65,75]   0   1  0   0  0   0   1  0
> 
/ we zien inderdaad  dat (75,85] , (85,95]	, (95,105]  niet voorkomen	,

/ 13	. 

> Lst <- list(name="Fred", wife="Mary", no.children=3,
+               child.ages=c(4,7,9))
> Lst
$name
[1] "Fred"

$wife
[1] "Mary"

$no.children
[1] 3

$child.ages
[1] 4 7 9

/ 13	. 

/ Geef of de index	, of de name	,

> Lst[[2]]
[1] "Mary"
/ of	,
> Lst$wife
[1] "Mary"
/ of	,
> Lst[["wife"]]
[1] "Mary"

/ Niet dubbelop	,
> Lst[2].$wife
Error: unexpected symbol in "Lst[2]."

/ we mogen de name zoveel mogelijk afkorten	,

> Lst$w
[1] "Mary"

/ maar NIET	,
> Lst[["w"]]
NULL

> Lst$child.ages
[1] 4 7 9
> Lst$child
[1] 4 7 9
> Lst$c
[1] 4 7 9

/ en	,
> Lst$c[1]
[1] 4

/ Niet in lists mag dat niet	,

> child.ages=c(1,2,3)
> child.ages[1]
[1] 1
> child[1]
Error: object 'child' not found

/ 13	. 

/ Lst[2] is een sublist van Lst	,
> Lst[2]
$wife
[1] "Mary"
> Lst[2]$wife
[1] "Mary"

/ 13	. 

/ concat lists	,

> list.a=list(name='foo',address='bar')
> list.b=list(name2='foo2',address2='bar2')
> list.ab=c(list.a,list.b)
> list.ab$name
[1] "foo"
> list.ab$name2
[1] "foo2"

/ 13	. 

/ wat als we list use ipv. c	?

> list.ab2=list(l.a=list.a,l.b=list.b)
> list.ab2$l.a
$name
[1] "foo"

$address
[1] "bar"

/ 13	. 

> x=matrix(c(1,2,3,4),2,2)
> x
     [,1] [,2]
[1,]    1    3
[2,]    2    4

 y=array(c(1,2,3,4),dim=c(2,2))
> y
     [,1] [,2]
[1,]    1    3
[2,]    2    4

/ verschil?
/ TODO




/ 13	. 

/ data frames	,

/ Intermezzo

/ par 4.2

> incomes
 [1] 60 49 40 61 64 60 59 54 62 69 70 42 56 61 61 61 58 51 48 65 49 49 41 48 52
[26] 46 59 46 58 43
> state
 [1] "tas" "sa"  "qld" "nsw" "nsw" "nt"  "wa"  "wa"  "qld" "vic" "nsw" "vic"
[13] "qld" "qld" "sa"  "tas" "sa"  "nt"  "wa"  "vic" "qld" "nsw" "nsw" "wa" 
[25] "sa"  "act" "nsw" "vic" "vic" "act"
> length(incomes)
[1] 30
> length(state)
[1] 30

> statef=factor(state)
> str(statef)
 Factor w/ 8 levels "act","nsw","nt",..: 6 5 4 2 2 3 8 8 4 7 ...
/ de states act, nsw,nt, ... zijn coded als 1,2,3,... en ze komen voor als 6,5,4,...

> incmeans=tapply(incomes,statef)
> incmeans
 [1] 6 5 4 2 2 3 8 8 4 7 2 7 4 4 5 6 5 3 8 7 4 2 2 8 5 1 2 7 7 1
/ we zien de codering van statef	,

/ het is	,
tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE) 

> incmeans=tapply(incomes,statef,mean)
> incmeans
     act      nsw       nt      qld       sa      tas      vic       wa 
44.50000 57.33333 55.50000 53.60000 55.00000 60.50000 56.00000 52.25000 

> tapply(incomes,statef,length)
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 
/=
> tapply(incomes,statef,function(x)length(x))
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 

/ Ook	,

> ls=tapply(incomes,statef,function(x)x)
> ls$act
[1] 46 43

> ls
$act
[1] 46 43

$nsw
[1] 61 64 70 49 41 59

$nt
[1] 60 51

$qld
[1] 40 62 56 61 49

$sa
[1] 49 61 58 52

$tas
[1] 60 61

$vic
[1] 69 42 65 46 58

$wa
[1] 59 54 48 48

> str(ls)
List of 8
 $ act: num [1:2] 46 43
 $ nsw: num [1:6] 61 64 70 49 41 59
 $ nt : num [1:2] 60 51
 $ qld: num [1:5] 40 62 56 61 49
 $ sa : num [1:4] 49 61 58 52
 $ tas: num [1:2] 60 61
 $ vic: num [1:5] 69 42 65 46 58
 $ wa : num [1:4] 59 54 48 48
 - attr(*, "dim")= int 8
 - attr(*, "dimnames")=List of 1
  ..$ : chr [1:8] "act" "nsw" "nt" "qld" ...


/ par 5.10

> statefr=table(statef)
> statefr
statef
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 
/=
> tapply(1:30, statef, length)
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 

/ Hoe create vector with 30 0's	?
> rep(0,30)

> cut(incomes,35+10*(0:7))
/=
> cut(incomes,breaks=35+10*(0:7))
 [1] (55,65] (45,55] (35,45] (55,65] (55,65] (55,65] (55,65] (45,55] (55,65]
[10] (65,75] (65,75] (35,45] (55,65] (55,65] (55,65] (55,65] (55,65] (45,55]
[19] (45,55] (55,65] (45,55] (45,55] (35,45] (45,55] (45,55] (45,55] (55,65]
[28] (45,55] (55,65] (35,45]
Levels: (35,45] (45,55] (55,65] (65,75] (75,85] (85,95] (95,105]

> str(cut(incomes,breaks=35+10*(0:7)))
 Factor w/ 7 levels "(35,45]","(45,55]",..: 3 2 1 3 3 3 3 2 3 4 ...

> incomef=cut(incomes,breaks=35+10*(0:7))
> table(incomef)
incomef
 (35,45]  (45,55]  (55,65]  (65,75]  (75,85]  (85,95] (95,105] 
       4       10       14        2        0        0        0 
> table(statef)
statef
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 


> table(incomef,statef)
          statef
incomef    act nsw nt qld sa tas vic wa
  (35,45]    1   1  0   1  0   0   1  0
  (45,55]    1   1  1   1  2   0   1  3
  (55,65]    0   3  1   3  2   2   2  1
  (65,75]    0   1  0   0  0   0   1  0
  (75,85]    0   0  0   0  0   0   0  0
  (85,95]    0   0  0   0  0   0   0  0
  (95,105]   0   0  0   0  0   0   0  0

/ er zijn 30 person's , en elk woont in een state en elk heeft een income	,
/ 3 betekent: er zijn 3 person's die in state nsw wonen	, en een income in (55,65] hebben	,

/ we kunnen ook	,
> aggregate(rep(1,30),list(incomef,statef),sum)
   Group.1 Group.2 x
1  (35,45]     act 1
2  (45,55]     act 1
3  (35,45]     nsw 1
4  (45,55]     nsw 1
5  (55,65]     nsw 3
6  (65,75]     nsw 1
7  (45,55]      nt 1
8  (55,65]      nt 1
9  (35,45]     qld 1
10 (45,55]     qld 1
11 (55,65]     qld 3
12 (45,55]      sa 2
13 (55,65]      sa 2
14 (55,65]     tas 2
15 (35,45]     vic 1
16 (45,55]     vic 1
17 (55,65]     vic 2
18 (65,75]     vic 1
19 (45,55]      wa 3
20 (55,65]      wa 1


/ Einde Intermezzo

> data.frame(home=state,loot=incomes,shot=incomef)
> data.frame(home=statef,loot=incomes,shot=incomef)

   home loot    shot
1   tas   60 (55,65]
2    sa   49 (45,55]
3   qld   40 (35,45]
4   nsw   61 (55,65]
5   nsw   64 (55,65]
6    nt   60 (55,65]
7    wa   59 (55,65]
8    wa   54 (45,55]
9   qld   62 (55,65]
10  vic   69 (65,75]
11  nsw   70 (65,75]
12  vic   42 (35,45]
13  qld   56 (55,65]
14  qld   61 (55,65]
15   sa   61 (55,65]
16  tas   61 (55,65]
17   sa   58 (55,65]
18   nt   51 (45,55]
19   wa   48 (45,55]
20  vic   65 (55,65]
21  qld   49 (45,55]
22  nsw   49 (45,55]
23  nsw   41 (35,45]
24   wa   48 (45,55]
25   sa   52 (45,55]
26  act   46 (45,55]
27  nsw   59 (55,65]
28  vic   46 (45,55]
29  vic   58 (55,65]
30  act   43 (35,45]


/ Tussen incomes en incomef is een verschil: incomef= categories van intervallen	, bij statef=categories van states	, dus state=statef	, daarom is WH table(state)=table(statef)	, table(incomes) != table(incomef)

> table (incomes)
incomes
40 41 42 43 46 48 49 51 52 54 56 58 59 60 61 62 64 65 69 70 
 1  1  1  1  2  2  3  1  1  1  1  2  2  2  4  1  1  1  1  1 
> table (incomef)
incomef
 (35,45]  (45,55]  (55,65]  (65,75]  (75,85]  (85,95] (95,105] 
       4       10       14        2        0        0        0 

/ 13	. 

> accountants=data.frame(home=statef,loot=incomes,shot=incomef)

> accountants$loot
 [1] 60 49 40 61 64 60 59 54 62 69 70 42 56 61 61 61 58 51 48 65 49 49 41 48 52
[26] 46 59 46 58 43

/ we willen niet steeds de list of data.frame geven	,
> attach(accountants)
> home
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa  tas sa  nt  wa 
[20] vic qld nsw nsw wa  sa  act nsw vic vic act
Levels: act nsw nt qld sa tas vic wa

/ Intermezzo

/ attach levert global vars	,

> ls=list(f=c(1,2,3),s=c(3,2,1))
> ls$f
[1] 1 2 3
> ls$s
[1] 3 2 1
> attach(ls)
The following object is masked _by_ .GlobalEnv:

    f

> f
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa  tas sa  nt  wa 
[20] vic qld nsw nsw wa  sa  act nsw vic vic act
Levels: act nsw nt qld sa tas vic wa
> s
[1] 3 2 1
> detach(ls)
> s
Error: object 's' not found
> f
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa  tas sa  nt  wa 
[20] vic qld nsw nsw wa  sa  act nsw vic vic act
Levels: act nsw nt qld sa tas vic wa

/ Einde Intermezzo

/ 7	. 

> df=data.frame(n=1:10,s=rep(c('c','d'),5))
> str(df)
'data.frame':	10 obs. of  2 variables:
 $ n: int  1 2 3 4 5 6 7 8 9 10
 $ s: Factor w/ 2 levels "c","d": 1 2 1 2 1 2 1 2 1 2
> df
    n s
1   1 c
2   2 d
3   3 c
4   4 d
5   5 c
6   6 d
7   7 c
8   8 d
9   9 c
10 10 d
> aggregate(df$n,list(df$s),sum)
  Group.1  x
1       c 25
2       d 30

/ we zien dat een char column automatisch een factor is	,
/ maar voor aggregate hoeft dat niet per se	,

> df=data.frame(n=rep(c(1,2),5),s=rep(c('c','d'),5))
/=
> df=data.frame(n=rep(1:2,5),s=c('c','d'))
/ we hoeven maar van 1 de aantallen op te geven, de andere wordt aangepast	,
> df
   n s
1  1 c
2  2 d
3  1 c
4  2 d
5  1 c
6  2 d
7  1 c
8  2 d
9  1 c
10 2 d
> str(df)
'data.frame':	10 obs. of  2 variables:
 $ n: num  1 2 1 2 1 2 1 2 1 2
 $ s: Factor w/ 2 levels "c","d": 1 2 1 2 1 2 1 2 1 2
> aggregate(df$s,list(df$n),length)
  Group.1 x
1       1 5
2       2 5

/ 7	. 

/ data.frame

/ DATA.FRAME LIST

/ een data.frame is een list	, van columns	,
/ als je een matrix geeft	, worden daar columns van create	, 
/ een char column wordt een factor	, voor aggregate maakt dat niet uit, en voor tapply ook niet	,
> df[2,]	/ pak een row	, alsof het een row is in een table	,

> m=matrix(1:4,2,2)
> m
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> data.frame(m,1:4)
  X1 X2 X1.4
1  1  3    1
2  2  4    2
3  1  3    3
4  2  4    4
> data.frame(m,1:2)
  X1 X2 X1.2
1  1  3    1
2  2  4    2
> data.frame(m,1:3)
Error in data.frame(m, 1:3) : 
  arguments imply differing number of rows: 2, 3

> df=data.frame(n=rep(1,10),s=c('c','d'))
> str(df)
'data.frame':	10 obs. of  2 variables:
 $ n: num  1 1 1 1 1 1 1 1 1 1
 $ s: Factor w/ 2 levels "c","d": 1 2 1 2 1 2 1 2 1 2
> tapply(df$n,df$s,sum)
 c  d 
 5 10 
/ Dat kan, omdat df$s een factor is	,

/ 137	,

> df=data.frame(n=rep(1,12),s=c('c','d'),t=c('x','y','z'))
> df
   n s t
1  1 c x
2  1 d y
3  1 c z
4  1 d x
5  1 c y
6  1 d z
7  1 c x
8  1 d y
9  1 c z
10 1 d x
11 1 c y
12 1 d z
> tapply(df$n,list(df$s,df$t),sum)
  x y z
c 2 2 2
d 2 2 2

/ 137	.

> df=data.frame(n=rep(1,12),s=c('c','d'),t=c('x','y','z'),u=c('k','l','m','n'))
> df
   n s t u
1  1 c x k
2  1 d y l
3  1 c z m
4  1 d x n
5  1 c y k
6  1 d z l
7  1 c x m
8  1 d y n
9  1 c z k
10 1 d x l
11 1 c y m
12 1 d z n
> tapply(df$n,list(df$s,df$t,df$u),sum)
, , k

   x  y  z
c  1  1  1
d NA NA NA

, , l

   x  y  z
c NA NA NA
d  1  1  1

, , m

   x  y  z
c  1  1  1
d NA NA NA

, , n

   x  y  z
c NA NA NA
d  1  1  1

/ sommige combinaties komen niet voor	,

/ 13	. 

/ list, data.frame

/ Lees	, 
http://stackoverflow.com/questions/15901224/what-is-difference-between-dataframe-and-list-in-r

/ 137	.

> df=data.frame(n=rep(1,12),s=c('c','d'))
> ls=list(n=rep(1,12),s=c('c','d'))
> df
   n s
1  1 c
2  1 d
3  1 c
4  1 d
5  1 c
6  1 d
7  1 c
8  1 d
9  1 c
10 1 d
11 1 c
12 1 d
> ls
$n
 [1] 1 1 1 1 1 1 1 1 1 1 1 1

$s
[1] "c" "d"

> str(df)
'data.frame':	12 obs. of  2 variables:
 $ n: num  1 1 1 1 1 1 1 1 1 1 ...
 $ s: Factor w/ 2 levels "c","d": 1 2 1 2 1 2 1 2 1 2 ...

/ dus 2 vectors	,

/ 137	. 

/ Zo pak je een row in een data.frame	,
> df[2,]
  n s
2 1 d



/ we zien dat van een list de columns niet automatisch even lang gemaakt worden	, een data.frame doet dat wel	, daarom kun je een data.frame als een sql table	, met rows	,
/ een data frame is een list van vectors	,



/ 137	 .

> tapply(df$n,df$s,sum)
c d 
6 6 

> ls=list(n=rep(1,12),s=rep(c('c','d'),6))
> ls
$n
 [1] 1 1 1 1 1 1 1 1 1 1 1 1

$s
 [1] "c" "d" "c" "d" "c" "d" "c" "d" "c" "d" "c" "d"

/ we zien het verschil	, met de factor 	, maar toch maakt het voor tapply niet uit	,
> str(df)
'data.frame':	12 obs. of  2 variables:
 $ n: num  1 1 1 1 1 1 1 1 1 1 ...
 $ s: Factor w/ 2 levels "c","d": 1 2 1 2 1 2 1 2 1 2 ...
> str(ls)
List of 2
 $ n: num [1:12] 1 1 1 1 1 1 1 1 1 1 ...
 $ s: chr [1:12] "c" "d" "c" "d" ...


> tapply(ls$n,ls$s,sum)
c d 
6 6 
/ Dit werkt dus toch!. tapply maakt van de 2de arg een factor, of een list van factors, nu een list van 1 lang	,

> ?tapply
/ tapply uses as.factor	,

> ls$s
 [1] "c" "d" "c" "d" "c" "d" "c" "d" "c" "d" "c" "d"
> as.factor(ls$s)
 [1] c d c d c d c d c d c d
Levels: c d

/ 137	.

> ls=list(n=rep(1,12),s=rep(c('c','d'),6),t=rep(1:3,4))
> ls
$n
 [1] 1 1 1 1 1 1 1 1 1 1 1 1

$s
 [1] "c" "d" "c" "d" "c" "d" "c" "d" "c" "d" "c" "d"

$t
 [1] 1 2 3 1 2 3 1 2 3 1 2 3

> tapply(ls$n,list(ls$s,ls$t),sum)
  1 2 3
c 2 2 2
d 2 2 2




/ 13	. 

/ ragged array	, 

/ lees	,
http://www.r-bloggers.com/efficient-ragged-arrays-in-r-and-rcpp/

> tapply(incomes,statef,mean)
     act      nsw       nt      qld       sa      tas      vic       wa 
44.50000 57.33333 55.50000 53.60000 55.00000 60.50000 56.00000 52.25000 
> str(tapply(incomes,statef,mean))
 num [1:8(1d)] 44.5 57.3 55.5 53.6 55 ...
 - attr(*, "dimnames")=List of 1
  ..$ : chr [1:8] "act" "nsw" "nt" "qld" ...

/ Dit zou een ragged array moeten zijn	,







/ 7	. 

/ files	,
/ TODO

/ Intermezzo

/ Scripts	,

> q()
Save workspace image? [y/n/c]: y

[eric@almond Manual]$ pwd
/home/eric/Devel/R/Manual
[eric@almond Manual]$ ls -lal
total 56
-rw-rw-r--. 1 eric eric    40 May  3 08:46 1.R
-rw-rw-r--. 1 eric eric  9505 May  3 08:47 .RData
-rw-------. 1 eric eric 10307 May  3 08:47 .Rhistory

[eric@almond Manual]$ cat 1.R
x=data.frame(n=1:4,s=c('k','l'))
str(x)

[eric@almond Manual]$ R
> source("1.R")
'data.frame':	4 obs. of  2 variables:
 $ n: int  1 2 3 4
 $ s: Factor w/ 2 levels "k","l": 1 2 1 2


/ Einde Intermezzo

/ 8	. 

/ 13	. 

> x=dbinom(0:4,4,0.5)
> x
[1] 0.0625 0.2500 0.3750 0.2500 0.0625
> str(x)
 num [1:5] 0.0625 0.25 0.375 0.25 0.0625
> barplot(x,names.arg=0:4)
/ we zien de values 0,1,2,3,4
/ OK

/ 13	. 

/ Lees	,
http://www.cyclismo.org/tutorial/R/probability.html

/ Later	,
https://www.datacamp.com/courses/free-introduction-to-r

> plot(x)
/ we zien horizontaal de indexes 1,2,3,4,5
/ Hoe de values 0,1,2,3,4	?

> x=0:4
> b=dbinom(x,4,.5)
> plot(x,b)
/ OK

/ 13	. 

> x=-10:10
> n=dnorm(x)
> plot(x,n)
/ OK

/ 13	. 

> x=0:20
> c=dchisq(x,df=5)
> plot(x,c)
/ OK

> pchisq(1.213,3)
[1] 0.2501119
/ See chi squared table, Vol2 (44)	, P <=1.213 bij 3 vrijheidsgraden  =25%	,

> x=0:15
> c=pchisq(x,3)
> plot(x,c)
/ OK	, we zien cumulative grafiek	,

/ 13	. 

> pchisq(5,3,lower.tail=T)
[1] 0.8282029
/= F(5)
> pchisq(5,3,lower.tail=F)
[1] 0.1717971
/= 1-F(5)
> pchisq(5,3,lower.tail=F,log=T)
[1] -1.761441
/= log(1-F(5))

/ 13	. 

returns the inverse cumulative density function (quantiles)

> pnorm(1)
[1] 0.8413447
> qnorm(pnorm(1))
[1] 1

/ 13	. 

/ Lees	, 
http://www.cyclismo.org/tutorial/R/hwI.html?highlight=qqnorm

/ 1ste quartile , 3th quartile != quantiles !

/ 1st quartile= mean of min and median	,
/ 3rd quartile= mean of median and max	,

> x=1:20
> summary(x)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   1.00    5.75   10.50   10.50   15.25   20.00 
> qqnorm(x)
/ TODO

> x=0:20
> summary(x)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      0       5      10      10      15      20 
> qqnorm(x)
/ TODO

/ 9	.

/ 13	. 

> ?split

> g=factor(round(runif(10)))	/ random uniform divided	,
> summary(g)
0 1 
3 7 
 x=rnorm(10)
> x
 [1]  0.2874633275  0.3562805524 -1.9861547703 -0.1014468822 -0.0001479631
 [6] -0.2873537532 -1.1192699659 -0.5867292546  1.5350413892 -0.0368738786
> xg=split(x,g)
> xg
$`0`
[1] -0.1014469 -1.1192700  1.5350414

$`1`
[1]  0.2874633275  0.3562805524 -1.9861547703 -0.0001479631 -0.2873537532
[6] -0.5867292546 -0.0368738786

> boxplot(xg)
/ we zien quartiles	, 
/ Hoe command om quartiles te zien	? Want summary werkt NIET	,
/ TODO

/ 13	. 

$ vi 2.R

g=factor(round(runif(10)))
g
x=rnorm(10)
y=rnorm(10)
xg=split(x,g)
yg=split(y,g)
for(i in 1:length(yg)){
  plot(xg[[i]],yg[[i]])
}

> source('2.R')
/ OK
/ Maar we zien alleen de 2de plot	, de 1ste is weg	,

>  g
 [1] 0 0 1 0 1 1 1 0 0 0
Levels: 0 1

> xg
$`0`
[1]  2.1650539  0.9336595 -0.7322333  0.7624530 -0.3528790  0.6175350

$`1`
[1]  0.5925554  0.7347969  1.0182917 -0.3200606

> yg
$`0`
[1]  0.3997652  0.5227433  0.2696960  1.7759105  1.8898390 -0.2782191

$`1`
[1]  0.48333616 -1.43926086  1.28386650  0.09930895

> xg[[1]]
[1]  2.1650539  0.9336595 -0.7322333  0.7624530 -0.3528790  0.6175350
> yg[[1]]
[1]  0.3997652  0.5227433  0.2696960  1.7759105  1.8898390 -0.2782191
> plot(xg[[1]],yg[[1]])
/ OK, we zien 7 punten	,
> plot(xg[[2]],yg[[2]])
/ OK, we zien 3 punten	,

/ 13	. 

/ we doen zelf	,

 x=round(9*runif(9));x
[1] 7 8 4 7 3 1 6 0 1
> y=round(9*runif(9));y
[1] 5 9 9 3 4 3 7 3 8
> z=c();for(i in 1:length(x)){z[i]=x[i]+y[i]};z
[1] 12 17 13 10  7  4 13  3  9

/ WH beter	,
/ 20 integer van 0,..,9	,
> ceiling(runif(20,-1,9))
/ TODO


/ Makkelijker	,
> z=x+y
> z
[1] 12 17 13 10  7  4 13  3  9

/ 10	. 


/ 13	. 
















































/ Einde R MANUAL


/ R IMPORT EXPORT

/ Lees	,
https://cran.r-project.org/doc/manuals/r-release/R-data.html#Imports

/ imports: scan
/ exports: cat

> df=data.frame(a="s \" quote")
> df
          a
1 s " quote
> write.table(df)
"a"
"1" "s \" quote"
> write.table(df,qmethod='double')
"a"
"1" "s "" quote"
> write.table(df,quote=F)
a
1 s " quote
> write.table(df,quote=F,sep=',')
a
1,s " quote

> write.table(df,file="/tmp/r.txt")
/ OK
> write.table(df,quote=F,sep=',',file="/tmp/r.txt")
/ OK
> read.table("/tmp/r.txt")
[1] V1 V2 V3
<0 rows> (or 0-length row.names)
Warning message:
In read.table("/tmp/r.txt") :
  incomplete final line found by readTableHeader on '/tmp/r.txt'


/ Maar	, 
> df=data.frame(a="s \" quote")
> df
          a
1 s " quote
> write.table(df,file='/tmp/r.txt')
> read.table(file='/tmp/r.txt')
          a
1 s " quote
/ OK

/ MORGENOCHTEND


/ 13	. 

> df=data.frame(n=1:4,s=c('k','l'))
> df
  n s
1 1 k
2 2 l
3 3 k
4 4 l
> write.table(df)
"n" "s"
"1" 1 "k"
"2" 2 "l"
"3" 3 "k"
"4" 4 "l"
> write.table(df,file='/tmp/r.txt')
> read.table(file='/tmp/r.txt')
  n s
1 1 k
2 2 l
3 3 k
4 4 l
/ OK








/ Einde R IMPORT EXPORT

/ R FACTOR 

/ 7	. 

/ factors

/ Lees http://www.stat.berkeley.edu/~s133/factors.html

/ 13	. 

> data = c(3,2,2,3,1,2,3,3,1,2,3,3,1)

> table(data)
data
1 2 3 
3 4 6 
> table(factor(data))

1 2 3 
3 4 6 

>   summary(data)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   2.000   2.000   2.231   3.000   3.000 
>   summary(factor(data))
1 2 3 
3 4 6 

> table(factor(data,levels=c(3,2,1)))

3 2 1 
6 4 3 

/ 13	.  

> fert = c(10,20,20,50,10,20,10,50,20)
> factor(fert)
[1] 10 20 20 50 10 20 10 50 20
Levels: 10 20 50
> fertf = factor(fert,levels=c(10,20,50),ordered=TRUE)
> fertf
[1] 10 20 20 50 10 20 10 50 20
Levels: 10 < 20 < 50

> mean(fert)
[1] 23.33333
> mean(fertf)
[1] NA
Warning message:
In mean.default(fertf) : argument is not numeric or logical: returning NA
> levels(fert)
NULL
> levels(fertf)
[1] "10" "20" "50"
> levels(fertf)[fertf]
[1] "10" "20" "20" "50" "10" "20" "10" "50" "20"
> as.numeric(levels(fertf)[fertf])
[1] 10 20 20 50 10 20 10 50 20
> mean(as.numeric(levels(fertf)[fertf]))
[1] 23.33333


/ 7	. 

/ Lees	,
http://www.r-bloggers.com/data-types-part-3-factors/
/=
http://rforpublichealth.blogspot.nl/2012/11/data-types-part-3-factors.html

> ls=list(Age=c(26,56,15,7,13),Race=factor(c("white","white","black","red","red")))

> ls$A
[1] 26 56 15  7 13
> ls$R
[1] white white black red   red  
Levels: black red white

> str(ls)
Age :  num [1:5] 26 56 15 7 13
Race :  Factor w/ 3 levels "black","red",..: 3 3 1 2 2

> str(ls$R)
 Factor w/ 3 levels "black","red",..: 3 3 1 2 2

/ black,red,white zijn coded als 1,2,3 (de volgorder voor de : )	, en ze komen voor als 3,3,1,2,2


/ we kunnen	,
> class(ls$R)
[1] "factor"


> levels(ls$R)
[1] "black" "red"   "white"

> summary(ls$R)
black   red white 
    1     2     2 

> table(ls$R)
black   red white 
    1     2     2 
/ TODO (Verschil)

> plot(ls$A~ls$R)
/ we zien het gemiddelde per category	, dus white: 41, black: 15, red:10

/ 13	. 

> cu= cut(ls$A,c(0,15,30,45,60))
> table(cu)
cu
 (0,15] (15,30] (30,45] (45,60] 
      3       1       0       1 
> summary(cu)
 (0,15] (15,30] (30,45] (45,60] 
      3       1       0       1 
/ TODO(Verschil)

/ we zien dat er maar 3 voorkomen	, 
/ ordered wil dan ook 3 labels	, 4 mag niet	, 
/ TODO

> ord=ordered(cu,labels=c("Low","Medium","large"))
> class(ord)
[1] "ordered" "factor" 
> class(ls$R)
[1] "factor"
> factor(ord)
[1] Medium large  Low    Low    Low   
Levels: Low < Medium < large
> table(ord)
ord
   Low Medium  large 
     3      1      1 







/ Einde R FACTOR 


/ R HELP


/ 7. 	

/ data.frame

     L3 <- LETTERS[1:3]
     fac <- sample(L3, 10, replace = TRUE)
     (d <- data.frame(x = 1, y = 1:10, fac = fac))
     ## The "same" with automatic column names:
     data.frame(1, 1:10, sample(L3, 10, replace = TRUE))

> L3<-LETTERS[1:3]
> L3
[1] "A" "B" "C"
> l3<-letters[1:3]
> l3
[1] "a" "b" "c"

> fac <- sample(L3, 10, replace = TRUE)
> fac
 [1] "B" "C" "C" "B" "C" "A" "C" "A" "B" "A"

> d <- data.frame(x = 1, y = 1:10, fac = fac)
> d
   x  y fac
1  1  1   B
2  1  2   C
3  1  3   C
4  1  4   B
5  1  5   C
6  1  6   A
7  1  7   C
8  1  8   A
9  1  9   B
10 1 10   A






/ Einde R HELP

/ R MISC 

/ Lees	,
http://www.r-bloggers.com/r-function-of-the-day-cut/

/ 13	. 

clinical.trial <-
    data.frame(patient = 1:100,              
               age = rnorm(100, mean = 60, sd = 8),
               year.enroll = sample(paste("19", 85:99, sep = ""),
                 100, replace = TRUE))

> clinical.trial
    patient      age year.enroll
1         1 43.90477        1990
2         2 66.98966        1985
3         3 71.76872        1988
4         4 50.92663        1998
5         5 56.57855        1993
6         6 68.60302        1995
7         7 49.72726        1993
...
97       97 61.32829        1989
98       98 74.81523        1996
99       99 54.44971        1995
100     100 57.59869        1985

/ cut toont van elk van de 100 in welk interval ze liggen	, en onderin levels = de intervals	,
/ met table zien we de levels en de aantal die in die intervals liggen	,

/ 13	. 

> cut(clinical.trial$age, breaks = 4)
  [1] (38.3,47.6] (66.2,75.5] (66.2,75.5] (47.6,56.9] (47.6,56.9] (66.2,75.5]
  [7] (47.6,56.9] (56.9,66.2] (66.2,75.5] (56.9,66.2] (56.9,66.2] (56.9,66.2]
 [13] (47.6,56.9] (47.6,56.9] (66.2,75.5] (47.6,56.9] (47.6,56.9] (47.6,56.9]
 [19] (56.9,66.2] (66.2,75.5] (56.9,66.2] (56.9,66.2] (66.2,75.5] (47.6,56.9]
 [25] (47.6,56.9] (56.9,66.2] (56.9,66.2] (56.9,66.2] (47.6,56.9] (66.2,75.5]
 [31] (66.2,75.5] (56.9,66.2] (47.6,56.9] (56.9,66.2] (38.3,47.6] (56.9,66.2]
 [37] (47.6,56.9] (47.6,56.9] (56.9,66.2] (66.2,75.5] (56.9,66.2] (56.9,66.2]
 [43] (47.6,56.9] (56.9,66.2] (56.9,66.2] (47.6,56.9] (66.2,75.5] (56.9,66.2]
 [49] (47.6,56.9] (56.9,66.2] (66.2,75.5] (47.6,56.9] (56.9,66.2] (56.9,66.2]
 [55] (38.3,47.6] (47.6,56.9] (47.6,56.9] (47.6,56.9] (47.6,56.9] (66.2,75.5]
 [61] (56.9,66.2] (56.9,66.2] (66.2,75.5] (47.6,56.9] (38.3,47.6] (56.9,66.2]
 [67] (47.6,56.9] (47.6,56.9] (38.3,47.6] (38.3,47.6] (47.6,56.9] (56.9,66.2]
 [73] (47.6,56.9] (56.9,66.2] (47.6,56.9] (66.2,75.5] (56.9,66.2] (38.3,47.6]
 [79] (66.2,75.5] (56.9,66.2] (56.9,66.2] (47.6,56.9] (38.3,47.6] (47.6,56.9]
 [85] (56.9,66.2] (66.2,75.5] (56.9,66.2] (56.9,66.2] (47.6,56.9] (56.9,66.2]
 [91] (56.9,66.2] (56.9,66.2] (47.6,56.9] (66.2,75.5] (66.2,75.5] (47.6,56.9]
 [97] (56.9,66.2] (66.2,75.5] (47.6,56.9] (56.9,66.2]
Levels: (38.3,47.6] (47.6,56.9] (56.9,66.2] (66.2,75.5]
> table(cut(clinical.trial$age, breaks = 4))

(38.3,47.6] (47.6,56.9] (56.9,66.2] (66.2,75.5] 
          8          34          38          20 

/ 13	. 

> cut(clinical.trial$age, breaks = 8)
  [1] (43,47.6]   (66.2,70.9] (70.9,75.5] (47.6,52.3] (52.3,56.9] (66.2,70.9]
  [7] (47.6,52.3] (61.6,66.2] (70.9,75.5] (56.9,61.6] (56.9,61.6] (61.6,66.2]
 [13] (52.3,56.9] (52.3,56.9] (70.9,75.5] (52.3,56.9] (52.3,56.9] (47.6,52.3]
 [19] (61.6,66.2] (66.2,70.9] (56.9,61.6] (61.6,66.2] (66.2,70.9] (47.6,52.3]
 [25] (52.3,56.9] (61.6,66.2] (61.6,66.2] (56.9,61.6] (52.3,56.9] (70.9,75.5]
 [31] (70.9,75.5] (61.6,66.2] (47.6,52.3] (56.9,61.6] (43,47.6]   (56.9,61.6]
 [37] (52.3,56.9] (52.3,56.9] (56.9,61.6] (66.2,70.9] (61.6,66.2] (56.9,61.6]
 [43] (47.6,52.3] (61.6,66.2] (56.9,61.6] (52.3,56.9] (66.2,70.9] (56.9,61.6]
 [49] (47.6,52.3] (56.9,61.6] (66.2,70.9] (52.3,56.9] (56.9,61.6] (61.6,66.2]
 [55] (43,47.6]   (52.3,56.9] (47.6,52.3] (52.3,56.9] (47.6,52.3] (70.9,75.5]
 [61] (56.9,61.6] (56.9,61.6] (66.2,70.9] (52.3,56.9] (43,47.6]   (56.9,61.6]
 [67] (52.3,56.9] (52.3,56.9] (43,47.6]   (43,47.6]   (47.6,52.3] (56.9,61.6]
 [73] (52.3,56.9] (61.6,66.2] (52.3,56.9] (66.2,70.9] (56.9,61.6] (43,47.6]  
 [79] (66.2,70.9] (61.6,66.2] (56.9,61.6] (47.6,52.3] (38.3,43]   (52.3,56.9]
 [85] (61.6,66.2] (66.2,70.9] (56.9,61.6] (56.9,61.6] (47.6,52.3] (61.6,66.2]
 [91] (61.6,66.2] (56.9,61.6] (52.3,56.9] (66.2,70.9] (66.2,70.9] (52.3,56.9]
 [97] (56.9,61.6] (70.9,75.5] (52.3,56.9] (56.9,61.6]
8 Levels: (38.3,43] (43,47.6] (47.6,52.3] (52.3,56.9] ... (70.9,75.5]
> table(cut(clinical.trial$age, breaks = 8))

  (38.3,43]   (43,47.6] (47.6,52.3] (52.3,56.9] (56.9,61.6] (61.6,66.2] 
          1           7          12          22          23          15 
(66.2,70.9] (70.9,75.5] 
         13           7 

/ 13	. 

> c2 <- cut(as.numeric(as.character(clinical.trial$year.enroll)),
+             breaks = 3)
> c2
  [1] (1990,1994] (1985,1990] (1985,1990] (1994,1999] (1990,1994] (1994,1999]
  [7] (1990,1994] (1985,1990] (1994,1999] (1994,1999] (1990,1994] (1985,1990]
 [13] (1985,1990] (1985,1990] (1990,1994] (1994,1999] (1990,1994] (1985,1990]
 [19] (1994,1999] (1985,1990] (1990,1994] (1990,1994] (1985,1990] (1990,1994]
 [25] (1994,1999] (1990,1994] (1985,1990] (1994,1999] (1990,1994] (1990,1994]
 [31] (1985,1990] (1985,1990] (1985,1990] (1985,1990] (1985,1990] (1994,1999]
 [37] (1985,1990] (1990,1994] (1985,1990] (1985,1990] (1990,1994] (1994,1999]
 [43] (1990,1994] (1985,1990] (1994,1999] (1985,1990] (1985,1990] (1985,1990]
 [49] (1985,1990] (1994,1999] (1985,1990] (1994,1999] (1990,1994] (1994,1999]
 [55] (1994,1999] (1994,1999] (1990,1994] (1994,1999] (1985,1990] (1985,1990]
 [61] (1994,1999] (1990,1994] (1985,1990] (1994,1999] (1990,1994] (1985,1990]
 [67] (1985,1990] (1985,1990] (1990,1994] (1985,1990] (1985,1990] (1990,1994]
 [73] (1990,1994] (1990,1994] (1985,1990] (1994,1999] (1994,1999] (1985,1990]
 [79] (1985,1990] (1990,1994] (1994,1999] (1985,1990] (1994,1999] (1990,1994]
 [85] (1990,1994] (1994,1999] (1994,1999] (1994,1999] (1985,1990] (1994,1999]
 [91] (1990,1994] (1994,1999] (1990,1994] (1985,1990] (1990,1994] (1994,1999]
 [97] (1985,1990] (1994,1999] (1994,1999] (1985,1990]
Levels: (1985,1990] (1990,1994] (1994,1999]
> table(c2)
c2
(1985,1990] (1990,1994] (1994,1999] 
         40          29          31 

/ 13	. 

> seq(30, 80, by = 10)
[1] 30 40 50 60 70 80

c1 <- cut(clinical.trial$age, breaks = seq(30, 80, by = 10))
> c1
  [1] (40,50] (60,70] (70,80] (50,60] (50,60] (60,70] (40,50] (60,70] (70,80]
 [10] (60,70] (60,70] (60,70] (50,60] (50,60] (70,80] (50,60] (50,60] (50,60]
 [19] (60,70] (70,80] (50,60] (60,70] (60,70] (50,60] (50,60] (60,70] (60,70]
 [28] (50,60] (50,60] (70,80] (70,80] (60,70] (50,60] (50,60] (40,50] (50,60]
 [37] (50,60] (50,60] (50,60] (60,70] (60,70] (60,70] (50,60] (60,70] (60,70]
 [46] (50,60] (60,70] (50,60] (50,60] (60,70] (60,70] (50,60] (50,60] (60,70]
 [55] (40,50] (50,60] (40,50] (50,60] (40,50] (70,80] (60,70] (50,60] (60,70]
 [64] (50,60] (40,50] (50,60] (50,60] (50,60] (40,50] (40,50] (50,60] (60,70]
 [73] (50,60] (60,70] (50,60] (60,70] (50,60] (40,50] (60,70] (60,70] (50,60]
 [82] (40,50] (30,40] (50,60] (60,70] (60,70] (50,60] (50,60] (50,60] (60,70]
 [91] (60,70] (60,70] (50,60] (60,70] (60,70] (50,60] (60,70] (70,80] (50,60]
[100] (50,60]
Levels: (30,40] (40,50] (50,60] (60,70] (70,80]

> table(c1)
c1
(30,40] (40,50] (50,60] (60,70] (70,80] 
      1      11      44      36       8 

/ 13	. 

> age.cat <- function(x, lower = 0, upper, by = 10, sep = "-", above.char = "+") {

 labels <- c(paste(seq(lower, upper - by, by = by), seq(lower + by - 1, upper - 1, by = by), sep = sep), paste(upper, above.char, sep = ""))

 cut(floor(x), breaks = c(seq(lower, upper, by = by), Inf), right = FALSE, labels = labels)
}

> table(age.cat(clinical.trial$age, upper = 70))

 0-9 10-19 20-29 30-39 40-49 50-59 60-69   70+ 
    0     0     0     1    11    44    36     8 







/ Einde R MISC

/ R BINOM 

/ 7	. 

/ dbinom(x,n,p)=p(X=x) als X~Bin(n,p)	, we kunnen ook een vector geven voor x	,

> dbinom(0:4,4,0.5)
[1] 0.0625 0.2500 0.3750 0.2500 0.0625
> dbinom(0:2,4,0.5)
[1] 0.0625 0.2500 0.3750

/ 0:4 en seq(0,4) is hetzelfde	,
> str(0:4)
 int [1:5] 0 1 2 3 4
> str(seq(0,4))
 int [1:5] 0 1 2 3 4
> str(seq(0,4,by=2))
 num [1:3] 0 2 4
> 0:4
[1] 0 1 2 3 4
> seq(0,4)
[1] 0 1 2 3 4

> pbinom(0:4,4,0.5)
[1] 0.0625 0.3125 0.6875 0.9375 1.0000

> plot(dbinom(0:4,4,0.5))
/ OK

> plot(dbinom(0,10,0.2))
/ TODO (0 staat in het midden bij 1.0)

> plot(dbinom(0:10,10,0.2))
/ we zien dat bin(4,1/2) sym is	, bin(10,1/5) is dat niet	, de top is aan de linkerkant	,

> plot(dbinom(0:10,10,0.8))
/ de bult is aan de rechterkant	,

/ we kunnen ook barplot	,

> x=dbinom(0:10,size=10,prob=1/5)
> barplot(x,names.arg=0:10)
/ OK

> plot(dunif(0:4,0,4))
> plot(dunif(0:100,0,100))
/ OK

/ Einde R BINOM

/ R PLOT

/ 7	 .

/ lees	,
http://stackoverflow.com/questions/8055508/the-tilde-operator-in-r

/ 7. 

/ Lees	,
http://www.statmethods.net/stats/regression.html

/ we hebben verband	, 
h=2*b+1	,

> reg=data.frame(b=c(0,1,2,3,4),h=c(1,3,5,7,9))
> reg
  b h
1 0 1
2 1 3
3 2 5
4 3 7
5 4 9

> with(reg,plot(b,h))
/=
> with(reg,plot(h~b))
/=
> plot(h~b,reg)
> title('foo bar')
/ OK

/ we hadden eerder	,
b=c(0,1,2,3,4)
h=c(1,3,5,7,9)
reg=data.frame(b,h)
/ Dan kunnen we	,
> plot(h~b)



/ 7	. 

> ls=list(Age=c(26,56,15,7,13),Race=factor(c("white","white","black","red","red")))
> summary(ls$R)
black   red white 
    1     2     2 
> plot(ls$A~ls$R)
/ we zien boxes	, met min en max, en mean	,
/ we zien black en daarboven 15	, 
/ we zien red, en daarboven de min en max values 7 en 13	, en het gemiddelde 10 ertussen in 	,
/ we zien white, en daarboven de min en max values 26 en 56	, en het gemiddelde 41 ertussen in 	,

/ Hoe barplot	? 
/ Heeft dat wel zin?
/ TODO

/ 7	. 

> d=dunif(0:100,0,100)
> d
  [1] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
 [16] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
 [31] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
 [46] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
 [61] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
 [76] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
 [91] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
> plot(d)
/ OK

> lst=1:100
> cu=cut(lst,seq(0,100,by=10))
> table(cu)
cu
  (0,10]  (10,20]  (20,30]  (30,40]  (40,50]  (50,60]  (60,70]  (70,80] 
      10       10       10       10       10       10       10       10 
 (80,90] (90,100] 
      10       10 
> plot(cu)
/ OK
/ We zien een barplot	?
/ TODO

> plot(lst~cu)
/ TODO (Wat betekent dit?)

/ Ook	,
> dcu=cut(d,seq(0,100,by=10))
> str(dcu)
 Factor w/ 10 levels "(0,10]","(10,20]",..: 1 1 1 1 1 1 1 1 1 1 ...
> summary(dcu)
  (0,10]  (10,20]  (20,30]  (30,40]  (40,50]  (50,60]  (60,70]  (70,80] 
     101        0        0        0        0        0        0        0 
 (80,90] (90,100] 
       0        0 


/ 7	. 

/ we wilden  de 10's in cu /100	, zodat 
  (0,10]  (10,20]  ... 
    0.10     0.10 ... 
/TODO

/ 7	 .

/ Lees	,
http://stackoverflow.com/questions/17759540/r-graph-of-binomial-distribution

graph <- function(n,p){
               x <- dbinom(0:n,size=n,prob=p)
               return(barplot(x,names.arg=0:n))
            }


   graph(20,0.1)
   graph(20,0.2)
   graph(20,0.3)
   graph(20,0.4)
   graph(20,0.5)
   graph(20,0.6)
   graph(20,0.7)
   graph(20,0.8)
   graph(20,0.9)

   #OR
   graph(20,scan())

graph <- function(n,p){
  x <- dbinom(0:n,size=n,prob=p)
  barplot(x,names.arg=0:n,
         main=sprintf(paste('bin. dist. ',n,p,sep=':')))
}
par(mfcol=c(2,5))
  mapply(graph,20,seq(0.1,1,0.1))

/ Einde R PLOT 

/ R AGGREGATE

/ 7	.

/ we hoeven aggregate alleen een list geven	, hij factors zelf eerst	, 

>?aggregate
    ## S3 method for class 'data.frame'
     aggregate(x, by, FUN, ..., simplify = TRUE)
Arguments:
       x: an R object.
      by: a list of grouping elements, each as long as the variables in
          the data frame ‘x’.  The elements are coerced to factors
          before use.

/ factor maakt groups	, lees manual par 4.2	,

/ een data.frame is een list van columns	,
> data.frame(c=1:2,d=2:3,e=4:5)
  c d e
1 1 2 4
2 2 3 5
> dim(data.frame(c=1:2,d=2:3,e=4:5))
[1] 2 3

/ 7	. 

> dim(c(1,2,3))
NULL
> dim(list(c(1,2,3)))
NULL
> dim(array(c(1,2,3)))
[1] 3
> dim(array(factor(c(1,2,3))))
[1] 3
> dim(list(factor(c(1,2,3))))
NULL

> dim(factor(c(1,2,3)))
NULL

> x=c(1,2)
> dim(x)
NULL
> class(x)
[1] "numeric"
> dim(x)=2
> dim(x)
[1] 2
> x
[1] 1 2
> class(x)
[1] "array"

> y=c(1,2,dim=2)
> y
        dim 
  1   2   2 
> class(y)
[1] "numeric"

> class(1:4)
[1] "integer"
> class (c(1,2,3,4))
[1] "numeric"





/ 7	. 

/ we wilden uitgaande van d 	, optellen per category, dus (0,10]: 0.1, ...

/ Lees	,
http://stackoverflow.com/questions/1660124/how-to-sum-a-variable-by-group

/ 13	. 

> vec=c("First", "First", "First", "Second","Third", "Third", "Second")
> freq=c(10,15,5,2,14,20,3)
> stov2=data.frame(Category=vec,Frequency=freq)
> stov2
  Category Frequency
1    First        10
2    First        15
3    First         5
4   Second         2
5    Third        14
6    Third        20
7   Second         3

> stov2$Category
[1] First  First  First  Second Third  Third  Second
Levels: First Second Third
> class(stov2$Category)
[1] "factor"

> aggregate(stov2$Frequency,list(stov2$Category),sum)
  Group.1  x
1   First 30
2  Second  5
3   Third 34

> aggregate(stov2$Frequency,list(vec),sum)
  Group.1  x
1   First 30
2  Second  5
3   Third 34

/ Dus we zien dat aggregate zelf ook een factor maakt	, hij groups	,

/ of zelfs	,
> aggregate(freq,list(vec),sum)
  Group.1  x
1   First 30
2  Second  5
3   Third 34

/ of	,

> aggregate(Frequency~Category,stov2,sum)
  Category Frequency
1    First        30
2   Second         5
3    Third        34

/ 13	. 

/ we hoeven geen data.frame te maken	, list is ook goed	,

> stov3=list(Category=vec,Frequency=freq)
> stov2
  Category Frequency
1    First        10
2    First        15
3    First         5
4   Second         2
5    Third        14
6    Third        20
7   Second         3
> stov3
$Category
[1] "First"  "First"  "First"  "Second" "Third"  "Third"  "Second"

$Frequency
[1] 10 15  5  2 14 20  3

> aggregate(Frequency~Category,stov3,sum)
  Category Frequency
1    First        30
2   Second         5
3    Third        34

> aggregate(stov3$Frequency,list(stov3$Category),sum)
  Group.1  x
1   First 30
2  Second  5
3   Third 34

> class(stov3$Category)
[1] "character"
/ Geen factor	, zoals bij data.frame	, maar dat hoeft ook niet	, aggregate maakt zelf een factor	, groups zelf	,

> list(stov3$Category)
[[1]]
[1] "First"  "First"  "First"  "Second" "Third"  "Third"  "Second"
/ een list met 1 elem	,

> as.list(stov3$Category)
[[1]]
[1] "First"

[[2]]
[1] "First"

[[3]]
[1] "First"

[[4]]
[1] "Second"

[[5]]
[1] "Third"

[[6]]
[1] "Third"

[[7]]
[1] "Second"
/ je maakt een list van een vector	,

/ 13	. 

/ AGGREGATE WITH 2 CATEGORIES

/ Lees	,
http://r.789695.n4.nabble.com/Basic-aggregate-help-td867127.html

/we kunnen ook aggregate op 2 factors	, we maken een list van 2 factors	,

> vec
[1] "First"  "First"  "First"  "Second" "Third"  "Third"  "Second"
> vec2=c(1,1,2,1,1,1,2)
> freq
[1] 10 15  5  2 14 20  3
> aggregate(stov5$Freqency,list(stov5$Category,stov5$Category2),sum)
  Group.1 Group.2  x
1   First       1 25
2  Second       1  2
3   Third       1 34
4   First       2  5
5  Second       2  3




/ 13	. 

> vec=rep(1,6)
> fact=factor(c(3,1,2,3,1,1))
> summary(fact)
1 2 3 
3 1 2 
> aggregate(vec,list(fact),sum)
/ of	,
> aggregate(vec,list(c(3,1,2,3,1,1)),sum)
  Group.1 x
1       1 3
2       2 1
3       3 2

> aggregate(vec,list(fact),mean)
/ of	,
> aggregate(vec,list(c(3,1,2,3,1,1)),mean)
  Group.1 x
1       1 1
2       2 1
3       3 1
> aggregate(vec,list(fact),prod)
/ of	,
> aggregate(vec,list(c(3,1,2,3,1,1)),prod)
  Group.1 x
1       1 1
2       2 1
3       3 1

/ Ander vb	, 
> vec=1:6 
> fact=factor(c(3,1,2,3,1,1))
> str(fact)
 Factor w/ 3 levels "1","2","3": 3 1 2 3 1 1

> aggregate(vec,list(fact),sum)
  Group.1  x
1       1 13
2       2  3
3       3  5

> aggregate(vec,list(fact),mean)
  Group.1        x
1       1 4.333333
2       2 3.000000
3       3 2.500000

> aggregate(vec,list(fact),prod)
  Group.1  x
1       1 60
2       2  3
3       3  4

/ 13	. 

/ Lees	,
http://stackoverflow.com/questions/11315087/how-to-aggregate-and-recover-original-columns-in-r-without-partial-duplicates

/ 13	. 

/ Lees	,
http://r.789695.n4.nabble.com/Basic-aggregate-help-td867127.html

/ In een data.frame x is x$Name een factor	, in een list y is y$Name een vector	,

> x=data.frame(Name=c("A","A","C"), Category=c("a","a","b"), Quantity=c(1,2,3))
> y=list(Name=c("A","A","C"), Category=c("a","a","b"), Quantity=c(1,2,3))
> x
  Name Category Quantity
1    A        a        1
2    A        a        2
3    C        b        3
> y
$Name
[1] "A" "A" "C"

$Category
[1] "a" "a" "b"

$Quantity
[1] 1 2 3

> x$Name
[1] A A C
Levels: A C
> y$Name
[1] "A" "A" "C"
> class(x$Name)
[1] "factor"
> classs(y$Name)
Error: could not find function "classs"
> class(y$Name)
[1] "character"


/ 13	.
/ Lees	,
http://r.789695.n4.nabble.com/Basic-aggregate-help-td867127.html

> x <- data.frame(Name=c("A","A","C"), Category=c("a","a","b"), Quantity=c(1,2,3)) 
> x
  Name Category Quantity
1    A        a        1
2    A        a        2
3    C        b        3
> names(x)
[1] "Name"     "Category" "Quantity"
> setdiff(names(x),"Quantity")
[1] "Name"     "Category"
> cls=class(setdiff(names(x),"Quantity"))
/=
> cls=c('Name","Category')
[1] "character"
> dim(cls)
NULL
> class(c('a','b'))
[1] "character"

 aggregate(x,list(cls),sum)
Error in aggregate.data.frame(x, list(cls), sum) : 
  arguments must have same length
> aggregate(x,list(x$Name,x$Category),sum)
Error in Summary.factor(c(1L, 1L), na.rm = FALSE) : 
  ‘sum’ not meaningful for factors
> aggregate(x$Quantity,list(x$Name,x$Category),sum)
  Group.1 Group.2 x
1       A       a 3
2       C       b 3
> list(cls)
[[1]]
[1] "Name"     "Category"

> x$Name
[1] A A C
Levels: A C
> class(x$Name)
[1] "factor"


> list(x$Name,x$Category)
[[1]]
[1] A A C
Levels: A C

[[2]]
[1] a a b
Levels: a b

> cls2=c('Name','Category')
> cls2
[1] "Name"     "Category"
> aggregate(x$Quantity,list(cls2),sum)
Error in aggregate.data.frame(as.data.frame(x), ...) : 
  arguments must have same length
> list(cls2)
[[1]]
[1] "Name"     "Category"

> aggregate(x$Quantity,list('Name','Category'),sum)
Error in aggregate.data.frame(as.data.frame(x), ...) : 
  arguments must have same length
> list('Name','Category')
[[1]]
[1] "Name"

[[2]]
[1] "Category"

/ Einde R AGGREGATE


/ FEDORA

/ 13	. 

/ Lees	,
https://www.reddit.com/r/linux4noobs/comments/38w4ic/is_there_a_difference_between_dnf_update_and_dnf/

As @meatygopher posted, dnf has deprecated the "update" option leaving "dnf upgrade" as the way to upgrade (update) packages. Distro upgrades are done with fedup and not yum or dnf.

/ 13	. 

$ sudo dnf upgrade --refresh
/ OK



/ Einde FEDORA




	


	



	


























/ 7	. 

/ Lees	, 
http://www.jklp.org/profession/books/mix/c06.html

/ Als we 
JMP SUB
/ dan wordt de return & in J stored	, en doet SUB zelf	,
STJ EXIT
/ omdat 
EXIT JMP *
/ wordt de return & op plaats * geschreven	, 
/ als SUB bij EXIT komt	, dan staat er dus 	,
JMP return &	, 

/ 7	 .

$ vi for8a.mixal

LIST EQU 0
M EQU 32
CONS EQU 19
 ORIG 1000
PRG LD1 0
2H ST1 LIST,1
 INC1 1
 CMP1 N
 JL 2B

 LD1 0
4H LDA LIST,1
 CHAR
 STX LIST,1
 INC1 1
 CMP1 N
 JL 4B
 OUT LIST(CONS)
 HLT
 ORIG LIST
 ORIG M
N CON 32
 END PRG

[eric@almond Manual]$ mixasm for8a.mixal ; mixvm -r  for8a
Program loaded. Start address: 1000
Running ...
0000000001000020000300004000050000600007000080000900010000110001200013
... done

/ Klopt	, 
/ Lees	,
http://www.gnu.org/software/mdk/manual/html_node/Devices.html
/ bij 19 is een regel 14 words	, 

/ See for8b waar we LIST en PLIST hebben	, PLIST is LIST na char	,

/ 7	. 

$ vi sub.mixal

 ORIG 1000
PRG JMP MAX
 JMP PR
 HLT

MSG ALF "hello"
 ALF "world"

MAX STJ EXIT
 OUT MSG(CONS)
EXIT JMP *

 END PRG

/ we zien	,

[eric@walnut Manual]$ mixvm -r sub
Program loaded. Start address: 1000
Running ...
HELLOWORLDN/ B2N) R7N,  9N< B2   R7N<  9                              
                                                                      
... done

/ wat we zien printed is wat achter ALF staat, dus MAX STJ ...

/ Oplossing:

/ schuif de code van MAX verder op	,

 ORIG 1000
PRG JMP MAX
 JMP PR
 HLT

MSG ALF "hello"
 ALF "world"

 ORIG 3000
MAX STJ EXIT
 OUT MSG(CONS)
EXIT JMP *

 END PRG

/ maar makkelijker	,

MSG ALF "hello"
 ALF "world"

 ORIG 1000
PRG JMP MAX
 JMP PR
 HLT

MAX STJ EXIT
 OUT MSG(CONS)
EXIT JMP *

PR STJ EXIT2
 OUT LIST(CONS)
EXIT2 JMP *

 END PRG

/ we zien	,
[eric@walnut Manual]$ mixvm -r sub
Program loaded. Start address: 1000
Running ...
HELLOWORLD                                                            
HELLOWORLD                                                            
... done

/ 7	. 

/ we moeten ORIG's van data niet tussen de code doen	, anders	,
(process:20761): libmix-CRITICAL **: mix_word_store_field: assertion `!is_bad_field_[f]' failed
/ TODO

$ vi  pr_with_sub.mixal

LIST EQU 0
M EQU 3
PLIST EQU 64
CONS EQU 19

 ORIG 1000
PRG LD1 0
2H CMP1 N
 JGE 4F
 ST1 LIST,1
 INC1 1
 JMP 2B

4H JMP MAX
 JMP PR
 HLT

MAX STJ EXIT
 LD1 0
6H CMP1 N
 JGE EXIT
 LDA LIST,1
 CHAR
 STX PLIST,1
 INC1 1
 JMP 6B
EXIT JMP *

PR STJ EXIT2
 OUT PLIST(CONS)
EXIT2 JMP *

 ORIG LIST
 ORIG M
N CON M
 ORIG PLIST

 END PRG

[eric@walnut Manual]$ mixvm -r  pr_with_sub 
Program loaded. Start address: 1000
Running ...
000000000100002                                                       
... done

/ we kunnen eenvoudiger	,

$ vi pr_with_sub.mixal	

LIST EQU 0
M EQU 3
PLIST EQU 64
CONS EQU 19

 ORIG M
N CON 3
 ORIG PLIST

 ORIG 1000
PRG LD1 0

/we kunnen ORIG LIST  weglaten	,

/ 7	.

/ for-loops	,

MAX STJ EXIT
 LD1 0
6H CMP1 N
 JGE EXIT
 LDA LIST,1

 INC1 1
 JMP 6B
EXIT JMP *

/ do-while loops	,
/ TODO

/ 7	. 

/ Er is een verschil tussen ENTA en ADD	, ADD werkt met &'s	, ENTA niet	, 

$ vi add.mixal

U EQU 32
 ORIG 1000
PRG LD1 =4=	 		/ I1=4
 LDA N				/ A=32
 ENTA 0,1			/ A=4
 ADD N				/ A=36
 INC1 1

 ORIG 0
N CON U

 END PRG

/ HIER HIER HIER

/ 7	. 

$ vi max2.mixal

 LDA N			/ A=32
 INCA 0,1		/ A=32+I1

/ OK	, 

/ Einde MIXAL









/ Einde MIXAL


/ ANDROID

/ Geef in gmail search	,
android
/ of	,
devfest
/ we zien Matthew Feigal	,


https://docs.google.com/presentation/d/11zUaraMhtgZitxL0Xi8NQedCVLXr0dv00mP46xVFbEQ/edit#slide=id.g1d4e015bb_551
https://github.com/GoogleCloudPlatform/endpoints-codelab-android


/ Einde ANDROID

/ OPEN IN FF

http://docs.spring.io/spring/docs/current/javadoc-api/
http://docs.spring.io/spring/docs/3.2.7.RELEASE/javadoc-api/index.html?overview-summary.html
http://docs.oracle.com/javase/8/docs/api/index.html
http://docs.spring.io/docs/Spring-MVC-step-by-step/index.html
http://localhost:8080/spring-mvc-step-by-step3/inventory.htm
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#mvc-ann-requestmapping
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#integration-testing-support-jdbc
https://dzone.com/articles/moving-springs-xml-annotations
https://www.mongodb.org/
http://docs.spring.io/spring-framework/docs/2.5.x/api/
https://www.youtube.com/watch?v=mbXPbLjiYTI					/ citus postgresql
https://docs.mongodb.org/manual/core/sharding-introduction/
http://www.postgres-xl.org/overview/
/ google search op AbstractTransactionalDataSourceSpringContextTests rollback
https://jdbc.postgresql.org/documentation/94/connect.html
http://spring.io/guides/gs/accessing-data-jpa/
https://www.youtube.com/watch?v=oG2rotiGr90			/ spring rest
https://www.youtube.com/watch?v=sbPSjI4tt10			/ spring boot
http://www.mkyong.com/webservices/jax-rs/json-example-with-jersey-jackson/
http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html
http://docs.spring.io/spring/docs/4.1.6.RELEASE/spring-framework-reference/htmlsingle/#spring-mvc-test-framework
http://spring.io/guides/gs/accessing-data-rest/
http://spring.io/guides/gs/accessing-data-jpa/
http://docs.spring.io/spring-boot/docs/current/api/
http://projects.spring.io/spring-framework/
http://spring.io/guides/gs/accessing-data-jpa/
http://www.petrikainulainen.net/spring-mvc-test-tutorial/
https://en.wikipedia.org/wiki/Chinese_remainder_theorem
http://camel.apache.org/maven/current/camel-core/apidocs/
http://camel.apache.org/jaxb.html
https://en.wikipedia.org/wiki/Finite_field
https://en.wikipedia.org/wiki/Gauss's_lemma_%28polynomial%29
https://www.openssl.org/docs/
https://www.openssl.org/docs/manmaster/apps/asn1parse.html
https://github.com/GoogleCloudPlatform/endpoints-codelab-android	 /TODO app
https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One
https://docs.gradle.org/current/userguide/tutorial_using_tasks.html
https://www.youtube.com/watch?v=MEAuFgsmND0								 /cockroach
https://aphyr.com/posts/299-the-trouble-with-timestamps
https://www.youtube.com/watch?v=XX-0y2Ryaic					/ postgresxl
https://en.wikipedia.org/wiki/Sylow_theorems
https://en.wikipedia.org/wiki/Simple_group
https://en.wikipedia.org/wiki/FLAGS_register
http://www.gnu.org/software/mdk/manual/html_node/MIX-architecture.html#MIX-architecture
http://www.jklp.org/profession/books/mix/c06.html
https://www.gnu.org/software/mdk/manual/html_node/Debugging.html#Debugging
http://www.gnu.org/software/mdk/manual/html_node/Devices.html
https://www.youtube.com/watch?v=ndKj77VW2eM		/ cockroach video
http://www.cockroachlabs.com/blog/
http://www.math.niu.edu/~beachy/abstract_algebra/guide/section/36soln.pdf

/ close ff, en open, History -> Open previous session

/ Einde OPEN IN FF

/ OPEN IN CHROME

http://docs.docker.com/examples/mongodb/
http://docs.mongodb.org/manual/security/
https://www.mongodb.com/presentations/mongodb-and-hadoop-driving-business-insights
https://docs.mongodb.org/manual/administration/install-on-linux/
http://docs.mongodb.org/manual/tutorial/install-mongodb-on-linux/
http://docs.mongodb.org/manual/tutorial/perform-two-phase-commits/
http://docs.mongodb.org/manual/reference/sql-comparison/
http://docs.mongodb.org/manual/core/sharding-introduction/



https://github.com/nginxinc/docker-nginx/blob/e35d3022416ca5221fcf958ed8aa6a55a5b043af/Dockerfile
https://hub.docker.com/r/sequenceiq/hadoop-docker/~/dockerfile/
https://github.com/docker-training/postgres
https://medium.com/@gargar454/deploy-a-mongodb-cluster-in-steps-9-using-docker-49205e231319
https://github.com/kubernetes/kubernetes/blob/master/docs/getting-started-guides/fedora/fedora_ansible_config.md
https://groups.google.com/forum/#!topic/docker-user/MR5zW0toJns
https://rhatdan.wordpress.com/2014/04/30/running-systemd-within-a-docker-container/
https://github.com/sequenceiq/hadoop-docker/blob/master/Dockerfile
https://www.youtube.com/watch?v=omTGY8LjVdA			/ video paas with kubernetes & docker
https://www.youtube.com/watch?v=OEflMTJUV4c#t=255		/ video JEE with Docker & kubernetes
http://developerblog.redhat.com/2014/05/05/running-systemd-within-docker-container/
http://blog.sequenceiq.com/blog/2014/12/02/hadoop-2-6-0-docker/
http://stackoverflow.com/questions/18496940/how-to-deal-with-persistent-storage-e-g-databases-in-docker
https://docs.docker.com/reference/builder/#copy
https://github.com/docker-library/mongo/blob/ea56087e928b5d734bf7661384ebf3c432d70f28/2.6/Dockerfile
https://docs.docker.com/userguide/usingdocker/
https://gist.github.com/Mulkave/10559775
https://docs.docker.com/examples/running_ssh_service/#clean-up
https://docs.docker.com/reference/builder/#copy
https://github.com/sequenceiq/hadoop-docker/blob/master/Dockerfile
http://developerblog.redhat.com/2014/05/05/running-systemd-within-docker-container/
https://github.com/kubernetes/kubernetes/blob/master/docs/getting-started-guides/fedora/fedora_manual_config.md
https://github.com/kubernetes/kubernetes/tree/master/docs
https://hub.docker.com/r/gelog/hadoop/
https://github.com/GELOG/docker-ubuntu-hadoop
https://www.youtube.com/watch?v=OEflMTJUV4c	 /video JEE Docker Kubernetes
https://bugzilla.redhat.com/show_bug.cgi?id=1142311		/ ERR docker on fedora
https://github.com/kubernetes/kubernetes/blob/master/docs/getting-started-guides/fedora/fedora_manual_config.md


http://hortonworks.com/wp-content/uploads/2014/09/HDPwithK.png
http://hadoop.apache.org/docs/stable/api/index.html
http://timothysc.github.io/blog/2013/09/14/hadoop-mapreduce/
http://stackoverflow.com/questions/21326274/hadoop-2-2-0-name-or-service-not-known-warning
http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html#Execution
/ google search: start-dfs.sh java_home is not set and could not be found
http://hadoop.apache.org/docs/r2.4.1/hadoop-project-dist/hadoop-common/ClusterSetup.html
http://docs.hortonworks.com/HDPDocuments/HDP1/HDP-1.3.2/bk_getting-started-guide/content/ch_hdp1_getting_started_chp3.html
https://raseshmori.wordpress.com/2012/10/14/install-hadoop-nextgen-yarn-multi-node-cluster/
http://hortonworks.com/blog/apache-hadoop-yarn-resourcemanager/
http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html
http://localhost:49241/dfshealth.html#tab-startup-progress
http://localhost:49242/cluster/
http://stackoverflow.com/questions/18634825/hadoop-cluster-stuck-hangs-on-reduce-copy

http://virtualjug.com/#sessions

http://www.cyberciti.biz/faq/centos-ssh/
https://bbs.archlinux.org/viewtopic.php?id=165382	
http://askubuntu.com/questions/123072/ssh-automatically-accept-keys
http://hortonworks.com/kb/generating-ssh-keys-for-passwordless-login/ / passwordless login	,
http://crosbymichael.com/setup-password-less-login-over-ssh.html

http://docs.datastax.com/en/cassandra/2.1/cassandra/configuration/configCassandra_yaml_r.html
http://docs.datastax.com/en/landing_page/doc/landing_page/current.html

http://livestream.com/accounts/1545775/osdi12/videos/4646642			/ video spanner
http://www.cs.cmu.edu/~pavlo/courses/fall2013/static/papers/murat-spanner.pdf
http://highscalability.com/blog/2011/1/11/google-megastore-3-billion-writes-and-20-billion-read-transa.html

http://www.mkyong.com/database/postgresql-point-in-time-recovery-incremental-backup/
https://wiki.postgresql.org/wiki/YUM_Installation
http://www.ovirt.org/Installing_PostgreSQL_DB			  / install postgresql
http://www.postgresql.org/docs/9.1/static/functions-info.html
https://fedoraproject.org/wiki/PostgreSQL
http://www.postgresql.org/docs/9.4/static/app-postgres.html
https://wiki.postgresql.org/wiki/Replication,_Clustering,_and_Connection_Pooling
http://www.postgresql.org/docs/current/interactive/high-availability.html
http://momjian.us/main/writings/pgsql/replication.pdf
https://www.youtube.com/watch?v=GobQw9LMEaw				/ postgres replication
http://www.postgresql.org/docs/current/interactive/explicit-joins.html
/ google search: postgresql sharding
/ fb search : postgresql big data, Alex Libman
http://lwn.net/Articles/653411/					/ sql





https://plus.google.com/u/0/+googlecloudplatform/posts
https://cloud.google.com/compute/docs/containers


https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security-Enhanced_Linux/index.html
https://fedoraproject.org/wiki/Getting_started_with_virtualization
http://redhatstackblog.redhat.com/2015/03/27/an-ecosystem-of-integrated-cloud-products/?utm_content=buffer2c7d8&utm_medium=social&utm_source=facebook.com&utm_campaign=buffer
https://docs.fedoraproject.org/en-US/Fedora/18/html/System_Administrators_Guide/s2_Set_All_the_Hostnames.html
https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/sec-Configuring_Yum_and_Yum_Repositories.html
https://developer.jboss.org/thread/1619		/ resteasy vs cxf jax-rs
http://www.infoq.com/news/2007/12/jsf-testing-tools
/ google search: java jackson
https://www.youtube.com/watch?v=S9YmaNuvw5U		/ systemd
https://www.linkedin.com/pulse/red-hat-forum-benelux-15-october-zeist-brita-de-kok
http://www.ortec-finance.com/Working-at-Ortec-Finance/Vacancies/Java-Software-Developer.aspx?sc_lang=nl-NL

http://dougx.net/fractals/index.php



http://spring.io/guides/tutorials/bookmarks/


http://help.eclipse.org/luna/index.jsp
http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Freference%2Fcdt_u_prop_general_idx.htm



http://stackoverflow.com/questions/tagged/c
http://stackoverflow.com/questions/8102397/const-char-vs-char
http://stackoverflow.com/questions/15434817/can-not-find-the-tag-library-descriptor-for-http-java-sun-com-jsp-jstl-core
http://stackoverflow.com/questions/31048389/no-adapter-for-endpoint-exception-apache-camel-with-spring-boot-spring-ws



https://www.youtube.com/watch?v=YrGSQXZmAXs
http://www.cute-test.com/projects/cute/wiki/Using_the_Cute_Eclipse_Plugin
http://cute-test.com/projects/cute/wiki/Using_the_Cute_Eclipse_Plugin
http://cute-test.com/projects/cute/wiki
http://www.learncpp.com/cpp-tutorial/813-friend-functions-and-classes/
http://clang.llvm.org/
http://stackoverflow.com/questions/5057021/why-are-c-inline-functions-in-the-header



http://www.javaworld.com/article/2077714/java-web-development/xa-transactions-using-spring.html
http://www.tutorialspoint.com/spring/spring_java_based_configuration.htm
http://docs.spring.io/spring-framework/docs/4.0.4.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html
https://giannisapi.wordpress.com/2011/09/30/spring-3-testing-with-junit-4-using-contextconfiguration-and-abstracttransactionaljunit4springcontexttests/
https://www.youtube.com/watch?v=Q6esdIY66rw				/ spring data
http://spring.io/guides
http://spring.io/guides/tutorials/bookmarks/



http://docs.seleniumhq.org/download/


https://angularu.com/ng/

http://www.jklp.org/profession/books/mix/c02.html

http://localhost:8080/people?page=1&size=1

https://www.gnu.org/software/mdk/manual/html_node/Debug-commands.html#Debug-commands
http://www.jklp.org/profession/books/mix/c06.html
http://mathoverflow.net/questions/51905/how-to-picture-mathbbc-p


/ Einde OPEN IN CHROME

/ OPEN IN BASH

for7.mixal
add.mixal
max2.mixal
[eric@almond Manual]$ pwd
/home/eric/Devel/MIX/Manual


/ Einde OPEN IN BASH

