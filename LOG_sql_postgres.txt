/ 7	. 

/ in docker container	, master slave	, see LOG_postgresql2.txt

/ we zijn in de master	,

/ \dnS+ hangt af van de database waarin je bent	,

/ \c foo connects to de foo database	, en de user blijft onveranderd	, het is 
\c db usr

/ 13	. 

foo=# create temp table bar(i int);
CREATE TABLE
foo=# \d
          List of relations
  Schema   | Name | Type  |  Owner   
-----------+------+-------+----------
 pg_temp_4 | bar  | table | postgres
(1 row)

foo=# \dnS+
                                     List of schemas
        Name        |  Owner   |  Access privileges   |           Description      
      
--------------------+----------+----------------------+----------------------------
------
 information_schema | postgres | postgres=UC/postgres+| 
                    |          | =U/postgres          | 
 pg_catalog         | postgres | postgres=UC/postgres+| system catalog schema
                    |          | =U/postgres          | 
 pg_temp_1          | postgres |                      | 
 pg_temp_4          | postgres |                      | 
 pg_toast           | postgres |                      | reserved schema for TOAST t
ables
 pg_toast_temp_1    | postgres |                      | 
 pg_toast_temp_4    | postgres |                      | 
 public             | postgres | postgres=UC/postgres+| standard public schema
                    |          | =UC/postgres         | 
(8 rows)


foo=# \c postgres
You are now connected to database "postgres" as user "postgres".
postgres=# \dnS+
                                     List of schemas
        Name        |  Owner   |  Access privileges   |           Description      
      
--------------------+----------+----------------------+----------------------------
------
 information_schema | postgres | postgres=UC/postgres+| 
                    |          | =U/postgres          | 
 pg_catalog         | postgres | postgres=UC/postgres+| system catalog schema
                    |          | =U/postgres          | 
 pg_temp_1          | postgres |                      | 
 pg_toast           | postgres |                      | reserved schema for TOAST t
ables
 pg_toast_temp_1    | postgres |                      | 
 public             | postgres | postgres=UC/postgres+| standard public schema
                    |          | =UC/postgres         | 
(6 rows)

/ 13	. 

/ als je een temp table maakt, en je \c naar een andere db en keert weer terug, dan is de temp table weg	,

/ als je binnen de conn blijft, en je wilt de temp table drop, use drop table	, drop temp table kan niet	,

foo=# create temp table bar(i int);
CREATE TABLE
foo=# drop table bar;
DROP TABLE

/ 13	. 

/ select into

foo=# select *
foo-# from (values(7))_;
 column1 
---------
       7
(1 row)

foo=# select * into bar
from (values(7))_;
SELECT 1

foo=# select*
foo-# from bar;
 column1 
---------
       7
(1 row)

/ 1313	. 

foo=# select * into temp bar
from (values(7))_;
SELECT 1
/ OK	,

foo=# select * into temp table bar
from (values(7))_;
SELECT 1
/ OK	,

foo=# select * into table bar
from (values(7))_;
SELECT 1
/ OK	,

/ 1313	. 

foo=# select n into table bar
from (values(7))t(n);
SELECT 1

foo=# select *from bar;
 n 
---
 7
(1 row)

/ 13	. 

/ generate_series in een table	,

foo=# select n into bar
from generate_series(0,10)t(n);
SELECT 11
foo=# select n from bar;
 n  
----
  0
...

/ 1313	. 

/ zonder naam	,

foo=# select * into bar
from generate_series(0,10);
SELECT 11

foo=# select*from bar;
 generate_series 
-----------------
               0
               1
               2
               3
               4
               5
               6
               7
               8
               9
              10
(11 rows)

/ 13	. 

foo=# with numbers as(
foo(# select*
foo(# from generate_series(1,5)
foo(# )
foo-# select *
foo-# from numbers;
 generate_series 
-----------------
               1
               2
               3
               4
               5
(5 rows)

/ 13	. 

foo=# with numbers as(
select*
from generate_series(1,5)
)
select * into bar
from numbers;
SELECT 5
foo=# select *
foo-# from bar;
 generate_series 
-----------------
               1
               2
               3
               4
               5
(5 rows)

/ 13	. 

foo=# with numbers as(
select*
from generate_series(1,5)
)
select generate_series*random()
foo-# from numbers; 
      ?column?      
--------------------
 0.0273240925744176
   1.33512936811894
  0.841836721636355
  0.325871406123042
   2.00562108540908
(5 rows)


/ 13	. 

foo=# with numbers as(
select*
from generate_series(1,5)
)
select generate_series,random()
from numbers;
 generate_series |      random       
-----------------+-------------------
               1 | 0.997579316608608
               2 | 0.255285303574055
               3 |  0.49440031638369
               4 | 0.780610703863204
               5 | 0.518066473305225
(5 rows)


/ 13	. 

/ lees,
https://dataschool.com/learn-sql/random-sequences/

foo=# select t.i,7*random()
from generate_series(1,5)t(i);
 i |     ?column?     
---+------------------
 1 | 5.59645607788116
 2 | 3.94555319705978
 3 | 4.28401217283681
 4 | 3.71547135431319
 5 |  2.3878477839753
(5 rows)

/ 13	. 

foo=# select max(i),(10*random())::int j
from generate_series(1,5)t(i)
group by j;
 max | j  
-----+----
   3 | 10
   5 |  9
(2 rows)

foo=# select count(i),(10*random())::int j
from generate_series(1,5)t(i)
group by j;
 count | j  
-------+----
     1 | 10
     1 |  8
     3 |  1
(3 rows)

foo=# select count(i),(10*random())::int j
from generate_series(1,5)t(i) 
group by j;
 count | j 
-------+---
     1 | 4
     3 | 3
     1 | 7
(3 rows)

/ over alle columns kan wel aggr fct zonder group by	,

foo=# select max(t.i)       
from generate_series(1,5)t(i);
 max 
-----
   5
(1 row)
foo=# select sum(t.i)
from generate_series(1,5)t(i);
 sum 
-----
  15
(1 row)

/ 13	. 

foo=# values(7);
 column1 
---------
       7
(1 row)

foo=# select *
from (values(7))_;
 column1 
---------
       7
(1 row)

foo=# select *
foo-# into temp table t  
foo-# from (values(7))_;
SELECT 1

foo=# select *
from t;
 column1 
---------
       7
(1 row)


select *
from (	
	select i,(10*random())::int j
	from generate_series(1,5)_(i)
)_;
 i | j 
---+---
 1 | 3
 2 | 9
 3 | 5
 4 | 7
 5 | 9
(5 rows)

/ Hoe zit het met de 2 _'s?

/ 1313	 .

select *
from generate_series(1,5)_(i)
join generate_series(1,5)__(j) on _.i=5-__.j;
 i | j 
---+---
 1 | 4
 2 | 3
 3 | 2
 4 | 1
(4 rows)


select*
from (values(7))_(i) 
join (values(13))__(j) on _.i=__.j-6;
 i | j  
---+----
 7 | 13
(1 row)

/ 131313	 

foo=# values(7);
 column1 
---------
       7
(1 row)

foo=# (values(7))_;
ERROR:  syntax error at or near "_"
LINE 1: (values(7))_;

/ 13	 

select *
into temp table t 
from (
  select i,(10*random())::int j
  from generate_series(1,5)_(i)
)_;
SELECT 5
foo=# select*from t;
 i | j 
---+---
 1 | 5
 2 | 3
 3 | 4
 4 | 7
 5 | 6
(5 rows)
commit;

foo=# values(random());
      column1      
-------------------
 0.408866154495627
(1 row)

/ 13	. 

/ vergl t met 	,

foo=# select*
from t 
cross join (values(random()))_(j);
 i | j |         j         
---+---+-------------------
 1 | 7 | 0.452587937004864
 2 | 0 | 0.452587937004864
 3 | 9 | 0.452587937004864
 4 | 9 | 0.452587937004864
 5 | 8 | 0.452587937004864
(5 rows)

/ 1313	. 

/ hoe maak je een table met 5 random's?
/ TODO

/ niet zo	,
foo=#  values(random(),random());
      column1      |      column2      
-------------------+-------------------
 0.783371998928487 | 0.824927776586264
(1 row)

/ maar zo	,

foo=# select random()
from generate_series(1,5)_;
       random        
---------------------
   0.368411855306476
 0.00667581846937537
    0.12870581401512
   0.297968475148082
   0.492900458630174
(5 rows)

/ 13	. 

select *
from t
where j=(
	select max(j)
	from t
);
 i | j 
---+---
 3 | 9
 4 | 9
(2 rows)

select t.*
from t
join (select max(j)m
	from t)_ on _.m=t.j; 
 i | j 
---+---
 3 | 9
 4 | 9
(2 rows)

with _ as(
select max(j)m
from t)
select t.*
from t
join _ on _.m=t.j;
 i | j 
---+---
 3 | 9
 4 | 9
(2 rows)

foo=# with _(m) as(
select max(j) 
from t)
select t.*
from t
join _ on _.m=t.j;
 i | j 
---+---
 3 | 9
 4 | 9
(2 rows)

/ 13	. 

foo=# select (10*random())::int  
from generate_series(1,10)t(i);
 int4 
------
    1
    6
...
/ dus t(i) bepaalt niet dat de column i heet	,
/ TODO

/ zo wel	,

with t(i) as(
select (10*random())::int
from generate_series(1,10))
select *
from t;
 i 
---
 9
 6
...

foo=# with t as(                                  
select (10*random())::int i 
from generate_series(1,10)) 
select *
from t;
 i  
----
  9
  3

with t as(                                  
select (10*random())::int i 
from generate_series(1,10)) 
select *
from t;
 i  
----
  9
  3
...


/ 13	. 

with t(i,j) as(
select (10*random())::int,(10*random())::int
from generate_series(1,100)
)
select *
into t2
from t;

select i,avg(j) 
from t 
group by i
having avg(j)>5
;
 i |        avg         
---+--------------------
 4 | 9.0000000000000000
 1 | 7.0000000000000000
 5 | 8.0000000000000000
 3 | 9.0000000000000000
(4 rows)

select i,count(*)
from t2
group by i;
 i  | count 
----+-------
  8 |    13
  4 |    14
  1 |    14
  5 |     5
  3 |     9
  0 |     4
 10 |     5
  9 |    10
  6 |    13
  2 |    11
  7 |     2
(11 rows)

select i,avg(j)
from t2 
group by i;
 i  |        avg         
----+--------------------
  6 | 4.6923076923076923
  8 | 5.5384615384615385
  2 | 4.3636363636363636
  1 | 4.5714285714285714
  3 | 5.2222222222222222
 10 | 4.0000000000000000
  4 | 4.5714285714285714
  5 | 4.0000000000000000
  9 | 6.4000000000000000
  0 | 3.2500000000000000
  7 | 8.0000000000000000
(11 rows)

/ 7	. 

postgres=# create table par(i int primary key);
postgres=# create table par2(i int,primary key(i));

postgres=# \d par
      Table "public.par"
 Column |  Type   | Modifiers 
--------+---------+-----------
 i      | integer | not null
Indexes:
    "par_pkey" PRIMARY KEY, btree (i)


/ 13	. 

postgres=# \h create table
 PRIMARY KEY index_parameters |
index_parameters in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:

[ INCLUDE ( column_name [, ... ] ) ]
[ WITH ( storage_parameter [= value] [, ... ] ) ]
[ USING INDEX TABLESPACE tablespace_name ]
/ TODO

/ 13	. 

/ als je een fk maakt in de col def zelf, use dan GEEN foreign key, alleen references	,

postgres=# create table chl(i int primary key references par(i));
CREATE TABLE

postgres=# create table chl2(i int,primary key(i),foreign key(i)references par(i));
CREATE TABLE

/ 13	. 

postgres=# drop table par;
ERROR:  cannot drop table par because other objects depend on it
DETAIL:  constraint chl_i_fkey on table chl depends on table par
constraint chl2_i_fkey on table chl2 depends on table par
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

postgres=# drop table par cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to constraint chl_i_fkey on table chl
drop cascades to constraint chl2_i_fkey on table chl2
DROP TABLE

/ table par is dropped	,
/ Van chl en chl2 zijn de fk's dropped	, 

postgres=# \d chl
      Table "public.chl"
 Column |  Type   | Modifiers 
--------+---------+-----------
 i      | integer | not null
Indexes:
    "chl_pkey" PRIMARY KEY, btree (i)

postgres=# \d chl2
     Table "public.chl2"
 Column |  Type   | Modifiers 
--------+---------+-----------
 i      | integer | not null
Indexes:
    "chl2_pkey" PRIMARY KEY, btree (i)

/ deze had geen dependencies	,
postgres=# drop table par2;
DROP TABLE

postgres=# drop table chl;
DROP TABLE
postgres=# drop table chl2
postgres-# ;
DROP TABLE

/ 13	. 

/ wanneer kan een col reference naar een andere col?

postgres=# create table par(i int,j int,primary key(i));
CREATE TABLE
postgres=# create table chl(j int primary key references par(j));         
ERROR:  there is no unique constraint matching given keys for referenced table "par"

/ het kan wel als we	,

postgres=# alter table par add unique(j);
ALTER TABLE
postgres=# \d par
      Table "public.par"
 Column |  Type   | Modifiers 
--------+---------+-----------
 i      | integer | not null
 j      | integer | 
Indexes:
    "par_pkey" PRIMARY KEY, btree (i)
    "par_j_key" UNIQUE CONSTRAINT, btree (j)

postgres=# create table chl(j int primary key references par(j));
CREATE TABLE

/ 13	. 

/ we willen table chl toch iets anders	,

postgres=# create table chl(j int references par(j));
CREATE TABLE

/ lees	,
https://pgdash.io/blog/postgres-psql-tips-tricks.html

postgres=# \pset null null
Null display is "null".

postgres=# insert into chl values(null);
INSERT 0 1
postgres=# insert into chl values(null);
INSERT 0 1

postgres=# select * from chl;
  j   
------
 null
 null
(2 rows)




