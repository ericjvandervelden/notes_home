/ See DIFFERENCE TABLE(VECTOR,FACTOR2) AND TABLE(FACTOR,FACTOR2)



/ R MANUAL

$ R

> ?solve
> example(solve)

> source("commands.R")
/ executes R code in commands.R

> sink("record.lis")
/ writes to record.lis
> sink()
/ restores output to console	, 

/ 7	 

/ example(solve) execs de examples ook echt	,

> example(solve)

solve> hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }

solve> h8 <- hilbert(8); h8
          [,1]      [,2]      [,3]       [,4]       [,5]       [,6]       [,7]
[1,] 1.0000000 0.5000000 0.3333333 0.25000000 0.20000000 0.16666667 0.14285714
[2,] 0.5000000 0.3333333 0.2500000 0.20000000 0.16666667 0.14285714 0.12500000
[3,] 0.3333333 0.2500000 0.2000000 0.16666667 0.14285714 0.12500000 0.11111111
[4,] 0.2500000 0.2000000 0.1666667 0.14285714 0.12500000 0.11111111 0.10000000
[5,] 0.2000000 0.1666667 0.1428571 0.12500000 0.11111111 0.10000000 0.09090909
[6,] 0.1666667 0.1428571 0.1250000 0.11111111 0.10000000 0.09090909 0.08333333
[7,] 0.1428571 0.1250000 0.1111111 0.10000000 0.09090909 0.08333333 0.07692308
[8,] 0.1250000 0.1111111 0.1000000 0.09090909 0.08333333 0.07692308 0.07142857
           [,8]
[1,] 0.12500000
[2,] 0.11111111
[3,] 0.10000000
[4,] 0.09090909
[5,] 0.08333333
[6,] 0.07692308
[7,] 0.07142857
[8,] 0.06666667

solve> sh8 <- solve(h8)

solve> round(sh8 %*% h8, 3)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    1    0    0    0    0    0    0    0
[2,]    0    1    0    0    0    0    0    0
[3,]    0    0    1    0    0    0    0    0
[4,]    0    0    0    1    0    0    0    0
[5,]    0    0    0    0    1    0    0    0
[6,]    0    0    0    0    0    1    0    0
[7,]    0    0    0    0    0    0    1    0
[8,]    0    0    0    0    0    0    0    1

solve> A <- hilbert(4)

solve> A[] <- as.complex(A)

solve> ## might not be supported on all platforms
solve> try(solve(A))
        [,1]     [,2]     [,3]     [,4]
[1,]   16+0i  -120+0i   240+0i  -140+0i
[2,] -120+0i  1200+0i -2700+0i  1680+0i
[3,]  240+0i -2700+0i  6480+0i -4200+0i
[4,] -140+0i  1680+0i -4200+0i  2800+0i


/ want	, 

> objects()
/=
> ls() 
[1] "A"       "h8"      "hilbert" "sh8"    

/ 7	. 

Two statistical functions are mean(x) which calculates the sample mean, which is the same as sum(x)/length(x), and var(x) which gives
	sum((x-mean(x))^2)/(length(x)-1)
or sample variance. 

If the argument to var() is an n-by-p matrix the value is a p-by-p sample covariance matrix got by regarding the rows as independent p-variate sample vectors.
/ TODO

/ 7	. 

> pmin(5:1, pi)
[1] 3.141593 3.141593 3.000000 2.000000 1.000000
> pmax(1:6,2:4)
[1] 2 3 4 4 5 6
> pmax(1:6,2:3)
[1] 2 3 3 4 5 6

Last metadata expiration check: 0:03:01 ago on Mon Sep  5 21:18:37 2016.
Installed Packages
gmp.x86_64                                         1:6.0.0-12.fc23                                         @@commandline
[eric@almond java]$ dnf list available *gmp*
gmp.i686                                                  1:6.0.0-12.fc23                                        fedora 
gmp-devel.i686                                            1:6.0.0-12.fc23                                        fedora 
gmp-devel.x86_64                                          1:6.0.0-12.fc23                                        fedora 
gmp-ecm.x86_64                                            6.4.4-6.fc23                                           fedora 
gmp-ecm-devel.i686                                        6.4.4-6.fc23                                           fedora 
gmp-ecm-devel.x86_64                                      6.4.4-6.fc23                                           fedora 
gmp-ecm-libs.i686                                         6.4.4-6.fc23                                           fedora 
gmp-ecm-libs.x86_64                                       6.4.4-6.fc23                                           fedora 
gmp-ecm-static.i686                                       6.4.4-6.fc23                                           fedora 
gmp-ecm-static.x86_64                                     6.4.4-6.fc23                                           fedora 
gmp-static.i686                                           1:6.0.0-12.fc23                                        fedora 
gmp-static.x86_64                                         1:6.0.0-12.fc23                                        fedora 
gmpc.x86_64                                               11.8.16-11.fc23                                        updates
gmpc-devel.i686                                           11.8.16-11.fc23                                        updates
gmpc-devel.x86_64                                         11.8.16-11.fc23                                        updates
gmpy.x86_64                                               1.17-4.fc23                                            fedora 
mingw32-gmp.noarch                                        6.0.0-3.fc23                                           fedora 
mingw64-gmp.noarch                                        6.0.0-3.fc23                                           fedora 
ocaml-mlgmpidl.x86_64                                     1.2.1-0.15.20120830.fc23                               fedora 
ocaml-mlgmpidl-devel.i686                                 1.2.1-0.15.20120830.fc23                               fedora 
ocaml-mlgmpidl-devel.x86_64                               1.2.1-0.15.20120830.fc23                               fedora 
ocaml-mlgmpidl-doc.x86_64                                 1.2.1-0.15.20120830.fc23                               fedora 
perl-Crypt-DH-GMP.x86_64                                  0.00012-3.fc23                                         fedora 
perl-Math-BigInt-GMP.x86_64                               1.40-1.fc23                                            fedora 
perl-Math-GMP.x86_64                                      2.11-1.fc23                                            fedora 
php-gmp.x86_64                                            5.6.24-1.fc23                                          updates
python-gmpy2.x86_64                                       2.0.7-1.fc23                                           fedora 
python3-gmpy2.x86_64                                      2.0.7-1.fc23                                           fedora 
texlive-gmp.noarch                                        4:svn21691.1.0-19.fc23                                 updates
texlive-gmp-doc.noarch                                    4:svn21691.1.0-19.fc23                                 updates

[eric@almond java]$ dnf list available *mpfr*
Last metadata expiration check: 0:00:41 ago on Mon Sep  5 21:12:36 2016.
Available Packages
mingw32-mpfr.noarch                                         3.1.3-1.fc23                                         fedora 
mingw64-mpfr.noarch                                         3.1.3-1.fc23                                         fedora 
mpfr.i686                                                   3.1.3-2.fc23                                         updates
mpfr-devel.i686                                             3.1.3-2.fc23                                         updates
mpfr-devel.x86_64                                           3.1.3-2.fc23                                         updates
[eric@almond java]$ 


/ Lees	,
https://cran.r-project.org/web/packages/gmp/index.html

/ 7	. 

> x=1:3
> rep(x,each=5)
 [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3

     seq(0, 1, length.out = 11)
     seq(stats::rnorm(20)) # effectively 'along'
     seq(1, 9, by = 2)     # matches 'end'
     seq(1, 9, by = pi)    # stays below 'end'
     seq(1, 6, by = 3)
     seq(1.575, 5.125, by = 0.05)
     seq(17) # same as 1:17, or even better seq_len(17)

> seq(0, 1, length.out = 10+1)
 [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> seq(0.1, 1, length.out = 10)
 [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

> seq(along.with=c(2,4,6))
[1] 1 2 3
> seq(along.with=c(2,4,6,7,12))
[1] 1 2 3 4 5
> seq_along(3:5)
[1] 1 2 3

> seq(1, 9, by = pi)
[1] 1.000000 4.141593 7.283185

> seq_len(17)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17

/ Lees	,
http://stackoverflow.com/questions/28421972/how-to-use-gmp-library-with-r

/ 7	. 

> z <- c(1:3,NA);  is.na(z)
[1] FALSE FALSE FALSE  TRUE

/ == op vector is coord gewijs	,

> x=1:2
> x==3:2
[1] FALSE  TRUE

/ NA=not available	, NaN=not a number	,

> is.na(NaN)
[1] TRUE

/ 7	. 

/ Hoe elems rm van vector	, 

> x=sample(1:10)
> x
 [1] 10  6  3  2  8  7  4  5  9  1
> x[!x %in% 6]
[1] 10  3  2  8  7  4  5  9  1
> x[!x %in% 3:5]
[1] 10  6  2  8  7  9  1

> x=rep(7,7)
> x[!x %in% 7]
numeric(0)

/ append	, 

> x=c(rep(7,7),rep(3,3))
> c(x,4)
 [1] 7 7 7 7 7 7 7 3 3 3 4

> x=numeric(0)
> c(x,1:7)
[1] 1 2 3 4 5 6 7

/ numeric, integer , character vectors	, 

/ kan wisselen	,  

> x=4:6
> x %in% 4:6
[1] TRUE TRUE TRUE	/ x %in% 3:7 TRUE TRUE TRUE 	, x %in% 5 FALSE TRUE FALSE
> x[x %in% 4:6]
[1] 4 5 6
> x
[1] 4 5 6
> x[!x %in% 4:6]
integer(0)
> x
[1] 4 5 6
> x[!x %in% 4:6]
integer(0)
> c(x[!x %in% 4:6],7:9)
[1] 7 8 9

> x
integer(0)
> x=numeric(0)
> x
numeric(0)
> x=c('foo','bar')
> x
[1] "foo" "bar"
> x %in% 'foo'
[1]  TRUE FALSE
> x[!x %in% 'foo']
[1] "bar"
> x[c(TRUE, FALSE)]
[1] "foo"
> x[!c(TRUE, FALSE)]
[1] "bar"

> x[!TRUE]
character(0)

/ Dus x was numeric, nu character	,  (als je x leeg had gemaakt)	,

> x=c(x,0)
> x
[1] "foo" "bar" "0"  
/ Van 0 wordt een string gemaakt	, 


/ Nog korter	, van numeric naar character	, 

> x=numeric(0)
> x=c(x,c('foo','bar'))
> x[FALSE]
character(0)

> y=numeric(0)
> y=c(y,'')
> y
[1] ""
> y[FALSE]
character(0)


/ 	7	.

> paste(c("X","Y"), 1:10, sep="")
 [1] "X1"  "Y2"  "X3"  "Y4"  "X5"  "Y6"  "X7"  "Y8"  "X9"  "Y10"
> paste(c("X","Y"), 1:10)
 [1] "X 1"  "Y 2"  "X 3"  "Y 4"  "X 5"  "Y 6"  "X 7"  "Y 8"  "X 9"  "Y 10"

/ 7	. 

> x
[1] "foo" "bar"
> x+1
Error in x + 1 : non-numeric argument to binary operator
> y=1:4
> y+1
[1] 2 3 4 5
> c(x,1)
[1] "foo" "bar" "1"  

/ 7	. 

> c("x","y")[rep(c(1,2,2,1), times=1)]
[1] "x" "y" "y" "x"
/ je geeft de index op	,
/ Maar dat doe je ook in x[1:10]	, x[6]	m

/ 13	. 

/ names makkelijker als indices	,
 
> fruit <- c(5, 10, 1, 20)
> names(fruit) <- c("orange", "banana", "apple", "peach")
> fruit
orange banana  apple  peach 
     5     10      1     20 
> lunch <- fruit[c("apple","orange")]
> lunch
 apple orange 
     1      5 
/ makkelijker als	, 
> fruit[c(3,1)]
 apple orange 
     1      5 

> x=c(NaN,1,NA,7)
> x
[1] NaN   1  NA   7
> is.na(x0
+ 
> is.na(x)
[1]  TRUE FALSE  TRUE FALSE
> x[is.na(x)]
[1] NaN  NA
> x[is.na(x)]=0

> seq(1,3,by=2)
[1] 1 3
/ Wat veel	,
> c(1,3)
[1] 1 3
/ beter	,

> x[c(1,3)]=0
> x
[1] 0 1 0 7
> x==0
[1]  TRUE FALSE  TRUE FALSE
> x[x==0]=1
> x
[1] 1 1 1 7

/ we kunnen met indices of met TRUE FALSE aangeven welk elem we van x we bedoelen, de TRUE FALSE rij is net zo lang als x	, en geeft WH ook zo een index	, bijv TRUE TRUE FALSE FALSE TRUE geeft c(1,2,5)	,


> a=1:10
> a[a>7]
[1]  8  9 10

> (a+1)[a>7]
[1]  9 10 11

> a[TRUE]
 [1]  1  2  3  4  5  6  7  8  9 10
> a[FALSE]
integer(0)
> a[c(TRUE,FALSE)]
[1] 1 3 5 7 9

> a[rep(1:5,times=8)]
 [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3
[39] 4 5
> a[rep(1:12,times=2)]
 [1]  1  2  3  4  5  6  7  8  9 10 NA NA  1  2  3  4  5  6  7  8  9 10 NA NA


/ 7	. 

/ vector: 1 type	,

> a=c(1,'foo')
> a
[1] "1"   "foo"

> a=c(1,1i)
> a
[1] 1+0i 0+1i

> a=1:10+2
> a
 [1]  3  4  5  6  7  8  9 10 11 12
> a[2*1:5]
[1]  4  6  8 10 12
/ want	,
> 2*1:5
[1]  2  4  6  8 10
> a=a[2*1:5]
> length(a)=3
> a
[1] 4 6 8

> a=1:4
> attr(a,"dim")=c(2,2)
> a
     [,1] [,2]
[1,]    1    3
[2,]    2    4

> class(a)
[1] "matrix"
> b=1:4
> class(b)
[1] "integer"

/ 13	 

A special attribute known as the class of the object is used to allow for an object-oriented style13 of programming in R. For example if an object has class "data.frame", it will be printed in a certain way, the plot() function will display it graphically in a certain way, and other so-called generic functions such as summary() will react to it as an argument in a way sensitive to its class.

To remove temporarily the effects of class, use the function unclass(). For example if winter has the class "data.frame" then

> winter
will print it in data frame form, which is rather like a matrix, whereas

> unclass(winter)
will print it as an ordinary list. Only in rather special situations do you need to use this facility, but one is when you are learning to come to terms with the idea of class and generic functions.

/ TODO

/ 13	. 

> attr(a,"dim")=c(2,2)
> attributes(a)
$dim
[1] 2 2
> a
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> class(a)
[1] "matrix"

/ unclass doet niets	, 
/ TODO

/ 13	 

As an exercise you may care to find the usual 95% confidence limits for the state mean incomes. To do this you could use tapply() once more with the length() function to find the sample sizes, and the qt() function to find the percentage points of the appropriate t-distributions. (You could also investigate R’s facilities for t-tests.)


/ 13	. 

/ 4.2

> mean(1:4)
[1] 2.5
> var(1:4) 
[1] 1.666667
/ Dus var=(1/n-1)(som kwadraten verschil met mean)	,

1		2		3		4
1.5	0.5	0.5	1.5
2.250.250.252.25
/ som kwadraten=5
5/3=1.6...


> v=rep('a',5)
> n=c(4,5,1,3,7)
> f=factor(v)
> f
[1] a a a a a
Levels: a
> tapply(n,f,mean)
a 
4 
> tapply(n,f,var) 
a 
5 
/ klopt	:
4		5		1		3		7
mean=4
0		1		3		0		3
var=20/5-1=5

> tapply(n,f,sd)^2             
a 
5 

/ in de tekst def ze stderr als sqrt (var/length), maar sd=sqrt(var)	,
/ TODO

>  e
function(x)sqrt(var(x)/length(x))
> tapply(n,f,e)   
a 
1 
/ TODO

/ 13	.

> z=1:8
> dim(z)=c(2,4)
> z
     [,1] [,2] [,3] [,4]
[1,]    1    3    5    7
[2,]    2    4    6    8

> dim(z)=c(2,2,2)
> z
, , 1

     [,1] [,2]
[1,]    1    3
[2,]    2    4

, , 2

     [,1] [,2]
[1,]    5    7
[2,]    6    8

/ we kunnen	,
> z[,,2]         
     [,1] [,2]
[1,]    5    7
[2,]    6    8

/ matrix with factor
/ TODO

/ 13	. 

/ google
r matrix factor

/ lees	,
http://stackoverflow.com/questions/28723059/can-we-get-factor-matrices-in-r

A factor is a vector object used to specify a discrete classification (grouping) of the components of other vectors of the same length.
/ een factor is dus een vector, die z'n values groups, en waartegen je een andere vector bekijkt, en er dan een fct op los laat	, 

/ een ragged array = (v,f) combinatie vector+factor	,

> sample(1:5)
[1] 3 5 2 1 4
> sample(1:5)
[1] 2 4 5 3 1

> sample(1:5,20,r=T)
 [1] 4 1 5 5 2 2 4 2 2 5 4 5 1 3 4 2 5 3 2 1
> sample(1:5,20,r=T)
 [1] 5 5 4 3 3 2 1 1 5 1 4 2 5 2 2 1 4 2 4 1

> f=factor(sample(1:5,20,r=T),1:5)
> f
 [1] 4 4 4 1 1 2 5 5 5 3 2 5 4 2 3 5 4 5 5 3
Levels: 1 2 3 4 5
> f=factor(sample(1:5,20,r=T),1:5)
> f
 [1] 4 5 2 2 4 1 3 4 5 5 5 2 1 4 2 5 2 5 1 1
Levels: 1 2 3 4 5

/ intermezzo

/ factor categories	, groups	,
/ we kunnen een 2de arg geven aan factor 1:5 of 1:4	, 

> n=sample(1:5,20,r=T)
> n
 [1] 3 1 2 4 5 2 4 2 4 4 4 3 1 1 2 2 2 3 1 4
> factor(n)
 [1] 3 1 2 4 5 2 4 2 4 4 4 3 1 1 2 2 2 3 1 4
Levels: 1 2 3 4 5
> factor(n)
 [1] 3 1 2 4 5 2 4 2 4 4 4 3 1 1 2 2 2 3 1 4
Levels: 1 2 3 4 5
> factor(n,1:5)
 [1] 3 1 2 4 5 2 4 2 4 4 4 3 1 1 2 2 2 3 1 4
Levels: 1 2 3 4 5
> factor(n,1:4)
 [1] 3    1    2    4    <NA> 2    4    2    4    4    4    3    1    1    2   
[16] 2    2    3    1    4   
Levels: 1 2 3 4


/ Einde intermezzo

/ intermezzo

> incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
+                61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
+                59, 46, 58, 43)
> length(incomes)
[1] 30

/ of je doet	, 
> sample(40:80,30,r=T)
 [1] 63 60 79 56 64 53 73 55 70 57 43 56 76 51 47 42 66 48 47 64 63 62 76 54 53
[26] 43 67 79 43 40

> a=factor(incomes)
> a
 [1] 60 49 40 61 64 60 59 54 62 69 70 42 56 61 61 61 58 51 48 65 49 49 41 48 52
[26] 46 59 46 58 43
Levels: 40 41 42 43 46 48 49 51 52 54 56 58 59 60 61 62 64 65 69 70
> b=as.factor(incomes)
> b
 [1] 60 49 40 61 64 60 59 54 62 69 70 42 56 61 61 61 58 51 48 65 49 49 41 48 52
[26] 46 59 46 58 43
Levels: 40 41 42 43 46 48 49 51 52 54 56 58 59 60 61 62 64 65 69 70
> a==b
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE

/ Einde intermezzo

/ count ze,	
> tapply(rep(1,20),f,sum)
1 2 3 4 5 
4 5 1 4 6 

/ intermezzo

> s=sample(1:10,r=T)
> s
 [1] 8 5 8 1 3 1 8 5 1 9
> f=factor(s)
> f
 [1] 8 5 8 1 3 1 8 5 1 9
Levels: 1 3 5 8 9
> tapply(rep(1,10),f,sum)
/ of	,
> table(f)
/ of
> table(s)
1 3 5 8 9 
3 1 2 3 1 
/ f groupeert s	, maar daar doet table blijkbaar niets mee	,



/ let op : rep(1,10), niet rep(1:10), waarin rep useless is trouwens	,

/ Einde intermezzo

/ 5.1 arrays

/ een vector heeft geen dim	,
> v=1:10
> dim(v)
NULL
/ arrays wel	,

/ 1313	.

> v=1:10
> dim(v)
NULL
> v
 [1]  1  2  3  4  5  6  7  8  9 10
> dim(v)=c(2,5)
> v
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    3    5    7    9
[2,]    2    4    6    8   10

/ 1313	.


> dim(f)=c(4,5)
> f
     [,1] [,2] [,3] [,4] [,5]
[1,] 4    4    5    1    2   
[2,] 5    1    5    4    5   
[3,] 2    3    5    2    1   
[4,] 2    4    2    5    1   
Levels: 1 2 3 4 5
> class(f)
[1] "factor"

/ 13	 .

> array(1:24,dim=c(3,4,2))
, , 1

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , 2

     [,1] [,2] [,3] [,4]
[1,]   13   16   19   22
[2,]   14   17   20   23
[3,]   15   18   21   24

> a[1:24]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
> a[2]
[1] 2

/ 13	. 

/ herhalen	,

> array(1:6,dim=c(3,4))
     [,1] [,2] [,3] [,4]
[1,]    1    4    1    4
[2,]    2    5    2    5
[3,]    3    6    3    6
> array(1:5,dim=c(3,4))
     [,1] [,2] [,3] [,4]
[1,]    1    4    2    5
[2,]    2    5    3    1
[3,]    3    1    4    2


/ 13	. 

> 2:4*3:5
[1]  6 12 20

> x=1:12
> x[x%%2==1]
[1]  1  3  5  7  9 11
> x[x%%2==0]
[1]  2  4  6  8 10 12
> x[x%%2==1]*x[x%%2==0]
[1]   2  12  30  56  90 132

/ of zo	,
> seq(1,12,by=2)
[1]  1  3  5  7  9 11
> seq(2,12,by=2)
[1]  2  4  6  8 10 12


> a=x[x%%2==0]
> dim(a)=c(2,3)
> a
     [,1] [,2] [,3]
[1,]    2    6   10
[2,]    4    8   12
> b=x[x%%2==1]
> dim(b)=c(2,3)
> b
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    3    7   11
> a*b
     [,1] [,2] [,3]
[1,]    2   30   90
[2,]   12   56  132

> b[,1]
[1] 1 3
> a*b[,1]
     [,1] [,2] [,3]
[1,]    2    6   10
[2,]   12   24   36

/ 13	 

/ outer product	,

> a
     [,1] [,2] [,3]
[1,]    2    6   10
[2,]    4    8   12
> 
> 
> b
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    3    7   11
> 
> 
> a%o%b
, , 1, 1

     [,1] [,2] [,3]
[1,]    2    6   10
[2,]    4    8   12

, , 2, 1

     [,1] [,2] [,3]
[1,]    6   18   30
[2,]   12   24   36

, , 1, 2

     [,1] [,2] [,3]
[1,]   10   30   50
[2,]   20   40   60

, , 2, 2

     [,1] [,2] [,3]
[1,]   14   42   70
[2,]   28   56   84

, , 1, 3

     [,1] [,2] [,3]
[1,]   18   54   90
[2,]   36   72  108

, , 2, 3

     [,1] [,2] [,3]
[1,]   22   66  110
[2,]   44   88  132

/ 13	. 

> a=seq(2,12,by=2)
> b=seq(1,12,by=2)
> outer(a,b,"*")
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    2    6   10   14   18   22
[2,]    4   12   20   28   36   44
[3,]    6   18   30   42   54   66
[4,]    8   24   40   56   72   88
[5,]   10   30   50   70   90  110
[6,]   12   36   60   84  108  132

> f=function(a,b)a*b
> outer(a,b,f)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    2    6   10   14   18   22
[2,]    4   12   20   28   36   44
[3,]    6   18   30   42   54   66
[4,]    8   24   40   56   72   88
[5,]   10   30   50   70   90  110
[6,]   12   36   60   84  108  132

/ 7	. 

/ google,
sample variance chi square
/ lees	,
http://www.math.uah.edu/stat/sample/Normal.html
http://stats.stackexchange.com/questions/121662/why-is-the-sampling-distribution-of-variance-a-chi-squared-distribution

/ google
sum standard normal, chi squared
/ lees	,
https://en.wikipedia.org/wiki/Chi-squared_distribution
https://en.wikipedia.org/wiki/Proofs_related_to_chi-squared_distribution

/ intermezzo

/ R: denk in columns	, 

> a=0:2
> b=3:5
> outer(a,b,"-")
     [,1] [,2] [,3]
[1,]   -3   -4   -5
[2,]   -2   -3   -4
[3,]   -1   -2   -3


0	- 3
1		4
2   5
=
-3	/=a-3, je denkt in b ook in columns ,dus eerst -3, dan -4, dan -5
-2
-1
/ dan a-4	,
-4
-3
-2
/ het result zijn ook weer columns	,

/ Einde intermezzo

/ intermezzo

/ Dit kan niet, een vector kan geen dim hebben	, 
> a=c(1:4,dim=c(2,2))
> a
                    dim1 dim2 
   1    2    3    4    2    2 

> a=array(1:4,dim=c(2,2))
> a
     [,1] [,2]
[1,]    1    3
[2,]    2    4

/ we oef 2x2 outer -	 

> a=array(1:4,dim=c(2,2))
> b=array(5:8,dim=c(2,2))
> a
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> b
     [,1] [,2]
[1,]    5    7
[2,]    6    8

> d=outer(a,b,"-")
> d
, , 1, 1					/= a-5

     [,1] [,2]
[1,]   -4   -2
[2,]   -3   -1

, , 2, 1					/= a-6	, inderdaad in b eerst de columns af,

     [,1] [,2]
[1,]   -5   -3
[2,]   -4   -2

, , 1, 2					/=a-7

     [,1] [,2]
[1,]   -6   -4
[2,]   -5   -3

, , 2, 2					/ a-8

     [,1] [,2]
[1,]   -7   -5
[2,]   -6   -4

/ dus het werkt zo:

1 3 - 5 7 
2 4   6 8 

=

a -5  | a -7
------------
a - 6 | a - 8o

=

-4 -2 | -6 -4
-3 -1 | -5 -3
---------------
-5 -3 | -7 -5
-4 -2 | -6 -4


/ maar	, 

> outer(1:3,2:4,"-")
     [,1] [,2] [,3]
[1,]   -1   -2   -3
[2,]    0   -1   -2
[3,]    1    0   -1

/ dus moeten we denken 
/ TODO

1 - 2 3 4
2
3

=

a-2 | a-3 | a-4

=

-1 | -2 | -3
0  | -1 | -2
1  |  0 | -1



/ Einde intermezzo

/ 7	. 

> d <- outer(0:2, 0:2)
/=
> d <- outer(0:2, 0:2,"*")	/ * is de default op	,
> d
     [,1] [,2] [,3]
[1,]    0    0    0
[2,]    0    1    2
[3,]    0    2    4
> table(d)
d
0 1 2 4 
5 1 2 1 

/ vreemd	, 
/ we moeten het zo denken	, 
0 * 0 1 2 
1
2

/ 13	. 

 eerst met de hand	,

/ alle mog det. met 0 en 1	,

/ eerst 

0 * 0 1
1 
=
0 0
0 1

/ dan	,

0 0 - 0 0
0 1		0 1
=

0 0 | 0 0
0 1 | 0 1
---------
0 0 | -1 -1 
0 1 |  -1 0 

/ dus er zijn 16 mog	, 
/ klopt	, voor een 2x2 det zijn er op elke van de 4 pos 2 mog, 0 of 1,  dus zijn er 16 2x2 matrices	, en die hebben elk een det.
/ we zien 
-1 0 1 
---------
3 10 3

/ nu met R	,

> v=0:1
> d=outer(v,v)
> e=outer(d,d,"-")
> f=table(e)
> f
e
-1  0  1 
 3 10  3 

> as.numeric(names(f))==-1:1
[1] TRUE TRUE TRUE
/ Dit geeft de range aan , horizontal	,

> plot(as.numeric(names(f)),f,type="h", xlab="Determinant",ylab="Frequency")
/ we kunnen ook 
type l of p	, 


/ 13	. 

/ nogmaals,

/ outer: neem d	, en haal er d[1,1] af, dat is e[,,1,1], haal er d[2,1] af (want werk in columns, dus d[2,1] en niet d[1,2]), dat is e[,,2,1], ...

> d=1:4
> dim(d)=c(2,2)
> d
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> e=outer(d,d,'-')
> e
, , 1, 1

     [,1] [,2]
[1,]    0    2
[2,]    1    3

, , 2, 1

     [,1] [,2]
[1,]   -1    1
[2,]    0    2

, , 1, 2

     [,1] [,2]
[1,]   -2    0
[2,]   -1    1

, , 2, 2

     [,1] [,2]
[1,]   -3   -1
[2,]   -2    0

/ 13	. 

> d <- outer(0:1, 0:1)
>  d
     [,1] [,2]
[1,]    0    0
[2,]    0    1
> e=outer(d,d,'-')
> e
, , 1, 1

     [,1] [,2]
[1,]    0    0
[2,]    0    1

, , 2, 1

     [,1] [,2]
[1,]    0    0
[2,]    0    1

, , 1, 2

     [,1] [,2]
[1,]    0    0
[2,]    0    1

, , 2, 2

     [,1] [,2]
[1,]   -1   -1
[2,]   -1    0

> dim(e)
[1] 2 2 2 2
/klopt	, 

0 0 | 0 0
0 1 | 0 1
---------
0 1 | -1 -1
0 1 | -1 0

/ we zien een 2x2 matrix	, dat zijn de laatste row column = 2 2 van 2 2 2 2	, 
/ ieder elem is ook een 2x2 matrix	,


> fr=table(e)
> fr
e
-1  0  1 
 3 10  3 
> plot(as.numeric(names(fr)), fr, type="h", xlab="Determinant", ylab="Frequency") 
/ OK
/ als we de 16 matrices write met 0 of 1, en de det berekenen, zien we precies deze freq, waar -1, 0, 1 de dets zijn. 
/ TODO

/ 13	. 

> a=array(1:9,c(3,3))
> a
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
> aperm(a,c(2,1))
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9

/ 13	. 

> a
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> b=outer(1:2,1:2)
> b
     [,1] [,2]
[1,]    1    2
[2,]    2    4
> a %*% b
     [,1] [,2]
[1,]    7   14
[2,]   10   20


> x=1:2
> x %*% a %*% x
     [,1]
[1,]   27

/ dit moeten we zo denken	, 

1 2 * 1 3 * 1 
      2 4   2

/ 13	 

> outer(1:2,3:4)
     [,1] [,2]
[1,]    3    4
[2,]    6    8

/ dus moeten we zo denken	, 

1 * 3 4
2			

/ en NIET	 

1 2 * 3
			4

/ intermezzo

/ 1:2 is een c, geen array	, 

> ar= array(1:2,1:2)
> ac= array(1:2,2:1)
> br=array(3:4,1:2)
> bc=array(3:4,2:1)

> outer(ac,br)
, , 1, 1

     [,1]
[1,]    3
[2,]    6

, , 1, 2

     [,1]
[1,]    4
[2,]    8

> dim(outer(ac,br))
[1] 2 1 1 2
/ we zien een 1x2 matrix=rij, dat zijn de laatste in 2 1 1 2	,  en elk elem in deze matrix is een 2x1 matrix=column	, 

3	4
6 8

> outer(ar,bc)
, , 1, 1

     [,1] [,2]
[1,]    3    6

, , 2, 1

     [,1] [,2]
[1,]    4    8

> dim(outer(ar,bc))
[1] 1 2 2 1
/ we zien een 2x1 matrix, dat zijn de laatste row column= 2 1 in 1 2 2 	,  en elk elem in deze matrix is een 2x1 matrix	, 

3 6
4 8

> outer(1:2,3:4)
     [,1] [,2]
[1,]    3    4
[2,]    6    8
> dim(outer(1:2,3:4))
[1] 2 2

> outer(1:2,3:5)
     [,1] [,2] [,3]
[1,]    3    4    5
[2,]    6    8   10

> dim(outer(1:2,3:5))
[1] 2 3

/ TODO 

/ einde intermezzo

/ 13	. 

/ WH is t ∘ outer het tensor product	, 
+U2218=∘

> t(outer(1:2,3:4))
     [,1] [,2]
[1,]    3    6
[2,]    4    8

/ we zien een tensor zo	,
1:2 ⊗ 3:4		/ +U2297=⊗

8
|
|
|
|			 4
-----6 |
2
|      |
|			 |
----1  ---3

/ 13	. 

> 1:2
[1] 1 2
> t(1:2)
     [,1] [,2]
[1,]    1    2
> t(t(1:2))
     [,1]
[1,]    1
[2,]    2


/ 13	. 

> a=t(outer(1:2,3:4))
> a
     [,1] [,2]
[1,]    3    6
[2,]    4    8
> aperm(a,2:1)
     [,1] [,2]
[1,]    3    4
[2,]    6    8

/ aperm(,2:1)=t

/ 13	.

> a=t(outer(1:2,3:4))
> a
     [,1] [,2]
[1,]    3    6
[2,]    4    8
> crossprod(a,1:2)
     [,1]
[1,]   11
[2,]   22
> t(a) %*% 1:2
     [,1]
[1,]   11
[2,]   22

> 1:2 %*% 3:4
     [,1]
[1,]   11
> t(1:2) %*% 3:4
     [,1]
[1,]   11
> 1:2 %*% t(3:4)
     [,1] [,2]
[1,]    3    4
[2,]    6    8
> t(1:2) %*% t(3:4)
Error in t(1:2) %*% t(3:4) : non-conformable arguments

> xr=array(1:2,1:2)
> xc=array(1:2,2:1)
> yr=array(3:4,1:2)
> yc=array(3:4,2:1)
/ of	,
> xr=t(1:2)
> xc=t(t(1:2))
> yr=t(3:4)
> yc=t(t(3:4))

> xr %*% yr
Error in xr %*% yr : non-conformable arguments
> xr %*% yc
     [,1]
[1,]   11
> xc %*% yr
     [,1] [,2]
[1,]    3    4
[2,]    6    8
> xc %*% yc
Error in xc %*% yc : non-conformable arguments

/ 13	. 

> xr %o% yr
, , 1, 1

     [,1] [,2]
[1,]    3    6

, , 1, 2

     [,1] [,2]
[1,]    4    8

> xr %o% yc
, , 1, 1

     [,1] [,2]
[1,]    3    6

, , 2, 1

     [,1] [,2]
[1,]    4    8

> xc %o% yr
, , 1, 1

     [,1]
[1,]    3
[2,]    6

, , 1, 2

     [,1]
[1,]    4
[2,]    8

> xc %o% yc
, , 1, 1

     [,1]
[1,]    3
[2,]    6

, , 2, 1

     [,1]
[1,]    4
[2,]    8


/ 13	. 

> 1:2 %*% 3:4
     [,1]
[1,]   11

> 1:2 %o% 3:4
     [,1] [,2]
[1,]    3    4
[2,]    6    8

> xr %*% yc
     [,1]
[1,]   11

> xr %o% yc
, , 1, 1

     [,1] [,2]
[1,]    3    6

, , 2, 1

     [,1] [,2]
[1,]    4    8




> 1:2 %*% a
     [,1] [,2]
[1,]   11   22
> t(1:2) %*% a
     [,1] [,2]
[1,]   11   22

> xr %*% yc
     [,1]
[1,]   11

/ 13	. 

> xr %*% a %*% xc
     [,1]
[1,]   55
> xr %*% a %*% xr
Error in xr %*% a %*% xr : non-conformable arguments
> xr %*% a %*% x
Error in xr %*% a %*% x : non-conformable arguments

> 1:2
[1] 1 2
> t(1:2)
     [,1] [,2]
[1,]    1    2
> t(t(1:2))
     [,1]
[1,]    1
[2,]    2

> 1:2 %*% a %*% 1:2
     [,1]
[1,]   55
> t(1:2) %*% a %*% 1:2
     [,1]
[1,]   55
> t(t(1:2)) %*% a %*% 1:2
Error in t(t(1:2)) %*% a : non-conformable arguments

> 1:2 %*% a %*% t(1:2)
Error in 1:2 %*% a %*% t(1:2) : non-conformable arguments

/ het lijkt er op dat 1:2 en liggend en staand kan gezien worden door R.

/ 13	 

> 1:2
[1] 1 2
> as.array(1:2)
[1] 1 2
> as.matrix(1:2)
     [,1]
[1,]    1
[2,]    2
> matrix(1:2)
     [,1]
[1,]    1
[2,]    2
> t(1:2)
     [,1] [,2]
[1,]    1    2

> dim(as.matrix(1:2))
[1] 2 1
> dim(as.array(1:2))
[1] 2
> dim(1:2)
NULL

/ als matrix is 1:2 dus een column	, 
/ als we t(1:2)	, dan wordt 1:2 WH eerst tot matrix gemaakt, een column dus, en dan t, dus een row	,
> dim(t(1:2))
[1] 1 2

> is.matrix(t(1:2))
[1] TRUE

> t(1:2) %*% a %*% t(t(1:2))
/ of	,
> t(1:2) %*% a %*% as.matrix(1:2)
     [,1]
[1,]   55
> as.matrix(1:2) %*% a %*% as.matrix(1:2)
Error in as.matrix(1:2) %*% a : non-conformable arguments
> 1:2 %*% a %*% 1:2
     [,1]
[1,]   55
/ ook hier wordt de linker 1:2 WH tot t(as.matrix(1:2)) , en de rechter 1:2 tot as.matrix(1:2)	,

/ 13	. 

/ crossprod is inner product	?

/ crossprod van
1 3		5 7
2 4		6	8

/ is inner prod van columns	, dus	, 

11 12 = 17	23
21 22		39	69

/ waar 21=inner product 2de column linker matrix in 1ste column rechter matrix


/ intermezzo 

/ lees	, 
http://www.r-tutor.com/r-introduction/matrix/matrix-construction
/ boek over Bayesian statistics	,

/ Einde intermezzo 

> matrix(data=c(0,1,1,0),nrow=2,ncol=2)
     [,1] [,2]
[1,]    0    1
[2,]    1    0

 Sm=matrix(data=c(0,1,1,0),nrow=2,ncol=2)
> eigen(Sm)
$values
[1]  1 -1

$vectors
          [,1]       [,2]
[1,] 0.7071068 -0.7071068
[2,] 0.7071068  0.7071068

> eigen(Sm)$values
[1]  1 -1


/ 13	 .

/ svd	, 

/ 1313	 

/ lees	,
https://en.wikipedia.org/wiki/Singular_value_decomposition

/ lees	,
https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix

In the mathematical discipline of linear algebra, eigendecomposition or sometimes spectral decomposition is the factorization of a matrix into a canonical form, whereby the matrix is represented in terms of its eigenvalues and eigenvectors. Only diagonalizable matrices can be factorized in this way.

/ Lees	, 
https://en.wikipedia.org/wiki/Diagonalizable_matrix

/ er is een basis van eigenvectoren als de matrix diagonaliseerbaar is	,
PAP⁻¹ = PU207bUb9 

Real symmetric matrices are diagonalizable by orthogonal matrices; i.e., given a real symmetric matrix A, QAQt is diagonal for some orthogonal matrix Q. More generally, matrices are diagonalizable by unitary matrices if and only if they are normal. In the case of the real symmetric matrix, we see that A = At, so clearly AAt = AtA holds. Examples of normal matrices are real symmetric (or skew-symmetric) matrices (e.g. covariance matrices) and Hermitian matrices (or skew-Hermitian matrices). See spectral theorems for generalizations to infinite-dimensional vector spaces.

As a rule of thumb, over C almost every matrix is diagonalizable. More precisely: the set of complex n×n matrices that are not diagonalizable over C, considered as a subset of Cn×n, has Lebesgue measure zero. One can also say that the diagonalizable matrices form a dense subset with respect to the Zariski topology: the complement lies inside the set where the discriminant of the characteristic polynomial vanishes, which is a hypersurface. From that follows also density in the usual (strong) topology given by a norm. The same is not true over R.
/ TODO

/ 13	 .

/ Ga naar	,
https://en.wikipedia.org/wiki/Normal_matrix

Among complex matrices, all unitary, Hermitian, and skew-Hermitian matrices are normal. Likewise, among real matrices, all orthogonal, symmetric, and skew-symmetric matrices are normal. However, it is not the case that all normal matrices are either unitary or (skew-)Hermitian. For example,

normal: A*A=AA*
/ bijv	,
unitary: A*A=AA*=I
hermites: A=A*
skew-hermites: A*=-A

A matrix is normal if and only if it is unitarily similar to a diagonal matrix, and therefore any matrix A satisfying the equation A∗A = AA∗ is diagonalizable.

N=VDV*	, N normal, D diagonal, V unitary	,

unitary: (Ux,Uy)=(x,y)

/ 13	 .

/ normal => diagonazable	,

/ hermites, symmetric: has real eigenvalues	, diagonizable	, A=UDUt , U unitary	, because u1,...,un are orthonormal chosen	,

/ unitary, orthonarmal columns	, also is diagonizable, U=VDVt	, V unitary	, 
/ hoe eindigt dit	?
/ TODO  
/ columns unitary matrix orthonormal	, -> standard base -> rotated/reflected base	, so unitary = rotation/reflection	,

/13	. 

/ lees	,
https://en.wikipedia.org/wiki/Singular_value_decomposition

In linear algebra, the singular value decomposition (SVD) is a factorization of a real or complex matrix. It is the generalization of the eigendecomposition of a positive semidefinite normal matrix UDU* (for example, a symmetric matrix with positive eigenvalues) to any mxn matrix via an extension of polar decomposition. It has many useful applications in signal processing and statistics.

Using the polar decomposition theorem, we can also consider M = RP as the composition of a stretch (positive definite normal matrix P = VΣV∗) with eigenvalue scale factors σi along the orthogonal eigenvectors Vi of P, followed by a single rotation (unitary matrix R = UV∗). If the rotation is done first, M = P'R, then R is the same and P' = UΣU∗ has the same eigenvalues, but is stretched along different (post-rotated) directions. This shows that the SVD is a generalization of the eigenvalue decomposition of pure stretches in orthogonal directions (symmetric matrix P) to arbitrary matrices (M = RP) which both stretch and rotate.




/ Ga naar	, 
https://en.wikipedia.org/wiki/Positive-definite_matrix#Negative-definite.2C_semidefinite_and_indefinite_matrices

M is called positive-semidefinite (or sometimes nonnegative-definite) if
	x*Mx=>0	, x in Cn

A matrix M is positive-semidefinite if and only if it arises as the Gram matrix of some set of vectors. In contrast to the positive-definite case, these vectors need not be linearly independent.

/ Lees	,
https://en.wikipedia.org/wiki/Gramian_matrix

/ lees	over determinant and volume	, 
http://math.stackexchange.com/questions/427528/why-determinant-is-volume-of-parallelepiped-in-any-dimensions

/ lees	,
https://en.wikipedia.org/wiki/Polar_decomposition#Matrix_polar_decomposition

A=UP: U unitary=rotatie/reflexie	, en P hermites=vergroting/verkleining langs assen (eigenwaarden zijn factoren van vergroting)	, 
/ dus het is als poolcoord	, r.e^iphi	,

/ 1313	. 

/ lees	,
http://www.euclideanspace.com/maths/geometry/rotations/theory/as2reflections/

/ R90=S2S1, als S1=spiegeling in hor, en S2 = spiegeling in 45	,

/ 1313	. 

/ lees	,
https://en.wikipedia.org/wiki/Orthogonal_group

n two dimensions, O(2) is the group of all rotations about the origin and all reflections along a line through the origin. SO(2) is the group of all rotations about the origin.

These groups are closely related: SO(2) is a subgroup of O(2), since any two reflections gives a rotation.

More generally, in any number of dimensions an even number of reflections gives a rotation, and a rotation followed by reflection (or vice versa) produces a reflection. Therefore, the rotations define a subgroup of O(2), but the reflections do not define a subgroup.

/ TODO

/ S1S2=R -> reflections are not subgroup of O(2)	,	 want een product gaat er uit	,

/ lees later	,
https://en.wikipedia.org/wiki/Unitary_group
https://en.wikipedia.org/wiki/Orthogonal_group
https://en.wikipedia.org/wiki/Rotation_group_SO(3)
Connection between SO(3) and SU(2)[edit]

/ 1313	.

/ lees	,
https://en.wikipedia.org/wiki/Singular_value_decomposition

n the special case that M is a normal matrix, which by definition must be square, the spectral theorem says that it can be unitarily diagonalized using a basis of eigenvectors, so that it can be written M = UDU∗ for a unitary matrix U and a diagonal matrix D. When M is also positive semi-definite, the decomposition M = UDU∗ is also a singular value decomposition. Otherwise, it can be recast as an SVD by moving the phase of each σi to either its corresponding Vi or Ui. The natural connection of the SVD to non-normal matrices is through the polar decomposition theorem: M=SR, where S=UΣU* is positive semidefinite and normal, and R=UV* is unitary.

Thus while related, the eigenvalue decomposition and SVD differ except for positive semi-definite normal matrices M: the eigenvalue decomposition is M = UDU−1 where U is not necessarily unitary and D is not necessarily positive semi-definite, while the SVD is M = UΣV∗ where Σ is diagonal and positive semi-definite, and U and V are unitary matrices that are not necessarily related except through the matrix M. While only non-defective square matrices have an eigenvalue decomposition, any mxn matrix has a SVD.

UDU-1
/ TODO

/ 13	. 

> a=matrix(c(5,4,-4,-5)/3,nrow=2)
> a
         [,1]      [,2]
[1,] 1.666667 -1.333333
[2,] 1.333333 -1.666667
> svd(a)
$d
[1] 3.0000000 0.3333333

$u
           [,1]       [,2]
[1,] -0.7071068 -0.7071068
[2,] -0.7071068  0.7071068

$v
           [,1]       [,2]
[1,] -0.7071068 -0.7071068
[2,]  0.7071068 -0.7071068

/ klopt	, see aant R5	,

a=$u $d $v*

/  | det(a) | = product hoofddiagonaal $d	, in R is dat 
> prod(svd(a)$d)
[1] 1

/ prod berekent het product van alle getallen in een matrix bijv	, prod(a) heeft geen betekenis	,

> det(a)
[1] -1

/ uit A=RP weten we : P pos def	, dus  P=VDV*	, D pos elems op hoofddiagonaal	, en A=UDV*	, D pos elems op hoofdiagonaal	, dus detD> 0	, en | detA | = detD


/ 13`	. 

/ 5.7.5

/ lsfit	, 
/ TODO

/ 13	. 

> m=cbind(1, 1:7) 
     [,1] [,2]
> m
[1,]    1    1
[2,]    1    2
[3,]    1    3
[4,]    1    4
[5,]    1    5
[6,]    1    6
[7,]    1    7
> cbind(m, 8:14)
     [,1] [,2] [,3]
[1,]    1    1    8
[2,]    1    2    9
[3,]    1    3   10
[4,]    1    4   11
[5,]    1    5   12
[6,]    1    6   13
[7,]    1    7   14

> cbind(m, 8:14)[, c(1, 3, 2)]
     [,1] [,2] [,3]
[1,]    1    8    1
[2,]    1    9    2
[3,]    1   10    3
[4,]    1   11    4
[5,]    1   12    5
[6,]    1   13    6
[7,]    1   14    7
/ [, c(1, 3, 2)] betekent: alle rows, en column 1,3,2 
/ er staat: [,1] + [,3] + [,2]

> rbind(1, 1:3)
     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    2    3
> cbind(0, rbind(1, 1:3))
     [,1] [,2] [,3] [,4]
[1,]    0    1    1    1
[2,]    0    1    2    3

Hence cbind(x) and rbind(x) are possibly the simplest ways explicitly to allow the vector x to be treated as a column or row matrix respectively.

> rbind(1:4)
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
> array(1:4)
[1] 1 2 3 4

> dim(1:4)
NULL
> dim(array(1:4))
[1] 4
> dim(rbind(1:4))
[1] 1 4

/ 13	. 

/ weer terug naar vector	,

> c(rbind(1:4))
[1] 1 2 3 4
> dim(c(rbind(1:4)))
NULL

/ 13	. 

/ intermezzo

/ factor & table

/ table op een vector kan ook, hij schakelt er WH factor ertussen	,

> table(1:8)

1 2 3 4 5 6 7 8 
1 1 1 1 1 1 1 1 
> table(c(1,3,1,3,2))

1 2 3 
2 1 2 
> table(factor(c(1,3,1,3,2)))

1 2 3 
2 1 2 

> rbinom(32, n = 5, prob = 0.4)
[1]  9 11 10 12 10
> rbinom(32, n = 5, prob = 0.4)
[1] 17 12  9 13  9
> rbinom(32, n = 5, prob = 0.4)
[1] 10 14 10 10 17

> factor(rbinom(32, n = 5, prob = 0.4))
[1] 11 15 19 8  16
Levels: 8 11 15 16 19
> factor(rbinom(32, n = 5, prob = 0.4))
[1] 11 18 18 11 14
Levels: 11 14 18

> table(factor(rbinom(32, n = 5, prob = 0.4)))

10 11 12 14 17 
 1  1  1  1  1 
> table(factor(rbinom(32, n = 5, prob = 0.4)))

11 13 14 15 
 1  2  1  1 

/ tapply

/ tapply schakelt er WH ook factor tussen	, 

> x=c(1,3,1,3,1,3,1,3,1,3)
> y=1:10
> tapply(y,x,sum)
 1  3 
25 30 

> f=factor(x)
> tapply(y,f,sum)
 1  3 
25 30 

/ lees
> ?tapply

/ tapply(groups, groups, length) = tapply(groups) 

> groups <- factor(rbinom(32, n = 5, prob = 0.4))
> groups
[1] 8  12 12 18 5 
Levels: 5 8 12 18
> tapply(groups, groups, length) 
 5  8 12 18 
 1  1  2  1 
/=
> table(groups)
groups
 5  8 12 18 
 1  1  2  1 

/ 13	. 

> ?tapply
     tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE)
Arguments:
   INDEX: list of one or more factors, each of same length as ‘X’.  The
          elements are coerced to factors by ‘as.factor’.

/ Inderdaad	, als 2de arg een vector	, wordt er een as.factor tussendoor gedaan	,

> tapply(1:n,rep(1:3,length=n),sum)
 1  2  3 
51 57 45 
/ je krijgt rij 1,2,3,1,2,3,... eh hij telt uit 1,2,3,4,5,... op welke er bij 1 staan	, 1+4+7+... en welke bij 2 staan, 2+5+8+...	, ...

/ we kunnen ook zelf de levels, waarop hij groups, opgeven	,

> n <- 17; fac <- factor(rep(1:3, length = n), levels = 1:5)
> table(fac)
fac
1 2 3 4 5 
6 6 5 0 0 
> tapply(1:n, fac, sum)
 1  2  3  4  5 
51 57 45 NA NA 

> n <- 17; fac <- factor(rep(1:3, length = n), levels = 5:9)
> tapply(1:n, fac, sum)
 5  6  7  8  9 
NA NA NA NA NA 

/ 13	. 

> tapply(rep(1:3, length = n),rep(1:3, length = n),sum)
/=
> tapply(rep(1:3, length = n),as.factor(rep(1:3, length = n)),sum)
 1  2  3 
 6 12 15 

> tapply(rep(1:3, length = n),rep(1:3, length = n),length)
/=
> tapply(rep(1:3, length = n),as.factor(rep(1:3, length = n)),length)
1 2 3 
6 6 5 

/ we kunnen ook	, 
> tapply(as.factor(rep(1:3, length = n)),as.factor(rep(1:3, length = n)),length) 
1 2 3 
6 6 5 

/ maar,	 

> tapply(as.factor(rep(1:3, length = n)),as.factor(rep(1:3, length = n)),sum)
/ ERR	,
  ‘sum’ not meaningful for factors

> as.factor(rep(1:3, length = n))
 [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2
Levels: 1 2 3


/ 13	. 

> states
 [1] "tas" "sa"  "qld" "nsw" "nsw" "nt"  "wa"  "wa"  "qld" "vic" "nsw" "vic"
[13] "qld" "qld" "sa"  "tas" "sa"  "nt"  "wa"  "vic" "qld" "nsw" "nsw" "wa" 
[25] "sa"  "act" "nsw" "vic" "vic" "act"

>  statef
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa  tas sa  nt  wa 
[20] vic qld nsw nsw wa  sa  act nsw vic vic act
Levels: act nsw nt qld sa tas vic wa

> tapply(state, state, length)
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 
> tapply(state, statef, length)
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 
> tapply(statef, statef, length)
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 


/ 13	. 

> cut(rep(1,5), 4)
[1] (0.9995,1] (0.9995,1] (0.9995,1] (0.9995,1] (0.9995,1]
Levels: (0.999,0.9995] (0.9995,1] (1,1.0005] (1.0005,1.001]
> table(cut(rep(1,5), 4))
(0.999,0.9995]     (0.9995,1]     (1,1.0005] (1.0005,1.001] 
             0              5              0              0 
> tapply(cut(rep(1,5), 4),cut(rep(1,5), 4),length)
(0.999,0.9995]     (0.9995,1]     (1,1.0005] (1.0005,1.001] 
            NA              5             NA             NA 

> incomes
 [1] 60 49 40 61 64 60 59 54 62 69 70 42 56 61 61 61 58 51 48 65 49 49 41 48 52
[26] 46 59 46 58 43
> cut(incomes, breaks = 35+10*(0:7))
 [1] (55,65] (45,55] (35,45] (55,65] (55,65] (55,65] (55,65] (45,55] (55,65]
[10] (65,75] (65,75] (35,45] (55,65] (55,65] (55,65] (55,65] (55,65] (45,55]
[19] (45,55] (55,65] (45,55] (45,55] (35,45] (45,55] (45,55] (45,55] (55,65]
[28] (45,55] (55,65] (35,45]
Levels: (35,45] (45,55] (55,65] (65,75] (75,85] (85,95] (95,105]
> table(cut(incomes, breaks = 35+10*(0:7)))
 (35,45]  (45,55]  (55,65]  (65,75]  (75,85]  (85,95] (95,105] 
       4       10       14        2        0        0        0 
> tapply(incomes,cut(incomes, breaks = 35+10*(0:7)),length)
 (35,45]  (45,55]  (55,65]  (65,75]  (75,85]  (85,95] (95,105] 
       4       10       14        2       NA       NA       NA 

/ DIFFERENCE TABLE(VECTOR,FACTOR2) AND TABLE(FACTOR,FACTOR2)

> incomef=cut(incomes, breaks = 35+10*(0:7))
> table(incomef,statef)
          statef
incomesf   act nsw nt qld sa tas vic wa
  (35,45]    1   1  0   1  0   0   1  0
  (45,55]    1   1  1   1  2   0   1  3
  (55,65]    0   3  1   3  2   2   2  1
  (65,75]    0   1  0   0  0   0   1  0
  (75,85]    0   0  0   0  0   0   0  0
  (85,95]    0   0  0   0  0   0   0  0
  (95,105]   0   0  0   0  0   0   0  0

> table(incomes,states)
/=
> table(incomes,statef)
       statef
incomes act nsw nt qld sa tas vic wa
     40   0   0  0   1  0   0   0  0
     41   0   1  0   0  0   0   0  0
     42   0   0  0   0  0   0   1  0
     43   1   0  0   0  0   0   0  0
     46   1   0  0   0  0   0   1  0
     48   0   0  0   0  0   0   0  2
     49   0   1  0   1  1   0   0  0
     51   0   0  1   0  0   0   0  0
     52   0   0  0   0  1   0   0  0
     54   0   0  0   0  0   0   0  1
     56   0   0  0   1  0   0   0  0
     58   0   0  0   0  1   0   1  0
     59   0   1  0   0  0   0   0  1
     60   0   0  1   0  0   1   0  0
     61   0   1  0   1  1   1   0  0
     62   0   0  0   1  0   0   0  0
     64   0   1  0   0  0   0   0  0
     65   0   0  0   0  0   0   1  0
     69   0   0  0   0  0   0   1  0
     70   0   1  0   0  0   0   0  0

/ De 2de arg wordt altijd as.factor	,
/ Hier zie je goed het verschil tussen table(factor,factor2) en table(vector,factor2)

/ Einde DIFFERENCE TABLE(VECTOR,FACTOR2) AND TABLE(FACTOR,FACTOR2)

/ 13	

/ lists	,

> Lst <- list(name="Fred", wife="Mary", no.children=3,child.ages=c(4,7,9))
> Lst[[1]]
[1] "Fred"
> Lst[1]
$name
[1] "Fred"
> Lst[1]$name
[1] "Fred"


> c(1,"foo")
[1] "1"   "foo"
> list(1,"foo")
[[1]]
[1] 1
[[2]]
[1] "foo"

> c(list(1,"foo"),list(2,"bar"))
[[1]]
[1] 1
[[2]]
[1] "foo"
[[3]]
[1] 2
[[4]]
[1] "bar"

/ 13	. 

> array(1:6,dim=c(2,3))
/=
> matrix(1:6,nrow=2)
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
> array(1:6,dim=c(3,2))
/=
> matrix(1:6,nrow=3)
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6

s.matrix(matrix(1:6,nrow=3))
[1] TRUE
> is.array(matrix(1:6,nrow=3))
[1] TRUE
> is.array(array(1:6,dim=c(2,3)))
[1] TRUE
> is.matrix(array(1:6,dim=c(2,3)))
[1] TRUE

/ 13	. 

> list(c(2,3),1,"foo",m)
[[1]]
[1] 2 3
[[2]]
[1] 1
[[3]]
[1] "foo"
[[4]]
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6

> c(c(2,3),1,"foo",m)
 [1] "2"   "3"   "1"   "foo" "1"   "2"   "3"   "4"   "5"   "6"  

> array(c(2,3),1,"foo",m)
Error in array(c(2, 3), 1, "foo", m) : unused argument (m)
/ TODO

> data.frame(c(2,3),1,"foo",m)
Error in data.frame(c(2, 3), 1, "foo", m) : 
  arguments imply differing number of rows: 2, 1, 3
/ TODO

/ 13	. 

/ als het past	, kun je van verschillende types een data.frame maken	,

> data.frame(1)
  X1
1  1
> data.frame(1,1:4)
  X1 X1.4
1  1    1
2  1    2
3  1    3
4  1    4

> data.frame(1,1:4,1:9)
Error in data.frame(1, 1:4, 1:9) : 
  arguments imply differing number of rows: 1, 4, 9

> data.frame(1,1:4,1:8)
  X1 X1.4 X1.8
1  1    1    1
2  1    2    2
3  1    3    3
4  1    4    4
5  1    1    5
6  1    2    6
7  1    3    7
8  1    4    8

> data.frame(1,1:4,matrix(1:4,nrow=2))
  X1 X1.4 X1.1 X2
1  1    1    1  3
2  1    2    2  4
3  1    3    1  3
4  1    4    2  4

> data.frame(1,1:4,matrix(1:4,nrow=2),c("foo","bar"))
  X1 X1.4 X1.1 X2 c..foo....bar..
1  1    1    1  3             foo
2  1    2    2  4             bar
3  1    3    1  3             foo
4  1    4    2  4             bar

/ 13	 

> a=1:4*2
> a
[1] 2 4 6 8
> f=factor(a)
> str(f)
 Factor w/ 4 levels "2","4","6","8": 1 2 3 4
> f=factor(a,labels=c("I","II","III","IV"))
> f
[1] I   II  III IV 
Levels: I II III IV
> str(f)
 Factor w/ 4 levels "I","II","III",..: 1 2 3 4

> b=1:8*3
> g=fact
factanal      factor        factor.scope  factorial     
> g=factor(b)
> str(g)
 Factor w/ 8 levels "3","6","9","12",..: 1 2 3 4 5 6 7 8

/ 13	. 

/ Kijk naar	, over factors	,
https://www.youtube.com/watch?v=wfJ8nKQXudE
https://www.youtube.com/watch?v=xkRBfy8_2MU

/ 13	. 

> a=c(2,4,4,6,8,2,4,4)
> f=factor(a)
> b=c(3,3,3,6)
> g=factor(b)
> data.frame(a,b)
  a b
1 2 3
2 4 3
3 4 3
4 6 6
5 8 3
6 2 3
7 4 3
8 4 6
> str(data.frame(a,b))
'data.frame':	8 obs. of  2 variables:
 $ a: num  2 4 4 6 8 2 4 4
 $ b: num  3 3 3 6 3 3 3 6
> data.frame(f,g)
  f g
1 2 3
2 4 3
3 4 3
4 6 6
5 8 3
6 2 3
7 4 3
8 4 6
> str(data.frame(f,g))
'data.frame':	8 obs. of  2 variables:
 $ f: Factor w/ 4 levels "2","4","6","8": 1 2 2 3 4 1 2 2
 $ g: Factor w/ 2 levels "3","6": 1 1 1 2 1 1 1 2

> table(data.frame(f,g))
   g
f   3 6
  2 2 0
  4 3 1
  6 0 1
  8 1 0
> table(data.frame(a,b))
   b
a   3 6
  2 2 0
  4 3 1
  6 0 1
  8 1 0
/ set WH factors ertussen	,

> str(table(data.frame(a,b)))
 'table' int [1:4, 1:2] 2 3 0 1 0 1 1 0
 - attr(*, "dimnames")=List of 2
  ..$ a: chr [1:4] "2" "4" "6" "8"
  ..$ b: chr [1:2] "3" "6"

/ 13	 

>  data.frame(a,b)*2
   a  b
1  4  6
2  8  6
3  8  6
4 12 12
5 16  6
6  4  6
7  8  6
8  8 12
>  data.frame(f,g)*2
   f  g
1 NA NA
2 NA NA
3 NA NA
4 NA NA
5 NA NA
6 NA NA
7 NA NA
8 NA NA
Warning messages:
1: In Ops.factor(left, right) : ‘*’ not meaningful for factors
2: In Ops.factor(left, right) : ‘*’ not meaningful for factors

> table(data.frame(a,b))*2
   b
a   3 6
  2 4 0
  4 6 2
  6 0 2
  8 2 0
> table(data.frame(f,g))*2
   g
f   3 6
  2 4 0
  4 6 2
  6 0 2
  8 2 0

/ 13	. 

> df=data.frame(1:2,1:4)
> df
  X1.2 X1.4
1    1    1
2    2    2
3    1    3
4    2    4
> df$X1.2[3]
[1] 1

> df
  X1.4 X1 X2
1    1  1  3
2    2  2  4
3    3  1  3
4    4  2  4
> df$X1.4
[1] 1 2 3 4
> df$X1
[1] 1 2 1 2
> df$X2
[1] 3 4 3 4

/ 13	. 

> df
  c..foo....bar.. X1
1             foo  1
2             bar  1
> df$c
[1] foo bar
Levels: bar foo
> df$c
[1] foo bar
Levels: bar foo
> str(df$c)
 Factor w/ 2 levels "bar","foo": 2 1

/ strings geven een factor in een data.frame	,
/ WH makkelijker opslaan	, een soort pointer	, is index	,
/ TODO

> search()
[1] ".GlobalEnv"        "package:stats"     "package:graphics" 
[4] "package:grDevices" "package:utils"     "package:datasets" 
[7] "package:methods"   "Autoloads"         "package:base"     

> attach(df)

> search()
 [1] ".GlobalEnv"        "df"                "package:stats"    
 [4] "package:graphics"  "package:grDevices" "package:utils"    
 [7] "package:datasets"  "package:methods"   "Autoloads"        
[10] "package:base"     

> c..foo....bar..
[1] foo bar
Levels: bar foo
> X1
[1] 1 1
/ we kunnen nu niet afkorten: c of c.. kent hij niet	, wel df$c of df$c..	,

> detach(df)

/ 13	. 











/ FACTOR

     The encoding of the vector happens as follows.  First all the
     values in ‘exclude’ are removed from ‘levels’. If ‘x[i]’ equals
     ‘levels[j]’, then the ‘i’-th element of the result is ‘j’.  If no
 
> ff <- factor(substring("statistics", 1:10, 1:10)) 
 [1] s t a t i s t i c s
Levels: a c i s t
> ff
 [1] s t a t i s t i c s
Levels: a c i s t
> as.integer(ff)
 [1] 4 5 1 5 3 4 5 3 2 4

/ Dus x[i]=levels[j] -> f[i]=j

/ we zien ook duidelijk een vector	, 
 [1] s t a t i s t i c s
/ of	,
 [1] 4 5 1 5 3 4 5 3 2 4

/ geef
r factor categorial variable
/ Lees	,
https://www.stat.berkeley.edu/classes/s133/factors.html

/ Lees	,
http://www.ats.ucla.edu/stat/r/modules/factor_variables.htm



/ Lees	,
http://www.ats.ucla.edu/stat/r/modules/dummy_vars.htm

> data=c(4,5,5,5,4,4,7,7)
> f=factor(data,levels=1:6,labels=c('a','b','c','d','e','f'))
> f
[1] d    e    e    e    d    d    <NA> <NA>
Levels: a b c d e f

>  hsb2 <- read.csv("http://www.ats.ucla.edu/stat/data/hsb2.csv")
> hsb2
     id female race ses schtyp prog read write math science socst
1    70      0    4   1      1    1   57    52   41      47    57
2   121      1    4   2      1    3   68    59   53      63    61
3    86      0    4   3      1    1   44    33   54      58    31
4   141      0    4   3      1    3   63    44   47      53    56
...







/ Einde FACTOR



/ Einde intermezzo


/ 7	. 

/ google: r categorial variables
/ Lees	 ,
https://stats.idre.ucla.edu/r/modules/coding-for-categorical-variables-in-regression-models/

In R there are at least three different functions that can be used to obtain contrast variables for use in regression or ANOVA. 

/ 13	. 

/ FACTOR

/ google: r factor
/ Lees	,
https://www.stat.berkeley.edu/classes/s133/factors.html

Conceptually, factors are variables in R which take on a limited number of different values; such variables are often refered to as categorical variables. One of the most important uses of factors is in statistical modeling; since categorical variables enter into statistical models differently than continuous variables, storing data as factors insures that the modeling functions will treat such data correctly.

levels: possible values of the factor=categorial variable	,

> data = c(1,2,2,3,1,2,3,3,1,2,3,3,1)		/ data is integer variable
> fdata = factor(data)
> fdata
 [1] 1 2 2 3 1 2 3 3 1 2 3 3 1									/ fdata is a categorial variable
Levels: 1 2 3
> rdata = factor(data,labels=c("I","II","III"))		/ change the values	,
> rdata
 [1] I   II  II  III I   II  III III I   II  III III I
Levels: I II III

> mons = c("March","April","January","November","January",
+ "September","October","September","November","August",
+ "January","November","November","February","May","August",
+ "July","December","August","August","September","November",
+ "February","April")
> mons = factor(mons)
> table(mons)
mons
    April    August  December  February   January      July
        2         4         1         2         3         1
    March       May  November   October September
        1         1         5         1         3

/ 13	. 

> fert = c(10,20,20,50,10,20,10,50,20)
> fert = factor(fert,levels=c(10,20,50),ordered=TRUE)
> fert
[1] 10 20 20 50 10 20 10 50 20
Levels: 10 < 20 < 50

If we wished to calculate the mean of the original numeric values of the fert variable, we would have to convert the values using the levels function:
> mean(fert)
[1] NA
Warning message:
argument is not numeric or logical: 
      returning NA in: mean.default(fert)
> mean(as.numeric(levels(fert)[fert]))
[1] 23.33333



/ Einde FACTOR











/ 13	. 

    x  <- array(1:24, 2:4)
     xt <- aperm(x, c(2,1,3))
     stopifnot(t(xt[,,2]) == x[,,2],
               t(xt[,,3]) == x[,,3],
               t(xt[,,4]) == x[,,4])

/ 13	. 

> crossprod(1:4)
     [,1]
[1,]   30

/ 13	. 

> w=matrix(2:1,1,2)
> tw=matrix(2:1,2,1)
> t(w)
     [,1]
[1,]    2
[2,]    1
> u=array(2:1,c(1,2))
> u
     [,1] [,2]
[1,]    2    1
> t(u)
     [,1]
[1,]    2
[2,]    1
> v=2:1  
> v
[1] 2 1
> t(v)
     [,1] [,2]
[1,]    2    1
> t(t(v))
     [,1]
[1,]    2
[2,]    1
> t(t(t(v)))
     [,1] [,2]
[1,]    2    1

/ 13	. 

/ het lijkt er op dat een vector wordt aangepast , maar een array/matrix niet: die moet kloppen	,
> v
[1] 1 2 3
> m
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

> t(v)
     [,1] [,2] [,3]
[1,]    1    2    3
> t(t(v))
     [,1]
[1,]    1
[2,]    2
[3,]    3

> m %*% v
     [,1]
[1,]   22
[2,]   28
> m %*% t(v)
Error in base::"%*%"(x, y) : non-conformable arguments
> m %*% t(t(v))
     [,1]
[1,]   22
[2,]   28

/ 13	. 

> v %*% t(m)
     [,1] [,2]
[1,]   22   28
> t(v) %*% t(m)
     [,1] [,2]
[1,]   22   28
> t(t(v)) %*% t(m)
Error in base::"%*%"(x, y) : non-conformable arguments

/ 13	. 

> m
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
> v
[1] 1 2 3

> v %*% m
Error in base::"%*%"(x, y) : non-conformable arguments
/ klopt	, hoe je v ook neerzet	, het kan niet	,

> t(v) %*% m
Error in base::"%*%"(x, y) : non-conformable arguments
> t(t(v)) %*% m
Error in base::"%*%"(x, y) : non-conformable arguments

> tcrossprod(v, m)
     [,1] [,2]
[1,]   22   28
> tcrossprod(t(v), m)
     [,1] [,2]
[1,]   22   28
> tcrossprod(t(t(v)), m)
Error in base::tcrossprod(x, y) : non-conformable arguments





































/ 7	. 

$ dnf list installed
R-core.x86_64                         3.2.3-2.fc23                 @updates     
R-core-devel.x86_64                   3.2.3-2.fc23                 @updates     

R.x86_64                              3.2.3-2.fc23                 @updates     	
/ TODO
R-devel.x86_64                        3.2.3-2.fc23                 @updates     	
/ TODO
R-java.x86_64                         3.2.3-2.fc23                 @updates     
/ TODO
R-java-devel.x86_64                   3.2.3-2.fc23                 @updates     
/ TODO


[eric@almond downloaded_packages]$ dnf repoquery -l R-core | less
/etc/ld.so.conf.d/R-i386.conf
/usr/bin/R
/usr/bin/Rscript
/usr/lib/R
/usr/lib/R/COPYING
...

/ 13	. 

R Installation and Administration

6 Add-on packages

> getOption("defaultPackages")
[1] "datasets"  "utils"     "grDevices" "graphics"  "stats"     "methods"  
/ en base	,

[eric@almond downloaded_packages]$  ls /usr/lib64/R/
bin  COPYING  etc  include  lib  library  modules  SVN-REVISION
/ WH R_HOME	,
[eric@almond downloaded_packages]$ ls /usr//lib64/R/library/
base       compiler   grid        methods   rpart    survival
boot       datasets   KernSmooth  mgcv      spatial  tcltk
class      foreign    lattice     nlme      splines  tools
cluster    graphics   MASS        nnet      stats    translations
codetools  grDevices  Matrix      parallel  stats4   utils

/ we zien base, datasets, ... van hierboven	, 

[eric@almond downloaded_packages]$ ls /usr//lib64/R/etc
javaconf  ldpaths  Makeconf  Renviron  repositories

> .Library
[1] "/usr/lib64/R/library"
> .Library.site
[1] "/usr/lib64/R/library" "/usr/share/R/library"
> .libPaths()
[1] "/home/eric/R/x86_64-redhat-linux-gnu-library/3.2"
[2] "/usr/lib64/R/library"                            
[3] "/usr/share/R/library"    

[eric@almond downloaded_packages]$ ls ~/R/x86_64-redhat-linux-gnu-library/3.2/
polynom  sfsmisc
[eric@almond downloaded_packages]$ ls /usr/lib64/R/library
base       compiler   grid        methods   rpart    survival
boot       datasets   KernSmooth  mgcv      spatial  tcltk
class      foreign    lattice     nlme      splines  tools
cluster    graphics   MASS        nnet      stats    translations
codetools  grDevices  Matrix      parallel  stats4   utils
[eric@almond downloaded_packages]$ ls /usr/share/R/library/
/ leeg	,

> Sys.getenv("R_LIBS_USER")
[1] "~/R/x86_64-redhat-linux-gnu-library/3.2"

 installing *source* package ‘gmp’ ...
** package ‘gmp’ successfully unpacked and MD5 sums checked
creating cache ./config.cache
checking for __gmpz_ui_sub in -lgmp... no
configure: error: GNU MP not found, or not 4.1.4 or up, see http://gmplib.org
ERROR: configuration failed for package ‘gmp’
* removing ‘/home/eric/R/x86_64-redhat-linux-gnu-library/3.2/gmp’

The downloaded source packages are in
	‘/tmp/Rtmpvhs4E5/downloaded_packages’

/ lees	, 
https://cran.r-project.org/web/packages/Rmpfr/index.html

/lees	, 
http://r.789695.n4.nabble.com/package-compile-error-on-RHEL-x86-64-td911454.html
/ over __gmpz_ui_sub, 
/ uses R CMD INSTALL

/ lees	,
http://kbroman.org/pkg_primer/pages/build.html

[eric@almond downloaded_packages]$ R CMD INSTALL /tmp/Rtmpvhs4E5/downloaded_packages/gmp_0.5-12.tar.gz 
* installing to library ‘/home/eric/R/x86_64-redhat-linux-gnu-library/3.2’
* installing *source* package ‘gmp’ ...
** package ‘gmp’ successfully unpacked and MD5 sums checked
creating cache ./config.cache
checking for __gmpz_ui_sub in -lgmp... no
configure: error: GNU MP not found, or not 4.1.4 or up, see http://gmplib.org
ERROR: configuration failed for package ‘gmp’
* removing ‘/home/eric/R/x86_64-redhat-linux-gnu-library/3.2/gmp’






/ 7	 .

/ Lees	,
http://stackoverflow.com/questions/27673000/rscript-there-is-no-package-called

> print(.libPaths())
[1] "/usr/lib64/R/library" "/usr/share/R/library"
> .libPaths(c(.libPaths(),"/usr/lib"))
> print(.libPaths())
[1] "/usr/lib64/R/library" "/usr/share/R/library" "/usr/lib"            

/ 7	 .

/ Lees	,
http://stackoverflow.com/questions/22277440/in-r-using-ubuntu-try-to-install-a-lib-depending-on-gmp-c-lib-it-wont-find-g


/ Ga naar de manual, ch13	, 
/ Dit is : An Introduction to R 
https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Packages
see Installing packages in R Installation and Administration) to install and update	, 
/ we komen in 	,
https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Installing-packages
/ Dit is : R Installation and Administration

/ we zien alle manuals	, 
https://cran.r-project.org/manuals.html

An Introduction to R
R Data Import/Export
R Installation and Administration
Writing R Extensions 
A draft of The R language definition d
R Internals
The R Reference Index:

/ 7	. 

> installed.packages()
/ TODO

/ Lees Par 6.3 in R installation and Administration	,

> .Library
[1] "/usr/lib64/R/library"

/ 7	 

/ Ook,	
    ‘update.packages’, ‘available.packages’, ‘download.packages’,
     ‘installed.packages’, ‘contrib.url’.


/ 13	. 

> install.packages('Rmpfr')
Installing package into ‘/home/eric/R/x86_64-redhat-linux-gnu-library/3.2’
(as ‘lib’ is unspecified)
--- Please select a CRAN mirror for use in this session ---
/ Kies Ghent	, 
also installing the dependency ‘gmp’

trying URL 'https://lib.ugent.be/CRAN/src/contrib/gmp_0.5-12.tar.gz'
Content type 'application/x-gzip' length 130077 bytes (127 KB)
==================================================
downloaded 127 KB

trying URL 'https://lib.ugent.be/CRAN/src/contrib/Rmpfr_0.6-0.tar.gz'
Content type 'application/x-gzip' length 582729 bytes (569 KB)
==================================================
downloaded 569 KB

* installing *source* package ‘gmp’ ...
** package ‘gmp’ successfully unpacked and MD5 sums checked
creating cache ./config.cache
checking for __gmpz_ui_sub in -lgmp... no
configure: error: GNU MP not found, or not 4.1.4 or up, see http://gmplib.org
ERROR: configuration failed for package ‘gmp’
* removing ‘/home/eric/R/x86_64-redhat-linux-gnu-library/3.2/gmp’
ERROR: dependency ‘gmp’ is not available for package ‘Rmpfr’
* removing ‘/home/eric/R/x86_64-redhat-linux-gnu-library/3.2/Rmpfr’

The downloaded source packages are in
	‘/tmp/RtmpMyxJwL/downloaded_packages’
Warning messages:
1: In install.packages("Rmpfr") :
  installation of package ‘gmp’ had non-zero exit status
2: In install.packages("Rmpfr") :
  installation of package ‘Rmpfr’ had non-zero exit status

> .libPaths()
[1] "/home/eric/R/x86_64-redhat-linux-gnu-library/3.2"
[2] "/usr/lib64/R/library"                            
[3] "/usr/share/R/library"        

/ 7. 	

[eric@almond R]$ pwd
/home/eric/Devel/R
[eric@almond R]$ cp -a /tmp/RtmpMyxJwL/downloaded_packages/ .





/ 7	 .

/ Op ubuntu OK	,

/ Lees	, 

https://www.datascienceriot.com/how-to-install-r-in-linux-ubuntu-16-04-xenial-xerus/kris/

/ we start in docker ubuntu	,

root@0725664ec517:/# apt-get update

root@0725664ec517:/# dpkg --get-selections | grep gmp
libgmp-dev:amd64				install
libgmp10:amd64					install
libgmp3-dev					install
libgmpxx4ldbl:amd64				install
/ Nu, achteraf	, eerst NIETS	,

root@0725664ec517:/# apt list --installed | grep gmp
/ Heb ik dit gedaan?
/ TODO

root@0725664ec517:/# apt-get install libgmp3-dev

root@0725664ec517:/# lsb_release -a
/ Niet in Docker 
/ Daarom	, 
oot@0725664ec517:/# cat /etc/*release
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=16.04
DISTRIB_CODENAME=xenial
DISTRIB_DESCRIPTION="Ubuntu 16.04 LTS"
NAME="Ubuntu"
VERSION="16.04 LTS (Xenial Xerus)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 16.04 LTS"
VERSION_ID="16.04"
HOME_URL="http://www.ubuntu.com/"
SUPPORT_URL="http://help.ubuntu.com/"
BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"
UBUNTU_CODENAME=xenial

root@0725664ec517:/# echo "deb http://cran.rstudio.com/bin/linux/ubuntu xenial/" | tee -a /etc/apt/sources.listdeb http://cran.rstudio.com/bin/linux/ubuntu xenial/
root@0725664ec517:/# cat /etc/apt/sources.list
# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
# newer versions of the distribution.

deb http://archive.ubuntu.com/ubuntu/ xenial main restricted
deb-src http://archive.ubuntu.com/ubuntu/ xenial main restricted

## Major bug fix updates produced after the final release of the
## distribution.
deb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted
deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted

## Uncomment the following two lines to add software from the 'universe'
## repository.
## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
## team. Also, please note that software in universe WILL NOT receive any
## review or updates from the Ubuntu security team.
deb http://archive.ubuntu.com/ubuntu/ xenial universe
deb-src http://archive.ubuntu.com/ubuntu/ xenial universe
deb http://archive.ubuntu.com/ubuntu/ xenial-updates universe
deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates universe

## N.B. software from this repository may not have been tested as
## extensively as that contained in the main release, although it includes
## newer versions of some applications which may provide useful features.
## Also, please note that software in backports WILL NOT receive any review
## or updates from the Ubuntu security team.
# deb http://archive.ubuntu.com/ubuntu/ xenial-backports main restricted
# deb-src http://archive.ubuntu.com/ubuntu/ xenial-backports main restricted

deb http://archive.ubuntu.com/ubuntu/ xenial-security main restricted
deb-src http://archive.ubuntu.com/ubuntu/ xenial-security main restricted
deb http://archive.ubuntu.com/ubuntu/ xenial-security universe
deb-src http://archive.ubuntu.com/ubuntu/ xenial-security universe
# deb http://archive.ubuntu.com/ubuntu/ xenial-security multiverse
# deb-src http://archive.ubuntu.com/ubuntu/ xenial-security multiverse
deb http://cran.rstudio.com/bin/linux/ubuntu xenial/

root@0725664ec517:/#  gpg --keyserver keyserver.ubuntu.com --recv-key E084DAB9
gpg: directory `/root/.gnupg' created
gpg: new configuration file `/root/.gnupg/gpg.conf' created
gpg: WARNING: options in `/root/.gnupg/gpg.conf' are not yet active during this run
gpg: keyring `/root/.gnupg/secring.gpg' created
gpg: keyring `/root/.gnupg/pubring.gpg' created
gpg: requesting key E084DAB9 from hkp server keyserver.ubuntu.com
gpg: /root/.gnupg/trustdb.gpg: trustdb created
gpg: key E084DAB9: public key "Michael Rutter <marutter@gmail.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)

root@0725664ec517:/# gpg -a --export E084DAB9 | apt-key add -
OK

root@0725664ec517:/# apt-get update
root@0725664ec517:/# apt-get install r-base r-base-dev
/ Install R	,

root@0725664ec517:/# R
> install.packages('gmp')
Installing package into '/usr/local/lib/R/site-library'
(as 'lib' is unspecified)
--- Please select a CRAN mirror for use in this session ---
HTTPS CRAN mirror 

 1: 0-Cloud [https]                    2: Algeria [https]                 
 3: Australia (Melbourne) [https]      4: Australia (Perth) [https]       
 5: Austria [https]                    6: Belgium (Ghent) [https]         
Selection: 6
trying URL 'https://lib.ugent.be/CRAN/src/contrib/gmp_0.5-12.tar.gz'
Content type 'application/x-gzip' length 130077 bytes (127 KB)
==================================================
downloaded 127 KB

* installing *source* package 'gmp' ...
** package 'gmp' successfully unpacked and MD5 sums checked
creating cache ./config.cache
checking for __gmpz_ui_sub in -lgmp... yes
updating cache ./config.cache
creating ./config.status
creating src/Makevars
** libs
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c apply.cc -o apply.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c biginteger.cc -o biginteger.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c bigintegerR.cc -o bigintegerR.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c bigmod.cc -o bigmod.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c bigrational.cc -o bigrational.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c bigrationalR.cc -o bigrationalR.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c bigvec.cc -o bigvec.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c bigvec_q.cc -o bigvec_q.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c extract_matrix.cc -o extract_matrix.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c factor.cc -o factor.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c factorize.cc -o factorize.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c init.cc -o init.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c matrix.cc -o matrix.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c matrixq.cc -o matrixq.o
g++ -I/usr/share/R/include -DNDEBUG -I/usr/local/include/       -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c solve.cc -o solve.o
g++ -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o gmp.so apply.o biginteger.o bigintegerR.o bigmod.o bigrational.o bigrationalR.o bigvec.o bigvec_q.o extract_matrix.o factor.o factorize.o init.o matrix.o matrixq.o solve.o -L/usr/local/lib/ -lgmp -L/usr/lib/R/lib -lR
installing to /usr/local/lib/R/site-library/gmp/libs
** R
** data
** preparing package for lazy loading
Creating a generic function for 'which.max' from package 'base' in package 'gmp'
Creating a generic function for 'which.min' from package 'base' in package 'gmp'
** help
*** installing help indices
** building package indices

Attaching package: 'gmp'

The following objects are masked from 'package:base':

    %*%, apply, crossprod, matrix, tcrossprod

** testing if installed package can be loaded
* DONE (gmp)

The downloaded source packages are in
	'/tmp/RtmpjvT1vW/downloaded_packages'

/ 13	. 

> library('gmp')

Attaching package: 'gmp'

The following objects are masked from 'package:base':

    %*%, apply, crossprod, matrix, tcrossprod

>  4^9
[1] 262144
> 5^262144
[1] Inf


> x <- pow.bigz(5,4^9)
> x
Big Integer ('bigz') :
[1] 620606987866087447074832055728467930919421926519911717317738324478446890420544620839553285931321349485035253770303663683982841794590287939217907896413001562813056130648742361989551149212969224876324067423266596922285621953874621042323534088395449559871528186289511069724375976843450129507660813935068404901191160699929926568099301259938271975526587719565309995276438998093283175080241558332247248559779700151125941289265945872056624218617237890012082751842933999101391215888650459655385867584223151909481355326107360857559379424168644356988805892732524316323249492420512640962691673104618378381545202638771401061171968052873214149454639250558993079337749040788199113873242179763112388758028783104830372553378956776992639131474698631635403592318398169766049527523470365775067845991971903958476530419618328370557877443728831536095595687278188136535874255961528052368239396098797700270909915520296477257449337496386440043216964158869797025960539307850266981043908205789164810126844405305719909486930540196091579061817941577193796914388142649901529545033700511196761537723321992911984637319290332263725820892098495478423635408198945460633049064941111931027698537027471927911062690313990295177372317584723804721189364511427905178136857822150332381916036422221580633685555154241932878964260108523361879921484901408275360523714171154532628218891905218752904711236625818819886923111271809647404471228704931682411384093113024792962857532782863101903587702191099392714060187195954392300190493679949589600313969267376351405608643929098427395200104486083111899853964304610758473277805554587439480383928476216931141758785031250627364405235869678559439444545227666592406138337486846016243289650621435832209315605503377196096021580300792698754457973602845403993921462211927841458267898134874980957060377354654918045444793008000882470017928275815652451786276451199637925745963061328280451266907720155464919652537995830833524781974006446820930880129957410807749296112288199085499565549310893971115388988153908811684545030381035984515688573254825193520417330269951810865135265587428530428871165742440180326205672339108762673923507302829080947467916299840992454977694170434544545004553705499927898038231431842130972614908743199239339049537463039908011539775745163363111687894512144470171171599034321325916810668925527973...

> pow.bigz(5,100)
Big Integer ('bigz') :
[1] 7888609052210118054117285652827862296732064351090230047702789306640625

> pow.bigz(5,1000)
Big Integer ('bigz') :
[1] 933263618503218878990089544723817169617091446371708024621714339795966910975775634454440327097881102359594989930324242624215487521354032394841520817203930756234410666138325150273995075985901831511100490796265113118240512514795933790805178271125415103810698378854426481119469814228660959222017662910442798456169448887147466528006328368452647429261829862165202793195289493607117850663668741065439805530718136320599844826041954101213229629869502194514609904214608668361244792952034826864617657926916047420065936389041737895822118365078045556628444273925387517127854796781556346403714877681766899855392069265439424008711973674701749862626690747296762535803929376233833981046927874558605253696441650390625


/ Einde R MANUAL

/ GOOGLE

https://coderwall.com/p/euwpig/a-better-git-log
http://stackoverflow.com/questions/2304087/what-is-head-in-git
https://www.youtube.com/watch?v=MAHKV1LkGm4
http://stackoverflow.com/questions/2765421/how-to-push-a-new-local-branch-to-a-remote-git-repository-and-track-it-too
https://help.github.com/articles/generating-an-ssh-key/
http://stackoverflow.com/questions/14613540/git-tag-in-branches
https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-log

https://ci.wildfly.org/viewLog.html?currentGroup=test&scope=%23teamcity%23org.jboss.as.test.integration.deployment.deploymentoverlay%23teamcity%23DeploymentOverlayTestCase&pager.currentPage=1&order=NAME_ASC&recordsPerPage=20&filterText=DeploymentOverlayTestCase&status=&buildTypeId=WF_MasterLinux&buildId=28261&tab=testsInfo

http://docs.spring.io/spring-boot/docs/current/reference/html/index.html
http://zezutom.blogspot.nl/2014/02/spring-series-part-5-component-vs-bean.html
http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html
https://spring.io/guides/gs/accessing-data-rest/
http://localhost:8080/reservations
https://spring.io/guides/gs/rest-service/
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-annotation-config
https://spring.io/guides/tutorials/bookmarks/
https://www.youtube.com/watch?v=sbPSjI4tt10

http://docs.scala-lang.org/overviews/core/futures.html

https://www.datascienceriot.com/how-to-install-r-in-linux-ubuntu-16-04-xenial-xerus/kris/
https://cran.r-project.org/doc/manuals/R-intro.html

https://www.postgresql.org/docs/9.4/static/overview.html
https://www.postgresql.org/docs/9.4/static/sql-explain.html
http://pgsnaga.blogspot.nl/2014/06/deploying-postgres-xl-in-2-minutes-with.html
http://www.postgres-xl.org/download/

http://www.javaworld.com/article/3060078/big-data/big-data-messaging-with-kafka-part-1.html

https://www.youtube.com/watch?v=f6kdp27TYZs
https://tour.golang.org/basics/8
https://tour.golang.org/concurrency/11

https://www.cockroachlabs.com/docs/start-a-local-cluster.html

http://redhatstackblog.redhat.com/2016/07/25/introduction-to-red-hat-openstack-platform-director/
http://developers.redhat.com/blog/2016/07/18/jboss-eap-7-on-openshift/
http://www.postmind.net/pgxl_docker-en.html
http://crosbymichael.com/advanced-docker-volumes.html
https://docs.docker.com/v1.11/engine/userguide/eng-image/dockerfile_best-practices/#entrypoint
https://docs.docker.com/v1.11/engine/reference/builder/#add
https://docs.docker.com/v1.11/engine/userguide/containers/networkingcontainers/

http://googlecloudplatform.github.io/
https://console.cloud.google.com/home/dashboard?project=web-server-project-1148&pli=1
https://cloud.google.com/container-engine/docs/quickstart
https://console.cloud.google.com/launcher?project=web-server-project-1148&cat=INFRASTRUCTURE
https://console.cloud.google.com/kubernetes/add?project=web-server-project-1148



http://kubernetes.io/docs/getting-started-guides/binary_release/
http://developers.redhat.com/products/cdk/overview/
https://mail.google.com/mail/u/0/?zx=pxvpi8qcigkn#search/redhat/155df7cc01fff8a1
http://www.meetup.com/JBoss-User-Group-Worldwide/events/228454602/
http://devops-assess.rhcloud.com/






/ Einde GOOGLE
